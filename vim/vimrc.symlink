set nocompatible
set modelines=0

" Always display the statusline in all windows
set laststatus=2
" Hide the default mode text (e.g. -- INSERT -- below the statusline)
set noshowmode

filetype off
" set the runtime path to include Vundle and initialize
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#rc()
" alternatively, pass a path where Vundle should install plugins
" let path = '~/some/path/here'
" call vundle#rc(path)

" let Vundle manage Vundle, required
Plugin 'gmarik/Vundle.vim'

Plugin 'kaihowl/vim-indent-sentence'
Plugin 'kien/ctrlp.vim'
Plugin 'mileszs/ack.vim'
Plugin 'tpope/vim-fugitive'
Plugin 'tpope/vim-unimpaired'
Plugin 'tpope/vim-dispatch'
Plugin 'tpope/vim-commentary'
Plugin 'tpope/vim-repeat'
Plugin 'tpope/vim-surround'
Plugin 'tpope/vim-vinegar'
Plugin 'nathanaelkane/vim-indent-guides'
Plugin 'kchmck/vim-coffee-script'
Plugin 'scrooloose/syntastic'
Plugin 'bronson/vim-trailing-whitespace'
Plugin 'kaihowl/vim-latex'
Plugin 'godlygeek/tabular'
Plugin 'justinmk/vim-sneak'
Plugin 'airblade/vim-gitgutter'
Plugin 'Cpp11-Syntax-Support'
Plugin 'majutsushi/tagbar'
Plugin 'vimwiki/vimwiki'
Plugin 'reedes/vim-colors-pencil'
Plugin 'altercation/vim-colors-solarized'
Plugin 'vim-airline/vim-airline'
Plugin 'vim-airline/vim-airline-themes'
Plugin 'edkolev/tmuxline.vim'
Plugin 'rking/ag.vim'
Plugin 'FelikZ/ctrlp-py-matcher'
Plugin 'ludovicchabant/vim-gutentags'
Plugin 'Valloric/YouCompleteMe'
Plugin 'rdnetto/YCM-Generator'
Plugin 'lyuts/vim-rtags'
" Plugin 'xolox/vim-easytags'
" Needed for vim-easytags
" Plugin 'xolox/vim-misc'

syntax enable

" let g:pencil_higher_contrast_ui = 0 " Yes, 0 means enabled here...
colorscheme solarized


" configure airline
" set laststatus=2 " use if status line is not showing
" set to use no special symbols at all
" this avoids having to patch fonts!
let g:airline_theme = 'solarized'
if !exists('g:airline_symbols')
  let g:airline_symbols = {}
endif
" unicode symbols
let g:airline_left_sep = ''
let g:airline_left_sep = ''
let g:airline_right_sep = ''
let g:airline_right_sep = ''

" configure tmuxline
let g:tmuxline_powerline_separators = 0


set tabstop=2 softtabstop=2 shiftwidth=2 expandtab

" Wrap gitcommit file types at the appropriate length
filetype indent plugin on

set wildignore+=*/node_modules/*,*.aux,*.d,*.o

" Enable indent guides per default
let g:indent_guides_enable_on_vim_startup = 1


" Shamelessly copied from Steve Losh's vimrc
" http://stevelosh.com/blog/2010/09/coming-home-to-vim/

" First off, some standard settings, making vim more 'sane'
set encoding=utf-8
set scrolloff=3
set autoindent
set wildmenu
set ttyfast
" Set both number and relativenumber for hybrid number
" If version is before 7.4, the last setting, i.e. relativenumber persists
set number
set relativenumber
set undofile
set noautochdir

let mapleader = ","

" fix vim's default regex handling / search behavior
set ignorecase
set smartcase
set gdefault
set incsearch
set showmatch
set hlsearch
nnoremap <leader><space> :noh<cr>

" handle lines intelligently
set wrap
set textwidth=79
set formatoptions+=qrn1
set colorcolumn=81

" set default chars for whitespace in list chars
set list
set listchars=eol:$,tab:>-,trail:~,extends:>,precedes:<

" Silent command
command! -nargs=1 Silent
      \ | execute ':silent '.<q-args>
      \ | execute ':redraw!'

" Restore position command
command! -nargs=1 RestoreCurPos
      \ | let save_cursor = getpos('.')
      \ | execute <q-args>
      \ | call setpos('.', save_cursor)

" Fugitive mappings
nnoremap <leader>gs :Gstatus<cr>
nnoremap <leader>gl :RestoreCurPos Silent Glog -n 20<cr>
nnoremap <leader>gd :Gdiff<cr>
nnoremap <leader>ge :RestoreCurPos Gedit<cr>
nnoremap <leader>gb :Gblame<cr>
nnoremap <leader>gru :Git rebase @{u}<cr>
nnoremap <leader>gri :Git rebase -i @{u}<cr>
nnoremap <leader>g- :Silent Git stash -u<cr>:windo e<cr>
nnoremap <leader>g+ :Silent Git stash pop<cr>:windo e<cr>
" Git snapshot (stash everything, and apply again immediately)
nnoremap <leader>g0 :Silent ! git-stash-push ""<left>

" Git diff mapping 'accept and next'
nnoremap <leader>n do]c

" Dispatch mappings
nnoremap <leader>gp :Disp git push<cr>
nnoremap <leader>gf :Disp git fetch<cr>

" Git mapping for finding conflict markers
nnoremap <leader>c /\m\(<<<<\\|====\\|>>>>\)<cr>

" Git review mapping
nnoremap <leader>r :Disp git review -R<cr>

" customize ctrlp plugin
let g:ctrlp_extensions = ['line', 'mixed']
let g:ctrlp_map = '<c-p>'
let g:ctrlp_cmd = 'CtrlP'
let g:ctrlp_switch_buffer = 't' " Do not switch to other tabs on <cr>
" PyMatcher for CtrlP
if !has('python')
    echo 'In order to use pymatcher plugin, you need +python compiled vim'
else
    let g:ctrlp_match_func = { 'match': 'pymatcher#PyMatch' }
endif

" Set delay to prevent extra search
let g:ctrlp_lazy_update = 200

" Do not clear filenames cache, to improve CtrlP startup
" You can manualy clear it by <F5>
let g:ctrlp_clear_cache_on_exit = 0

" Set no file limit, we are building a big project
let g:ctrlp_max_files = 0

" If ag is available use it as filename list generator instead of 'find'
if executable("ag")
    set grepprg=ag\ --nogroup\ --nocolor
    let g:ctrlp_user_command = 'ag %s -i --nocolor --nogroup
      \ --ignore .git
      \ --ignore .svn
      \ --ignore .hg
      \ --ignore .DS_Store
      \ --ignore "**/*.pyc"
      \ --ignore "node_modules"
      \ --hidden -g ""'
endif

nnoremap <c-l> :CtrlPLine<cr>

" Normal mode commands
" easier escaping
inoremap jj <ESC>
" join two lines
inoremap JJ <esc>Ji

" python pep8 compliance
au BufEnter *.py set sw=4 ts=4 sta et fo=croql

" Syntastic settings
" Ignore certain syntastic latex warnings
let g:syntastic_quiet_messages={"regex": "Do not use @ in LaTeX macro names."}
let g:syntastic_python_checkers = ['python', 'pyflakes', 'pep8']
let g:syntastic_always_populate_loc_list = 1
let g:syntastic_java_checkers = []
" Syntastic / Eclim
" Only Java validation is done by Eclim
let g:EclimJavaValidate = 1
let g:EclimXmlValidate = 0

" Make mappings
if filereadable('/proc/cpuinfo')
  let &makeprg = 'make -j'.(system('grep -c ^processor /proc/cpuinfo')+1)
endif
nnoremap <leader>mm :Make<cr>
nnoremap <leader>mc :Make clean<cr>
" For latex file run latex instead of makefile
au FileType tex nnoremap <buffer> <leader>mm :silent! call Tex_RunLaTeX()<CR>

" Sudo after the fact
cmap w!! w !sudo tee % >/dev/null

set pastetoggle=<leader>p

" Make sure latex-suite is invoked for plaintex files
let g:tex_flavor='latex'

" Configure pdf format for latex-suite
let g:Tex_DefaultTargetFormat = 'pdf'
let g:Tex_CompileRule_pdf = 'pdflatex -synctex=1 --interaction=nonstopmode $*'
let g:Tex_ViewRule_pdf = 'Skim'

" Set more sensible ignore warning level for latex-suite
" ensures that missing numbers, undefined references, and citations are shown
let g:Tex_IgnoreLevel = 4

" Change default alt mappings for latex-suite to mac friendly ones
imap <leader>lb <Plug>Tex_MathBF
imap <leader>lc <Plug>Tex_MathCal
imap <leader>ll <Plug>Tex_LeftRight
imap <leader>li <Plug>Tex_InsertItemOnThisLine

" Blindly robbed from Janus vim.rc
" https://github.com/rdeits/janus/blob/master/vimrc
" Calculate the number of screen lines needed to display a file with folds at
" the given fold_level. This is used to set the initial fold level of a file
" in order to display the entire file on screen if possible without closing
" any unnecessary folds.
function! ScreenLines(fold_level)
  let line_num = 1
  let screen_lines = 0
  let prev_fold_level = 0
  let cur_fold_level = 0
  let buf_length = line("$")
  while line_num <= buf_length
    let fold_expr = foldlevel(line_num)
    let prev_fold_level = cur_fold_level
    let cur_fold_level = fold_expr
    if (cur_fold_level <= a:fold_level) || ((cur_fold_level != prev_fold_level) && (prev_fold_level <= a:fold_level))
      let screen_lines = screen_lines + 1
    endif
      let line_num = line_num+1
   endwhile
   return screen_lines
endfunction

" Increase the fold level until the entire file will fit on the screen or
" foldlevel reaches 10, whichever comes first.
function! FoldToScreen()
  let ndx = 0
  set foldlevel=0
  while ndx < 10
    let ndx = ndx + 1
    if ScreenLines(ndx) > &lines
      break
    endif
    set foldlevel+=1
  endwhile
endfunction

autocmd BufWinEnter *.tex call FoldToScreen()

" Function to break lines in tex files on period(.) and wrap to colorcolumn
" This makes version control for latex files easier since git is line-based
command! -range LineBreakTexSource :silent! <line1>,<line2>s/\. /.\r/g | :<line1>,<line2>normal gw | :noh<cr>

" Comment out, if you need to debug latex-suite
"let g:Tex_Debug=1
"let g:Tex_DebugLog="texdebug.log"

" Allow to delete old characters in insert mode
" Also needed that latex-suite will be able to delete placeholders
set backspace=2

" enable spellchecking for git commits
au FileType gitcommit setlocal spell
au FileType gitcommit setlocal textwidth=71 colorcolumn=+1
" and for markdown files
au FileType markdown setlocal spell
" and for tex files
au FileType tex setlocal spell
au FileType tex syntax spell toplevel
" and for vimwiki files
au FileType vimwiki setlocal spell

" vim-wiki options
let g:vimwiki_folding='list'
au FileType vimwiki setlocal textwidth=120 colorcolumn=""

" Indent-sentence mapping
" For paragraph, restore position using register T
nnoremap <leader>ip i//CURSOR//<esc>vip :call g:IndentSentence()<cr>:%s/\/\/CURSOR\/\///<cr>
vnoremap <leader>is :call g:IndentSentence()<cr>

" gitgutter configuration
" explicitly set hunk navigation commands
nmap [h <Plug>GitGutterPrevHunk
nmap ]h <Plug>GitGutterNextHunk

" open tagbar (and focus) (or jump to if open)
nnoremap <leader>t :TagbarOpen fj<cr>
" show line numbers in tagbar
let g:tagbar_show_linenumbers=-1

" some java eclim mappings
nnoremap <leader>i :JavaImport<cr>
nnoremap <leader>d :JavaDocSearch -x declarations<cr>
nnoremap <leader>s :JavaSearchContext<cr>
nnoremap <leader>p :ProjectProblems!<cr>

" integrate eclim and youcompleteme
let g:EclimCompletionMethod = 'omnifunc'

" map YcmCompleter GoTo
nnoremap <leader>g :YcmCompleter GoTo<cr>

" Disable auto completion of log statements in java eclim
let g:EclimLoggingDisabled = 1

" Configure vim-easytags / tags in general
set tags=./tags
" Use tags file relative to current working directory
set cpo+=d
" Only us project specific tag files
" let g:easytags_dynamic_files = 2
" let g:easytags_auto_highlight = 0

let ag_additional_options = '--smart-case'
" Set smart case for Ag
if executable("ag")
  " Copied from source for destinction between ag version from 0.25.0 onward
  if split(system("ag --version"), "[ \n\r\t]")[2] =~ '\d\+.\(\(2[5-9]\)\|\([3-9][0-9]\)\)\(.\d\+\)\?'
    let g:ag_prg="ag --vimgrep" . " " . ag_additional_options
  else
    " --noheading seems odd here, but see https://github.com/ggreer/the_silver_searcher/issues/361
    let g:ag_prg="ag --column --nogroup --noheading" . " " . ag_additional_options
  endif
endif

" Ag short cut to search with current and parent directories
" Basic idea: http://vim.wikia.com/wiki/Invoke_a_function_with_a_count_prefix
" http://learnvimscriptthehardway.stevelosh.com/chapters/32.html
" The count supplies how many parent directories should be included
" 1 indicates the current directory, 2 would include .., and so on.
" 0 indicates to start the search at the cwd instead.
function! AgParentSearch(parents)
  let command = 'Ag -w '.shellescape(expand("<cword>"))
  if a:parents > 0
    let command .= ' %'.(repeat(':h', a:parents))
  endif
  execute command
endfunction

command! -nargs=1 AgParentSearch call AgParentSearch(<args>)
noremap <leader>a :<C-U>AgParentSearch(v:count)<CR>

" Add yaml file type for salt sls files
au BufEnter *.sls set ft=yaml

" Configure gutentags status line
" set statusline+=%{gutentags#statusline()}
function! GutentagsAirline(...)
  let g:airline_section_warning = '%{airline#util#wrap(airline#extensions#syntastic#get_warnings(),0)} %{airline#util#wrap(airline#extensions#whitespace#check(),0)} %{gutentags#statusline()}'
endfunction
autocmd VimEnter * call GutentagsAirline()

autocmd FileType groovy set sw=4 ts=4 sta et fo=croql

" https://github.com/tommcdo/vimfiles/blob/master/config/diffopt.vim
" Provide a function to toggle iwhite (ignore whitespace)
function! s:toggle_iwhite(opt)
	if a:opt == -1 || (a:opt == 0 && &diffopt =~ 'iwhite')
		echo ':set diffopt-=iwhite'
		set diffopt-=iwhite
	elseif a:opt == 1 || (a:opt == 0 && &diffopt !~ 'iwhite')
		echo ':set diffopt+=iwhite'
		set diffopt+=iwhite
	endif
endfunction

" Add mappings for toggling and setting iwhite (in the style of unimpaired.vim)
nnoremap coD :call <SID>toggle_iwhite(0)<CR>
nnoremap [oD :call <SID>toggle_iwhite(1)<CR>
nnoremap ]oD :call <SID>toggle_iwhite(-1)<CR>

" Netrw settings to show linenumbers abs/rel by default
let g:netrw_bufsettings = 'noma nomod nu rnu nobl nowrap ro'

" Do not use the location but the quickfix list for rtags
let g:rtagsUseLocationList = 0

" Additional function to print class hierarchy in rtags
function! RtagsShowHierarchy()
  let &l:grepprg = rtags#getRcCmd()." --class-hierarchy ".rtags#getCurrentLocation()
  let &l:grepformat = "%.%#\t%f:%l:%c:\t%m"
  grep
  copen
  redraw!
endfunction

noremap <Leader>rh :call RtagsShowHierarchy()<CR>


"" Toggle between .h and .cpp with F4.
function! ToggleBetweenHeaderAndSourceFile()
  let bufname = bufname("%")
  let bufname_base = fnamemodify(bufname, ":r") . "."
  let ext = fnamemodify(bufname, ":e")
  if ext == "h" || ext == "hpp"
    let ext = "cpp"
  elseif ext == "cpp"
    if filereadable(bufname_base . "hpp")
      let ext = "hpp"
    else
      let ext = "h"
    endif
  else
    return
  endif
  let bufname_new = bufname_base . ext

  let bufname_alt = bufname("#")
  if bufname_new == bufname_alt
    execute ":e#"
  else
    execute ":e " . bufname_new
  endif
endfunction

map <silent> <Leader>q :call ToggleBetweenHeaderAndSourceFile()<CR>

set exrc            " enable per-directory .vimrc files
set secure          " disable unsafe commands in local .vimrc files
