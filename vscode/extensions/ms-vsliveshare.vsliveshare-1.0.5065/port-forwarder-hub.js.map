{"version":3,"sources":["../../../webpack/bootstrap","../../../D:/a/_work/1/s/vscode/http-client/lib/src/Errors.js","../../../D:/a/_work/1/s/vscode/http-client/lib/src/FetchRequest.js","../../../D:/a/_work/1/s/vscode/http-client/lib/src/createTimeoutTokenSource.js","../../../D:/a/_work/1/s/vscode/http-client/lib/src/fetch.js","../../../D:/a/_work/1/s/vscode/http-client/lib/src/http-client.js","../../../D:/a/_work/1/s/vscode/http-client/lib/src/index.js","../../../D:/a/_work/1/s/vscode/http-client/lib/src/toAbortSignal.js","../../../D:/a/_work/1/s/vscode/logging/core/dist/src/GlobalPatternTraceFilter.js","../../../D:/a/_work/1/s/vscode/logging/core/dist/src/Logger.js","../../../D:/a/_work/1/s/vscode/logging/core/dist/src/LoggerSettings.js","../../../D:/a/_work/1/s/vscode/logging/core/dist/src/Privacy.js","../../../D:/a/_work/1/s/vscode/logging/core/dist/src/TraceFilters.js","../../../D:/a/_work/1/s/vscode/logging/core/dist/src/TraceFormat.js","../../../D:/a/_work/1/s/vscode/logging/core/dist/src/TraceListener.js","../../../D:/a/_work/1/s/vscode/logging/core/dist/src/TraceSource.js","../../../D:/a/_work/1/s/vscode/logging/core/dist/src/VerbosityTraceFilter.js","../../../D:/a/_work/1/s/vscode/logging/core/dist/src/index.js","../../../D:/a/_work/1/s/vscode/logging/core/dist/src/interfaces/LogLevel.js","../../../D:/a/_work/1/s/vscode/logging/core/dist/src/interfaces/LogValueType.js","../../../D:/a/_work/1/s/vscode/logging/core/dist/src/interfaces/index.js","../../../D:/a/_work/1/s/vscode/logging/core/dist/src/listeners/BrowserConsoleTraceLogger.js","../../../D:/a/_work/1/s/vscode/logging/core/dist/src/listeners/ConsoleTraceListener.js","../../../D:/a/_work/1/s/vscode/logging/core/dist/src/listeners/MemoryTraceListener.js","../../../D:/a/_work/1/s/vscode/logging/core/dist/src/listeners/OutputTraceListener.js","../../../D:/a/_work/1/s/vscode/logging/core/dist/src/listeners/index.js","../../../D:/a/_work/1/s/vscode/logging/core/dist/src/loggers/DebugConsoleLogger.js","../../../D:/a/_work/1/s/vscode/logging/core/dist/src/loggers/index.js","../../../D:/a/_work/1/s/vscode/logging/core/dist/src/mocks/TraceLoggerMock.js","../../../D:/a/_work/1/s/vscode/logging/core/dist/src/mocks/index.js","../../../D:/a/_work/1/s/vscode/logging/core/dist/src/utils/errorToString.js","../../../D:/a/_work/1/s/vscode/logging/core/dist/src/utils/index.js","../../../D:/a/_work/1/s/vscode/logging/core/node_modules/balanced-match/index.js","../../../D:/a/_work/1/s/vscode/logging/core/node_modules/brace-expansion/index.js","../../../D:/a/_work/1/s/vscode/logging/core/node_modules/buffer-from/index.js","../../../D:/a/_work/1/s/vscode/logging/core/node_modules/concat-map/index.js","../../../D:/a/_work/1/s/vscode/logging/core/node_modules/debug/src/browser.js","../../../D:/a/_work/1/s/vscode/logging/core/node_modules/debug/src/common.js","../../../D:/a/_work/1/s/vscode/logging/core/node_modules/debug/src/index.js","../../../D:/a/_work/1/s/vscode/logging/core/node_modules/debug/src/node.js","../../../D:/a/_work/1/s/vscode/logging/core/node_modules/has-flag/index.js","../../../D:/a/_work/1/s/vscode/logging/core/node_modules/minimatch/minimatch.js","../../../D:/a/_work/1/s/vscode/logging/core/node_modules/ms/index.js","../../../D:/a/_work/1/s/vscode/logging/core/node_modules/source-map-support/source-map-support.js","../../../D:/a/_work/1/s/vscode/logging/core/node_modules/source-map/lib/array-set.js","../../../D:/a/_work/1/s/vscode/logging/core/node_modules/source-map/lib/base64-vlq.js","../../../D:/a/_work/1/s/vscode/logging/core/node_modules/source-map/lib/base64.js","../../../D:/a/_work/1/s/vscode/logging/core/node_modules/source-map/lib/binary-search.js","../../../D:/a/_work/1/s/vscode/logging/core/node_modules/source-map/lib/mapping-list.js","../../../D:/a/_work/1/s/vscode/logging/core/node_modules/source-map/lib/quick-sort.js","../../../D:/a/_work/1/s/vscode/logging/core/node_modules/source-map/lib/source-map-consumer.js","../../../D:/a/_work/1/s/vscode/logging/core/node_modules/source-map/lib/source-map-generator.js","../../../D:/a/_work/1/s/vscode/logging/core/node_modules/source-map/lib/source-node.js","../../../D:/a/_work/1/s/vscode/logging/core/node_modules/source-map/lib/util.js","../../../D:/a/_work/1/s/vscode/logging/core/node_modules/source-map/source-map.js","../../../D:/a/_work/1/s/vscode/logging/core/node_modules/supports-color/index.js","../../../D:/a/_work/1/s/vscode/logging/desktop/dist/src/index.js","../../../D:/a/_work/1/s/vscode/logging/desktop/dist/src/logFileTraceListener.js","../../../D:/a/_work/1/s/vscode/logging/desktop/dist/src/logLocations.js","../../../D:/a/_work/1/s/vscode/logging/desktop/dist/src/telemetry/LogFilter.js","../../../D:/a/_work/1/s/vscode/logging/desktop/dist/src/telemetry/telemetryStrings.js","../../../D:/a/_work/1/s/vscode/node/server/dist/src/MutliChannelRpcSocketServer.js","../../../D:/a/_work/1/s/vscode/node/server/dist/src/index.js","../../../D:/a/_work/1/s/vscode/node/server/dist/src/serverUtils.js","../../../D:/a/_work/1/s/vscode/node/utils/dist/src/NodeFileAccess.js","../../../D:/a/_work/1/s/vscode/node/utils/dist/src/fileUtils.js","../../../D:/a/_work/1/s/vscode/node/utils/dist/src/getPipePath.js","../../../D:/a/_work/1/s/vscode/node/utils/dist/src/getPlatformProperty.js","../../../D:/a/_work/1/s/vscode/node/utils/dist/src/index.js","../../../D:/a/_work/1/s/vscode/node/utils/dist/src/lockFileUtils.js","../../../D:/a/_work/1/s/vscode/node/utils/dist/src/osPlatform.js","../../../D:/a/_work/1/s/vscode/node/utils/dist/src/processUtils.js","../../../D:/a/_work/1/s/vscode/node/utils/dist/src/socketUtils.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/api/context.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/api/global-utils.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/api/metrics.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/api/propagation.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/api/trace.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/baggage/Baggage.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/baggage/EntryValue.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/common/Exception.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/common/Logger.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/common/Time.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/context/context.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/context/propagation/NoopTextMapPropagator.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/context/propagation/TextMapPropagator.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/index.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/metrics/BatchObserverResult.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/metrics/BoundInstrument.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/metrics/Meter.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/metrics/MeterProvider.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/metrics/Metric.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/metrics/NoopMeter.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/metrics/NoopMeterProvider.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/metrics/Observation.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/metrics/ObserverResult.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/platform/index.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/platform/node/globalThis.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/platform/node/index.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/trace/Event.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/trace/NoopLogger.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/trace/NoopSpan.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/trace/NoopTracer.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/trace/NoopTracerProvider.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/trace/ProxyTracer.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/trace/ProxyTracerProvider.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/trace/Sampler.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/trace/SamplingResult.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/trace/SpanOptions.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/trace/TimedEvent.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/trace/attributes.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/trace/link.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/trace/link_context.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/trace/span.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/trace/span_context.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/trace/span_kind.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/trace/spancontext-utils.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/trace/status.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/trace/trace_flags.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/trace/trace_state.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/trace/tracer.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/api/build/src/trace/tracer_provider.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/context-base/build/src/NoopContextManager.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/context-base/build/src/context.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/context-base/build/src/index.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/context-base/build/src/types.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/build/src/ExportResult.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/build/src/baggage/propagation/HttpBaggage.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/build/src/common/ConsoleLogger.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/build/src/common/NoopLogger.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/build/src/common/attributes.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/build/src/common/global-error-handler.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/build/src/common/logging-error-handler.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/build/src/common/time.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/build/src/common/types.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/build/src/context/propagation/HttpTraceContext.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/build/src/context/propagation/composite.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/build/src/context/propagation/types.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/build/src/index.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/build/src/internal/validators.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/build/src/platform/BaseAbstractPlugin.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/build/src/platform/index.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/build/src/platform/node sync","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/build/src/platform/node/BasePlugin.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/build/src/platform/node/RandomIdGenerator.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/build/src/platform/node/environment.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/build/src/platform/node/hex-to-base64.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/build/src/platform/node/index.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/build/src/platform/node/performance.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/build/src/platform/node/sdk-info.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/build/src/platform/node/timer-util.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/build/src/trace/IdGenerator.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/build/src/trace/NoRecordingSpan.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/build/src/trace/Plugin.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/build/src/trace/TraceState.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOffSampler.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOnSampler.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/build/src/trace/sampler/ParentBasedSampler.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/build/src/trace/sampler/TraceIdRatioBasedSampler.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/build/src/utils/deep-merge.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/build/src/utils/environment.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/build/src/utils/url.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/build/src/utils/wrap.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/build/src/version.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/classes/comparator.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/classes/range.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/classes/semver.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/functions/clean.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/functions/cmp.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/functions/coerce.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/functions/compare-build.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/functions/compare-loose.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/functions/compare.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/functions/diff.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/functions/eq.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/functions/gt.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/functions/gte.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/functions/inc.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/functions/lt.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/functions/lte.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/functions/major.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/functions/minor.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/functions/neq.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/functions/parse.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/functions/patch.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/functions/prerelease.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/functions/rcompare.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/functions/rsort.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/functions/satisfies.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/functions/sort.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/functions/valid.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/index.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/internal/constants.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/internal/debug.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/internal/identifiers.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/internal/parse-options.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/internal/re.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/ranges/gtr.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/ranges/intersects.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/ranges/ltr.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/ranges/max-satisfying.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/ranges/min-satisfying.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/ranges/min-version.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/ranges/outside.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/ranges/simplify.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/ranges/subset.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/ranges/to-comparators.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/core/node_modules/semver/ranges/valid.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/resources/build/src/Resource.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/resources/build/src/config.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/resources/build/src/constants.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/resources/build/src/index.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/resources/build/src/platform/index.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/resources/build/src/platform/node/detect-resources.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/resources/build/src/platform/node/detectors/EnvDetector.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/resources/build/src/platform/node/detectors/ProcessDetector.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/resources/build/src/platform/node/detectors/index.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/resources/build/src/platform/node/index.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/resources/build/src/types.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/semantic-conventions/build/src/index.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/semantic-conventions/build/src/trace/database.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/semantic-conventions/build/src/trace/exception.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/semantic-conventions/build/src/trace/faas.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/semantic-conventions/build/src/trace/general.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/semantic-conventions/build/src/trace/http.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/semantic-conventions/build/src/trace/index.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/semantic-conventions/build/src/trace/messaging.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/semantic-conventions/build/src/trace/os.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/semantic-conventions/build/src/trace/rpc.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/tracing/build/src/BasicTracerProvider.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/tracing/build/src/MultiSpanProcessor.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/tracing/build/src/NoopSpanProcessor.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/tracing/build/src/Span.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/tracing/build/src/SpanProcessor.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/tracing/build/src/Tracer.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/tracing/build/src/config.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/tracing/build/src/export/BatchSpanProcessor.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/tracing/build/src/export/ConsoleSpanExporter.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/tracing/build/src/export/InMemorySpanExporter.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/tracing/build/src/export/ReadableSpan.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/tracing/build/src/export/SimpleSpanProcessor.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/tracing/build/src/export/SpanExporter.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/tracing/build/src/index.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/tracing/build/src/types.js","../../../D:/a/_work/1/s/vscode/node_modules/@opentelemetry/tracing/build/src/utility.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/algorithms/ecdsaCurves.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/algorithms/encryptionAlgorithm.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/algorithms/hmacAlgorithm.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/algorithms/keyExchangeAlgorithm.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/algorithms/node/keyFormatters.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/algorithms/node/nodeECDsa.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/algorithms/node/nodeEncryption.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/algorithms/node/nodeHmac.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/algorithms/node/nodeKeyExchange.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/algorithms/node/nodeRandom.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/algorithms/node/nodeRsa.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/algorithms/publicKeyAlgorithm.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/algorithms/sshAlgorithms.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/algorithms/web/jsonWebKeyFormatter.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/algorithms/web/webECDsa.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/algorithms/web/webEncryption.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/algorithms/web/webHmac.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/algorithms/web/webKeyExchange.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/algorithms/web/webRandom.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/algorithms/web/webRsa.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/errors.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/events/sshAuthenticatingEventArgs.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/events/sshChannelClosedEventArgs.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/events/sshChannelOpeningEventArgs.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/events/sshRequestEventArgs.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/events/sshSessionClosedEventArgs.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/index.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/io/bigInt.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/io/derData.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/io/sshData.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/io/sshProtocol.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/messages/authenticationMessages.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/messages/connectionMessages.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/messages/kexMessages.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/messages/sshMessage.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/messages/transportMessages.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/metrics/channelMetrics.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/metrics/sessionContour.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/metrics/sessionMetrics.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/multiChannelStream.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/services/authenticationService.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/services/connectionService.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/services/keyExchangeService.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/services/serviceActivation.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/services/sshService.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/sshChannel.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/sshClientSession.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/sshRpcMessageStream.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/sshServerSession.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/sshSession.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/sshSessionAlgorithms.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/sshSessionConfiguration.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/sshStream.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/sshVersionInfo.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/streams.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/trace.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/util/cancellation.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/util/promiseCompletionSource.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/util/queue.js","../../../D:/a/_work/1/s/vscode/node_modules/@vs/vs-ssh/util/semaphore.js","../../../D:/a/_work/1/s/vscode/node_modules/abort-controller/dist/abort-controller.js","../../../D:/a/_work/1/s/vscode/node_modules/ansi-colors/index.js","../../../D:/a/_work/1/s/vscode/node_modules/ansi-regex/index.js","../../../D:/a/_work/1/s/vscode/node_modules/ansi-wrap/index.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/AutoCollection/AsyncHooksScopeManager.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/AutoCollection/Console.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/AutoCollection/CorrelationContextManager.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/AutoCollection/Exceptions.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/AutoCollection/HeartBeat.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/AutoCollection/HttpDependencies.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/AutoCollection/HttpDependencyParser.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/AutoCollection/HttpRequestParser.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/AutoCollection/HttpRequests.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/AutoCollection/NativePerformance.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/AutoCollection/Performance.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/AutoCollection/RequestParser.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/SpanParser.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/azure-coretracing.sub.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/bunyan.sub.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/console.sub.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/initialization.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/mongodb.sub.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/mysql.sub.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/postgres.sub.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/redis.sub.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/winston.sub.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Declarations/Constants.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Declarations/Contracts/Constants.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Declarations/Contracts/Generated/AvailabilityData.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Declarations/Contracts/Generated/Base.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Declarations/Contracts/Generated/ContextTagKeys.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Declarations/Contracts/Generated/Data.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Declarations/Contracts/Generated/DataPoint.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Declarations/Contracts/Generated/DataPointType.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Declarations/Contracts/Generated/Domain.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Declarations/Contracts/Generated/Envelope.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Declarations/Contracts/Generated/EventData.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Declarations/Contracts/Generated/ExceptionData.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Declarations/Contracts/Generated/ExceptionDetails.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Declarations/Contracts/Generated/MessageData.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Declarations/Contracts/Generated/MetricData.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Declarations/Contracts/Generated/PageViewData.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Declarations/Contracts/Generated/RemoteDependencyData.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Declarations/Contracts/Generated/RequestData.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Declarations/Contracts/Generated/SeverityLevel.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Declarations/Contracts/Generated/StackFrame.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Declarations/Contracts/Generated/index.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/TelemetryType.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/index.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Declarations/Contracts/index.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Library/Channel.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Library/Config.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Library/ConnectionStringParser.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Library/Context.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Library/CorrelationIdManager.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Library/EnvelopeFactory.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Library/Functions.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Library/Logging.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Library/NodeClient.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Library/QuickPulseEnvelopeFactory.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Library/QuickPulseSender.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Library/QuickPulseStateManager.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Library/QuickPulseUtil.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Library/RequestResponseHeaders.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Library/Sender.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Library/TelemetryClient.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Library/Traceparent.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Library/Tracestate.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/Library/Util.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/TelemetryProcessors/PerformanceMetricsTelemetryProcessor.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/TelemetryProcessors/SamplingTelemetryProcessor.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/TelemetryProcessors/index.js","../../../D:/a/_work/1/s/vscode/node_modules/applicationinsights/out/applicationinsights.js","../../../D:/a/_work/1/s/vscode/node_modules/asn1/lib/ber/errors.js","../../../D:/a/_work/1/s/vscode/node_modules/asn1/lib/ber/index.js","../../../D:/a/_work/1/s/vscode/node_modules/asn1/lib/ber/reader.js","../../../D:/a/_work/1/s/vscode/node_modules/asn1/lib/ber/types.js","../../../D:/a/_work/1/s/vscode/node_modules/asn1/lib/ber/writer.js","../../../D:/a/_work/1/s/vscode/node_modules/asn1/lib/index.js","../../../D:/a/_work/1/s/vscode/node_modules/async-hook-jl/async-hook.js","../../../D:/a/_work/1/s/vscode/node_modules/async-hook-jl/index.js","../../../D:/a/_work/1/s/vscode/node_modules/async-hook-jl/patches/next-tick.js","../../../D:/a/_work/1/s/vscode/node_modules/async-hook-jl/patches/promise.js","../../../D:/a/_work/1/s/vscode/node_modules/async-hook-jl/patches/timers.js","../../../D:/a/_work/1/s/vscode/node_modules/async-listener/es6-wrapped-promise.js","../../../D:/a/_work/1/s/vscode/node_modules/async-listener/glue.js","../../../D:/a/_work/1/s/vscode/node_modules/async-listener/index.js","../../../D:/a/_work/1/s/vscode/node_modules/bufferutil/fallback.js","../../../D:/a/_work/1/s/vscode/node_modules/bufferutil/index.js","../../../D:/a/_work/1/s/vscode/node_modules/cls-hooked/context-legacy.js","../../../D:/a/_work/1/s/vscode/node_modules/cls-hooked/context.js","../../../D:/a/_work/1/s/vscode/node_modules/cls-hooked/index.js","../../../D:/a/_work/1/s/vscode/node_modules/color-convert/conversions.js","../../../D:/a/_work/1/s/vscode/node_modules/color-convert/index.js","../../../D:/a/_work/1/s/vscode/node_modules/color-convert/node_modules/color-name/index.js","../../../D:/a/_work/1/s/vscode/node_modules/color-convert/route.js","../../../D:/a/_work/1/s/vscode/node_modules/continuation-local-storage/context.js","../../../D:/a/_work/1/s/vscode/node_modules/dateformat/lib/dateformat.js","../../../D:/a/_work/1/s/vscode/node_modules/debug/src/browser.js","../../../D:/a/_work/1/s/vscode/node_modules/debug/src/common.js","../../../D:/a/_work/1/s/vscode/node_modules/debug/src/index.js","../../../D:/a/_work/1/s/vscode/node_modules/debug/src/node.js","../../../D:/a/_work/1/s/vscode/node_modules/decamelize/index.js","../../../D:/a/_work/1/s/vscode/node_modules/diagnostic-channel-publishers/dist/src sync ^.*\\/lib\\/Connection$","../../../D:/a/_work/1/s/vscode/node_modules/diagnostic-channel-publishers/dist/src sync ^.*\\/lib\\/Pool$","../../../D:/a/_work/1/s/vscode/node_modules/diagnostic-channel-publishers/dist/src/azure-coretracing.pub.js","../../../D:/a/_work/1/s/vscode/node_modules/diagnostic-channel-publishers/dist/src/bunyan.pub.js","../../../D:/a/_work/1/s/vscode/node_modules/diagnostic-channel-publishers/dist/src/console.pub.js","../../../D:/a/_work/1/s/vscode/node_modules/diagnostic-channel-publishers/dist/src/index.js","../../../D:/a/_work/1/s/vscode/node_modules/diagnostic-channel-publishers/dist/src/mongodb-core.pub.js","../../../D:/a/_work/1/s/vscode/node_modules/diagnostic-channel-publishers/dist/src/mongodb.pub.js","../../../D:/a/_work/1/s/vscode/node_modules/diagnostic-channel-publishers/dist/src/mysql.pub.js","../../../D:/a/_work/1/s/vscode/node_modules/diagnostic-channel-publishers/dist/src/pg-pool.pub.js","../../../D:/a/_work/1/s/vscode/node_modules/diagnostic-channel-publishers/dist/src/pg.pub.js","../../../D:/a/_work/1/s/vscode/node_modules/diagnostic-channel-publishers/dist/src/redis.pub.js","../../../D:/a/_work/1/s/vscode/node_modules/diagnostic-channel-publishers/dist/src/tedious.pub.js","../../../D:/a/_work/1/s/vscode/node_modules/diagnostic-channel-publishers/dist/src/winston.pub.js","../../../D:/a/_work/1/s/vscode/node_modules/diagnostic-channel/dist/src/channel.js","../../../D:/a/_work/1/s/vscode/node_modules/diagnostic-channel/dist/src/patchRequire.js","../../../D:/a/_work/1/s/vscode/node_modules/diffie-hellman/index.js","../../../D:/a/_work/1/s/vscode/node_modules/emitter-listener/listener.js","../../../D:/a/_work/1/s/vscode/node_modules/emoji-regex/index.js","../../../D:/a/_work/1/s/vscode/node_modules/event-target-shim/dist/event-target-shim.js","../../../D:/a/_work/1/s/vscode/node_modules/fs-extra/lib/copy-sync/copy-sync.js","../../../D:/a/_work/1/s/vscode/node_modules/fs-extra/lib/copy-sync/index.js","../../../D:/a/_work/1/s/vscode/node_modules/fs-extra/lib/copy/copy.js","../../../D:/a/_work/1/s/vscode/node_modules/fs-extra/lib/copy/index.js","../../../D:/a/_work/1/s/vscode/node_modules/fs-extra/lib/empty/index.js","../../../D:/a/_work/1/s/vscode/node_modules/fs-extra/lib/ensure/file.js","../../../D:/a/_work/1/s/vscode/node_modules/fs-extra/lib/ensure/index.js","../../../D:/a/_work/1/s/vscode/node_modules/fs-extra/lib/ensure/link.js","../../../D:/a/_work/1/s/vscode/node_modules/fs-extra/lib/ensure/symlink-paths.js","../../../D:/a/_work/1/s/vscode/node_modules/fs-extra/lib/ensure/symlink-type.js","../../../D:/a/_work/1/s/vscode/node_modules/fs-extra/lib/ensure/symlink.js","../../../D:/a/_work/1/s/vscode/node_modules/fs-extra/lib/fs/index.js","../../../D:/a/_work/1/s/vscode/node_modules/fs-extra/lib/index.js","../../../D:/a/_work/1/s/vscode/node_modules/fs-extra/lib/json/index.js","../../../D:/a/_work/1/s/vscode/node_modules/fs-extra/lib/json/jsonfile.js","../../../D:/a/_work/1/s/vscode/node_modules/fs-extra/lib/json/output-json-sync.js","../../../D:/a/_work/1/s/vscode/node_modules/fs-extra/lib/json/output-json.js","../../../D:/a/_work/1/s/vscode/node_modules/fs-extra/lib/mkdirs/index.js","../../../D:/a/_work/1/s/vscode/node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js","../../../D:/a/_work/1/s/vscode/node_modules/fs-extra/lib/mkdirs/mkdirs.js","../../../D:/a/_work/1/s/vscode/node_modules/fs-extra/lib/mkdirs/win32.js","../../../D:/a/_work/1/s/vscode/node_modules/fs-extra/lib/move-sync/index.js","../../../D:/a/_work/1/s/vscode/node_modules/fs-extra/lib/move-sync/move-sync.js","../../../D:/a/_work/1/s/vscode/node_modules/fs-extra/lib/move/index.js","../../../D:/a/_work/1/s/vscode/node_modules/fs-extra/lib/move/move.js","../../../D:/a/_work/1/s/vscode/node_modules/fs-extra/lib/output/index.js","../../../D:/a/_work/1/s/vscode/node_modules/fs-extra/lib/path-exists/index.js","../../../D:/a/_work/1/s/vscode/node_modules/fs-extra/lib/remove/index.js","../../../D:/a/_work/1/s/vscode/node_modules/fs-extra/lib/remove/rimraf.js","../../../D:/a/_work/1/s/vscode/node_modules/fs-extra/lib/util/buffer.js","../../../D:/a/_work/1/s/vscode/node_modules/fs-extra/lib/util/stat.js","../../../D:/a/_work/1/s/vscode/node_modules/fs-extra/lib/util/utimes.js","../../../D:/a/_work/1/s/vscode/node_modules/fs-extra/node_modules/graceful-fs/clone.js","../../../D:/a/_work/1/s/vscode/node_modules/fs-extra/node_modules/graceful-fs/graceful-fs.js","../../../D:/a/_work/1/s/vscode/node_modules/fs-extra/node_modules/graceful-fs/legacy-streams.js","../../../D:/a/_work/1/s/vscode/node_modules/fs-extra/node_modules/graceful-fs/polyfills.js","../../../D:/a/_work/1/s/vscode/node_modules/get-port/index.js","../../../D:/a/_work/1/s/vscode/node_modules/is-fullwidth-code-point/index.js","../../../D:/a/_work/1/s/vscode/node_modules/is-typedarray/index.js","../../../D:/a/_work/1/s/vscode/node_modules/js-sha256/src/sha256.js","../../../D:/a/_work/1/s/vscode/node_modules/jsonfile/index.js","../../../D:/a/_work/1/s/vscode/node_modules/jsonfile/node_modules/graceful-fs/clone.js","../../../D:/a/_work/1/s/vscode/node_modules/jsonfile/node_modules/graceful-fs/graceful-fs.js","../../../D:/a/_work/1/s/vscode/node_modules/jsonfile/node_modules/graceful-fs/legacy-streams.js","../../../D:/a/_work/1/s/vscode/node_modules/jsonfile/node_modules/graceful-fs/polyfills.js","../../../D:/a/_work/1/s/vscode/node_modules/lockfile/lockfile.js","../../../D:/a/_work/1/s/vscode/node_modules/lru-cache/index.js","../../../D:/a/_work/1/s/vscode/node_modules/ms/index.js","../../../D:/a/_work/1/s/vscode/node_modules/node-fetch/lib/index.mjs","../../../D:/a/_work/1/s/vscode/node_modules/node-gyp-build/index.js","../../../D:/a/_work/1/s/vscode/node_modules/node-rsa/src/NodeRSA.js","../../../D:/a/_work/1/s/vscode/node_modules/node-rsa/src/encryptEngines/encryptEngines.js","../../../D:/a/_work/1/s/vscode/node_modules/node-rsa/src/encryptEngines/io.js","../../../D:/a/_work/1/s/vscode/node_modules/node-rsa/src/encryptEngines/js.js","../../../D:/a/_work/1/s/vscode/node_modules/node-rsa/src/encryptEngines/node12.js","../../../D:/a/_work/1/s/vscode/node_modules/node-rsa/src/formats/components.js","../../../D:/a/_work/1/s/vscode/node_modules/node-rsa/src/formats/formats.js","../../../D:/a/_work/1/s/vscode/node_modules/node-rsa/src/formats/pkcs1.js","../../../D:/a/_work/1/s/vscode/node_modules/node-rsa/src/formats/pkcs8.js","../../../D:/a/_work/1/s/vscode/node_modules/node-rsa/src/libs/jsbn.js","../../../D:/a/_work/1/s/vscode/node_modules/node-rsa/src/libs/rsa.js","../../../D:/a/_work/1/s/vscode/node_modules/node-rsa/src/schemes/oaep.js","../../../D:/a/_work/1/s/vscode/node_modules/node-rsa/src/schemes/pkcs1.js","../../../D:/a/_work/1/s/vscode/node_modules/node-rsa/src/schemes/pss.js","../../../D:/a/_work/1/s/vscode/node_modules/node-rsa/src/schemes/schemes.js","../../../D:/a/_work/1/s/vscode/node_modules/node-rsa/src/utils.js","../../../D:/a/_work/1/s/vscode/node_modules/p-limit/index.js","../../../D:/a/_work/1/s/vscode/node_modules/p-try/index.js","../../../D:/a/_work/1/s/vscode/node_modules/path-browserify/index.js","../../../D:/a/_work/1/s/vscode/node_modules/path-exists/index.js","../../../D:/a/_work/1/s/vscode/node_modules/performance-ponyfill/node-ponyfill.js","../../../D:/a/_work/1/s/vscode/node_modules/randombytes/index.js","../../../D:/a/_work/1/s/vscode/node_modules/require-directory/index.js","../../../D:/a/_work/1/s/vscode/node_modules/safer-buffer/safer.js","../../../D:/a/_work/1/s/vscode/node_modules/semver/semver.js","../../../D:/a/_work/1/s/vscode/node_modules/set-blocking/index.js","../../../D:/a/_work/1/s/vscode/node_modules/shimmer/index.js","../../../D:/a/_work/1/s/vscode/node_modules/signal-exit/index.js","../../../D:/a/_work/1/s/vscode/node_modules/signal-exit/signals.js","../../../D:/a/_work/1/s/vscode/node_modules/stack-chain/format.js","../../../D:/a/_work/1/s/vscode/node_modules/stack-chain/index.js","../../../D:/a/_work/1/s/vscode/node_modules/stack-chain/stack-chain.js","../../../D:/a/_work/1/s/vscode/node_modules/sudo-prompt/index.js","../../../D:/a/_work/1/s/vscode/node_modules/supports-color/index.js","../../../D:/a/_work/1/s/vscode/node_modules/supports-color/node_modules/has-flag/index.js","../../../D:/a/_work/1/s/vscode/node_modules/typedarray-to-buffer/index.js","../../../D:/a/_work/1/s/vscode/node_modules/universalify/index.js","../../../D:/a/_work/1/s/vscode/node_modules/utf-8-validate/fallback.js","../../../D:/a/_work/1/s/vscode/node_modules/utf-8-validate/index.js","../../../D:/a/_work/1/s/vscode/node_modules/uuid/index.js","../../../D:/a/_work/1/s/vscode/node_modules/uuid/lib/bytesToUuid.js","../../../D:/a/_work/1/s/vscode/node_modules/uuid/lib/rng.js","../../../D:/a/_work/1/s/vscode/node_modules/uuid/v1.js","../../../D:/a/_work/1/s/vscode/node_modules/uuid/v4.js","../../../D:/a/_work/1/s/vscode/node_modules/vscode-jsonrpc/lib/cancellation.js","../../../D:/a/_work/1/s/vscode/node_modules/vscode-jsonrpc/lib/events.js","../../../D:/a/_work/1/s/vscode/node_modules/vscode-jsonrpc/lib/is.js","../../../D:/a/_work/1/s/vscode/node_modules/vscode-jsonrpc/lib/linkedMap.js","../../../D:/a/_work/1/s/vscode/node_modules/vscode-jsonrpc/lib/main.js","../../../D:/a/_work/1/s/vscode/node_modules/vscode-jsonrpc/lib/messageReader.js","../../../D:/a/_work/1/s/vscode/node_modules/vscode-jsonrpc/lib/messageWriter.js","../../../D:/a/_work/1/s/vscode/node_modules/vscode-jsonrpc/lib/messages.js","../../../D:/a/_work/1/s/vscode/node_modules/vscode-jsonrpc/lib/pipeSupport.js","../../../D:/a/_work/1/s/vscode/node_modules/vscode-jsonrpc/lib/socketSupport.js","../../../(webpack)/buildin/amd-options.js","../../../(webpack)/buildin/module.js","../../../D:/a/_work/1/s/vscode/node_modules/websocket/index.js","../../../D:/a/_work/1/s/vscode/node_modules/websocket/lib/Deprecation.js","../../../D:/a/_work/1/s/vscode/node_modules/websocket/lib/W3CWebSocket.js","../../../D:/a/_work/1/s/vscode/node_modules/websocket/lib/WebSocketClient.js","../../../D:/a/_work/1/s/vscode/node_modules/websocket/lib/WebSocketConnection.js","../../../D:/a/_work/1/s/vscode/node_modules/websocket/lib/WebSocketFrame.js","../../../D:/a/_work/1/s/vscode/node_modules/websocket/lib/WebSocketRequest.js","../../../D:/a/_work/1/s/vscode/node_modules/websocket/lib/WebSocketRouter.js","../../../D:/a/_work/1/s/vscode/node_modules/websocket/lib/WebSocketRouterRequest.js","../../../D:/a/_work/1/s/vscode/node_modules/websocket/lib/WebSocketServer.js","../../../D:/a/_work/1/s/vscode/node_modules/websocket/lib/utils.js","../../../D:/a/_work/1/s/vscode/node_modules/websocket/lib/version.js","../../../D:/a/_work/1/s/vscode/node_modules/websocket/lib/websocket.js","../../../D:/a/_work/1/s/vscode/node_modules/websocket/node_modules/debug/src/browser.js","../../../D:/a/_work/1/s/vscode/node_modules/websocket/node_modules/debug/src/debug.js","../../../D:/a/_work/1/s/vscode/node_modules/websocket/node_modules/debug/src/index.js","../../../D:/a/_work/1/s/vscode/node_modules/websocket/node_modules/debug/src/node.js","../../../D:/a/_work/1/s/vscode/node_modules/websocket/node_modules/ms/index.js","../../../D:/a/_work/1/s/vscode/node_modules/websocket/vendor/FastBufferList.js","../../../D:/a/_work/1/s/vscode/node_modules/which-module/index.js","../../../D:/a/_work/1/s/vscode/node_modules/y18n/index.js","../../../D:/a/_work/1/s/vscode/node_modules/yaeti/index.js","../../../D:/a/_work/1/s/vscode/node_modules/yaeti/lib/Event.js","../../../D:/a/_work/1/s/vscode/node_modules/yaeti/lib/EventTarget.js","../../../D:/a/_work/1/s/vscode/node_modules/yallist/iterator.js","../../../D:/a/_work/1/s/vscode/node_modules/yallist/yallist.js","../../../D:/a/_work/1/s/vscode/node_modules/yargs sync","../../../D:/a/_work/1/s/vscode/node_modules/yargs-parser sync","../../../D:/a/_work/1/s/vscode/node_modules/yargs-parser/index.js","../../../D:/a/_work/1/s/vscode/node_modules/yargs-parser/lib/tokenize-arg-string.js","../../../D:/a/_work/1/s/vscode/node_modules/yargs-parser/node_modules/camelcase/index.js","../../../D:/a/_work/1/s/vscode/node_modules/yargs/index.js","../../../D:/a/_work/1/s/vscode/node_modules/yargs/lib sync","../../../D:/a/_work/1/s/vscode/node_modules/yargs/lib/apply-extends.js","../../../D:/a/_work/1/s/vscode/node_modules/yargs/lib/argsert.js","../../../D:/a/_work/1/s/vscode/node_modules/yargs/lib/command.js","../../../D:/a/_work/1/s/vscode/node_modules/yargs/lib/completion-templates.js","../../../D:/a/_work/1/s/vscode/node_modules/yargs/lib/completion.js","../../../D:/a/_work/1/s/vscode/node_modules/yargs/lib/decamelize.js","../../../D:/a/_work/1/s/vscode/node_modules/yargs/lib/is-promise.js","../../../D:/a/_work/1/s/vscode/node_modules/yargs/lib/levenshtein.js","../../../D:/a/_work/1/s/vscode/node_modules/yargs/lib/middleware.js","../../../D:/a/_work/1/s/vscode/node_modules/yargs/lib/obj-filter.js","../../../D:/a/_work/1/s/vscode/node_modules/yargs/lib/usage.js","../../../D:/a/_work/1/s/vscode/node_modules/yargs/lib/validation.js","../../../D:/a/_work/1/s/vscode/node_modules/yargs/lib/yerror.js","../../../D:/a/_work/1/s/vscode/node_modules/yargs/node_modules/ansi-styles/index.js","../../../D:/a/_work/1/s/vscode/node_modules/yargs/node_modules/cliui/index.js","../../../D:/a/_work/1/s/vscode/node_modules/yargs/node_modules/find-up/index.js","../../../D:/a/_work/1/s/vscode/node_modules/yargs/node_modules/get-caller-file/index.js","../../../D:/a/_work/1/s/vscode/node_modules/yargs/node_modules/locate-path/index.js","../../../D:/a/_work/1/s/vscode/node_modules/yargs/node_modules/p-locate/index.js","../../../D:/a/_work/1/s/vscode/node_modules/yargs/node_modules/require-main-filename sync","../../../D:/a/_work/1/s/vscode/node_modules/yargs/node_modules/require-main-filename/index.js","../../../D:/a/_work/1/s/vscode/node_modules/yargs/node_modules/string-width/index.js","../../../D:/a/_work/1/s/vscode/node_modules/yargs/node_modules/strip-ansi/index.js","../../../D:/a/_work/1/s/vscode/node_modules/yargs/node_modules/wrap-ansi/index.js","../../../D:/a/_work/1/s/vscode/node_modules/yargs/yargs.js","../../../D:/a/_work/1/s/vscode/performance/dist/src/Performance.js","../../../D:/a/_work/1/s/vscode/performance/dist/src/PerformanceBlocks.js","../../../D:/a/_work/1/s/vscode/performance/dist/src/WaterfallNode.js","../../../D:/a/_work/1/s/vscode/performance/dist/src/index.js","../../../D:/a/_work/1/s/vscode/performance/dist/src/logPerformanceWaterfall.js","../../../D:/a/_work/1/s/vscode/performance/dist/src/mocks/PerformanceMock.js","../../../D:/a/_work/1/s/vscode/performance/dist/src/mocks/index.js","../../../D:/a/_work/1/s/vscode/performance/dist/src/sortByStartTime.js","../../../D:/a/_work/1/s/vscode/rpc/core/dist/src/DataFormat.js","../../../D:/a/_work/1/s/vscode/rpc/core/dist/src/RpcClient.js","../../../D:/a/_work/1/s/vscode/rpc/core/dist/src/RpcClientProxy.js","../../../D:/a/_work/1/s/vscode/rpc/core/dist/src/RpcConnectionErrors.js","../../../D:/a/_work/1/s/vscode/rpc/core/dist/src/RpcLoggerAdapter.js","../../../D:/a/_work/1/s/vscode/rpc/core/dist/src/RpcMessageWriter.js","../../../D:/a/_work/1/s/vscode/rpc/core/dist/src/RpcProxy.js","../../../D:/a/_work/1/s/vscode/rpc/core/dist/src/RpcProxyCache.js","../../../D:/a/_work/1/s/vscode/rpc/core/dist/src/RpcServer.js","../../../D:/a/_work/1/s/vscode/rpc/core/dist/src/RpcServiceHandler.js","../../../D:/a/_work/1/s/vscode/rpc/core/dist/src/RpcUtils.js","../../../D:/a/_work/1/s/vscode/rpc/core/dist/src/createDuplexRpcMessageStreams.js","../../../D:/a/_work/1/s/vscode/rpc/core/dist/src/index.js","../../../D:/a/_work/1/s/vscode/rpc/core/dist/src/sendRpcRequest.js","../../../D:/a/_work/1/s/vscode/rpc/ssh/dist/src/MultiChannelRpcServer.js","../../../D:/a/_work/1/s/vscode/rpc/ssh/dist/src/SshRpcServer.js","../../../D:/a/_work/1/s/vscode/rpc/ssh/dist/src/createDuplexMultiChannelRpcClient.js","../../../D:/a/_work/1/s/vscode/rpc/ssh/dist/src/createDuplexStreams.js","../../../D:/a/_work/1/s/vscode/rpc/ssh/dist/src/createMultiChannelRpcClient.js","../../../D:/a/_work/1/s/vscode/rpc/ssh/dist/src/index.js","../../../D:/a/_work/1/s/vscode/telemetry/core/dist/src/FaultType.js","../../../D:/a/_work/1/s/vscode/telemetry/core/dist/src/Result.js","../../../D:/a/_work/1/s/vscode/telemetry/core/dist/src/Telemetry.js","../../../D:/a/_work/1/s/vscode/telemetry/core/dist/src/TelemetryFilters.js","../../../D:/a/_work/1/s/vscode/telemetry/core/dist/src/TelemetryStrings.js","../../../D:/a/_work/1/s/vscode/telemetry/core/dist/src/index.js","../../../D:/a/_work/1/s/vscode/telemetry/node-telemetry-reporter/dist/src/TelemetryReporter.js","../../../D:/a/_work/1/s/vscode/telemetry/node-telemetry-reporter/dist/src/index.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/components/CallbackContainer.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/components/DisposableClass.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/components/Mutex.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/components/Signal.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/components/index.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/constants/index.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/constants/time.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/errors/AggregateError.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/errors/AssertionError.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/errors/AuthenticationError.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/errors/BaseError.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/errors/CancellationError.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/errors/NotImplementedError.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/errors/PromiseRaceError.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/errors/index.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/index.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/mocks/DisposableClassMock.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/mocks/index.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/utils/arrayUnique.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/utils/asserts/assert.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/utils/asserts/assertDefined.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/utils/asserts/assertInstance.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/utils/asserts/assertNever.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/utils/asserts/index.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/utils/cleanupPII.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/utils/connectEvents.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/utils/createDisposable.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/utils/debounce.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/utils/decorators/index.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/utils/decorators/withHelperDecorator.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/utils/decorators/withRetriesDecorator.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/utils/defer.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/utils/dispose.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/utils/errorToObject.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/utils/errorToString.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/utils/hashString.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/utils/idFunction.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/utils/index.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/utils/isThenable.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/utils/notImplemented.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/utils/once.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/utils/onlyOnce.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/utils/promiseAny.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/utils/raceAsync.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/utils/randomBytes.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/utils/randomInt.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/utils/randomString.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/utils/throttle.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/utils/timeoutPromise.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/utils/toCamelCase.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/utils/wait.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/utils/withCache.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/utils/withMutexByArguments.js","../../../D:/a/_work/1/s/vscode/utils/dist/src/utils/withRetries.js","../../../D:/a/_work/1/s/vscode/vsls-contracts/dist/src/contracts/ContactProtocol.js","../../../D:/a/_work/1/s/vscode/vsls-contracts/dist/src/contracts/VSLS.js","../../../D:/a/_work/1/s/vscode/vsls-contracts/dist/src/index.js","../../../D:/a/_work/1/s/vscode/workspace/client-hub/dist/src/WorkspaceHubClient.js","../../../D:/a/_work/1/s/vscode/workspace/client-hub/dist/src/index.js","../../../D:/a/_work/1/s/vscode/workspace/client/dist/src/SshHelpers.js","../../../D:/a/_work/1/s/vscode/workspace/client/dist/src/SshWorkspaceSession.js","../../../D:/a/_work/1/s/vscode/workspace/client/dist/src/SshWorkspaceSessionFactory.js","../../../D:/a/_work/1/s/vscode/workspace/client/dist/src/WorkspaceClient.js","../../../D:/a/_work/1/s/vscode/workspace/client/dist/src/index.js","../../../D:/a/_work/1/s/vscode/workspace/connection-hub/dist/src/connection/CodespaceConnection.js","../../../D:/a/_work/1/s/vscode/workspace/connection-hub/dist/src/connection/Connection.js","../../../D:/a/_work/1/s/vscode/workspace/connection-hub/dist/src/connection/LiveShareConnection.js","../../../D:/a/_work/1/s/vscode/workspace/connection-hub/dist/src/connection/LiveShareJointConnection.js","../../../D:/a/_work/1/s/vscode/workspace/connection-hub/dist/src/connection/VSCodeConnection.js","../../../D:/a/_work/1/s/vscode/workspace/connection-hub/dist/src/connection/VSCodeJointConnection.js","../../../D:/a/_work/1/s/vscode/workspace/connection-hub/dist/src/connectionHub/ConnectionHub.js","../../../D:/a/_work/1/s/vscode/workspace/connection-hub/dist/src/connectionHub/ConnectionHubRecord.js","../../../D:/a/_work/1/s/vscode/workspace/connection-hub/dist/src/connectionHub/constants.js","../../../D:/a/_work/1/s/vscode/workspace/connection-hub/dist/src/constants.js","../../../D:/a/_work/1/s/vscode/workspace/connection-hub/dist/src/errors/ConnectionCancellationError.js","../../../D:/a/_work/1/s/vscode/workspace/connection-hub/dist/src/errors/ConnectionError.js","../../../D:/a/_work/1/s/vscode/workspace/connection-hub/dist/src/errors/ConnectionStateError.js","../../../D:/a/_work/1/s/vscode/workspace/connection-hub/dist/src/errors/ConnectionTimeoutError.js","../../../D:/a/_work/1/s/vscode/workspace/connection-hub/dist/src/errors/index.js","../../../D:/a/_work/1/s/vscode/workspace/connection-hub/dist/src/index.js","../../../D:/a/_work/1/s/vscode/workspace/connection-hub/dist/src/interfaces/TConnectionTypes.js","../../../D:/a/_work/1/s/vscode/workspace/connection-hub/dist/src/interfaces/VSCodeServerHostRPCService.js","../../../D:/a/_work/1/s/vscode/workspace/connection-hub/dist/src/mocks/connection/ConnectionMock.js","../../../D:/a/_work/1/s/vscode/workspace/connection-hub/dist/src/mocks/connection/VSCodeConnectionMock.js","../../../D:/a/_work/1/s/vscode/workspace/connection-hub/dist/src/mocks/connectionHub/ConnectionHubMock.js","../../../D:/a/_work/1/s/vscode/workspace/connection-hub/dist/src/mocks/helpers/getConnectionHubMockOptions.js","../../../D:/a/_work/1/s/vscode/workspace/connection-hub/dist/src/mocks/helpers/getConnectionMockOptions.js","../../../D:/a/_work/1/s/vscode/workspace/connection-hub/dist/src/mocks/helpers/getLiveShareConnectionMockOptionsTestHelper.js","../../../D:/a/_work/1/s/vscode/workspace/connection-hub/dist/src/mocks/helpers/index.js","../../../D:/a/_work/1/s/vscode/workspace/connection-hub/dist/src/mocks/index.js","../../../D:/a/_work/1/s/vscode/workspace/connection-hub/dist/src/performance/PerformanceEventIds.js","../../../D:/a/_work/1/s/vscode/workspace/connection-hub/dist/src/performance/PerformanceGroupIds.js","../../../D:/a/_work/1/s/vscode/workspace/connection-hub/dist/src/utils/errorToConnectionError.js","../../../D:/a/_work/1/s/vscode/workspace/connection-hub/dist/src/utils/findSourcePort.js","../../../D:/a/_work/1/s/vscode/workspace/connection-hub/dist/src/utils/getVSCodeServerSessionName.js","../../../D:/a/_work/1/s/vscode/workspace/connection-hub/dist/src/utils/isVSCodeServerSession.js","../../../D:/a/_work/1/s/vscode/workspace/core/dist/src/ConnectedState.js","../../../D:/a/_work/1/s/vscode/workspace/core/dist/src/Errors.js","../../../D:/a/_work/1/s/vscode/workspace/core/dist/src/IWorkspaceConnection.js","../../../D:/a/_work/1/s/vscode/workspace/core/dist/src/IWorkspaceSessionInfo.js","../../../D:/a/_work/1/s/vscode/workspace/core/dist/src/RpcErrorCodes.js","../../../D:/a/_work/1/s/vscode/workspace/core/dist/src/WorkspaceApi.js","../../../D:/a/_work/1/s/vscode/workspace/core/dist/src/WorkspaceClientBase.js","../../../D:/a/_work/1/s/vscode/workspace/core/dist/src/WorkspaceServiceClient.js","../../../D:/a/_work/1/s/vscode/workspace/core/dist/src/checkConnectionWithTimeout.js","../../../D:/a/_work/1/s/vscode/workspace/core/dist/src/checkWorkspaceClient.js","../../../D:/a/_work/1/s/vscode/workspace/core/dist/src/index.js","../../../D:/a/_work/1/s/vscode/workspace/core/dist/src/telemetryStrings.js","../../../D:/a/_work/1/s/vscode/workspace/hub-util/dist/src/hubUtils.js","../../../D:/a/_work/1/s/vscode/workspace/hub-util/dist/src/index.js","../../../D:/a/_work/1/s/vscode/workspace/hub-util/dist/src/logUtils.js","../../../../dist/src/LocalPortForwarder.js","../../../../dist/src/SudoPortForwarderClient.js","../../../../dist/src/SudoPortForwarderService.js","../../../../dist/src/SudoPortForwarderServiceClient.js","../../../../dist/src/connection/HubClientConnection.js","../../../../dist/src/connection/connection-hub.js","../../../../dist/src/index.js","../../../../dist/src/performance/performance.js","../../.././app.ts","../../../external \"assert\"","../../../external \"async_hooks\"","../../../external \"buffer\"","../../../external \"child_process\"","../../../external \"console\"","../../../external \"constants\"","../../../external \"crypto\"","../../../external \"dns\"","../../../external \"events\"","../../../external \"fs\"","../../../external \"http\"","../../../external \"https\"","../../../external \"module\"","../../../external \"net\"","../../../external \"os\"","../../../external \"path\"","../../../external \"perf_hooks\"","../../../external \"stream\"","../../../external \"timers\"","../../../external \"tty\"","../../../external \"url\"","../../../external \"util\"","../../../external \"vscode\"","../../../external \"zlib\""],"names":[],"mappings":";;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,iDAAiD,gBAAgB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,iDAAiD,gBAAgB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;;;;;;ACjEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAgD;AACsB;AACqD;AAClF;AACzC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA,sBAAsB,6DAAqB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,6DAAqB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oDAAK;AAClC,mCAAmC,YAAY,0BAA0B,UAAU,SAAS,gBAAgB;AAC5G;AACA;AACA;AACA,uCAAuC,YAAY,2BAA2B,UAAU;AACxF,0BAA0B,6DAAqB;AAC/C;AACA,mCAAmC,YAAY,wBAAwB,UAAU,SAAS,aAAa;AACvG,sBAAsB,uDAAe;AACrC;AACA;AACA;AACA,sBAAsB,qEAA6B;AACnD;AACA;AACA,sBAAsB,+DAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+DAAuB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+DAAuB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,8CAAO,4BAA4B,6BAA6B;AAC1F;AACA;AACA;AACA;AACA,iGAAiG,0FAAwB;AACzH,mBAAmB,8CAAO,WAAW,SAAS,oEAAa,qBAAqB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iGAAiG,0FAAwB;AACzH,mBAAmB,8CAAO,sBAAsB,SAAS,oEAAa,qBAAqB;AAC3F;AACA;AACA,wC;;;;;;;;;;;;AChLA;AAAA;AAAA;AAAA;AAAyD;AAClD;AACP,4BAA4B,sEAAuB;AACnD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,oD;;;;;;;;;;;;ACfA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA0E;AACA;AAC1E;AACA;AACA;AACA;AACA;AACA,OAAO,wFAAwF;AACxF,8EAA8E,kDAAS;AACvF,sFAAsF,kDAAW;AACjG,sHAAsH,gEAAmB;AAChJ,iC;;;;;;;;;;;;ACXA;AAAA;AAAA;AAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,0CAA0C;AAC1C;AACA,2DAA2D;AAC3D;AACA;AACA,mBAAmB,0DAAY,sCAAsC,wBAAwB;AAC7F;AACA;AACA,+DAA+D,UAAU,SAAS;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;AC1CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA2C;AAClB;AACzB,iC;;;;;;;;;;;;ACFA;AAAA;AAAA;AAA0C;AACnC;AACP,2BAA2B,sDAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,yC;;;;;;;;;;;;ACZa;AACb,8CAA8C,cAAc;AAC5D,kBAAkB,mBAAO,CAAC,yEAAW;AACrC,qBAAqB,mBAAO,CAAC,qEAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oD;;;;;;;;;;;;ACxCa;AACb,8CAA8C,cAAc;AAC5D,mBAAmB,mBAAO,CAAC,iFAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;;;;;;ACjDa;AACb,8CAA8C,cAAc;AAC5D,uBAAuB,mBAAO,CAAC,yFAA2B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0C;;;;;;;;;;;;AChBa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA,oBAAoB,mBAAO,CAAC,6DAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mC;;;;;;;;;;;;ACvCa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;;;;;;;;;ACXa;AACb,8CAA8C,cAAc;AAC5D,mBAAmB,mBAAO,CAAC,mEAAY;AACvC,aAAa,mBAAO,CAAC,kBAAM;AAC3B,kBAAkB,mBAAO,CAAC,yDAAW;AACrC,yBAAyB,mBAAO,CAAC,uEAAkB;AACnD,mBAAmB,mBAAO,CAAC,iFAAuB;AAClD,uBAAuB,mBAAO,CAAC,yFAA2B;AAC1D,gBAAgB,mBAAO,CAAC,2DAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,WAAW,EAAE,OAAO,GAAG,cAAc,KAAK,GAAG,IAAI,QAAQ;AAChF;AACA;AACA,uBAAuB,WAAW,EAAE,OAAO,GAAG,cAAc,IAAI,QAAQ;AACxE;AACA;AACA;AACA;AACA,gCAAgC,EAAE,IAAI,IAAI;AAC1C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,SAAS,EAAE,cAAc,EAAE,SAAS,EAAE,SAAS,EAAE,UAAU;AACpF;AACA;AACA;AACA,uBAAuB,SAAS,EAAE,cAAc,EAAE,SAAS,EAAE,SAAS,EAAE,UAAU;AAClF;AACA;AACA;AACA,uBAAuB,cAAc,EAAE,kBAAkB,EAAE,SAAS,EAAE,UAAU;AAChF;AACA;AACA;AACA,uBAAuB,SAAS,EAAE,UAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uBAAuB,GAAG,oBAAoB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,aAAa,GAAG,UAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;ACvKa;AACb,8CAA8C,cAAc;AAC5D,sBAAsB,mBAAO,CAAC,iEAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iDAAiD,GAAG,OAAO,IAAI,KAAK;AAC3F;AACA;AACA;AACA;AACA;AACA,yC;;;;;;;;;;;;ACvBa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,iBAAiB,mBAAO,CAAC,sBAAQ;AACjC,qBAAqB,mBAAO,CAAC,qEAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,UAAU,GAAG,KAAK;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;ACxFa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gD;;;;;;;;;;;;ACXa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA,SAAS,mBAAO,CAAC,qEAAc;AAC/B;AACA;AACA;AACA,SAAS,mBAAO,CAAC,mEAAa;AAC9B;AACA;AACA;AACA,SAAS,mBAAO,CAAC,+DAAW;AAC5B;AACA;AACA;AACA,SAAS,mBAAO,CAAC,2DAAS;AAC1B;AACA;AACA;AACA,SAAS,mBAAO,CAAC,2DAAS;AAC1B;AACA;AACA;AACA,uBAAuB,mBAAO,CAAC,uEAAkB;AACjD;AACA,iCAAiC,mBAAO,CAAC,2FAA4B;AACrE;AACA,6BAA6B,mBAAO,CAAC,mFAAwB;AAC7D;AACA,sBAAsB,mBAAO,CAAC,qEAAiB;AAC/C;AACA,oBAAoB,mBAAO,CAAC,iEAAe;AAC3C;AACA,oBAAoB,mBAAO,CAAC,iEAAe;AAC3C;AACA,qBAAqB,mBAAO,CAAC,mEAAgB;AAC7C;AACA,eAAe,mBAAO,CAAC,uDAAU;AACjC;AACA;AACA,gBAAgB,mBAAO,CAAC,yDAAW;AACnC;AACA,iC;;;;;;;;;;;;AC/Ca;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,uDAAuD;AACxD;AACA,oC;;;;;;;;;;;;AChBa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,mEAAmE;AACpE;AACA,wC;;;;;;;;;;;;ACba;AACb,8CAA8C,cAAc;AAC5D,iBAAiB,mBAAO,CAAC,sEAAY;AACrC;AACA,qBAAqB,mBAAO,CAAC,8EAAgB;AAC7C;AACA,iC;;;;;;;;;;;;ACNa;AACb,8CAA8C,cAAc;AAC5D,mBAAmB,mBAAO,CAAC,kFAAwB;AACnD,kBAAkB,mBAAO,CAAC,gEAAY;AACtC,+BAA+B,mBAAO,CAAC,6FAAwB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qD;;;;;;;;;;;;ACnCa;AACb,8CAA8C,cAAc;AAC5D,mBAAmB,mBAAO,CAAC,kFAAwB;AACnD,sBAAsB,mBAAO,CAAC,kEAAgB;AAC9C,wBAAwB,mBAAO,CAAC,sEAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gD;;;;;;;;;;;;ACxCa;AACb,8CAA8C,cAAc;AAC5D,sBAAsB,mBAAO,CAAC,kEAAgB;AAC9C,wBAAwB,mBAAO,CAAC,sEAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+C;;;;;;;;;;;;AClDa;AACb,8CAA8C,cAAc;AAC5D,sBAAsB,mBAAO,CAAC,kEAAgB;AAC9C,wBAAwB,mBAAO,CAAC,sEAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mBAAO,CAAC,sBAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+C;;;;;;;;;;;;AC3Ca;AACb,8CAA8C,cAAc;AAC5D,kCAAkC,mBAAO,CAAC,uGAA6B;AACvE;AACA,6BAA6B,mBAAO,CAAC,6FAAwB;AAC7D;AACA,4BAA4B,mBAAO,CAAC,2FAAuB;AAC3D;AACA,4BAA4B,mBAAO,CAAC,2FAAuB;AAC3D;AACA,iC;;;;;;;;;;;;ACVa;AACb,8CAA8C,cAAc;AAC5D,gBAAgB,mBAAO,CAAC,iEAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,OAAO,GAAG,KAAK;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8C;;;;;;;;;;;;ACjDa;AACb,8CAA8C,cAAc;AAC5D,2BAA2B,mBAAO,CAAC,uFAAsB;AACzD;AACA,iC;;;;;;;;;;;;ACJa;AACb,8CAA8C,cAAc;AAC5D;AACA,iBAAiB,EAAE;AACnB,gBAAgB,EAAE;AAClB,kBAAkB,EAAE;AACpB,iBAAiB,EAAE;AACnB,kBAAkB,EAAE;AACpB;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2C;;;;;;;;;;;;ACpCa;AACb,8CAA8C,cAAc;AAC5D,wBAAwB,mBAAO,CAAC,+EAAmB;AACnD;AACA,iC;;;;;;;;;;;;ACJa;AACb,8CAA8C,cAAc;AAC5D,6BAA6B,mBAAO,CAAC,oGAAoB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;;;;;;;;;ACjCa;AACb,8CAA8C,cAAc;AAC5D,sBAAsB,mBAAO,CAAC,2EAAiB;AAC/C;AACA,iC;;;;;;;;;;;;ACJa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;AC1DA,gBAAgB,mBAAO,CAAC,uEAAY;AACpC,eAAe,mBAAO,CAAC,+EAAgB;;AAEvC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;AACA,mCAAmC;AACnC,oCAAoC;AACpC;AACA;AACA;;;AAGA;AACA;AACA,wCAAwC,GAAG,IAAI;AAC/C;AACA;AACA;;AAEA;AACA,qBAAqB,KAAK;;AAE1B;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,aAAa;AAClC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B,uCAAuC,GAAG;AAC1C,YAAY,GAAG,yBAAyB;AACxC;AACA;AACA,8BAA8B;AAC9B,cAAc,GAAG;AACjB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,KAAK;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ,EAAE;AACV,2BAA2B;AAC3B,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,YAAY,KAAK,QAAQ,EAAE,IAAI,EAAE;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,mCAAmC,2BAA2B;AAC9D;;AAEA,iBAAiB,cAAc;AAC/B,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACvMA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACpEA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;ACZA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;;AAEvD;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,qEAAU;;AAEnC,OAAO,WAAW;;AAElB;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;;;;;;;;;;;;AC3QA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAO,CAAC,uDAAI;AACpC;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,cAAc;AAC1B;AACA;AACA;AACA;;AAEA,iBAAiB,sBAAsB;AACvC;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;;AAEA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACpQA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,mBAAO,CAAC,0EAAc;AACxC,CAAC;AACD,kBAAkB,mBAAO,CAAC,oEAAW;AACrC;;;;;;;;;;;;ACTA;AACA;AACA;;AAEA,YAAY,mBAAO,CAAC,gBAAK;AACzB,aAAa,mBAAO,CAAC,kBAAM;;AAE3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,uBAAuB,mBAAO,CAAC,+EAAgB;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,4DAA4D;AAC5D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA,CAAC,IAAI;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,2BAA2B;;AAEnC;AACA;AACA,iDAAiD,EAAE;AACnD,sBAAsB,WAAW,IAAI,KAAK;;AAE1C;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,qEAAU;;AAEnC,OAAO,WAAW;;AAElB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACtQa;;AAEb;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACPA;AACA;;AAEA,YAAY;AACZ;AACA,SAAS,mBAAO,CAAC,kBAAM;AACvB,CAAC;;AAED;AACA,aAAa,mBAAO,CAAC,iFAAiB;;AAEtC;AACA,QAAQ,uCAAuC;AAC/C,QAAQ,2BAA2B;AACnC,QAAQ,2BAA2B;AACnC,QAAQ,2BAA2B;AACnC,QAAQ;AACR;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,yCAAyC,IAAI;;AAE7C;AACA;AACA;;AAEA;AACA,gCAAgC;;AAEhC,aAAa;AACb;AACA;AACA;AACA;AACA,GAAG,IAAI;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;AACL,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK,IAAI;AACT,KAAK,GAAG;AACR,KAAK,KAAK;AACV,KAAK,IAAI,IAAI,EAAE;AACf,KAAK,IAAI,EAAE,IAAI;AACf;AACA;AACA,KAAK,IAAI,OAAO,IAAI;AACpB,KAAK,EAAE,OAAO,EAAE;AAChB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sBAAsB,IAAI;AAC1B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,IAAI;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,IAAI;AACvC;AACA;AACA;AACA,gCAAgC,EAAE,EAAE,KAAK;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,6CAA6C;AAC7C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;;AAEA,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK,6CAA6C;;AAElD;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B;AAC3B;;;;;;;;;;;;AC15BA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACjKA,wBAAwB,mBAAO,CAAC,4EAAY;AAC5C,WAAW,mBAAO,CAAC,kBAAM;;AAEzB;AACA;AACA,OAAO,mBAAO,CAAC,cAAI;AACnB;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA,iBAAiB,mBAAO,CAAC,yEAAa;;AAEtC;AACA;AACA;;AAEA;AACA;;AAEA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,YAAY,kBAAkB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,2BAA2B;AAC3B;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0DAA0D,gCAAgC,EAAE;AAC5F,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2DAA2D,GAAG,sBAAsB,GAAG;AACvF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,wBAAwB;AAC5D,sCAAsC,sBAAsB;AAC5D,wCAAwC,4BAA4B;AACpE,iDAAiD,wBAAwB;AACzE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sCAAsC,eAAe;AACrD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,eAAe;AACf;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,2FAA2F,oBAAoB;AAC/G;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;AC1kBA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA,WAAW,mBAAO,CAAC,sEAAQ;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACxHA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D,oBAAoB;AACpB;AACA;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,0EAAU;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;;;;;;;;;;;AC3IA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gBAAgB;;AAEhB,mBAAmB;AACnB,oBAAoB;;AAEpB,gBAAgB;AAChB,gBAAgB;;AAEhB,gBAAgB;AAChB,iBAAiB;;AAEjB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;AClEA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;AC9GA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA,WAAW,mBAAO,CAAC,sEAAQ;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC9EA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA,WAAW,OAAO;AAClB;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA,WAAW,SAAS;AACpB;AACA,WAAW,OAAO;AAClB;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjHA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA,WAAW,mBAAO,CAAC,sEAAQ;AAC3B,mBAAmB,mBAAO,CAAC,wFAAiB;AAC5C,eAAe,mBAAO,CAAC,gFAAa;AACpC,gBAAgB,mBAAO,CAAC,kFAAc;AACtC,gBAAgB,mBAAO,CAAC,kFAAc;;AAEtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,mBAAmB;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,MAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,kCAAkC;AAC/C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sDAAsD,YAAY;AAClE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB,cAAc;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wCAAwC;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,mBAAmB,EAAE;AACpE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA,6BAA6B,MAAM;AACnC;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C,qBAAqB,+CAA+C;AACpE;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA,qBAAqB,4BAA4B;AACjD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;ACxnCA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,mBAAO,CAAC,kFAAc;AACtC,WAAW,mBAAO,CAAC,sEAAQ;AAC3B,eAAe,mBAAO,CAAC,gFAAa;AACpC,kBAAkB,mBAAO,CAAC,sFAAgB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C,SAAS;AACnD;AACA;;AAEA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACxaA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,mBAAO,CAAC,sGAAwB;AACzD,WAAW,mBAAO,CAAC,sEAAQ;;AAE3B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;;AAEA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,4CAA4C,cAAc;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH,UAAU;AACV;;AAEA;;;;;;;;;;;;AC5ZA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;;AAEA;AACA,cAAc;AACd;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;ACveA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mBAAO,CAAC,0GAA4B;AACjE,4BAA4B,mBAAO,CAAC,wGAA2B;AAC/D,qBAAqB,mBAAO,CAAC,wFAAmB;;;;;;;;;;;;;ACPnC;AACb,WAAW,mBAAO,CAAC,cAAI;AACvB,YAAY,mBAAO,CAAC,gBAAK;AACzB,gBAAgB,mBAAO,CAAC,mEAAU;;AAElC,OAAO,IAAI;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iCAAiC,GAAG;AACpC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1Ia;AACb,8CAA8C,cAAc;AAC5D;AACA,6BAA6B,mBAAO,CAAC,sFAAwB;AAC7D;AACA;AACA,qBAAqB,mBAAO,CAAC,sEAAgB;AAC7C;AACA;AACA,kBAAkB,mBAAO,CAAC,oFAAuB;AACjD;AACA,iC;;;;;;;;;;;;ACXa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,0BAA0B,mBAAO,CAAC,oEAAiB;AACnD,wBAAwB,mBAAO,CAAC,cAAI;AACpC,0BAA0B,mBAAO,CAAC,kBAAM;AACxC,wBAAwB,mBAAO,CAAC,cAAI;AACpC,2BAA2B,mBAAO,CAAC,kGAA8B;AACjE,uBAAuB,mBAAO,CAAC,sEAAgB;AAC/C,wBAAwB,mBAAO,CAAC,iEAAmB;AACnD,sBAAsB,mBAAO,CAAC,6DAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,WAAW,GAAG,WAAW,EAAE,MAAM,GAAG,iBAAiB;AACvH;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2KAA2K,YAAY;AACvL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,gD;;;;;;;;;;;;ACpGa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA,wC;;;;;;;;;;;;ACLa;AACb,8CAA8C,cAAc;AAC5D,sBAAsB,mBAAO,CAAC,6DAAiB;AAC/C,+BAA+B,mBAAO,CAAC,uFAAyB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;ACzBa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4C;;;;;;;;;;;;ACTa;AACb,8CAA8C,cAAc;AAC5D,sBAAsB,mBAAO,CAAC,wDAAiB;AAC/C,iBAAiB,mBAAO,CAAC,0DAAY;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uD;;;;;;;;;;;;ACrBa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,SAAS,mBAAO,CAAC,gGAA+B;AAChD,SAAS,mBAAO,CAAC,gEAAe;AAChC,iC;;;;;;;;;;;;ACPa;AACb,8CAA8C,cAAc;AAC5D,YAAY,mBAAO,CAAC,gBAAK;AACzB,WAAW,mBAAO,CAAC,cAAI;AACvB,WAAW,mBAAO,CAAC,cAAI;AACvB,qBAAqB,mBAAO,CAAC,qDAAgB;AAC7C,yBAAyB,mBAAO,CAAC,8DAAoB;AACrD;AACA;AACA;AACA;AACA,WAAW,2DAA2D,EAAE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,MAAM;AAC7D;AACA;AACA,0DAA0D,8DAA8D;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,6CAA6C;AACxG,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,aAAa,GAAG,MAAM;AAC/E;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,kDAAkD,gCAAgC;AAClF;AACA;AACA;AACA;AACA,8CAA8C,MAAM,SAAS,gCAAgC;AAC7F;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,+CAA+C,EAAE;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,MAAM;AAC1D;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,4DAA4D,8BAA8B;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;AC3Ja;AACb,8CAA8C,cAAc;AAC5D,WAAW,mBAAO,CAAC,cAAI;AACvB,aAAa,mBAAO,CAAC,kBAAM;AAC3B,YAAY,mBAAO,CAAC,0DAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0C;;;;;;;;;;;;ACnKa;AACb,8CAA8C,cAAc;AAC5D,yBAAyB,mBAAO,CAAC,qEAAkB;AACnD,aAAa,mBAAO,CAAC,kBAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;AC7Ba;AACb,8CAA8C,cAAc;AAC5D,WAAW,mBAAO,CAAC,cAAI;AACvB;AACA;AACA,+BAA+B,SAAS;AACxC;AACA;AACA;AACA;AACA,kBAAkB,YAAY,cAAc,SAAS;AACrD;AACA;AACA;AACA,uC;;;;;;;;;;;;ACda;AACb,8CAA8C,cAAc;AAC5D,WAAW,mBAAO,CAAC,cAAI;AACvB,qBAAqB,mBAAO,CAAC,6DAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+C;;;;;;;;;;;;AChBa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,oBAAoB,mBAAO,CAAC,+DAAe;AAC3C;AACA,sBAAsB,mBAAO,CAAC,mEAAiB;AAC/C;AACA,qBAAqB,mBAAO,CAAC,iEAAgB;AAC7C;AACA;AACA,SAAS,mBAAO,CAAC,2DAAa;AAC9B,uBAAuB,mBAAO,CAAC,qEAAkB;AACjD;AACA,4BAA4B,mBAAO,CAAC,+EAAuB;AAC3D;AACA,oBAAoB,mBAAO,CAAC,+DAAe;AAC3C;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,6DAAc;AACzC;AACA,iC;;;;;;;;;;;;ACvBa;AACb,8CAA8C,cAAc;AAC5D,iBAAiB,mBAAO,CAAC,yDAAU;AACnC,sBAAsB,mBAAO,CAAC,6DAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oCAAoC,+CAA+C;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,yC;;;;;;;;;;;;AC3Ca;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,6DAA6D;AAC9D,sC;;;;;;;;;;;;ACTa;AACb,8CAA8C,cAAc;AAC5D,WAAW,mBAAO,CAAC,cAAI;AACvB,aAAa,mBAAO,CAAC,kBAAM;AAC3B,WAAW,mBAAO,CAAC,cAAI;AACvB,sBAAsB,mBAAO,CAAC,oCAAe;AAC7C,aAAa,mBAAO,CAAC,4DAAa;AAClC,qBAAqB,mBAAO,CAAC,6DAAc;AAC3C;AACA;AACA;AACA;AACA,sDAAsD,cAAc,YAAY,YAAY;AAC5F;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,UAAU,IAAI,eAAe;AACrE;AACA,gCAAgC,qCAAqC;AACrE;AACA;AACA,4CAA4C,iDAAiD;AAC7F;AACA;AACA,mCAAmC,UAAU,IAAI,eAAe;AAChE;AACA,6DAA6D,UAAU,IAAI,eAAe,OAAO,qCAAqC;AACtI;AACA;AACA,uCAAuC,0CAA0C;AACjF;AACA;AACA,wC;;;;;;;;;;;;AC9Da;AACb,8CAA8C,cAAc;AAC5D,YAAY,mBAAO,CAAC,gBAAK;AACzB,sBAAsB,mBAAO,CAAC,+DAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;ACnCa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,qBAAqB,mBAAO,CAAC,sGAA6B;AAC1D,qBAAqB,mBAAO,CAAC,2FAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yBAAyB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,mC;;;;;;;;;;;;ACnFa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,iBAAiB,mBAAO,CAAC,sFAAa;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;;;;;;;;;AC9Ca;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,0BAA0B,mBAAO,CAAC,kHAA8B;AAChE,qBAAqB,mBAAO,CAAC,2FAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,mC;;;;;;;;;;;;ACjEa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,8BAA8B,mBAAO,CAAC,kJAA8C;AACpF,0BAA0B,mBAAO,CAAC,0IAA0C;AAC5E,qBAAqB,mBAAO,CAAC,2FAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mDAAmD;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mDAAmD;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,uC;;;;;;;;;;;;AC/Ea;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,2BAA2B,mBAAO,CAAC,gHAA6B;AAChE,4BAA4B,mBAAO,CAAC,kHAA8B;AAClE,0BAA0B,mBAAO,CAAC,8GAA4B;AAC9D,qBAAqB,mBAAO,CAAC,2FAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,iC;;;;;;;;;;;;ACvEa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,mC;;;;;;;;;;;;ACjBa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,uDAAuD;AACxD,sC;;;;;;;;;;;;AClBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,qC;;;;;;;;;;;;ACjBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,kC;;;;;;;;;;;;ACjBa;AACb,8CAA8C,cAAc;AAC5D,gC;;;;;;;;;;;;ACFa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,qBAAqB,mBAAO,CAAC,sGAA6B;AAC1D,UAAU,mBAAO,CAAC,qEAAK;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA,mC;;;;;;;;;;;;ACzHa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA,6BAA6B,wBAAwB;AACrD;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,iD;;;;;;;;;;;;ACrCa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,6C;;;;;;;;;;;;ACxCa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oCAAoC,aAAa,EAAE,EAAE;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,aAAa,mBAAO,CAAC,+FAAoB;AACzC,aAAa,mBAAO,CAAC,yFAAiB;AACtC,aAAa,mBAAO,CAAC,qFAAe;AACpC,aAAa,mBAAO,CAAC,6FAAmB;AACxC,aAAa,mBAAO,CAAC,yIAAyC;AAC9D,aAAa,mBAAO,CAAC,iJAA6C;AAClE,aAAa,mBAAO,CAAC,6FAAmB;AACxC,aAAa,mBAAO,CAAC,mGAAsB;AAC3C,aAAa,mBAAO,CAAC,qHAA+B;AACpD,aAAa,mBAAO,CAAC,6GAA2B;AAChD,aAAa,mBAAO,CAAC,yFAAiB;AACtC,aAAa,mBAAO,CAAC,yGAAyB;AAC9C,aAAa,mBAAO,CAAC,2FAAkB;AACvC,aAAa,mBAAO,CAAC,iGAAqB;AAC1C,aAAa,mBAAO,CAAC,iHAA6B;AAClD,aAAa,mBAAO,CAAC,qGAAuB;AAC5C,aAAa,mBAAO,CAAC,2GAA0B;AAC/C,aAAa,mBAAO,CAAC,+FAAoB;AACzC,aAAa,mBAAO,CAAC,qFAAe;AACpC,aAAa,mBAAO,CAAC,mGAAsB;AAC3C,aAAa,mBAAO,CAAC,mFAAc;AACnC,aAAa,mBAAO,CAAC,+FAAoB;AACzC,aAAa,mBAAO,CAAC,2FAAkB;AACvC,aAAa,mBAAO,CAAC,+FAAoB;AACzC,aAAa,mBAAO,CAAC,+GAA4B;AACjD,aAAa,mBAAO,CAAC,iGAAqB;AAC1C,aAAa,mBAAO,CAAC,iHAA6B;AAClD,aAAa,mBAAO,CAAC,yFAAiB;AACtC,aAAa,mBAAO,CAAC,uGAAwB;AAC7C,aAAa,mBAAO,CAAC,mGAAsB;AAC3C,aAAa,mBAAO,CAAC,6FAAmB;AACxC,aAAa,mBAAO,CAAC,mFAAc;AACnC,aAAa,mBAAO,CAAC,iGAAqB;AAC1C,aAAa,mBAAO,CAAC,uFAAgB;AACrC,aAAa,mBAAO,CAAC,+FAAoB;AACzC,aAAa,mBAAO,CAAC,iGAAqB;AAC1C,aAAa,mBAAO,CAAC,iGAAqB;AAC1C,aAAa,mBAAO,CAAC,yGAAyB;AAC9C,aAAa,mBAAO,CAAC,uFAAgB;AACrC,0BAA0B,mBAAO,CAAC,6GAA2B;AAC7D,kDAAkD,qCAAqC,2CAA2C,EAAE,EAAE;AACtI,mDAAmD,qCAAqC,4CAA4C,EAAE,EAAE;AACxI,wDAAwD,qCAAqC,iDAAiD,EAAE,EAAE;AAClJ,sDAAsD,qCAAqC,+CAA+C,EAAE,EAAE;AAC9I,kDAAkD,qCAAqC,2CAA2C,EAAE,EAAE;AACtI,iDAAiD,qCAAqC,0CAA0C,EAAE,EAAE;AACpI,qBAAqB,mBAAO,CAAC,sGAA6B;AAC1D,gDAAgD,qCAAqC,oCAAoC,EAAE,EAAE;AAC7H,oDAAoD,qCAAqC,wCAAwC,EAAE,EAAE;AACrI,gBAAgB,mBAAO,CAAC,qFAAe;AACvC;AACA;AACA,cAAc,mBAAO,CAAC,iFAAa;AACnC;AACA;AACA,gBAAgB,mBAAO,CAAC,qFAAe;AACvC;AACA;AACA,oBAAoB,mBAAO,CAAC,6FAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;;;;;AC/Fa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,+C;;;;;;;;;;;;ACjBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,2C;;;;;;;;;;;;ACjBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,iC;;;;;;;;;;;;ACjBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,yC;;;;;;;;;;;;ACjBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0DAA0D;AAC3D,kC;;;;;;;;;;;;ACxBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,uDAAuD;AACpF;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,8CAA8C,cAAc;AAC5D;AACA;AACA,8CAA8C,YAAY;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;AC/Ma;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,kBAAkB,mBAAO,CAAC,yFAAa;AACvC;AACA,6BAA6B,oBAAoB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,6C;;;;;;;;;;;;ACjCa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,uC;;;;;;;;;;;;ACjBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,0C;;;;;;;;;;;;ACjBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oCAAoC,aAAa,EAAE,EAAE;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,aAAa,mBAAO,CAAC,sFAAQ;AAC7B,iC;;;;;;;;;;;;AC5Ba;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;ACrBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oCAAoC,aAAa,EAAE,EAAE;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,aAAa,mBAAO,CAAC,iGAAc;AACnC,iC;;;;;;;;;;;;AC5Ba;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,iC;;;;;;;;;;;;ACjBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,sC;;;;;;;;;;;;ACrDa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,0BAA0B,mBAAO,CAAC,uGAAqB;AACvD;AACA,gCAAgC,WAAW;AAC3C;AACA;AACA;AACA;AACA;AACA,sCAAsC,yDAAyD;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA,CAAC;AACD;AACA;AACA,oC;;;;;;;;;;;;ACjEa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,iBAAiB,mBAAO,CAAC,qFAAY;AACrC,0BAA0B,mBAAO,CAAC,uGAAqB;AACvD,gBAAgB,mBAAO,CAAC,8FAAoB;AAC5C;AACA,6BAA6B,aAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;AC7Da;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,mBAAmB,mBAAO,CAAC,yFAAc;AACzC;AACA,6BAA6B,qBAAqB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,8C;;;;;;;;;;;;ACnCa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,mBAAmB,mBAAO,CAAC,yFAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,uC;;;;;;;;;;;;AC1Da;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,oBAAoB,mBAAO,CAAC,2FAAe;AAC3C,2BAA2B,mBAAO,CAAC,yGAAsB;AACzD;AACA,mCAAmC,kBAAkB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,+C;;;;;;;;;;;;ACvDa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,mC;;;;;;;;;;;;ACjBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA,8CAA8C,WAAW;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA,CAAC,+EAA+E;AAChF,0C;;;;;;;;;;;;ACxCa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,uC;;;;;;;;;;;;ACjBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,sC;;;;;;;;;;;;ACjBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,sC;;;;;;;;;;;;ACjBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,gC;;;;;;;;;;;;ACjBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,wC;;;;;;;;;;;;ACjBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,gC;;;;;;;;;;;;ACjBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,wC;;;;;;;;;;;;ACjBa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,uDAAuD;AACxD,qC;;;;;;;;;;;;AC7Ca;AACb,8CAA8C,cAAc;AAC5D;AACA,oBAAoB,mBAAO,CAAC,2FAAe;AAC3C,sCAAsC,GAAG;AACzC,oCAAoC,GAAG;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kBAAkB;AAC3C,yBAAyB,kBAAkB;AAC3C;AACA;AACA;AACA;AACA;AACA,6C;;;;;;;;;;;;AC7Ba;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,6DAA6D;AAC9D,kC;;;;;;;;;;;;ACtBa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,6DAA6D;AAC9D,uC;;;;;;;;;;;;ACzBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,uC;;;;;;;;;;;;ACjBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,kC;;;;;;;;;;;;ACjBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,2C;;;;;;;;;;;;ACjBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,gBAAgB,mBAAO,CAAC,sFAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,8C;;;;;;;;;;;;ACxCa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mC;;;;;;;;;;;;ACpEa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oCAAoC,aAAa,EAAE,EAAE;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,gBAAgB,mBAAO,CAAC,sFAAW;AACnC,oDAAoD,qCAAqC,mCAAmC,EAAE,EAAE;AAChI,gDAAgD,qCAAqC,+BAA+B,EAAE,EAAE;AACxH,aAAa,mBAAO,CAAC,4GAAsB;AAC3C,aAAa,mBAAO,CAAC,kFAAS;AAC9B,iC;;;;;;;;;;;;AChCa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,iC;;;;;;;;;;;;ACjBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA,CAAC,+EAA+E;AAChF,wC;;;;;;;;;;;;ACvBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,cAAc,mBAAO,CAAC,oFAAoB;AAC1C;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO,EAAE,oCAAoC,EAAE,QAAQ;AACpF;AACA,SAAS;AACT;AACA;AACA,oDAAoD,wBAAwB,GAAG,uCAAuC;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;ACvGa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,gBAAgB,mBAAO,CAAC,iFAAS;AACjC,mBAAmB,mBAAO,CAAC,uFAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,+BAA+B;AAC/B,8BAA8B;AAC9B,8BAA8B;AAC9B;AACA;AACA,yC;;;;;;;;;;;;ACjDa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,+BAA+B;AAC/B;AACA,8BAA8B;AAC9B;AACA,8BAA8B;AAC9B;AACA;AACA,sC;;;;;;;;;;;;AC9Ba;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;AC/Da;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,gCAAgC,mBAAO,CAAC,iHAAyB;AACjE;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA,gBAAgB,EAAE;AAClB;AACA,gD;;;;;;;;;;;;ACvCa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,wBAAwB,mBAAO,CAAC,iGAAiB;AACjD,gBAAgB,mBAAO,CAAC,iFAAS;AACjC;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iD;;;;;;;;;;;;ACjEa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,mBAAmB,mBAAO,CAAC,uFAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB,EAAE,UAAU;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gC;;;;;;;;;;;;ACjKa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,uDAAuD;AACxD,iC;;;;;;;;;;;;ACzBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,cAAc,mBAAO,CAAC,oFAAoB;AAC1C,qBAAqB,mBAAO,CAAC,oGAAwB;AACrD;AACA;AACA;AACA,6BAA6B;AAC7B,sCAAsC,EAAE;AACxC,gCAAgC,GAAG,SAAS,GAAG;AAC/C,iCAAiC,GAAG,SAAS,GAAG;AAChD,8BAA8B,EAAE;AAChC;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA,sBAAsB,QAAQ,EAAE,QAAQ,EAAE,OAAO,EAAE,eAAe;AAClE,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ,GAAG,oBAAoB,GAAG,mBAAmB,IAAI,qEAAqE;AAC7J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4C;;;;;;;;;;;;AC5Ga;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,qBAAqB,mBAAO,CAAC,sGAAyB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,4BAA4B,SAAS,YAAY;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,4BAA4B,SAAS,YAAY;AAC5G;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;AChFa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,iC;;;;;;;;;;;;ACjBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oCAAoC,aAAa,EAAE,EAAE;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,aAAa,mBAAO,CAAC,kGAAqB;AAC1C,aAAa,mBAAO,CAAC,wGAAwB;AAC7C,aAAa,mBAAO,CAAC,sHAA+B;AACpD,aAAa,mBAAO,CAAC,wHAAgC;AACrD,aAAa,mBAAO,CAAC,kGAAqB;AAC1C,aAAa,mBAAO,CAAC,sFAAe;AACpC,aAAa,mBAAO,CAAC,wFAAgB;AACrC,aAAa,mBAAO,CAAC,wFAAgB;AACrC,aAAa,mBAAO,CAAC,8EAAW;AAChC,aAAa,mBAAO,CAAC,0HAAiC;AACtD,aAAa,mBAAO,CAAC,wIAAwC;AAC7D,aAAa,mBAAO,CAAC,kHAA6B;AAClD,aAAa,mBAAO,CAAC,8HAAmC;AACxD,aAAa,mBAAO,CAAC,sFAAY;AACjC,aAAa,mBAAO,CAAC,0GAAyB;AAC9C,aAAa,mBAAO,CAAC,wFAAgB;AACrC,aAAa,mBAAO,CAAC,4HAAkC;AACvD,aAAa,mBAAO,CAAC,0HAAiC;AACtD,aAAa,mBAAO,CAAC,gIAAoC;AACzD,aAAa,mBAAO,CAAC,4IAA0C;AAC/D,aAAa,mBAAO,CAAC,gGAAoB;AACzC,aAAa,mBAAO,CAAC,kGAAqB;AAC1C,aAAa,mBAAO,CAAC,gGAAoB;AACzC,aAAa,mBAAO,CAAC,kFAAa;AAClC,aAAa,mBAAO,CAAC,oFAAc;AACnC,iC;;;;;;;;;;;;ACpDa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA,0BAA0B,sBAAsB,MAAM;AACtD,oCAAoC,sBAAsB,MAAM,QAAQ,sBAAsB,KAAK;AACnG,0CAA0C,UAAU,GAAG,iBAAiB;AACxE,uCAAuC,MAAM;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;AC7Ca;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8C;;;;;;;;;;;;AC7Ba;AACb;AACA;AACA,kCAAkC,oCAAoC,aAAa,EAAE,EAAE;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAO,CAAC,uFAAQ;AAC7B,iC;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA,yG;;;;;;;;;;;;ACRa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,eAAe,mBAAO,CAAC,mFAAQ;AAC/B,aAAa,mBAAO,CAAC,kBAAM;AAC3B,6BAA6B,mBAAO,CAAC,8GAAuB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,qGAAQ,gDAAgD,CAAC;AACvG;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,sC;;;;;;;;;;;;ACnFa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6C;;;;;;;;;;;;ACvDa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,sBAAsB,mBAAO,CAAC,sGAAyB;AACvD;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,uC;;;;;;;;;;;;AC3Ba;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;;;;;;;;;AC7Ba;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oCAAoC,aAAa,EAAE,EAAE;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,aAAa,mBAAO,CAAC,kGAAc;AACnC,aAAa,mBAAO,CAAC,oGAAe;AACpC,aAAa,mBAAO,CAAC,wGAAiB;AACtC,aAAa,mBAAO,CAAC,gHAAqB;AAC1C,aAAa,mBAAO,CAAC,oGAAe;AACpC,aAAa,mBAAO,CAAC,8FAAY;AACjC,aAAa,mBAAO,CAAC,kGAAc;AACnC,iC;;;;;;;;;;;;AClCa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,qBAAqB,mBAAO,CAAC,8BAAY;AACzC;AACA,uC;;;;;;;;;;;;ACpBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,kBAAkB,mBAAO,CAAC,kFAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;;;;;;AC1Ba;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;ACtBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,uC;;;;;;;;;;;;ACjBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,cAAc,mBAAO,CAAC,oFAAoB;AAC1C;AACA,oCAAoC,eAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2C;;;;;;;;;;;;AClCa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,kC;;;;;;;;;;;;ACjBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,qBAAqB,mBAAO,CAAC,uGAAwB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;ACtGa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,cAAc,mBAAO,CAAC,oFAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4C;;;;;;;;;;;;AC/Ba;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,cAAc,mBAAO,CAAC,oFAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2C;;;;;;;;;;;;AC/Ba;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,cAAc,mBAAO,CAAC,oFAAoB;AAC1C,+BAA+B,mBAAO,CAAC,0HAAmC;AAC1E,2BAA2B,mBAAO,CAAC,8GAAoB;AACvD,0BAA0B,mBAAO,CAAC,4GAAmB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO,sBAAsB,wBAAwB,qCAAqC,2BAA2B,wCAAwC,uBAAuB,oCAAoC,0BAA0B,wCAAwC;AACtT;AACA;AACA;AACA,8C;;;;;;;;;;;;AC5Da;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,cAAc,mBAAO,CAAC,oFAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sBAAsB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,EAAE,aAAa;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oD;;;;;;;;;;;;AC/Ca;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;ACzDa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,gBAAgB,mBAAO,CAAC,yFAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;ACnHa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW,2CAA2C;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+B;;;;;;;;;;;;AC5Ca;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gC;;;;;;;;;;;;AC7Ba;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA,mC;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iDAAiD,KAAK;AACtD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB,mBAAO,CAAC,uHAA2B;AACxD,OAAO,MAAM,GAAG,mBAAO,CAAC,iGAAgB;AACxC,YAAY,mBAAO,CAAC,qGAAkB;AACtC,cAAc,mBAAO,CAAC,uGAAmB;AACzC,eAAe,mBAAO,CAAC,8FAAU;AACjC,cAAc,mBAAO,CAAC,4FAAS;;;;;;;;;;;;ACtI/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mDAAmD,MAAM;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC,SAAS,GAAG,MAAM;AACpD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA,SAAS;AACT;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,mBAAO,CAAC,wDAAW;AAC/B,uBAAuB,YAAY;;AAEnC,qBAAqB,mBAAO,CAAC,uHAA2B;AACxD,mBAAmB,mBAAO,CAAC,sGAAc;AACzC,cAAc,mBAAO,CAAC,uGAAmB;AACzC,eAAe,mBAAO,CAAC,8FAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,iGAAgB;;AAE5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL,iBAAiB,EAAE,QAAQ,OAAO;AAClC,KAAK;AACL;AACA,iBAAiB,EAAE,GAAG,EAAE,MAAM,EAAE,GAAG,OAAO;AAC1C,KAAK;AACL;AACA,iBAAiB,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG;AAChC,OAAO,IAAI,EAAE,GAAG,OAAO;AACvB,KAAK;AACL;AACA,iBAAiB,EAAE,GAAG,EAAE,GAAG;AAC3B,OAAO,IAAI,EAAE,GAAG,OAAO;AACvB;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL,iBAAiB,EAAE,MAAM,EAAE,IAAI,OAAO;AACtC,KAAK;AACL;AACA,mBAAmB,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,GAAG,OAAO;AAChD,OAAO;AACP,mBAAmB,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,OAAO;AAC3C;AACA,KAAK;AACL;AACA;AACA;AACA,qBAAqB,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG;AACpC,WAAW,IAAI,EAAE,GAAG,EAAE,GAAG,OAAO;AAChC,SAAS;AACT,qBAAqB,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG;AACpC,WAAW,IAAI,EAAE,GAAG,OAAO;AAC3B;AACA,OAAO;AACP,mBAAmB,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG;AAClC,SAAS,IAAI,OAAO;AACpB;AACA,KAAK;AACL;AACA;AACA;AACA,qBAAqB,EAAE,GAAG,EAAE,GAAG;AAC/B,WAAW,EAAE,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,OAAO;AACpC,SAAS;AACT,qBAAqB,EAAE,GAAG,EAAE,GAAG;AAC/B,WAAW,EAAE,EAAE,IAAI,EAAE,GAAG,OAAO;AAC/B;AACA,OAAO;AACP,mBAAmB,EAAE,GAAG,EAAE,GAAG;AAC7B,SAAS,IAAI,OAAO;AACpB;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA,eAAe,SAAS,GAAG,EAAE,GAAG,EAAE,EAAE,GAAG;AACvC,KAAK;AACL,iBAAiB,EAAE,MAAM,GAAG,IAAI,OAAO;AACvC,KAAK;AACL,iBAAiB,EAAE,GAAG,EAAE,IAAI;AAC5B,OAAO,IAAI,EAAE,GAAG,OAAO;AACvB;;AAEA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,gBAAgB,GAAG,MAAM,kBAAkB;AAC3C,GAAG;AACH,gBAAgB,GAAG,GAAG,GAAG,IAAI,kBAAkB;AAC/C,GAAG;AACH,gBAAgB,KAAK;AACrB,GAAG;AACH,gBAAgB,KAAK,EAAE,kBAAkB;AACzC;;AAEA;AACA;AACA,GAAG;AACH,aAAa,QAAQ;AACrB,GAAG;AACH,aAAa,GAAG,GAAG,QAAQ;AAC3B,GAAG;AACH,cAAc,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI;AACpC,GAAG;AACH,aAAa,GAAG,GAAG,GAAG,GAAG,QAAQ;AACjC,GAAG;AACH,cAAc,GAAG;AACjB;;AAEA,aAAa,KAAK,GAAG,GAAG;AACxB;;AAEA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;AC7fA,cAAc,mBAAO,CAAC,uGAAmB;AACzC,OAAO,+BAA+B,GAAG,mBAAO,CAAC,+GAAuB;AACxE,OAAO,QAAQ,GAAG,mBAAO,CAAC,iGAAgB;;AAE1C,qBAAqB,mBAAO,CAAC,uHAA2B;AACxD,OAAO,qBAAqB,GAAG,mBAAO,CAAC,mHAAyB;AAChE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL,8CAA8C,QAAQ;AACtD;;AAEA;AACA;AACA,kCAAkC,WAAW;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,8CAA8C,QAAQ;AACtD;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA,sBAAsB,WAAW,GAAG,WAAW,GAAG,WAAW;AAC7D;AACA,0BAA0B,0BAA0B;AACpD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA,uDAAuD,QAAQ;AAC/D;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC9RA,cAAc,mBAAO,CAAC,8FAAS;AAC/B;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACLA,WAAW,mBAAO,CAAC,wFAAM;AACzB,YAAY,mBAAO,CAAC,0FAAO;AAC3B,WAAW,mBAAO,CAAC,wFAAM;AACzB,YAAY,mBAAO,CAAC,0FAAO;AAC3B,WAAW,mBAAO,CAAC,wFAAM;AACzB,YAAY,mBAAO,CAAC,0FAAO;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,+CAA+C,GAAG;AAClD;AACA;AACA;;;;;;;;;;;;AC/CA,eAAe,mBAAO,CAAC,uGAAmB;AAC1C,cAAc,mBAAO,CAAC,8FAAS;AAC/B,OAAO,MAAM,GAAG,mBAAO,CAAC,iGAAgB;;AAExC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,SAAS,GAAG,gBAAgB,GAAG,gBAAgB;AACjE;AACA;;;;;;;;;;;;AClDA,eAAe,mBAAO,CAAC,uGAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA,gBAAgB,mBAAO,CAAC,kGAAW;AACnC;AACA;;;;;;;;;;;;ACFA,eAAe,mBAAO,CAAC,uGAAmB;AAC1C;AACA;;AAEA;;;;;;;;;;;;ACJA,cAAc,mBAAO,CAAC,8FAAS;AAC/B,WAAW,mBAAO,CAAC,wFAAM;;AAEzB;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtBA,gBAAgB,mBAAO,CAAC,kGAAW;AACnC;AACA;;;;;;;;;;;;ACFA,gBAAgB,mBAAO,CAAC,kGAAW;AACnC;AACA;;;;;;;;;;;;ACFA,gBAAgB,mBAAO,CAAC,kGAAW;AACnC;AACA;;;;;;;;;;;;ACFA,eAAe,mBAAO,CAAC,uGAAmB;;AAE1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;;;;;;ACdA,gBAAgB,mBAAO,CAAC,kGAAW;AACnC;AACA;;;;;;;;;;;;ACFA,gBAAgB,mBAAO,CAAC,kGAAW;AACnC;AACA;;;;;;;;;;;;ACFA,eAAe,mBAAO,CAAC,uGAAmB;AAC1C;AACA;;;;;;;;;;;;ACFA,eAAe,mBAAO,CAAC,uGAAmB;AAC1C;AACA;;;;;;;;;;;;ACFA,gBAAgB,mBAAO,CAAC,kGAAW;AACnC;AACA;;;;;;;;;;;;ACFA,OAAO,WAAW,GAAG,mBAAO,CAAC,+GAAuB;AACpD,OAAO,QAAQ,GAAG,mBAAO,CAAC,iGAAgB;AAC1C,eAAe,mBAAO,CAAC,uGAAmB;;AAE1C,qBAAqB,mBAAO,CAAC,uHAA2B;AACxD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;;;;;;;;;;;AChCA,eAAe,mBAAO,CAAC,uGAAmB;AAC1C;AACA;;;;;;;;;;;;ACFA,cAAc,mBAAO,CAAC,8FAAS;AAC/B;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACLA,gBAAgB,mBAAO,CAAC,kGAAW;AACnC;AACA;;;;;;;;;;;;ACFA,qBAAqB,mBAAO,CAAC,8GAAiB;AAC9C;AACA;;;;;;;;;;;;ACFA,cAAc,mBAAO,CAAC,qGAAkB;AACxC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACTA,qBAAqB,mBAAO,CAAC,8GAAiB;AAC9C;AACA;;;;;;;;;;;;ACFA,cAAc,mBAAO,CAAC,8FAAS;AAC/B;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACLA;AACA,mBAAmB,mBAAO,CAAC,gGAAe;AAC1C;AACA;AACA;AACA;AACA,uBAAuB,mBAAO,CAAC,8GAAsB;AACrD,UAAU,mBAAO,CAAC,sGAAkB;AACpC,sBAAsB,mBAAO,CAAC,kHAAwB;AACtD,uBAAuB,mBAAO,CAAC,kHAAwB;AACvD,SAAS,mBAAO,CAAC,wGAAmB;AACpC,SAAS,mBAAO,CAAC,wGAAmB;AACpC,SAAS,mBAAO,CAAC,wGAAmB;AACpC,OAAO,mBAAO,CAAC,oGAAiB;AAChC,QAAQ,mBAAO,CAAC,sGAAkB;AAClC,SAAS,mBAAO,CAAC,wGAAmB;AACpC,SAAS,mBAAO,CAAC,wGAAmB;AACpC,SAAS,mBAAO,CAAC,wGAAmB;AACpC,cAAc,mBAAO,CAAC,kHAAwB;AAC9C,WAAW,mBAAO,CAAC,4GAAqB;AACxC,YAAY,mBAAO,CAAC,8GAAsB;AAC1C,gBAAgB,mBAAO,CAAC,wHAA2B;AACnD,gBAAgB,mBAAO,CAAC,wHAA2B;AACnD,QAAQ,mBAAO,CAAC,sGAAkB;AAClC,SAAS,mBAAO,CAAC,wGAAmB;AACpC,MAAM,mBAAO,CAAC,kGAAgB;AAC9B,MAAM,mBAAO,CAAC,kGAAgB;AAC9B,MAAM,mBAAO,CAAC,kGAAgB;AAC9B,OAAO,mBAAO,CAAC,oGAAiB;AAChC,OAAO,mBAAO,CAAC,oGAAiB;AAChC,OAAO,mBAAO,CAAC,oGAAiB;AAChC,OAAO,mBAAO,CAAC,oGAAiB;AAChC,UAAU,mBAAO,CAAC,0GAAoB;AACtC,cAAc,mBAAO,CAAC,8GAAsB;AAC5C,SAAS,mBAAO,CAAC,oGAAiB;AAClC,aAAa,mBAAO,CAAC,gHAAuB;AAC5C,iBAAiB,mBAAO,CAAC,oHAAyB;AAClD,iBAAiB,mBAAO,CAAC,oHAAyB;AAClD,iBAAiB,mBAAO,CAAC,oHAAyB;AAClD,cAAc,mBAAO,CAAC,8GAAsB;AAC5C,cAAc,mBAAO,CAAC,kGAAgB;AACtC,WAAW,mBAAO,CAAC,sGAAkB;AACrC,OAAO,mBAAO,CAAC,8FAAc;AAC7B,OAAO,mBAAO,CAAC,8FAAc;AAC7B,cAAc,mBAAO,CAAC,4GAAqB;AAC3C,iBAAiB,mBAAO,CAAC,wGAAmB;AAC5C,UAAU,mBAAO,CAAC,oGAAiB;AACnC;;;;;;;;;;;;AC/CA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACRA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,GAAG,IAAI;AACP;;;;;;;;;;;;ACVA,OAAO,4BAA4B,GAAG,mBAAO,CAAC,qGAAa;AAC3D,cAAc,mBAAO,CAAC,6FAAS;AAC/B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,+BAA+B,yBAAyB;AACxD,uBAAuB,yBAAyB;AAChD,uBAAuB,yBAAyB;;AAEhD,oCAAoC,8BAA8B;AAClE,4BAA4B,8BAA8B;AAC1D,4BAA4B,8BAA8B;;AAE1D;AACA;;AAEA,0CAA0C;AAC1C,CAAC,GAAG,4BAA4B;;AAEhC,+CAA+C;AAC/C,CAAC,GAAG,4BAA4B;;AAEhC;AACA;AACA;;AAEA,kCAAkC;AAClC,CAAC,QAAQ,4BAA4B;;AAErC,wCAAwC;AACxC,CAAC,QAAQ,iCAAiC;;AAE1C;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,+BAA+B;AAC/B,CAAC,QAAQ,uBAAuB;;AAEhC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,8BAA8B;AAC9B,CAAC,EAAE,kBAAkB;AACrB,eAAe;;AAEf,wBAAwB,iBAAiB;;AAEzC;AACA;AACA;AACA,qCAAqC;AACrC,CAAC,EAAE,uBAAuB;AAC1B,eAAe;;AAEf,yBAAyB,kBAAkB;;AAE3C;;AAEA;AACA;AACA;AACA,wCAAwC,8BAA8B;AACtE,mCAAmC,yBAAyB;;AAE5D,uCAAuC,wBAAwB;AAC/D,6BAA6B,wBAAwB;AACrD,6BAA6B,wBAAwB;AACrD,yBAAyB,kBAAkB;AAC3C,kCAAkC;AAClC;;AAEA,4CAA4C,6BAA6B;AACzE,kCAAkC,6BAA6B;AAC/D,kCAAkC,6BAA6B;AAC/D,8BAA8B,uBAAuB;AACrD,uCAAuC;AACvC;;AAEA,0BAA0B,YAAY,MAAM,mBAAmB;AAC/D,+BAA+B,YAAY,MAAM,wBAAwB;;AAEzE;AACA;AACA,yBAAyB;AACzB,oBAAoB,IAAI,EAAE,2BAA2B;AACrD,0BAA0B,IAAI,2BAA2B;AACzD,0BAA0B,IAAI,2BAA2B;AACzD;AACA;;AAEA;AACA;AACA;;AAEA,kCAAkC,iBAAiB;AACnD;;AAEA,yBAAyB,iBAAiB,EAAE,mBAAmB;AAC/D,8BAA8B,iBAAiB,EAAE,wBAAwB;;AAEzE;AACA;AACA;;AAEA,kCAAkC,iBAAiB;AACnD;;AAEA,yBAAyB,iBAAiB,EAAE,mBAAmB;AAC/D,8BAA8B,iBAAiB,EAAE,wBAAwB;;AAEzE;AACA,mCAAmC,YAAY,OAAO,kBAAkB;AACxE,8BAA8B,YAAY,OAAO,iBAAiB;;AAElE;AACA;AACA,uCAAuC;AACvC,CAAC,OAAO,kBAAkB,GAAG,mBAAmB;AAChD;;AAEA;AACA;AACA;AACA;AACA,oCAAoC,mBAAmB;AACvD;AACA,uBAAuB,mBAAmB;AAC1C;;AAEA,yCAAyC,wBAAwB;AACjE;AACA,4BAA4B,wBAAwB;AACpD;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrLA;AACA,gBAAgB,mBAAO,CAAC,+FAAW;AACnC;AACA;;;;;;;;;;;;ACHA,cAAc,mBAAO,CAAC,qGAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA,gBAAgB,mBAAO,CAAC,+FAAW;AACnC;AACA;AACA;;;;;;;;;;;;ACHA,eAAe,mBAAO,CAAC,uGAAmB;AAC1C,cAAc,mBAAO,CAAC,qGAAkB;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;;ACxBA,eAAe,mBAAO,CAAC,uGAAmB;AAC1C,cAAc,mBAAO,CAAC,qGAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;;ACvBA,eAAe,mBAAO,CAAC,uGAAmB;AAC1C,cAAc,mBAAO,CAAC,qGAAkB;AACxC,WAAW,mBAAO,CAAC,mGAAiB;;AAEpC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,sBAAsB;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,oBAAoB;AACvE;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;AC3DA,eAAe,mBAAO,CAAC,uGAAmB;AAC1C,mBAAmB,mBAAO,CAAC,+GAAuB;AAClD,OAAO,IAAI;AACX,cAAc,mBAAO,CAAC,qGAAkB;AACxC,kBAAkB,mBAAO,CAAC,iHAAwB;AAClD,WAAW,mBAAO,CAAC,mGAAiB;AACpC,WAAW,mBAAO,CAAC,mGAAiB;AACpC,YAAY,mBAAO,CAAC,qGAAkB;AACtC,YAAY,mBAAO,CAAC,qGAAkB;;AAEtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,sBAAsB;AACvC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC/EA;AACA;AACA;AACA,kBAAkB,mBAAO,CAAC,oHAA2B;AACrD,gBAAgB,mBAAO,CAAC,gHAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,IAAI;AAC3B;AACA,uBAAuB,IAAI;AAC3B;AACA,qBAAqB,IAAI,KAAK,IAAI;AAClC;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3CA,cAAc,mBAAO,CAAC,wGAAqB;AAC3C,OAAO,MAAM,GAAG,mBAAO,CAAC,kHAA0B;AAClD,kBAAkB,mBAAO,CAAC,oHAA2B;AACrD,gBAAgB,mBAAO,CAAC,gHAAyB;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACjKA,cAAc,mBAAO,CAAC,qGAAkB;;AAExC;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACPA,cAAc,mBAAO,CAAC,qGAAkB;AACxC;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;;;;;;;ACVa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,eAAe,mBAAO,CAAC,sFAAqB;AAC5C,oBAAoB,mBAAO,CAAC,uFAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,8BAA8B,eAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA,gCAAgC;AAChC,oC;;;;;;;;;;;;ACpEa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,kC;;;;;;;;;;;;ACjBa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;AC7Ga;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oCAAoC,aAAa,EAAE,EAAE;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,aAAa,mBAAO,CAAC,qFAAY;AACjC,aAAa,mBAAO,CAAC,2FAAY;AACjC,aAAa,mBAAO,CAAC,uFAAa;AAClC,aAAa,mBAAO,CAAC,+EAAS;AAC9B,aAAa,mBAAO,CAAC,iFAAU;AAC/B,iC;;;;;;;;;;;;AChCa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oCAAoC,aAAa,EAAE,EAAE;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,aAAa,mBAAO,CAAC,4FAAQ;AAC7B,iC;;;;;;;;;;;;AC5Ba;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,mBAAmB,mBAAO,CAAC,yFAAgB;AAC3C,aAAa,mBAAO,CAAC,kBAAM;AAC3B,eAAe,mBAAO,CAAC,sFAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,kFAAkF,mBAAmB;AACrG;AACA;AACA;AACA,kFAAkF,mBAAmB,WAAW,UAAU;AAC1H;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC,kCAAkC,eAAe;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA,4C;;;;;;;;;;;;ACrEa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,YAAY,mBAAO,CAAC,iFAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,UAAU;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,kCAAkC;AACnF;AACA;AACA,mDAAmD,kCAAkC;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;ACjIa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,YAAY,mBAAO,CAAC,iFAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA,2C;;;;;;;;;;;;ACtDa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oCAAoC,aAAa,EAAE,EAAE;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,aAAa,mBAAO,CAAC,mHAAe;AACpC,aAAa,mBAAO,CAAC,2HAAmB;AACxC,iC;;;;;;;;;;;;AC7Ba;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oCAAoC,aAAa,EAAE,EAAE;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,aAAa,mBAAO,CAAC,mHAAoB;AACzC,aAAa,mBAAO,CAAC,2GAAa;AAClC,iC;;;;;;;;;;;;AC7Ba;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,iC;;;;;;;;;;;;ACjBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oCAAoC,aAAa,EAAE,EAAE;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,aAAa,mBAAO,CAAC,gGAAS;AAC9B,iC;;;;;;;;;;;;AC5Ba;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;;;;;;AC1Ia;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;ACxBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gC;;;;;;;;;;;;ACxJa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mC;;;;;;;;;;;;ACxCa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gC;;;;;;;;;;;;ACvCa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oCAAoC,aAAa,EAAE,EAAE;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,aAAa,mBAAO,CAAC,sGAAY;AACjC,aAAa,mBAAO,CAAC,wGAAa;AAClC,aAAa,mBAAO,CAAC,oGAAW;AAChC,aAAa,mBAAO,CAAC,8FAAQ;AAC7B,aAAa,mBAAO,CAAC,0FAAM;AAC3B,aAAa,mBAAO,CAAC,4FAAO;AAC5B,aAAa,mBAAO,CAAC,8FAAQ;AAC7B,aAAa,mBAAO,CAAC,wGAAa;AAClC,iC;;;;;;;;;;;;ACnCa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;ACzIa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,2BAA2B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8B;;;;;;;;;;;;AChEa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+B;;;;;;;;;;;;AC3Ba;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,YAAY,mBAAO,CAAC,oFAAoB;AACxC,eAAe,mBAAO,CAAC,sFAAqB;AAC5C,WAAW,mBAAO,CAAC,uEAAG;AACtB,iBAAiB,mBAAO,CAAC,+EAAU;AACnC,6BAA6B,mBAAO,CAAC,uGAAsB;AAC3D,4BAA4B,mBAAO,CAAC,qGAAqB;AACzD,oBAAoB,mBAAO,CAAC,gGAA0B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA,SAAS;AACT;AACA;AACA,uBAAuB,KAAK,GAAG,QAAQ;AACvC;AACA,kDAAkD,gBAAgB;AAClE;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+C;;;;;;;;;;;;ACrFa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,eAAe,mBAAO,CAAC,sFAAqB;AAC5C;AACA,0BAA0B,oBAAoB;AAC9C,iCAAiC,oBAAoB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,8C;;;;;;;;;;;;AClEa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA,8BAA8B;AAC9B,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6C;;;;;;;;;;;;AC9Ba;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,YAAY,mBAAO,CAAC,oFAAoB;AACxC,eAAe,mBAAO,CAAC,sFAAqB;AAC5C,+BAA+B,mBAAO,CAAC,sHAAqC;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,IAAI;AAC5D;AACA;AACA;AACA,sEAAsE,IAAI;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,UAAU;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,wBAAwB;AACpG;AACA;AACA;AACA;AACA;AACA,gC;;;;;;;;;;;;ACjLa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,yC;;;;;;;;;;;;ACjBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,YAAY,mBAAO,CAAC,oFAAoB;AACxC,eAAe,mBAAO,CAAC,sFAAqB;AAC5C,eAAe,mBAAO,CAAC,2EAAQ;AAC/B,kBAAkB,mBAAO,CAAC,iFAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;;;;;;AC9Ha;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,eAAe,mBAAO,CAAC,sFAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,kC;;;;;;;;;;;;AClCa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,cAAc,mBAAO,CAAC,oFAAoB;AAC1C,eAAe,mBAAO,CAAC,sFAAqB;AAC5C;AACA;AACA;AACA,0BAA0B,oBAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8C;;;;;;;;;;;;AC7Ha;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,eAAe,mBAAO,CAAC,sFAAqB;AAC5C;AACA,8BAA8B,mBAAmB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wCAAwC;AACjE;AACA;AACA;AACA;AACA,+C;;;;;;;;;;;;ACxEa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,eAAe,mBAAO,CAAC,sFAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,yCAAyC,wCAAwC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gD;;;;;;;;;;;;ACvDa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,wC;;;;;;;;;;;;ACjBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,cAAc,mBAAO,CAAC,oFAAoB;AAC1C,eAAe,mBAAO,CAAC,sFAAqB;AAC5C;AACA,6BAA6B,oBAAoB,oBAAoB;AACrE,OAAO,mBAAmB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gKAAgK,OAAO;AACvK;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,+C;;;;;;;;;;;;ACvEa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,wC;;;;;;;;;;;;ACjBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oCAAoC,aAAa,EAAE,EAAE;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,aAAa,mBAAO,CAAC,+EAAU;AAC/B,aAAa,mBAAO,CAAC,yGAAuB;AAC5C,aAAa,mBAAO,CAAC,uHAA8B;AACnD,aAAa,mBAAO,CAAC,qHAA6B;AAClD,aAAa,mBAAO,CAAC,yHAA+B;AACpD,aAAa,mBAAO,CAAC,yGAAuB;AAC5C,aAAa,mBAAO,CAAC,uHAA8B;AACnD,aAAa,mBAAO,CAAC,yGAAuB;AAC5C,aAAa,mBAAO,CAAC,2EAAQ;AAC7B,aAAa,mBAAO,CAAC,6FAAiB;AACtC,aAAa,mBAAO,CAAC,6EAAS;AAC9B,iC;;;;;;;;;;;;ACtCa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,iC;;;;;;;;;;;;ACjBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,iBAAiB,mBAAO,CAAC,+EAAU;AACnC,eAAe,mBAAO,CAAC,sFAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,YAAY;AACZ,yCAAyC,mEAAmE;AAC5G;AACA;AACA;AACA,mC;;;;;;;;;;;;ACvCa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,uC;;;;;;;;;;;;AC7Ba;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+C;;;;;;;;;;;;ACZa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;;;;;;;;;ACfa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gD;;;;;;;;;;;;ACfa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,iBAAiB,mBAAO,CAAC,mEAAiB;AAC1C,kBAAkB,mBAAO,CAAC,qEAAkB;AAC5C,sBAAsB,mBAAO,CAAC,+EAAgB;AAC9C;AACA,8BAA8B,KAAK;AACnC;AACA;AACA,sBAAsB,KAAK;AAC3B;AACA;AACA,oBAAoB,KAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yCAAyC;AACzE,gCAAgC,yCAAyC;AACzE;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D,8CAA8C,yCAAyC;AACvF;AACA;AACA;AACA,gCAAgC,yCAAyC;AACzE,gCAAgC,yCAAyC;AACzE;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,WAAW;AACnE;AACA;AACA;AACA;AACA;AACA,2DAA2D,UAAU;AACrE;AACA,mFAAmF,iBAAiB;AACpG,gFAAgF,iBAAiB;AACjG;AACA,oBAAoB,iCAAiC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,QAAQ;AACxE;AACA,uEAAuE,iBAAiB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,UAAU;AACrE;AACA,mFAAmF,iBAAiB;AACpG,gFAAgF,iBAAiB;AACjG;AACA,oBAAoB,iCAAiC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;;;;;;;;;ACpLa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,iBAAiB,mBAAO,CAAC,sBAAQ;AACjC,6BAA6B,mBAAO,CAAC,6FAAuB;AAC5D,sBAAsB,mBAAO,CAAC,+EAAgB;AAC9C,iBAAiB,mBAAO,CAAC,mEAAiB;AAC1C,kBAAkB,mBAAO,CAAC,qEAAkB;AAC5C,kBAAkB,mBAAO,CAAC,qEAAkB;AAC5C,wBAAwB,mBAAO,CAAC,uFAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,oCAAoC,8BAA8B;AAClE;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU;AACrD;AACA,mFAAmF,iBAAiB;AACpG,gFAAgF,iBAAiB;AACjG;AACA,oBAAoB,6CAA6C;AACjE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,yCAAyC;AAC9E,qCAAqC,yCAAyC;AAC9E;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,qBAAqB;AAC/E;AACA;AACA;AACA;AACA;AACA,sDAAsD,sBAAsB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,6CAA6C;AAC5F,+CAA+C,6CAA6C;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,qC;;;;;;;;;;;;AC7Ua;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,iBAAiB,mBAAO,CAAC,sBAAQ;AACjC,8BAA8B,mBAAO,CAAC,+FAAwB;AAC9D,gBAAgB,mBAAO,CAAC,2DAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,cAAc;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,gBAAgB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,cAAc;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,mBAAmB,GAAG,WAAW;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc,aAAa,YAAY;AAC1D;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY,iCAAiC,iBAAiB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc,aAAa,YAAY;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,0C;;;;;;;;;;;;ACnKa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,iBAAiB,mBAAO,CAAC,sBAAQ;AACjC,wBAAwB,mBAAO,CAAC,mFAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,kBAAkB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,kBAAkB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,oC;;;;;;;;;;;;ACpEa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,iBAAiB,mBAAO,CAAC,sBAAQ;AACjC,+BAA+B,mBAAO,CAAC,iGAAyB;AAChE,mBAAmB,mBAAO,CAAC,6EAAY;AACvC,iBAAiB,mBAAO,CAAC,mEAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,iBAAiB;AAC7F;AACA;AACA;AACA;AACA,6DAA6D,iBAAiB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,iBAAiB;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,2C;;;;;;;;;;;;AClGa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,eAAe,mBAAO,CAAC,sBAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;ACda;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,iBAAiB,mBAAO,CAAC,sBAAQ;AACjC,6BAA6B,mBAAO,CAAC,6FAAuB;AAC5D,kBAAkB,mBAAO,CAAC,qEAAkB;AAC5C,mBAAmB,mBAAO,CAAC,6EAAY;AACvC,wBAAwB,mBAAO,CAAC,uFAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,oCAAoC,+BAA+B;AACnE;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,mBAAO,CAAC,4DAAU;AAC/E,uCAAuC,mBAAmB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,cAAc;AACxE;AACA;AACA;AACA;AACA,sEAAsE,oBAAoB;AAC1F;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,mC;;;;;;;;;;;;AC9Qa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,iBAAiB,mBAAO,CAAC,sBAAQ;AACjC,kBAAkB,mBAAO,CAAC,kEAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc,eAAe,UAAU;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8C;;;;;;;;;;;;AChCa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,+BAA+B,mBAAO,CAAC,gGAAwB;AAC/D,wDAAwD,qCAAqC,oDAAoD,EAAE,EAAE;AACrJ,6BAA6B,mBAAO,CAAC,4FAAsB;AAC3D,sDAAsD,qCAAqC,gDAAgD,EAAE,EAAE;AAC/I,8BAA8B,mBAAO,CAAC,8FAAuB;AAC7D,uDAAuD,qCAAqC,kDAAkD,EAAE,EAAE;AAClJ,wBAAwB,mBAAO,CAAC,kFAAiB;AACjD,iDAAiD,qCAAqC,sCAAsC,EAAE,EAAE;AAChI;AACA;AACA,yBAAyB,mBAAO,CAAC,4FAAsB;AACvD,iBAAiB,mBAAO,CAAC,4EAAc;AACvC,mBAAmB,mBAAO,CAAC,gFAAgB;AAC3C,wBAAwB,mBAAO,CAAC,0FAAqB;AACrD,kBAAkB,mBAAO,CAAC,8EAAe;AACzC,oBAAoB,mBAAO,CAAC,kFAAiB;AAC7C;AACA;AACA;AACA,MAAM,mBAAO,CAAC,gGAAwB;AACtC;AACA;AACA,MAAM,mBAAO,CAAC,gGAAwB;AACtC,6CAA6C,mBAAO,CAAC,gFAAgB;AACrE;AACA,mDAAmD,mBAAO,CAAC,oFAAkB;AAC7E;AACA;AACA;AACA,MAAM,mBAAO,CAAC,8FAAuB;AACrC;AACA,gDAAgD,mBAAO,CAAC,kFAAiB;AACzE,sDAAsD,mBAAO,CAAC,sFAAmB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;;;;;;;;;AC/Ea;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,iBAAiB,mBAAO,CAAC,mEAAiB;AAC1C,sBAAsB,mBAAO,CAAC,+EAAgB;AAC9C;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,yBAAyB;AAC3F;AACA;AACA,wEAAwE,iBAAiB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+C;;;;;;;;;;;;ACtHa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,iBAAiB,mBAAO,CAAC,sBAAQ;AACjC,6BAA6B,mBAAO,CAAC,6FAAuB;AAC5D,kBAAkB,mBAAO,CAAC,qEAAkB;AAC5C,sBAAsB,mBAAO,CAAC,+EAAgB;AAC9C,iBAAiB,mBAAO,CAAC,mEAAiB;AAC1C,8BAA8B,mBAAO,CAAC,kGAAuB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,iBAAiB;AACnF,2EAA2E,iBAAiB;AAC5F;AACA,oBAAoB,kDAAkD;AACtE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,qBAAqB;AAC/E;AACA;AACA;AACA;AACA;AACA,sDAAsD,sBAAsB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,uBAAuB,2BAA2B,EAAE;AAC3H;AACA;AACA,4DAA4D,iBAAiB;AAC7E;AACA;AACA,iFAAiF,iBAAiB;AAClG;AACA;AACA,SAAS;AACT;AACA,+CAA+C,6CAA6C;AAC5F,+CAA+C,6CAA6C;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yCAAyC;AAC5D,mBAAmB,yCAAyC;AAC5D,mDAAmD,uBAAuB,2BAA2B,EAAE;AACvG;AACA;AACA,eAAe;AACf;AACA,oC;;;;;;;;;;;;ACvRa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,gBAAgB,mBAAO,CAAC,2DAAa;AACrC,iBAAiB,mBAAO,CAAC,sBAAQ;AACjC,8BAA8B,mBAAO,CAAC,+FAAwB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,cAAc;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,mBAAmB,GAAG,gBAAgB;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mBAAmB,GAAG,gBAAgB;AAClE,kEAAkE,mCAAmC;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY,iCAAiC,iBAAiB;AACjF;AACA;AACA;AACA;AACA;AACA,uEAAuE,kEAAkE;AACzI;AACA;AACA,uEAAuE,kEAAkE;AACzI;AACA;AACA;AACA,mBAAmB,cAAc,aAAa,YAAY;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,+BAA+B;AAC1G;AACA;AACA;AACA;AACA,qEAAqE,+BAA+B;AACpG;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY,iCAAiC,iBAAiB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,mBAAmB,cAAc,aAAa,YAAY;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,yC;;;;;;;;;;;;ACpNa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,iBAAiB,mBAAO,CAAC,sBAAQ;AACjC,wBAAwB,mBAAO,CAAC,mFAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,kBAAkB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,kBAAkB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,sBAAsB,OAAO,EAAE;AACjG;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,sBAAsB,2BAA2B,EAAE;AACjH;AACA;AACA,2CAA2C,sBAAsB,2BAA2B,EAAE;AAC9F;AACA,eAAe;AACf;AACA,mC;;;;;;;;;;;;ACtEa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,iBAAiB,mBAAO,CAAC,sBAAQ;AACjC,yBAAyB,mBAAO,CAAC,kEAAgB;AACjD,+BAA+B,mBAAO,CAAC,iGAAyB;AAChE,kBAAkB,mBAAO,CAAC,0EAAW;AACrC,iBAAiB,mBAAO,CAAC,mEAAiB;AAC1C,8BAA8B,mBAAO,CAAC,kGAAuB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,iBAAiB;AAC7F;AACA;AACA;AACA;AACA,6DAA6D,iBAAiB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yBAAyB;AAC/C,sBAAsB,yBAAyB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kCAAkC;AACtD,gFAAgF,iBAAiB;AACjG,6EAA6E,iBAAiB;AAC9F,SAAS;AACT;AACA,oHAAoH,oBAAoB,yBAAyB;AACjK,2EAA2E,iBAAiB;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,0C;;;;;;;;;;;;AC7Ga;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;ACZa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,iBAAiB,mBAAO,CAAC,sBAAQ;AACjC,6BAA6B,mBAAO,CAAC,6FAAuB;AAC5D,kBAAkB,mBAAO,CAAC,0EAAW;AACrC,kBAAkB,mBAAO,CAAC,qEAAkB;AAC5C,8BAA8B,mBAAO,CAAC,kGAAuB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2BAA2B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,cAAc;AACxE;AACA;AACA;AACA;AACA,yEAAyE,oBAAoB;AAC7F;AACA;AACA;AACA;AACA;AACA,uBAAuB,2BAA2B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,kC;;;;;;;;;;;;ACpNa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;;;;;;AC/Ca;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,yBAAyB,mBAAO,CAAC,qEAAgB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8FAA8F;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,iEAAiE;AACtG;AACA,2BAA2B,yGAAyG;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,yBAAyB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,kCAAkC,iDAAiD;AACnF;AACA;AACA;AACA,kCAAkC,kDAAkD;AACpF;AACA;AACA,kCAAkC,0BAA0B;AAC5D;AACA;AACA,gEAAgE,mBAAmB;AACnF;AACA;AACA,0EAA0E,mBAAmB;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gDAAgD;AACtE;AACA;AACA,sBAAsB,gDAAgD,GAAG,gCAAgC;AACzG;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA,sD;;;;;;;;;;;;ACxKa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qD;;;;;;;;;;;;ACrBa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,6BAA6B,mBAAO,CAAC,oGAAgC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB,EAAE,qGAAqG;AACjJ;AACA;AACA;AACA,sD;;;;;;;;;;;;ACxBa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iBAAiB,gCAAgC,aAAa;AAC7F;AACA;AACA;AACA,+C;;;;;;;;;;;;ACjBa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,4BAA4B,mBAAO,CAAC,kGAA+B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qDAAqD,IAAI,aAAa;AACxF;AACA;AACA;AACA,qD;;;;;;;;;;;;ACpBa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA,gCAAgC,mBAAO,CAAC,2FAA2B;AACnE,2DAA2D,qCAAqC,0DAA0D,EAAE,EAAE;AAC9J,6DAA6D,qCAAqC,4DAA4D,EAAE,EAAE;AAClK,uBAAuB,mBAAO,CAAC,yEAAkB;AACjD,kDAAkD,qCAAqC,wCAAwC,EAAE,EAAE;AACnI,mBAAmB,mBAAO,CAAC,iEAAc;AACzC,8CAA8C,qCAAqC,gCAAgC,EAAE,EAAE;AACvH,yBAAyB,mBAAO,CAAC,6EAAoB;AACrD,oDAAoD,qCAAqC,4CAA4C,EAAE,EAAE;AACzI,yBAAyB,mBAAO,CAAC,6EAAoB;AACrD,oDAAoD,qCAAqC,4CAA4C,EAAE,EAAE;AACzI,mBAAmB,mBAAO,CAAC,iEAAc;AACzC,8CAA8C,qCAAqC,gCAAgC,EAAE,EAAE;AACvH,kBAAkB,mBAAO,CAAC,+DAAa;AACvC,6CAA6C,qCAAqC,8BAA8B,EAAE,EAAE;AACpH,gBAAgB,mBAAO,CAAC,2DAAW;AACnC,8CAA8C,qCAAqC,6BAA6B,EAAE,EAAE;AACpH,8CAA8C,qCAAqC,6BAA6B,EAAE,EAAE;AACpH,mDAAmD,qCAAqC,kCAAkC,EAAE,EAAE;AAC9H,4BAA4B,mBAAO,CAAC,mFAAuB;AAC3D,uDAAuD,qCAAqC,kDAAkD,EAAE,EAAE;AAClJ,mBAAmB,mBAAO,CAAC,mFAAuB;AAClD,8CAA8C,qCAAqC,gCAAgC,EAAE,EAAE;AACvH,0BAA0B,mBAAO,CAAC,iGAA8B;AAChE,qDAAqD,qCAAqC,8CAA8C,EAAE,EAAE;AAC5I,mCAAmC,mBAAO,CAAC,+GAAqC;AAChF,yDAAyD,qCAAqC,2DAA2D,EAAE,EAAE;AAC7J,8DAA8D,qCAAqC,gEAAgE,EAAE,EAAE;AACvK,4BAA4B,mBAAO,CAAC,iGAA8B;AAClE,uDAAuD,qCAAqC,kDAAkD,EAAE,EAAE;AAClJ,mCAAmC,mBAAO,CAAC,+GAAqC;AAChF,8DAA8D,qCAAqC,gEAAgE,EAAE,EAAE;AACvK,kCAAkC,mBAAO,CAAC,6GAAoC;AAC9E,6DAA6D,qCAAqC,8DAA8D,EAAE,EAAE;AACpK,kCAAkC,mBAAO,CAAC,6GAAoC;AAC9E,6DAA6D,qCAAqC,8DAA8D,EAAE,EAAE;AACpK,mBAAmB,mBAAO,CAAC,mFAAuB;AAClD,8CAA8C,qCAAqC,gCAAgC,EAAE,EAAE;AACvH,0BAA0B,mBAAO,CAAC,iGAA8B;AAChE,yDAAyD,qCAAqC,kDAAkD,EAAE,EAAE;AACpJ,gDAAgD,qCAAqC,yCAAyC,EAAE,EAAE;AAClI,gEAAgE,qCAAqC,yDAAyD,EAAE,EAAE;AAClK,gEAAgE,qCAAqC,yDAAyD,EAAE,EAAE;AAClK,uDAAuD,qCAAqC,gDAAgD,EAAE,EAAE;AAChJ,6DAA6D,qCAAqC,sDAAsD,EAAE,EAAE;AAC5J,2BAA2B,mBAAO,CAAC,mGAA+B;AAClE,+DAA+D,qCAAqC,yDAAyD,EAAE,EAAE;AACjK,sDAAsD,qCAAqC,gDAAgD,EAAE,EAAE;AAC/I,yDAAyD,qCAAqC,mDAAmD,EAAE,EAAE;AACrJ,sDAAsD,qCAAqC,gDAAgD,EAAE,EAAE;AAC/I,yDAAyD,qCAAqC,mDAAmD,EAAE,EAAE;AACrJ,sBAAsB,mBAAO,CAAC,6FAA4B;AAC1D,iDAAiD,qCAAqC,sCAAsC,EAAE,EAAE;AAChI,wDAAwD,qCAAqC,6CAA6C,EAAE,EAAE;AAC9I,sDAAsD,qCAAqC,2CAA2C,EAAE,EAAE;AAC1I,uDAAuD,qCAAqC,4CAA4C,EAAE,EAAE;AAC5I,iDAAiD,qCAAqC,sCAAsC,EAAE,EAAE;AAChI,8CAA8C,qCAAqC,mCAAmC,EAAE,EAAE;AAC1H,uCAAuC,qCAAqC,4BAA4B,EAAE,EAAE;AAC5G,yCAAyC,qCAAqC,8BAA8B,EAAE,EAAE;AAChH,gBAAgB,mBAAO,CAAC,iEAAc;AACtC,iDAAiD,qCAAqC,gCAAgC,EAAE,EAAE;AAC1H,iDAAiD,qCAAqC,gCAAgC,EAAE,EAAE;AAC1H,gDAAgD,qCAAqC,+BAA+B,EAAE,EAAE;AACxH,gBAAgB,mBAAO,CAAC,iEAAc;AACtC,6CAA6C,qCAAqC,4BAA4B,EAAE,EAAE;AAClH,6CAA6C,qCAAqC,4BAA4B,EAAE,EAAE;AAClH,eAAe,mBAAO,CAAC,+DAAa;AACpC,0CAA0C,qCAAqC,wBAAwB,EAAE,EAAE;AAC3G,eAAe,mBAAO,CAAC,yDAAU;AACjC,mDAAmD,qCAAqC,iCAAiC,EAAE,EAAE;AAC7H,sDAAsD,qCAAqC,oCAAoC,EAAE,EAAE;AACnI,qDAAqD,qCAAqC,mCAAmC,EAAE,EAAE;AACjI,uDAAuD,qCAAqC,qCAAqC,EAAE,EAAE;AACrI,qBAAqB,mBAAO,CAAC,+EAAqB;AAClD,qDAAqD,qCAAqC,yCAAyC,EAAE,EAAE;AACvI,2DAA2D,qCAAqC,+CAA+C,EAAE,EAAE;AACnJ,qDAAqD,qCAAqC,yCAAyC,EAAE,EAAE;AACvI,gCAAgC,mBAAO,CAAC,qGAAgC;AACxE,2DAA2D,qCAAqC,0DAA0D,EAAE,EAAE;AAC9J,kBAAkB,mBAAO,CAAC,yEAAkB;AAC5C,6CAA6C,qCAAqC,8BAA8B,EAAE,EAAE;AACpH,cAAc,mBAAO,CAAC,iEAAc;AACpC,yCAAyC,qCAAqC,sBAAsB,EAAE,EAAE;AACxG,uBAAuB,mBAAO,CAAC,yFAA0B;AACzD,kDAAkD,qCAAqC,wCAAwC,EAAE,EAAE;AACnI,uBAAuB,mBAAO,CAAC,yFAA0B;AACzD,kDAAkD,qCAAqC,wCAAwC,EAAE,EAAE;AACnI,uBAAuB,mBAAO,CAAC,yFAA0B;AACzD,kDAAkD,qCAAqC,wCAAwC,EAAE,EAAE;AACnI,2BAA2B,mBAAO,CAAC,iFAAsB;AACzD,sDAAsD,qCAAqC,gDAAgD,EAAE,EAAE;AAC/I,iC;;;;;;;;;;;;ACnGa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,iBAAiB,mBAAO,CAAC,sBAAQ;AACjC,kBAAkB,mBAAO,CAAC,8DAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,UAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wCAAwC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,aAAa,kCAAkC,eAAe;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;;;;;;ACzJa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,iBAAiB,mBAAO,CAAC,sBAAQ;AACjC,iBAAiB,mBAAO,CAAC,4DAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS,WAAW,OAAO;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,KAAK;AAC3D;AACA;AACA,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,aAAa,sBAAsB,KAAK;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,IAAI;AAChD;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mC;;;;;;;;;;;;ACzSa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,iBAAiB,mBAAO,CAAC,sBAAQ;AACjC,wBAAwB,mBAAO,CAAC,8FAA6B;AAC7D,iBAAiB,mBAAO,CAAC,4DAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qCAAqC,GAAG,YAAY,KAAK,YAAY;AACpF;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qBAAqB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qBAAqB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mC;;;;;;;;;;;;AC7Pa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,gBAAgB,mBAAO,CAAC,wDAAU;AAClC,iBAAiB,mBAAO,CAAC,sBAAQ;AACjC,gBAAgB,mBAAO,CAAC,kEAAe;AACvC,oBAAoB,mBAAO,CAAC,0EAAmB;AAC/C,qBAAqB,mBAAO,CAAC,oFAAwB;AACrD,kBAAkB,mBAAO,CAAC,kEAAe;AACzC,4BAA4B,mBAAO,CAAC,kGAA+B;AACnE,sBAAsB,mBAAO,CAAC,sFAAyB;AACvD,6BAA6B,mBAAO,CAAC,oGAAgC;AACrE,iBAAiB,mBAAO,CAAC,0DAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,4BAA4B,GAAG,QAAQ;AACtF;AACA;AACA,mDAAmD,4BAA4B,GAAG,QAAQ;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,2BAA2B,GAAG,QAAQ;AACnF;AACA;AACA,iDAAiD,2BAA2B,GAAG,QAAQ;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA,uC;;;;;;;;;;;;AC1gBa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,qBAAqB,mBAAO,CAAC,0EAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,kD;;;;;;;;;;;;ACzIa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,qBAAqB,mBAAO,CAAC,0EAAc;AAC3C,kBAAkB,mBAAO,CAAC,kEAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB,qBAAqB,sBAAsB,iBAAiB,mBAAmB;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gHAAgH;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,eAAe,IAAI,kDAAkD,IAAI,iBAAiB;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,qFAAqF;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB,gBAAgB,iBAAiB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,8BAA8B;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA,gDAAgD;AAChD;AACA;AACA,wEAAwE,iBAAiB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8C;;;;;;;;;;;;ACxSa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,iBAAiB,mBAAO,CAAC,sBAAQ;AACjC,qBAAqB,mBAAO,CAAC,0EAAc;AAC3C,wBAAwB,mBAAO,CAAC,8FAA6B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;AC5Fa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,iBAAiB,mBAAO,CAAC,sBAAQ;AACjC,kBAAkB,mBAAO,CAAC,kEAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sBAAsB,GAAG,KAAK;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;AC/Da;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,qBAAqB,mBAAO,CAAC,0EAAc;AAC3C,6BAA6B,mBAAO,CAAC,0FAAsB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wFAAwF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB,gBAAgB,8BAA8B;AAChF,iBAAiB,iBAAiB,mBAAmB,oBAAoB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB,IAAI,aAAa;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB,gBAAgB,iBAAiB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB,IAAI,qBAAqB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0GAA0G;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,eAAe,IAAI,gDAAgD,IAAI,iBAAiB;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6C;;;;;;;;;;;;AC5Ta;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,eAAe,KAAK,oBAAoB;AACrE;AACA;AACA;AACA,0C;;;;;;;;;;;;AC1Ca;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,iBAAiB,mBAAO,CAAC,0DAAW;AACpC,gBAAgB,mBAAO,CAAC,kEAAe;AACvC,oBAAoB,mBAAO,CAAC,0EAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,QAAQ;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA,2BAA2B,wBAAwB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC,0C;;;;;;;;;;;;ACzWa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,yBAAyB,mBAAO,CAAC,qEAAgB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,wBAAwB;AACzE;AACA;AACA,iDAAiD,uBAAuB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,wBAAwB;AAC9D;AACA;AACA;AACA;AACA;AACA,0CAA0C,wBAAwB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,sCAAsC;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kBAAkB,KAAK,uBAAuB;AAC/E,0BAA0B,eAAe,KAAK,oBAAoB;AAClE,8BAA8B,oBAAoB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,IAAI,KAAK,IAAI,KAAK,IAAI,IAAI;AACnE;AACA;AACA;AACA,qCAAqC,QAAQ,IAAI;AACjD;AACA;AACA;AACA;AACA;AACA,0C;;;;;;;;;;;;AClNa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,yBAAyB,mBAAO,CAAC,qEAAgB;AACjD,gBAAgB,mBAAO,CAAC,uDAAS;AACjC,oBAAoB,mBAAO,CAAC,+DAAa;AACzC,qBAAqB,mBAAO,CAAC,iEAAc;AAC3C,kCAAkC,mBAAO,CAAC,2FAA2B;AACrE,4BAA4B,mBAAO,CAAC,iGAA8B;AAClE,4BAA4B,mBAAO,CAAC,iGAA8B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8C;;;;;;;;;;;;;;;;;;;;;;;AC/Ia;AACb;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,gBAAgB,mBAAO,CAAC,wDAAU;AAClC,qBAAqB,mBAAO,CAAC,0EAAc;AAC3C,iCAAiC,mBAAO,CAAC,4GAAoC;AAC7E,yBAAyB,mBAAO,CAAC,qEAAgB;AACjD,kBAAkB,mBAAO,CAAC,kEAAe;AACzC,4BAA4B,mBAAO,CAAC,kGAA+B;AACnE,qCAAqC,mBAAO,CAAC,gHAAsC;AACnF,4BAA4B,mBAAO,CAAC,wFAAqB;AACzD,4BAA4B,mBAAO,CAAC,wFAAqB;AACzD,gBAAgB,mBAAO,CAAC,kEAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,QAAQ;AAChE;AACA;AACA;AACA,sDAAsD,mBAAmB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kLAAkL,6BAA6B;AAC/M;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,4EAA4E;AAClH;AACA;AACA;AACA;AACA,sDAAsD,4EAA4E;AAClI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,qBAAqB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,sDAAsD;AACtG;AACA;AACA,iD;;;;;;;;;;;;AC1Ta;AACb;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,gBAAgB,mBAAO,CAAC,wDAAU;AAClC,qBAAqB,mBAAO,CAAC,0EAAc;AAC3C,6BAA6B,mBAAO,CAAC,oGAAgC;AACrE,kCAAkC,mBAAO,CAAC,sGAAiC;AAC3E,qBAAqB,mBAAO,CAAC,kEAAe;AAC5C,uBAAuB,mBAAO,CAAC,gFAAsB;AACrD,iBAAiB,mBAAO,CAAC,0DAAW;AACpC,qCAAqC,mBAAO,CAAC,gHAAsC;AACnF,4BAA4B,mBAAO,CAAC,wFAAqB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,QAAQ;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,yBAAyB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,yBAAyB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,yBAAyB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,aAAa,wBAAwB,QAAQ;AAC/E;AACA;AACA,kCAAkC,aAAa,wBAAwB,UAAU;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,kDAAkD;AAClG;AACA;AACA,6C;;;;;;;;;;;;ACvVa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,gBAAgB,mBAAO,CAAC,wDAAU;AAClC,iBAAiB,mBAAO,CAAC,sBAAQ;AACjC,qBAAqB,mBAAO,CAAC,kEAAe;AAC5C,qBAAqB,mBAAO,CAAC,0EAAc;AAC3C,iBAAiB,mBAAO,CAAC,gEAAc;AACvC,sBAAsB,mBAAO,CAAC,sFAAyB;AACvD,wBAAwB,mBAAO,CAAC,8FAA6B;AAC7D,kBAAkB,mBAAO,CAAC,kEAAe;AACzC,iBAAiB,mBAAO,CAAC,0DAAW;AACpC,4BAA4B,mBAAO,CAAC,kGAA+B;AACnE,+BAA+B,mBAAO,CAAC,sFAAyB;AAChE,yBAAyB,mBAAO,CAAC,qEAAgB;AACjD,4BAA4B,mBAAO,CAAC,wFAAqB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,QAAQ;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,YAAY;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,oDAAoD;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,MAAM;AAC3C,uBAAuB,4BAA4B;AACnD,uBAAuB,4BAA4B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,kBAAkB,MAAM,OAAO;AACzE;AACA;AACA;AACA;AACA,kCAAkC,kBAAkB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,iBAAiB;AAC5F,2EAA2E,iBAAiB;AAC5F,oEAAoE,iBAAiB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,mDAAmD;AACnG;AACA;AACA,8C;;;;;;;;;;;;ACnfa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,iBAAiB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,6C;;;;;;;;;;;;AC5Ca;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;ACpEa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,gBAAgB,mBAAO,CAAC,uDAAS;AACjC,yBAAyB,mBAAO,CAAC,qEAAgB;AACjD,4BAA4B,mBAAO,CAAC,iGAA8B;AAClE,6BAA6B,mBAAO,CAAC,mGAA+B;AACpE,4BAA4B,mBAAO,CAAC,iGAA8B;AAClE,yBAAyB,mBAAO,CAAC,yFAA0B;AAC3D,kCAAkC,mBAAO,CAAC,qGAAgC;AAC1E,iBAAiB,mBAAO,CAAC,yDAAU;AACnC,8BAA8B,mBAAO,CAAC,iGAA8B;AACpE,oCAAoC,mBAAO,CAAC,6GAAoC;AAChF,uBAAuB,mBAAO,CAAC,+EAAqB;AACpD,oBAAoB,mBAAO,CAAC,yEAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,KAAK;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,+BAA+B;AAC1G,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,KAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,KAAK,WAAW,cAAc;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,uBAAuB,OAAO,2BAA2B;AAChG;AACA;AACA;AACA;AACA;AACA,+BAA+B,KAAK,UAAU,cAAc,WAAW,gBAAgB;AACvF;AACA;AACA;AACA,+BAA+B,KAAK,UAAU,cAAc,WAAW,gBAAgB,GAAG,sBAAsB;AAChH;AACA;AACA;AACA,+BAA+B,KAAK,UAAU,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,uDAAuD,aAAa,eAAe,KAAK;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iBAAiB,QAAQ,eAAe,cAAc,qBAAqB;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;AC3Za;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,gBAAgB,mBAAO,CAAC,uDAAS;AACjC,qBAAqB,mBAAO,CAAC,iEAAc;AAC3C,4BAA4B,mBAAO,CAAC,iGAA8B;AAClE,qCAAqC,mBAAO,CAAC,+GAAqC;AAClF,kCAAkC,mBAAO,CAAC,qGAAgC;AAC1E,uBAAuB,mBAAO,CAAC,+EAAqB;AACpD,kCAAkC,mBAAO,CAAC,2FAA2B;AACrE,gCAAgC,mBAAO,CAAC,yGAAkC;AAC1E,4BAA4B,mBAAO,CAAC,iGAA8B;AAClE,iBAAiB,mBAAO,CAAC,yDAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,KAAK;AACvC;AACA;AACA,8BAA8B,KAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,KAAK;AACvC;AACA;AACA,kCAAkC,KAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC,kBAAkB;AAClB,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,QAAQ;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,QAAQ;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,QAAQ;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,QAAQ;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,MAAM;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4C;;;;;;;;;;;;ACrTa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,YAAY,mBAAO,CAAC,qEAAgB;AACpC,iBAAiB,mBAAO,CAAC,sBAAQ;AACjC,kBAAkB,mBAAO,CAAC,iEAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,kFAAkF,QAAQ;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,UAAU,IAAI,YAAY;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,0BAA0B;AAClE;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+C;;;;;;;;;;;;AC7Ha;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,qBAAqB,mBAAO,CAAC,iEAAc;AAC3C,yBAAyB,mBAAO,CAAC,qEAAgB;AACjD,4BAA4B,mBAAO,CAAC,iGAA8B;AAClE,iBAAiB,mBAAO,CAAC,yDAAU;AACnC,kCAAkC,mBAAO,CAAC,2FAA2B;AACrE,gBAAgB,mBAAO,CAAC,uDAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,oBAAoB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,QAAQ;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,QAAQ;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,+BAA+B;AACtG,SAAS;AACT,2DAA2D,wBAAwB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4C;;;;;;;;;;;;ACxKa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,gBAAgB,mBAAO,CAAC,uDAAS;AACjC,iBAAiB,mBAAO,CAAC,sBAAQ;AACjC,yBAAyB,mBAAO,CAAC,qEAAgB;AACjD,kCAAkC,mBAAO,CAAC,2FAA2B;AACrE,qBAAqB,mBAAO,CAAC,iEAAc;AAC3C,yBAAyB,mBAAO,CAAC,yEAAkB;AACnD,sBAAsB,mBAAO,CAAC,yEAAkB;AAChD,6BAA6B,mBAAO,CAAC,mGAA+B;AACpE,4BAA4B,mBAAO,CAAC,iGAA8B;AAClE,4BAA4B,mBAAO,CAAC,iGAA8B;AAClE,gCAAgC,mBAAO,CAAC,yGAAkC;AAC1E,sBAAsB,mBAAO,CAAC,qFAAwB;AACtD,6BAA6B,mBAAO,CAAC,mGAA+B;AACpE,iCAAiC,mBAAO,CAAC,2GAAmC;AAC5E,4BAA4B,mBAAO,CAAC,iGAA8B;AAClE,yBAAyB,mBAAO,CAAC,yFAA0B;AAC3D,kCAAkC,mBAAO,CAAC,qGAAgC;AAC1E,oCAAoC,mBAAO,CAAC,6GAAoC;AAChF,8BAA8B,mBAAO,CAAC,iGAA8B;AACpE,wBAAwB,mBAAO,CAAC,6FAA4B;AAC5D,uBAAuB,mBAAO,CAAC,+EAAqB;AACpD,iBAAiB,mBAAO,CAAC,yDAAU;AACnC,oBAAoB,mBAAO,CAAC,yEAAkB;AAC9C;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,KAAK,GAAG,8BAA8B;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,+BAA+B;AACtG,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,wBAAwB,oBAAoB,cAAc;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,mBAAmB;AAC7D;AACA;AACA;AACA,qEAAqE,cAAc;AACnF;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,KAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,+BAA+B;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,QAAQ,IAAI,+BAA+B;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,QAAQ,IAAI,+BAA+B;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,KAAK,kBAAkB,KAAK;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,KAAK,SAAS,gDAAgD,KAAK,cAAc;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,KAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,KAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;ACr2Ba;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gD;;;;;;;;;;;;ACnBa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,wBAAwB,mBAAO,CAAC,6FAA4B;AAC5D,6BAA6B,mBAAO,CAAC,mGAA+B;AACpE,4BAA4B,mBAAO,CAAC,iGAA8B;AAClE,gCAAgC,mBAAO,CAAC,yGAAkC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0GAA0G;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mD;;;;;;;;;;;;AC7La;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,kCAAkC,mBAAO,CAAC,qGAAgC;AAC1E,iBAAiB,mBAAO,CAAC,sBAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,mBAAmB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0CAA0C,yBAAyB,QAAQ,uBAAuB,cAAc,6BAA6B;AAC7I;AACA;AACA;AACA,qC;;;;;;;;;;;;AC7Ha;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,oBAAoB,mBAAO,CAAC,kEAAgB;AAC5C,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gBAAgB,GAAG,YAAY,GAAG,eAAe;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0C;;;;;;;;;;;;AC5Fa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,iBAAiB,mBAAO,CAAC,sBAAQ;AACjC,yBAAyB,mBAAO,CAAC,qEAAgB;AACjD,uBAAuB,mBAAO,CAAC,+EAAqB;AACpD,iBAAiB,mBAAO,CAAC,yDAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,8BAA8B;AACrE;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,wCAAwC,uCAAuC;AAC/E,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mC;;;;;;;;;;;;ACvPa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA,oBAAoB,mBAAO,CAAC,kEAAgB;AAC5C,4DAA4D;AAC5D,cAAc,mBAAO,CAAC,oDAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;;;;;ACrBa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,yBAAyB,mBAAO,CAAC,qEAAgB;AACjD,qDAAqD,qCAAqC,2CAA2C,EAAE,EAAE;AACzI,2DAA2D,qCAAqC,iDAAiD,EAAE,EAAE;AACrJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA,wC;;;;;;;;;;;;ACrCa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,qBAAqB;AACrB,eAAe;AACf;AACA;AACA,mD;;;;;;;;;;;;ACjBa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;;;;;AC7Fa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,kCAAkC,mBAAO,CAAC,gGAA2B;AACrE,uBAAuB,mBAAO,CAAC,0EAAgB;AAC/C,iBAAiB,mBAAO,CAAC,0DAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;AC/HA;AACA;AACA;AACA;AACa;;AAEb,8CAA8C,cAAc;;AAE5D,sBAAsB,mBAAO,CAAC,yFAAmB;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,qCAAqC;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gBAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,mBAAmB;AACjC,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,iDAAiD;AAC3I;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAmB;AAChC,YAAY,mBAAmB;AAC/B,CAAC;AACD;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AC9HA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;;AAEA,WAAW,mBAAO,CAAC,wDAAW;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACvca;;AAEb,mBAAmB,kBAAkB,KAAK;AAC1C;AACA,4BAA4B,gBAAgB,6CAA6C;AACzF,aAAa,IAAI,IAAI,IAAI,IAAI;AAC7B;;AAEA;AACA;;;;;;;;;;;;;ACTa;;AAEb;AACA;AACA;;;;;;;;;;;;;ACJa;AACb;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,kCAAkC,mBAAO,CAAC,2HAA6B;AACvE,eAAe,mBAAO,CAAC,sBAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,uDAAuD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,yBAAyB,EAAE,EAAE;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mBAAmB,mDAAmD;AACvG;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,kD;;;;;;;;;;;;AC9Fa;AACb,kBAAkB,mBAAO,CAAC,2IAAqC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mBAAO,CAAC,qIAAkC;AACtD,YAAY,mBAAO,CAAC,mIAAiC;AACrD,YAAY,mBAAO,CAAC,qIAAkC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,mC;;;;;;;;;;;;AC5Ba;AACb,8CAA8C,cAAc;AAC5D,cAAc,mBAAO,CAAC,yFAAoB;AAC1C,kBAAkB,mBAAO,CAAC,2IAAqC;AAC/D,kBAAkB,mBAAO,CAAC,iGAAwB;AAClD,iBAAiB,mBAAO,CAAC,+FAAuB;AAChD,wBAAwB,mBAAO,CAAC,2GAAqB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mBAAO,CAAC,0DAAY;AACnD;AACA;AACA,+BAA+B,mBAAO,CAAC,4FAA4B;AACnE;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0JAA0J;AAC1J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8GAA8G;AAC9G;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wBAAwB;AACjD;AACA;AACA;AACA,CAAC;AACD,qD;;;;;;;;;;;;ACxPa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,kEAAkE;AAC7G,kDAAkD,mBAAmB;AACrE,yCAAyC,sBAAsB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF;AACxF;AACA;AACA;AACA;AACA,wFAAwF;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,sC;;;;;;;;;;;;AC7Ea;AACb,SAAS,mBAAO,CAAC,cAAI;AACrB,gBAAgB,mBAAO,CAAC,uGAA2B;AACnD,WAAW,mBAAO,CAAC,mFAAiB;AACpC,cAAc,mBAAO,CAAC,yFAAoB;AAC1C,kCAAkC,mBAAO,CAAC,yHAAoC;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,kDAAkD,EAAE,EAAE,EAAE;AAChH,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,wEAAwE;AACvH;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,wEAAwE;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,qC;;;;;;;;;;;;ACrJa;AACb,WAAW,mBAAO,CAAC,kBAAM;AACzB,YAAY,mBAAO,CAAC,oBAAO;AAC3B,cAAc,mBAAO,CAAC,yFAAoB;AAC1C,WAAW,mBAAO,CAAC,mFAAiB;AACpC,6BAA6B,mBAAO,CAAC,uHAAmC;AACxE,2BAA2B,mBAAO,CAAC,iHAAwB;AAC3D,kCAAkC,mBAAO,CAAC,2HAA6B;AACvE,2BAA2B,mBAAO,CAAC,mHAAiC;AACpE,kBAAkB,mBAAO,CAAC,iGAAwB;AAClD,kBAAkB,mBAAO,CAAC,2IAAqC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mBAAO,CAAC,yJAA4C;AAChE,YAAY,mBAAO,CAAC,qIAAkC;AACtD,YAAY,mBAAO,CAAC,iIAAgC;AACpD,YAAY,mBAAO,CAAC,iIAAgC;AACpD,YAAY,mBAAO,CAAC,uIAAmC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,qCAAqC;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,4C;;;;;;;;;;;;AChNa;AACb;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,UAAU,mBAAO,CAAC,gBAAK;AACvB,gBAAgB,mBAAO,CAAC,6GAA2B;AACnD,WAAW,mBAAO,CAAC,mFAAiB;AACpC,6BAA6B,mBAAO,CAAC,uHAAmC;AACxE,oBAAoB,mBAAO,CAAC,mGAAiB;AAC7C,2BAA2B,mBAAO,CAAC,mHAAiC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,gD;;;;;;;;;;;;ACtKa;AACb;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,UAAU,mBAAO,CAAC,gBAAK;AACvB,gBAAgB,mBAAO,CAAC,6GAA2B;AACnD,WAAW,mBAAO,CAAC,mFAAiB;AACpC,6BAA6B,mBAAO,CAAC,uHAAmC;AACxE,oBAAoB,mBAAO,CAAC,mGAAiB;AAC7C,2BAA2B,mBAAO,CAAC,mHAAiC;AACpE,iBAAiB,mBAAO,CAAC,+FAAuB;AAChD,kBAAkB,mBAAO,CAAC,iGAAwB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,6BAA6B,IAAI,QAAQ,IAAI,QAAQ,IAAI,QAAQ,IAAI;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F;AAC5F,8FAA8F;AAC9F,0FAA0F;AAC1F,yFAAyF;AACzF,qFAAqF;AACrF;AACA;AACA;AACA,sEAAsE;AACtE,4GAA4G;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,CAAC;AACD;AACA,6C;;;;;;;;;;;;AClQa;AACb,WAAW,mBAAO,CAAC,kBAAM;AACzB,YAAY,mBAAO,CAAC,oBAAO;AAC3B,cAAc,mBAAO,CAAC,yFAAoB;AAC1C,WAAW,mBAAO,CAAC,mFAAiB;AACpC,6BAA6B,mBAAO,CAAC,uHAAmC;AACxE,wBAAwB,mBAAO,CAAC,2GAAqB;AACrD,kCAAkC,mBAAO,CAAC,2HAA6B;AACvE,6BAA6B,mBAAO,CAAC,+FAAe;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,uCAAuC;AACxH;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,wC;;;;;;;;;;;;AC7Oa;AACb;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,aAAa,mBAAO,CAAC,uFAAmB;AACxC,cAAc,mBAAO,CAAC,yFAAoB;AAC1C,cAAc,mBAAO,CAAC,yFAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,yCAAyC,sBAAsB;AAC/D,4CAA4C,4BAA4B;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,mBAAO,CAAC,4JAAoC;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,oCAAoC,EAAE;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qCAAqC;AACpD,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sCAAsC;AAC1D;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA,2DAA2D,0BAA0B;AACrF;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8CAA8C;AACtE;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,oBAAoB,uDAAuD;AAC3E;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,CAAC;AACD;AACA,6C;;;;;;;;;;;;AC1Pa;AACb,SAAS,mBAAO,CAAC,cAAI;AACrB,gBAAgB,mBAAO,CAAC,uGAA2B;AACnD;AACA;AACA;AACA;AACA;AACA,4CAA4C,4BAA4B;AACxE,mDAAmD,mCAAmC;AACtF,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,iCAAiC,EAAE;AAC3F,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+HAA+H;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,gHAAgH;AACtJ,sCAAsC,+GAA+G;AACrJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mEAAmE;AACrG,kCAAkC,qEAAqE;AACvG;AACA;AACA,sCAAsC,4EAA4E;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oKAAoK;AACpK,sGAAsG;AACtG;AACA;AACA;AACA,sCAAsC,yEAAyE;AAC/G;AACA;AACA,0CAA0C,0FAA0F;AACpI;AACA;AACA;AACA,0CAA0C,sFAAsF;AAChI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gHAAgH;AAChH;AACA;AACA;AACA,0CAA0C,+EAA+E;AACzH,0CAA0C,6FAA6F;AACvI;AACA;AACA;AACA,8CAA8C,+FAA+F;AAC7I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,4EAA4E;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,uC;;;;;;;;;;;;ACrRa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,yC;;;;;;;;;;;;AC3Ca;AACb;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA,+BAA+B,mBAAO,CAAC,sHAA2B;AAClE,gBAAgB,mBAAO,CAAC,0GAA8B;AACtD;AACA,mCAAmC;AACnC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,0CAA0C,kCAAkC;AAC/G;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;ACrFa;AACb,8CAA8C,cAAc;AAC5D,2BAA2B,mBAAO,CAAC,qFAAoB;AACvD,kBAAkB,mBAAO,CAAC,oGAA2B;AACrD,iBAAiB,mBAAO,CAAC,gHAAc;AACvC,+BAA+B,mBAAO,CAAC,sHAA2B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,oBAAoB,EAAE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,iD;;;;;;;;;;;;AC9Ca;AACb,8CAA8C,cAAc;AAC5D,kBAAkB,mBAAO,CAAC,gHAA8B;AACxD,2BAA2B,mBAAO,CAAC,qFAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uBAAuB;AAC1D;AACA;AACA,+BAA+B,sCAAsC;AACrE;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,oBAAoB,EAAE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;AC/Ca;AACb,8CAA8C,cAAc;AAC5D,kBAAkB,mBAAO,CAAC,gHAA8B;AACxD,2BAA2B,mBAAO,CAAC,qFAAoB;AACvD;AACA;AACA;AACA;AACA;AACA,mCAAmC,qBAAqB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8HAA8H;AAC7J;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,oBAAoB,EAAE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;ACzCa;AACb;AACA;AACA,8CAA8C,cAAc;AAC5D,+BAA+B,mBAAO,CAAC,sHAA2B;AAClE,cAAc,mBAAO,CAAC,4FAAuB;AAC7C;AACA;AACA;AACA,qBAAqB,mBAAO,CAAC,yGAA+B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mBAAO,CAAC,qFAAoB;AAClD;AACA;AACA;AACA;AACA,0C;;;;;;;;;;;;AC9Ca;AACb,8CAA8C,cAAc;AAC5D,2BAA2B,mBAAO,CAAC,qFAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,oBAAoB,EAAE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;ACxCa;AACb,8CAA8C,cAAc;AAC5D,2BAA2B,mBAAO,CAAC,qFAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,oBAAoB,EAAE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;ACzCa;AACb,8CAA8C,cAAc;AAC5D,2BAA2B,mBAAO,CAAC,qFAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,oBAAoB,EAAE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;;;;;;;;;ACtCa;AACb,8CAA8C,cAAc;AAC5D,2BAA2B,mBAAO,CAAC,qFAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,oBAAoB,EAAE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;ACvCa;AACb,8CAA8C,cAAc;AAC5D,kBAAkB,mBAAO,CAAC,gHAA8B;AACxD,2BAA2B,mBAAO,CAAC,qFAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,oBAAoB,EAAE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;AC1Ea;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kFAAkF;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,qFAAqF;AACtF;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;AC9Ga;AACb,8CAA8C,cAAc;AAC5D,kBAAkB,mBAAO,CAAC,yGAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;ACtBa;AACb;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD;AACA,aAAa,mBAAO,CAAC,uGAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,4C;;;;;;;;;;;;AC7BA;AACa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,gC;;;;;;;;;;;;ACXA;AACa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,0C;;;;;;;;;;;;AC/Ba;AACb;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD;AACA,WAAW,mBAAO,CAAC,mGAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,gC;;;;;;;;;;;;ACzBa;AACb;AACA,oBAAoB,mBAAO,CAAC,qHAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,qC;;;;;;;;;;;;ACdA;AACa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;AACA,yC;;;;;;;;;;;;ACXA;AACa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kC;;;;;;;;;;;;ACXa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,oC;;;;;;;;;;;;ACba;AACb;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD;AACA,aAAa,mBAAO,CAAC,uGAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,qC;;;;;;;;;;;;AC7Ba;AACb;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD;AACA,aAAa,mBAAO,CAAC,uGAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,yC;;;;;;;;;;;;AC9Ba;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,4C;;;;;;;;;;;;ACZa;AACb;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD;AACA,aAAa,mBAAO,CAAC,uGAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,uC;;;;;;;;;;;;AC5Ba;AACb;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD;AACA,aAAa,mBAAO,CAAC,uGAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,sC;;;;;;;;;;;;AC7Ba;AACb;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD;AACA,gBAAgB,mBAAO,CAAC,6GAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,wC;;;;;;;;;;;;AC7Ba;AACb;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD;AACA,aAAa,mBAAO,CAAC,uGAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,gD;;;;;;;;;;;;AC9Ba;AACb;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD;AACA,aAAa,mBAAO,CAAC,uGAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,uC;;;;;;;;;;;;AC7BA;AACa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;AACA,yC;;;;;;;;;;;;ACdA;AACa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,sC;;;;;;;;;;;;ACXA;AACa;AACb,8CAA8C,cAAc;AAC5D,2BAA2B,mBAAO,CAAC,2HAAoB;AACvD,eAAe,mBAAO,CAAC,mGAAQ;AAC/B,yBAAyB,mBAAO,CAAC,uHAAkB;AACnD,eAAe,mBAAO,CAAC,mGAAQ;AAC/B,oBAAoB,mBAAO,CAAC,6GAAa;AACzC,wBAAwB,mBAAO,CAAC,qHAAiB;AACjD,iBAAiB,mBAAO,CAAC,uGAAU;AACnC,mBAAmB,mBAAO,CAAC,2GAAY;AACvC,oBAAoB,mBAAO,CAAC,6GAAa;AACzC,wBAAwB,mBAAO,CAAC,qHAAiB;AACjD,2BAA2B,mBAAO,CAAC,2HAAoB;AACvD,sBAAsB,mBAAO,CAAC,iHAAe;AAC7C,qBAAqB,mBAAO,CAAC,+GAAc;AAC3C,uBAAuB,mBAAO,CAAC,mHAAgB;AAC/C,+BAA+B,mBAAO,CAAC,mIAAwB;AAC/D,sBAAsB,mBAAO,CAAC,iHAAe;AAC7C,wBAAwB,mBAAO,CAAC,qHAAiB;AACjD,qBAAqB,mBAAO,CAAC,+GAAc;AAC3C,iC;;;;;;;;;;;;ACrBa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sEAAsE;AACvE,yC;;;;;;;;;;;;AC9Ea;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,SAAS,mBAAO,CAAC,0HAAiB;AAClC,iC;;;;;;;;;;;;ACNa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,SAAS,mBAAO,CAAC,mGAAa;AAC9B,SAAS,mBAAO,CAAC,yGAAa;AAC9B,SAAS,mBAAO,CAAC,mHAAkB;AACnC,iC;;;;;;;;;;;;ACRa;AACb,cAAc,mBAAO,CAAC,gFAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,mC;;;;;;;;;;;;ACjGa;AACb,2BAA2B,mBAAO,CAAC,0GAAwB;AAC3D,6BAA6B,mBAAO,CAAC,8GAA0B;AAC/D,cAAc,mBAAO,CAAC,gFAAW;AACjC,gBAAgB,mBAAO,CAAC,uGAA2B;AACnD,UAAU,mBAAO,CAAC,gBAAK;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,4CAA4C;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0EAA0E;AAC1E;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,GAAG;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kC;;;;;;;;;;;;ACrHa;AACb,gBAAgB,mBAAO,CAAC,uGAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA,CAAC;AACD;AACA,kD;;;;;;;;;;;;ACtCa;AACb,SAAS,mBAAO,CAAC,cAAI;AACrB,SAAS,mBAAO,CAAC,cAAI;AACrB,WAAW,mBAAO,CAAC,kBAAM;AACzB,gBAAgB,mBAAO,CAAC,6GAA2B;AACnD,cAAc,mBAAO,CAAC,gFAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,mC;;;;;;;;;;;;AC/Da;AACb,WAAW,mBAAO,CAAC,0EAAQ;AAC3B,cAAc,mBAAO,CAAC,gFAAW;AACjC;AACA;AACA;AACA;AACA,6BAA6B,kBAAkB,gBAAgB,wBAAwB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,uGAAuG,mBAAmB,EAAE;AAC5H;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uGAAuG,uBAAuB,EAAE;AAChI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,gD;;;;;;;;;;;;ACxJa;AACb,gBAAgB,mBAAO,CAAC,6GAA2B;AACnD,WAAW,mBAAO,CAAC,0EAAQ;AAC3B,kCAAkC,mBAAO,CAAC,2IAA6C;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,KAAK,yDAAyD;AAC5F;AACA,CAAC;AACD;AACA,2C;;;;;;;;;;;;ACnUa;AACb,8CAA8C,cAAc;AAC5D,qC;;;;;;;;;;;;ACFa;AACb;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,mC;;;;;;;;;;;;AC7Ba;AACb;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,sBAAsB,mBAAO,CAAC,gGAAmB;AACjD,4BAA4B,mBAAO,CAAC,iHAAgC;AACpE,4BAA4B,mBAAO,CAAC,yHAAoC;AACxE,cAAc,mBAAO,CAAC,gFAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,sC;;;;;;;;;;;;ACxEa;AACb;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,mBAAO,CAAC,cAAI;AACrB,gBAAgB,mBAAO,CAAC,6GAA2B;AACnD,gBAAgB,mBAAO,CAAC,uGAA2B;AACnD,WAAW,mBAAO,CAAC,0EAAQ;AAC3B,cAAc,mBAAO,CAAC,gFAAW;AACjC,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,aAAa,aAAa;AACjE;AACA;AACA;AACA;AACA;AACA,uCAAuC,aAAa,iGAAiG;AACrJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,aAAa,yFAAyF;AACjJ;AACA;AACA;AACA;AACA;AACA,yCAAyC,aAAa;AACtD,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,4CAA4C,aAAa,4OAA4O;AACrS;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,qD;;;;;;;;;;;;AChKa;AACb,YAAY,mBAAO,CAAC,oBAAO;AAC3B,kCAAkC,mBAAO,CAAC,yHAAoC;AAC9E,cAAc,mBAAO,CAAC,gFAAW;AACjC,qBAAqB,mBAAO,CAAC,8FAAkB;AAC/C,WAAW,mBAAO,CAAC,0EAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,4C;;;;;;;;;;;;AC5Ea;AACb,cAAc,mBAAO,CAAC,gFAAW;AACjC,aAAa,mBAAO,CAAC,8EAAU;AAC/B,gCAAgC,mBAAO,CAAC,oHAA6B;AACrE,uBAAuB,mBAAO,CAAC,kGAAoB;AACnD,gBAAgB,mBAAO,CAAC,uGAA2B;AACnD,cAAc,mBAAO,CAAC,gFAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,0BAA0B,EAAE;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kD;;;;;;;;;;;;AC9Ja;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,kBAAkB;AAClB,0C;;;;;;;;;;;;ACda;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kD;;;;;;;;;;;;AC5Ca;AACb,SAAS,mBAAO,CAAC,cAAI;AACrB,SAAS,mBAAO,CAAC,cAAI;AACrB,WAAW,mBAAO,CAAC,kBAAM;AACzB,WAAW,mBAAO,CAAC,kBAAM;AACzB,oBAAoB,mBAAO,CAAC,oCAAe;AAC3C,cAAc,mBAAO,CAAC,gFAAW;AACjC,kCAAkC,mBAAO,CAAC,yHAAoC;AAC9E,WAAW,mBAAO,CAAC,0EAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,oBAAoB;AACzF,0CAA0C,oBAAoB,EAAE;AAChE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,6EAA6E,oBAAoB;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,+CAA+C,kBAAkB,EAAE;AACnE,yCAAyC,0BAA0B,EAAE;AACrE;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,YAAY,oBAAoB,oCAAoC,EAAE;AAC3H,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,YAAY;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,kDAAkD,EAAE;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,kC;;;;;;;;;;;;ACvda;AACb,UAAU,mBAAO,CAAC,gBAAK;AACvB,aAAa,mBAAO,CAAC,8EAAU;AAC/B,cAAc,mBAAO,CAAC,gFAAW;AACjC,gBAAgB,mBAAO,CAAC,6GAA2B;AACnD,cAAc,mBAAO,CAAC,gFAAW;AACjC,0BAA0B,mBAAO,CAAC,uGAAwB;AAC1D,kCAAkC,mBAAO,CAAC,2IAA6C;AACvF,aAAa,mBAAO,CAAC,8EAAU;AAC/B,WAAW,mBAAO,CAAC,0EAAQ;AAC3B,cAAc,mBAAO,CAAC,gFAAW;AACjC,sBAAsB,mBAAO,CAAC,gGAAmB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,kCAAkC,EAAE,eAAe,4BAA4B,EAAE,eAAe,kCAAkC,EAAE;AACpL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA6F,gGAAgG;AAC7L;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8BAA8B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,2C;;;;;;;;;;;;AChLa;AACb,WAAW,mBAAO,CAAC,0EAAQ;AAC3B,2BAA2B,mBAAO,CAAC,0GAAwB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,EAAE;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,EAAE;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,GAAG;AACtC;AACA;AACA,mCAAmC,GAAG;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,uC;;;;;;;;;;;;AC3Ga;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,MAAM;AAChF,0EAA0E,KAAK;AAC/E;AACA;AACA;AACA;AACA,4DAA4D,MAAM;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,qBAAqB;AAC9D;AACA,sCAAsC;AACtC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,sC;;;;;;;;;;;;AC3Ea;AACb;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAO,CAAC,kBAAM;AACzB,YAAY,mBAAO,CAAC,oBAAO;AAC3B,UAAU,mBAAO,CAAC,gBAAK;AACvB,gBAAgB,mBAAO,CAAC,4BAAW;AACnC,cAAc,mBAAO,CAAC,gFAAW;AACjC,6BAA6B,mBAAO,CAAC,8GAA0B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,IAAI;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4BAA4B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mBAAmB,gGAAgG;AACpJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,YAAY,yGAAyG,oBAAoB,kCAAkC,GAAG;AACnN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,+CAA+C,EAAE;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA,gC;;;;;;;;;;;;ACvVa;AACb,8CAA8C,cAAc;AAC5D,6BAA6B,mBAAO,CAAC,+GAA+B;AACpE,oBAAoB,mBAAO,CAAC,6GAA2B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gE;;;;;;;;;;;;AC1Ba;AACb,8CAA8C,cAAc;AAC5D,gBAAgB,mBAAO,CAAC,6GAA2B;AACnD;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sD;;;;;;;;;;;;AC9Ca;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,SAAS,mBAAO,CAAC,kIAA8B;AAC/C,SAAS,mBAAO,CAAC,sJAAwC;AACzD,iC;;;;;;;;;;;;ACPa;AACb,8CAA8C,cAAc;AAC5D,gCAAgC,mBAAO,CAAC,0IAA4C,EAAE;AACtF,yBAAyB,mBAAO,CAAC,sGAA0B;AAC3D,4BAA4B,mBAAO,CAAC,4GAA6B;AACjE,6BAA6B,mBAAO,CAAC,8GAA8B;AACnE,gBAAgB,mBAAO,CAAC,0GAA4B;AACpD,kCAAkC,mBAAO,CAAC,wHAAmC;AAC7E,8BAA8B,mBAAO,CAAC,gHAA+B;AACrE,2BAA2B,mBAAO,CAAC,kHAAgC;AACnE,cAAc,mBAAO,CAAC,wFAAmB;AACzC,uBAAuB,mBAAO,CAAC,sHAAkC;AACjE,0BAA0B,mBAAO,CAAC,0HAAoC;AACtE;AACA;AACA,0BAA0B,mBAAO,CAAC,8FAAsB;AACxD,oBAAoB,mBAAO,CAAC,4GAA0B;AACtD,8BAA8B,mBAAO,CAAC,4FAAqB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oGAAoG;AACrG;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,oBAAoB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA,2CAA2C,2BAA2B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA,gDAAgD,+BAA+B;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA,4CAA4C,4BAA4B;AACxE,8CAA8C,6BAA6B;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E;AAC/E;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+C;;;;;;;;;;;ACpWA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACZA;;AAEA,aAAa,mBAAO,CAAC,2DAAU;AAC/B,YAAY,mBAAO,CAAC,yDAAS;;AAE7B,aAAa,mBAAO,CAAC,2DAAU;AAC/B,aAAa,mBAAO,CAAC,2DAAU;;;AAG/B;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1BA;;AAEA,aAAa,mBAAO,CAAC,sBAAQ;AAC7B,aAAa,mBAAO,CAAC,8DAAc;;AAEnC,WAAW,mBAAO,CAAC,yDAAS;AAC5B,aAAa,mBAAO,CAAC,2DAAU;;;AAG/B;;AAEA;;;;AAIA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,oBAAoB;AACxC,CAAC;;AAED;AACA;AACA,oBAAoB,uBAAuB;AAC3C,CAAC;;AAED;AACA,oBAAoB,oCAAoC;AACxD,CAAC;;AAED;AACA,oBAAoB,wCAAwC;AAC5D,CAAC;;;AAGD;AACA,2CAA2C;AAC3C;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,UAAU;AAC7B;;AAEA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4CAA4C;AAC5C;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4CAA4C;;AAE5C;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,cAAc;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,4CAA4C;AAC5C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;AAIA;;AAEA;;;;;;;;;;;;ACrQA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnCA;;AAEA,aAAa,mBAAO,CAAC,sBAAQ;AAC7B,aAAa,mBAAO,CAAC,8DAAc;AACnC,WAAW,mBAAO,CAAC,yDAAS;AAC5B,aAAa,mBAAO,CAAC,2DAAU;;;AAG/B;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;;;AAIA;;AAEA;AACA,6CAA6C;;AAE7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,GAAG;AACvB;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;;AAEA;;;;;;;;;;;;AC5TA;;AAEA;AACA;;AAEA,UAAU,mBAAO,CAAC,6DAAa;;;;AAI/B;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;;;;;;;;;;;ACnBa;;AAEb;AACA;;AAEA;AACA,cAAc,mBAAO,CAAC,qFAAwB;AAC9C,aAAa,mBAAO,CAAC,iFAAsB;AAC3C,YAAY,mBAAO,CAAC,+EAAqB;AACzC;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,mBAAO,CAAC,qEAAgB;;AAEzC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,E;;;;;;;;;;;;ACrIa;;AAEb,kBAAkB,mBAAO,CAAC,uEAAiB;;AAE3C;AACA;AACA;AACA;AACA,oCAAoC,mBAAO,CAAC,qEAAgB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,qBAAqB,mBAAO,CAAC,4DAAa;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA,C;;;;;;;;;;;;;;;;;;;;;;;AC9Ba;;AAEb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACxDa;;AAEb;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/Da;;AAEb,eAAe,mBAAO,CAAC,sBAAQ;;AAE/B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACpHa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpCA,WAAW,mBAAO,CAAC,oDAAS;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,gBAAgB;;AAElC;;AAEA,iBAAiB,iBAAiB;AAClC;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACvea;;AAEb;;AAEA,mBAAmB,mBAAO,CAAC,oDAAS;AACpC,mBAAmB,mBAAO,CAAC,mDAAQ;AACnC;AACA;AACA,mBAAmB,mBAAO,CAAC,4DAAW;AACtC,mBAAmB,mBAAO,CAAC,kBAAM;AACjC;;AAEA;AACA;AACA;AACA;;AAEA,UAAU,mBAAO,CAAC,gBAAK;;AAEvB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA,0BAA0B,yCAAyC;;AAEnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED,WAAW,mBAAO,CAAC,kBAAM;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;;AAED,mBAAmB,mBAAO,CAAC,oCAAe;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,sBAAQ;AAC7B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU,mBAAO,CAAC,gBAAK;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,SAAS,mBAAO,CAAC,cAAI;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK,QAAQ,mBAAO,CAAC,kBAAM,EAAE,EAAE,cAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK,UAAU,mBAAO,CAAC,sBAAQ,EAAE,EAAE,cAAc;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gDAAgD,gBAAgB;AAChE,0DAA0D,gBAAgB;;AAE1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,mBAAO,CAAC,0FAA0B;AACvD,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd,KAAK;AACL,cAAc;AACd,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,0BAA0B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACjqBa;;AAEb;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;;AAEA,kBAAkB;;;;;;;;;;;;;ACjCL;;AAEb;AACA,mBAAmB,mBAAO,CAAC,kEAAgB;AAC3C,CAAC;AACD,mBAAmB,mBAAO,CAAC,6DAAY;AACvC;;;;;;;;;;;;;ACNa;;AAEb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,oBAAoB,mBAAO,CAAC,yEAAkB;AAC9C,kBAAkB,mBAAO,CAAC,gEAAe;;AAEzC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,EAAE;;;AAGF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA,mBAAmB,mBAAO,CAAC,4DAAa;AACxC;AACA;AACA;AACA;;;;;;;;;;;;;ACnaA;AACa;;AAEb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,oBAAoB,mBAAO,CAAC,yEAAkB;AAC9C,oBAAoB,mBAAO,CAAC,gCAAa;;AAEzC;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,8JAA8J,sCAAsC;AACpM;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gLAAgL,sCAAsC;AACtN,gBAAgB,UAAU,qCAAqC,UAAU,IAAI,IAAI,wBAAwB,WAAW,uBAAuB,oBAAoB,aAAa,UAAU,OAAO,iBAAiB;AAC9M;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yKAAyK,sCAAsC;AAC/M,cAAc,UAAU,wBAAwB,UAAU,IAAI,IAAI,GAAG,iBAAiB,cAAc,WAAW,uBAAuB,oBAAoB,aAAa,UAAU,OAAO,iBAAiB,UAAU,0BAA0B;AAC7O;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,UAAU,4BAA4B,UAAU,eAAe,WAAW,uBAAuB,oBAAoB,aAAa,UAAU,OAAO,iBAAiB,WAAW,uBAAuB,sCAAsC,EAAE;AAC5P;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU,sBAAsB,UAAU,eAAe,WAAW,aAAa,UAAU,uBAAuB,oBAAoB,OAAO,iBAAiB,WAAW,sBAAsB;AAC/M;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,gBAAgB,UAAU,oBAAoB,UAAU,eAAe,WAAW,aAAa,UAAU,uBAAuB,oBAAoB,OAAO,iBAAiB,GAAG,sBAAsB;AACrM;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,UAAU,kBAAkB,UAAU,eAAe,WAAW,aAAa,UAAU,uBAAuB,oBAAoB,OAAO,iBAAiB,GAAG,sBAAsB;AACjM;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,UAAU,iBAAiB,UAAU,eAAe,WAAW,aAAa,UAAU,uBAAuB,oBAAoB,OAAO,iBAAiB,GAAG,sBAAsB;AAChM;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,yDAAyD;AACzD,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qCAAqC,KAAK;AAC1C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,UAAU,QAAQ,KAAK,KAAK,KAAK,gCAAgC,QAAQ,cAAc,WAAW,aAAa,UAAU,UAAU,qCAAqC,YAAY,SAAS;AACtN;AACA,YAAY;AACZ;AACA,yBAAyB,UAAU,QAAQ,KAAK,KAAK,KAAK,4BAA4B,QAAQ,cAAc,WAAW,aAAa,UAAU,UAAU,qCAAqC,YAAY,SAAS;AAClN;AACA,UAAU;AACV;AACA;AACA;AACA,uBAAuB,UAAU,QAAQ,KAAK,KAAK,KAAK,YAAY,QAAQ,cAAc,WAAW,aAAa,UAAU,UAAU,qCAAqC,YAAY,SAAS;AAChM;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,UAAU,QAAQ,KAAK,KAAK,KAAK,YAAY,QAAQ,cAAc,WAAW,aAAa,UAAU,UAAU,gCAAgC,sCAAsC,EAAE,YAAY,SAAS;AAChO;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,UAAU,qCAAqC,KAAK,KAAK,KAAK,YAAY,QAAQ,cAAc,WAAW,aAAa,UAAU,UAAU,gCAAgC,2CAA2C,EAAE,YAAY,SAAS;AACpQ;AACA,SAAS;AACT;AACA,oBAAoB,UAAU,wBAAwB,KAAK,KAAK,KAAK,YAAY,QAAQ,cAAc,WAAW,aAAa,UAAU,UAAU,gCAAgC,2CAA2C,EAAE,YAAY,SAAS;AACrP;AACA;;;AAGA;AACA,uCAAuC,iBAAiB;AACxD;AACA;AACA,kBAAkB,UAAU,yBAAyB,KAAK,KAAK,KAAK,aAAa,SAAS,WAAW,QAAQ,cAAc,WAAW,aAAa,UAAU,UAAU,gCAAgC,sCAAsC,EAAE,YAAY,SAAS;AACpQ;;AAEA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,UAAU,UAAU,KAAK,YAAY,QAAQ,cAAc,WAAW,aAAa,UAAU,UAAU,gCAAgC,sCAAsC,EAAE,WAAW,sBAAsB;AACpO;AACA;;AAEA;;AAEA,OAAO;AACP;AACA;AACA,kBAAkB,UAAU,0BAA0B,KAAK,YAAY,QAAQ,cAAc,WAAW,aAAa,UAAU,UAAU,gCAAgC,sCAAsC,EAAE,uBAAuB,mCAAmC,sCAAsC,EAAE;AACnT;AACA;AACA,KAAK;AACL;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,UAAU,SAAS,KAAK,YAAY,QAAQ,cAAc,WAAW,aAAa,UAAU,UAAU,gCAAgC,sCAAsC,EAAE,WAAW,sBAAsB;AACnO;;AAEA;;AAEA,OAAO;AACP;AACA;AACA;AACA,kBAAkB,UAAU,yBAAyB,KAAK,YAAY,QAAQ,cAAc,WAAW,aAAa,UAAU,UAAU,gCAAgC,sCAAsC,EAAE,WAAW,sBAAsB;AACjP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,kBAAkB,UAAU,WAAW,KAAK,eAAe,WAAW,WAAW,QAAQ,aAAa,UAAU,UAAU,gCAAgC,sCAAsC,EAAE,WAAW,kDAAkD;AAC/P;;AAEA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,yBAAyB,qBAAqB;AAC9C,yBAAyB,qBAAqB;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;;;;;;;;;;;;;;AC1dY;;AAEb,eAAe,mBAAO,CAAC,mDAAQ;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,2DAAW;AACtC,CAAC;AACD,mBAAmB,mBAAO,CAAC,yEAAkB;AAC7C;;;;;;;;;;;;ACdA;AACA,kBAAkB,mBAAO,CAAC,qFAAY;;AAEtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO,2BAA2B;AAClC,OAAO,2BAA2B;AAClC,OAAO,2BAA2B;AAClC,OAAO,2BAA2B;AAClC,QAAQ,4BAA4B;AACpC,OAAO,2BAA2B;AAClC,OAAO,2BAA2B;AAClC,OAAO,2BAA2B;AAClC,OAAO,6BAA6B;AACpC,WAAW,iCAAiC;AAC5C,UAAU,gCAAgC;AAC1C,WAAW,iCAAiC;AAC5C,OAAO,qCAAqC;AAC5C,SAAS,2CAA2C;AACpD,QAAQ;AACR;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qDAAqD,gBAAgB;AACrE,mDAAmD,cAAc;AACjE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;;AAEA;;AAEA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO,QAAQ;AAC/B,gBAAgB,OAAO,QAAQ;AAC/B,iBAAiB,OAAO,OAAO;AAC/B,iBAAiB,OAAO,OAAO;AAC/B,gBAAgB,QAAQ,OAAO;AAC/B,gBAAgB,QAAQ,OAAO;AAC/B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,sEAAsE;;AAEtE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+CAA+C,EAAE,UAAU,EAAE;AAC7D;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,aAAa,aAAa;AACzC;AACA,eAAe,aAAa,aAAa;AACzC;AACA,eAAe,aAAa,aAAa;AACzC;AACA,eAAe,aAAa,aAAa;AACzC;AACA,eAAe,aAAa,aAAa;AACzC;AACA,eAAe,aAAa;AAC5B;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACn2BA,kBAAkB,mBAAO,CAAC,sEAAe;AACzC,YAAY,mBAAO,CAAC,0DAAS;;AAE7B;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,kCAAkC;AAClC;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,wDAAwD,uCAAuC;AAC/F,sDAAsD,qCAAqC;;AAE3F;AACA;;AAEA;AACA;;AAEA;AACA;AACA,EAAE;AACF,CAAC;;AAED;;;;;;;;;;;;;AC7EY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvJA,kBAAkB,mBAAO,CAAC,sEAAe;;AAEzC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;;AAEzB;;AAEA;AACA;AACA;;AAEA,yCAAyC,SAAS;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qCAAqC,SAAS;AAC9C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;AC/Fa;;AAEb,kBAAkB,mBAAO,CAAC,sBAAQ;AAClC,kBAAkB,mBAAO,CAAC,yEAAkB;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,mBAAO,CAAC,kEAAgB;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uDAAuD;AACvD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,0BAA0B,yBAAyB,EAAE;AACrD,0CAA0C,uCAAuC,EAAE;AACnF,0CAA0C,sCAAsC,EAAE;AAClF,iCAAiC,sCAAsC;AACvE,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,iCAAiC;;AAEjC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB,IAAI,GAAG,IAAI;AAChC,kJAAkJ,EAAE;AACpJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,EAAE;AACd,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,WAAW;AACX;AACA;;;;AAIA,MAAM,IAA0C;AAChD,IAAI,mCAAO;AACX;AACA,KAAK;AAAA,oGAAC;AACN,GAAG,MAAM,EAIN;AACH,CAAC;;;;;;;;;;;;ACpOD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,wDAAU;;AAEnC,OAAO,WAAW;;AAElB;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;;;;;;;;;;;;ACtQA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAO,CAAC,0CAAI;;AAEpC;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,cAAc;AAC1B;AACA;AACA;AACA;;AAEA,iBAAiB,sBAAsB;AACvC;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA,aAAa,kCAAkC;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;;AAEA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACzQA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,mBAAO,CAAC,6DAAc;AACxC,CAAC;AACD,kBAAkB,mBAAO,CAAC,uDAAW;AACrC;;;;;;;;;;;;ACTA;AACA;AACA;;AAEA,YAAY,mBAAO,CAAC,gBAAK;AACzB,aAAa,mBAAO,CAAC,kBAAM;;AAE3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,uBAAuB,mBAAO,CAAC,kEAAgB;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,4DAA4D;AAC5D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA,CAAC,IAAI;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,2BAA2B;;AAEnC;AACA;AACA,iDAAiD,EAAE;AACnD,sBAAsB,WAAW,IAAI,KAAK;;AAE1C;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,wDAAU;;AAEnC,OAAO,WAAW;;AAElB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AChQa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA,4H;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA,sH;;;;;;;;;;;;ACRa;AACb;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,2BAA2B,mBAAO,CAAC,qFAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mBAAO,CAAC,4FAAwB;AACtD,4BAA4B,mBAAO,CAAC,oFAAoB;AACxD;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,YAAY;AACrD;AACA;AACA;AACA,yBAAyB,EAAE;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA,wCAAwC;AACxC;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iD;;;;;;;;;;;;AC3Ea;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA,2BAA2B,mBAAO,CAAC,qFAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,gCAAgC;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;AC5Ba;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA,2BAA2B,mBAAO,CAAC,qFAAoB;AACvD,eAAe,mBAAO,CAAC,sBAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,mBAAmB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,iCAAiC;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,8BAA8B;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,mBAAO,CAAC,wBAAS;AACrB;AACA;AACA,uC;;;;;;;;;;;;AC9Da;AACb;AACA;AACA,8CAA8C,cAAc;AAC5D,eAAe,mBAAO,CAAC,mHAAyB;AAChD;AACA,aAAa,mBAAO,CAAC,6FAAc;AACnC;AACA,iBAAiB,mBAAO,CAAC,+FAAe;AACxC;AACA,kBAAkB,mBAAO,CAAC,yGAAoB;AAC9C;AACA,cAAc,mBAAO,CAAC,+FAAe;AACrC;AACA,YAAY,mBAAO,CAAC,2FAAa;AACjC;AACA,aAAa,mBAAO,CAAC,+FAAe;AACpC;AACA,SAAS,mBAAO,CAAC,qFAAU;AAC3B;AACA,YAAY,mBAAO,CAAC,2FAAa;AACjC;AACA,cAAc,mBAAO,CAAC,+FAAe;AACrC;AACA,cAAc,mBAAO,CAAC,+FAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;;;;;ACxCa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA,2BAA2B,mBAAO,CAAC,qFAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4C;;;;;;;;;;;;ACzCa;AACb;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA,2BAA2B,mBAAO,CAAC,qFAAoB;AACvD;AACA;AACA;AACA;AACA,iFAAiF,aAAa,EAAE;AAChG,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,UAAU,mBAAmB;AAC5E,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,yDAAyD,0DAA0D,EAAE,EAAE;AAClK;AACA;AACA;AACA,6DAA6D,0DAA0D;AACvH;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,yDAAyD,2DAA2D,EAAE,EAAE;AACnK;AACA;AACA;AACA,6DAA6D,2DAA2D;AACxH;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gGAAgG,aAAa,EAAE;AAC/G,+CAA+C,UAAU,mBAAmB;AAC5E,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,yDAAyD,0DAA0D,EAAE,EAAE;AAC5K;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,yDAAyD,2DAA2D,EAAE,EAAE;AAC7K;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gGAAgG,aAAa,EAAE;AAC/G;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,yDAAyD,0DAA0D,EAAE,EAAE;AAC5K;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,yDAAyD,2DAA2D,EAAE,EAAE;AAC7K;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;ACpLa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA,2BAA2B,mBAAO,CAAC,qFAAoB;AACvD,WAAW,mBAAO,CAAC,kBAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,QAAQ;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,wHAAQ,kCAAkC,iBAAiB,CAAC;AACtF,0DAA0D,uEAAuE,EAAE;AACnI;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,wHAAwH;AACnL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB,kHAAQ,kCAAkC,WAAW,CAAC;AAC1E,oDAAoD,2DAA2D,EAAE;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;ACjFa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA,2BAA2B,mBAAO,CAAC,qFAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;ACvBa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA,2BAA2B,mBAAO,CAAC,qFAAoB;AACvD,eAAe,mBAAO,CAAC,sBAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,iFAAiF,YAAY;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,IAAI;AACjE;AACA,kDAAkD,IAAI;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA,qBAAqB;AACrB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,iFAAiF,YAAY;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;;;;;;ACnRa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA,2BAA2B,mBAAO,CAAC,qFAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,8GAA8G;AACjL;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;AC3Ca;AACb;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA,2BAA2B,mBAAO,CAAC,qFAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,SAAS;AAC3C;AACA;AACA,qBAAqB,mBAAmB,iCAAiC;AACzE;AACA,qBAAqB,oEAAoE;AACzF;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;ACtDa;AACb;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,4DAA4D,cAAc;AAC1E;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA,2BAA2B,mBAAO,CAAC,qFAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,mEAAmE;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,4BAA4B,EAAE;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F;AAC/F,6DAA6D;AAC7D;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,6DAA6D,mEAAmE;AAChI;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,mBAAmB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,mBAAmB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;ACxJa;AACb;AACA;AACA,8CAA8C,cAAc;AAC5D,qBAAqB,mBAAO,CAAC,sFAAgB;AAC7C,qBAAqB,mBAAO,CAAC,sFAAgB;AAC7C;AACA,wCAAwC,aAAa;AACrD;AACA;AACA,uBAAuB,mBAAO,CAAC,gFAAsB,UAAU;AAC/D;AACA,0DAA0D,WAAW;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,gCAAgC,qBAAqB;AACrD;AACA;AACA;AACA,qCAAqC,qCAAqC;AAC1E;AACA;AACA,gCAAgC,qBAAqB;AACrD;AACA;AACA,+BAA+B,0BAA0B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,WAAW;AACrE;AACA,+EAA+E,wCAAwC,EAAE;AACzH;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,iDAAiD,EAAE;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,uBAAuB,mBAAO,CAAC,sBAAQ;AACvC;AACA;AACA;AACA;AACA;AACA,mC;;;;;;;;;;;;AC5Ga;AACb;AACA;AACA,8CAA8C,cAAc;AAC5D,WAAW,mBAAO,CAAC,kBAAM;AACzB,aAAa,mBAAO,CAAC,mDAAQ;AAC7B;AACA,mBAAmB,mBAAO,CAAC,sBAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,gBAAgB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;;;;;;;;;;;;;;;;;;;ACzDA,aAAa,mBAAO,CAAC,sBAAQ;;AAE7B;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACTa;;AAEb,cAAc,mBAAO,CAAC,oDAAS;AAC/B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,+CAA+C,kCAAkC,EAAE;AACnF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;;;;;;;AC3Ka;;AAEb;AACA;AACA;AACA;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACa;;AAEb,8CAA8C,cAAc;;AAE5D;AACA,aAAa,OAAO;AACpB,cAAc,YAAY;AAC1B,eAAe,aAAa;AAC5B,cAAc,OAAO;AACrB,cAAc,iBAAiB;AAC/B,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,cAAc;AAC5B,cAAc,OAAO;AACrB;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,OAAO,aAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,8CAA8C,iCAAiC;;AAE/E;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,KAAK;;AAEL;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,mBAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,mBAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,yDAAyD;AAC/E,KAAK;;AAEL;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,iBAAiB;AAC5B,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,cAAc;AACzB,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,SAAS;AACvB,cAAc,MAAM;AACpB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,kBAAkB;AAChC;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,IAAI;AACf,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,YAAY;AACvB,aAAa,0BAA0B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,mBAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,gCAAgC;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;;AAEL,mBAAmB,uBAAuB;AAC1C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,SAAS,iDAAiD;AACzE,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,SAAS,iDAAiD;AACzE,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO,aAAa;AACnC,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACt2BY;;AAEZ,WAAW,mBAAO,CAAC,wFAAa;AAChC,aAAa,mBAAO,CAAC,kBAAM;AAC3B,mBAAmB,mBAAO,CAAC,kEAAW;AACtC,mBAAmB,mBAAO,CAAC,yEAAmB;AAC9C,aAAa,mBAAO,CAAC,kEAAc;;AAEnC;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kGAAkG;AAClG;AACA;;AAEA,SAAS,oBAAoB;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,wBAAwB,KAAK;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,mBAAO,CAAC,sEAAgB;;AAExC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,uDAAuD,KAAK,oBAAoB,IAAI;AACpF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS,WAAW;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,YAAY,kCAAkC,aAAa;AACjG;;AAEA;AACA;AACA;AACA;AACA,2CAA2C,aAAa,UAAU,YAAY;AAC9E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACnKY;;AAEZ;AACA,YAAY,mBAAO,CAAC,2EAAa;AACjC;;;;;;;;;;;;;ACJY;;AAEZ,WAAW,mBAAO,CAAC,wFAAa;AAChC,aAAa,mBAAO,CAAC,kBAAM;AAC3B,eAAe,mBAAO,CAAC,kEAAW;AAClC,mBAAmB,mBAAO,CAAC,4EAAgB;AAC3C,eAAe,mBAAO,CAAC,sEAAgB;AACvC,aAAa,mBAAO,CAAC,kEAAc;;AAEnC;AACA;AACA;AACA;AACA,GAAG;AACH,YAAY;AACZ;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kGAAkG;AAClG;AACA;;AAEA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH,4BAA4B,KAAK;AACjC,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,2CAA2C,qBAAqB;AAChE;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,2DAA2D,KAAK,oBAAoB,IAAI;AACxF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,YAAY,kCAAkC,aAAa;AACzG;;AAEA;AACA;AACA;AACA;AACA,mDAAmD,aAAa,UAAU,YAAY;AACtF;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;;;;;;ACnNY;;AAEZ,UAAU,mBAAO,CAAC,8DAAc;AAChC;AACA,UAAU,mBAAO,CAAC,4DAAQ;AAC1B;;;;;;;;;;;;;ACLY;;AAEZ,UAAU,mBAAO,CAAC,8DAAc;AAChC,WAAW,mBAAO,CAAC,wFAAa;AAChC,aAAa,mBAAO,CAAC,kBAAM;AAC3B,cAAc,mBAAO,CAAC,kEAAW;AACjC,eAAe,mBAAO,CAAC,kEAAW;;AAElC;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/CY;;AAEZ,UAAU,mBAAO,CAAC,8DAAc;AAChC,aAAa,mBAAO,CAAC,kBAAM;AAC3B,WAAW,mBAAO,CAAC,wFAAa;AAChC,cAAc,mBAAO,CAAC,kEAAW;AACjC,mBAAmB,mBAAO,CAAC,4EAAgB;;AAE3C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AChDY;;AAEZ,aAAa,mBAAO,CAAC,8DAAQ;AAC7B,aAAa,mBAAO,CAAC,8DAAQ;AAC7B,gBAAgB,mBAAO,CAAC,oEAAW;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtBY;;AAEZ,UAAU,mBAAO,CAAC,8DAAc;AAChC,aAAa,mBAAO,CAAC,kBAAM;AAC3B,WAAW,mBAAO,CAAC,wFAAa;AAChC,cAAc,mBAAO,CAAC,kEAAW;AACjC,mBAAmB,mBAAO,CAAC,4EAAgB;;AAE3C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AC5DY;;AAEZ,aAAa,mBAAO,CAAC,kBAAM;AAC3B,WAAW,mBAAO,CAAC,wFAAa;AAChC,mBAAmB,mBAAO,CAAC,4EAAgB;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AClGY;;AAEZ,WAAW,mBAAO,CAAC,wFAAa;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AC9BY;;AAEZ,UAAU,mBAAO,CAAC,8DAAc;AAChC,aAAa,mBAAO,CAAC,kBAAM;AAC3B,WAAW,mBAAO,CAAC,wFAAa;AAChC,gBAAgB,mBAAO,CAAC,kEAAW;AACnC;AACA;;AAEA,sBAAsB,mBAAO,CAAC,gFAAiB;AAC/C;AACA;;AAEA,qBAAqB,mBAAO,CAAC,8EAAgB;AAC7C;AACA;;AAEA,mBAAmB,mBAAO,CAAC,4EAAgB;;AAE3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AC9DY;AACZ;AACA;AACA,UAAU,mBAAO,CAAC,8DAAc;AAChC,WAAW,mBAAO,CAAC,wFAAa;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AC5GY;;AAEZ;AACA,IAAI;AACJ;AACA,EAAE,mBAAO,CAAC,yDAAM;AAChB;AACA,EAAE,mBAAO,CAAC,uEAAa;AACvB,EAAE,mBAAO,CAAC,6DAAQ;AAClB,EAAE,mBAAO,CAAC,+DAAS;AACnB,EAAE,mBAAO,CAAC,iEAAU;AACpB,EAAE,mBAAO,CAAC,6DAAQ;AAClB,EAAE,mBAAO,CAAC,iEAAU;AACpB,EAAE,mBAAO,CAAC,uEAAa;AACvB,EAAE,mBAAO,CAAC,6DAAQ;AAClB,EAAE,mBAAO,CAAC,iEAAU;AACpB,EAAE,mBAAO,CAAC,2EAAe;AACzB,EAAE,mBAAO,CAAC,iEAAU;AACpB;;AAEA;AACA;AACA,WAAW,mBAAO,CAAC,cAAI;AACvB;AACA;AACA,YAAY;AACZ,GAAG;AACH;;;;;;;;;;;;;AC3BY;;AAEZ,UAAU,mBAAO,CAAC,8DAAc;AAChC,iBAAiB,mBAAO,CAAC,oEAAY;;AAErC,wBAAwB,mBAAO,CAAC,0EAAe;AAC/C,0BAA0B,mBAAO,CAAC,oFAAoB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACfY;;AAEZ,UAAU,mBAAO,CAAC,8DAAc;AAChC,iBAAiB,mBAAO,CAAC,sDAAU;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACXY;;AAEZ,WAAW,mBAAO,CAAC,wFAAa;AAChC,aAAa,mBAAO,CAAC,kBAAM;AAC3B,cAAc,mBAAO,CAAC,kEAAW;AACjC,iBAAiB,mBAAO,CAAC,oEAAY;;AAErC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;;ACjBY;;AAEZ,aAAa,mBAAO,CAAC,kBAAM;AAC3B,cAAc,mBAAO,CAAC,kEAAW;AACjC,mBAAmB,mBAAO,CAAC,4EAAgB;AAC3C,iBAAiB,mBAAO,CAAC,oEAAY;;AAErC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;;;;;;;;;;;;;AC1BY;AACZ,UAAU,mBAAO,CAAC,8DAAc;AAChC,iBAAiB,mBAAO,CAAC,kEAAU;AACnC,mBAAmB,mBAAO,CAAC,4EAAe;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACbY;;AAEZ,WAAW,mBAAO,CAAC,wFAAa;AAChC,aAAa,mBAAO,CAAC,kBAAM;AAC3B,yBAAyB,mBAAO,CAAC,gEAAS;;AAE1C;;AAEA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;;ACrDY;;AAEZ,WAAW,mBAAO,CAAC,wFAAa;AAChC,aAAa,mBAAO,CAAC,kBAAM;AAC3B,yBAAyB,mBAAO,CAAC,gEAAS;;AAE1C;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;;;;;;AC9DY;;AAEZ,aAAa,mBAAO,CAAC,kBAAM;;AAE3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACxBY;;AAEZ;AACA,YAAY,mBAAO,CAAC,2EAAa;AACjC;;;;;;;;;;;;;ACJY;;AAEZ,WAAW,mBAAO,CAAC,wFAAa;AAChC,aAAa,mBAAO,CAAC,kBAAM;AAC3B,iBAAiB,mBAAO,CAAC,wEAAc;AACvC,mBAAmB,mBAAO,CAAC,kEAAW;AACtC,mBAAmB,mBAAO,CAAC,kEAAW;AACtC,aAAa,mBAAO,CAAC,kEAAc;;AAEnC;AACA;AACA;;AAEA,SAAS,UAAU;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC9CY;;AAEZ,UAAU,mBAAO,CAAC,8DAAc;AAChC;AACA,UAAU,mBAAO,CAAC,4DAAQ;AAC1B;;;;;;;;;;;;;ACLY;;AAEZ,WAAW,mBAAO,CAAC,wFAAa;AAChC,aAAa,mBAAO,CAAC,kBAAM;AAC3B,aAAa,mBAAO,CAAC,8DAAS;AAC9B,eAAe,mBAAO,CAAC,kEAAW;AAClC,eAAe,mBAAO,CAAC,kEAAW;AAClC,mBAAmB,mBAAO,CAAC,4EAAgB;AAC3C,aAAa,mBAAO,CAAC,kEAAc;;AAEnC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;;;;;;AChEY;;AAEZ,UAAU,mBAAO,CAAC,8DAAc;AAChC,WAAW,mBAAO,CAAC,wFAAa;AAChC,aAAa,mBAAO,CAAC,kBAAM;AAC3B,cAAc,mBAAO,CAAC,kEAAW;AACjC,mBAAmB,mBAAO,CAAC,4EAAgB;;AAE3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACvCY;AACZ,UAAU,mBAAO,CAAC,8DAAc;AAChC,WAAW,mBAAO,CAAC,0DAAO;;AAE1B;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACXY;;AAEZ,UAAU,mBAAO,CAAC,8DAAc;AAChC,eAAe,mBAAO,CAAC,kEAAU;;AAEjC;AACA;AACA;AACA;;;;;;;;;;;;;ACRY;;AAEZ,WAAW,mBAAO,CAAC,wFAAa;AAChC,aAAa,mBAAO,CAAC,kBAAM;AAC3B,eAAe,mBAAO,CAAC,sBAAQ;;AAE/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,aAAa;AACpB,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACzTY;AACZ;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACXY;;AAEZ,WAAW,mBAAO,CAAC,wFAAa;AAChC,aAAa,mBAAO,CAAC,kBAAM;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,eAAe;AACjC;AACA,qBAAqB,eAAe;AACpC;AACA,sDAAsD,0BAA0B;AAChF;AACA;AACA,yBAAyB,oBAAoB;AAC7C,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA,sDAAsD,0BAA0B;AAChF;AACA;AACA,yBAAyB,oBAAoB;AAC7C,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,gCAAgC,eAAe;AAC/C,GAAG;AACH;AACA;AACA;AACA;AACA,oCAAoC,eAAe;AACnD,KAAK;AACL;AACA;AACA,GAAG;AACH,uCAAuC;AACvC;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oBAAoB;AACzC,GAAG;AACH;;AAEA;AACA,SAAS,oBAAoB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,eAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,eAAe;AACzD,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,SAAS,IAAI,IAAI,kCAAkC,KAAK;AAC3E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3KY;;AAEZ,WAAW,mBAAO,CAAC,wFAAa;AAChC,WAAW,mBAAO,CAAC,cAAI;AACvB,aAAa,mBAAO,CAAC,kBAAM;;AAE3B,YAAY,IAAI;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9EY;;AAEZ;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;;;;;;AClBA,SAAS,mBAAO,CAAC,cAAI;AACrB,gBAAgB,mBAAO,CAAC,yFAAgB;AACxC,aAAa,mBAAO,CAAC,mGAAqB;AAC1C,YAAY,mBAAO,CAAC,iFAAY;;AAEhC,WAAW,mBAAO,CAAC,kBAAM;;AAEzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA,MAAM,mBAAO,CAAC,sBAAQ;AACtB,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzVA,aAAa,mBAAO,CAAC,sBAAQ;;AAE7B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB;;AAEA;;AAEA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;;AAEA;;AAEA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrHA,gBAAgB,mBAAO,CAAC,4BAAW;;AAEnC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH,yCAAyC;AACzC;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL,8CAA8C;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACrVa;AACb,YAAY,mBAAO,CAAC,gBAAK;;AAEzB;AACA;AACA,WAAW,KAAK;AAChB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS,KAAK;AACd;AACA;AACA,GAAG;AACH,EAAE;AACF,CAAC;;AAED;AACA;AACA;AACA;;AAEA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+CAA+C,iBAAiB,EAAE;AAClE;AACA;AACA;AACA;;AAEA,4CAA4C,iBAAiB,EAAE;AAC/D;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;AC5Ga;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;AC7CA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;ACxCA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,YAAY,KAA4B,IAAI,6HAAU;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,0BAA0B;AACtD;AACA;AACA,OAAO;AACP,4BAA4B,0BAA0B;AACtD;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,MAAM,mCAAO;AACb;AACA,OAAO;AAAA,oGAAC;AACR;AACA;AACA,CAAC;;;;;;;;;;;;ACrgBD;AACA;AACA,QAAQ,mBAAO,CAAC,wFAAa;AAC7B,CAAC;AACD,QAAQ,mBAAO,CAAC,cAAI;AACpB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,eAAe;AACf;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACrIY;;AAEZ;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;;;;;;AClBA,SAAS,mBAAO,CAAC,cAAI;AACrB,gBAAgB,mBAAO,CAAC,yFAAgB;AACxC,aAAa,mBAAO,CAAC,mGAAqB;AAC1C,YAAY,mBAAO,CAAC,iFAAY;;AAEhC,WAAW,mBAAO,CAAC,kBAAM;;AAEzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA,MAAM,mBAAO,CAAC,sBAAQ;AACtB,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzVA,aAAa,mBAAO,CAAC,sBAAQ;;AAE7B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB;;AAEA;;AAEA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;;AAEA;;AAEA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrHA,gBAAgB,mBAAO,CAAC,4BAAW;;AAEnC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH,yCAAyC;AACzC;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL,8CAA8C;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;ACrVA,SAAS,mBAAO,CAAC,cAAI;;AAErB;AACA;AACA,UAAU,mBAAO,CAAC,4BAAW;AAC7B;AACA;;AAEA,SAAS,mBAAO,CAAC,cAAI;AACrB;AACA;AACA;AACA;;AAEA;AACA,WAAW,mBAAO,CAAC,kBAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,4DAAa;AAClC;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,WAAW,iDAAiD;AAC5D;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,uCAAuC,aAAa;AACpD;;AAEA;AACA;AACA;AACA,OAAO,sBAAsB;AAC7B;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA,SAAS,mBAAmB;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG;AACH;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS,mBAAmB;AAC5B;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC9TY;;AAEZ;AACA,gBAAgB,mBAAO,CAAC,sDAAS;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,2BAA2B;;AAE3B,iBAAiB;AACjB,oBAAoB;;AAEpB;AACA;AACA,0CAA0C,iBAAiB;AAC3D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C,iBAAiB;AAC3D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC7UA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACjKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4B;AACJ;AACF;AACI;AACF;;AAExB;;AAEA;AACA,iBAAiB,mCAAM;;AAEvB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,qBAAqB;AAClD;AACA;AACA;AACA;;AAEA;AACA,QAAQ,mBAAmB;AAC3B,QAAQ,mBAAmB;AAC3B,SAAS;AACT,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA,oBAAoB,mCAAM;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kFAAkF;AAClF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE,yBAAyB,kCAAkC;AAC7D;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE,0BAA0B,mCAAM,GAAG;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,mCAAM;AAC3B;AACA,iHAAiH,UAAU,IAAI,YAAY;AAC3I;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ,+EAA+E,WAAW,WAAW,YAAY;AACjH;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,QAAQ,mBAAmB;AAC3B,YAAY,mBAAmB;AAC/B,eAAe,mBAAmB;AAClC,QAAQ,mBAAmB;AAC3B,QAAQ,mBAAmB;AAC3B,QAAQ;AACR,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qEAAqE,SAAS;AAC9E;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,mCAAM;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,oEAAoE,WAAW,SAAS,eAAe;AACvG,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,yEAAyE,WAAW,IAAI,YAAY;AACpG;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA,6CAA6C,WAAW,eAAe,YAAY;AACnF;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,4EAA4E,WAAW,IAAI,YAAY;AACvG;AACA,GAAG;AACH,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY,EAAE;AACd,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,mCAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,qBAAqB;AACrB,EAAE;AACF;AACA,4CAA4C;AAC5C,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA,8BAA8B,WAAW,mBAAmB;AAC5D,EAAE,0BAA0B,mCAAM;AAClC;AACA;AACA;AACA,EAAE;AACF;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,KAAK;AAChB;AACA,yBAAyB,KAAK;AAC9B;AACA;;AAEA;AACA,YAAY,MAAM;AAClB;AACA,yBAAyB,MAAM;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,OAAO,mBAAmB;AAC1B,WAAW,mBAAmB;AAC9B,OAAO,mBAAmB;AAC1B,UAAU,mBAAmB;AAC7B,OAAO,mBAAmB;AAC1B,UAAU,mBAAmB;AAC7B,QAAQ,mBAAmB;AAC3B,UAAU,mBAAmB;AAC7B,WAAW;AACX,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA,EAAE;AACF;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;;AAE9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,qBAAqB,iCAAI;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA,OAAO,mBAAmB;AAC1B,UAAU,mBAAmB;AAC7B,MAAM,mBAAmB;AACzB,cAAc,mBAAmB;AACjC,cAAc,mBAAmB;AACjC,WAAW,mBAAmB;AAC9B,SAAS;AACT,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA,kBAAkB,gCAAG;AACrB,mBAAmB,gCAAG;;AAEtB,gDAAgD,mCAAM;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA,IAAI;AACJ;AACA,6BAA6B,MAAM;AACnC;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH,iEAAiE;;AAEjE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,UAAU,mBAAmB;AAC7B,OAAO,mBAAmB;AAC1B,WAAW,mBAAmB;AAC9B,YAAY,mBAAmB;AAC/B,SAAS,mBAAmB;AAC5B,UAAU;AACV,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+CAA+C,mCAAM;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB;AACxB;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sBAAsB,mCAAM;AAC5B,oBAAoB,gCAAG;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,gDAAgD,kCAAK,GAAG,iCAAI;AAC5D;;AAEA;;AAEA;AACA;AACA;AACA,+CAA+C,mCAAM;AACrD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kDAAkD,YAAY;AAC9D;AACA,KAAK;AACL,IAAI;AACJ;;AAEA;AACA,uCAAuC,YAAY,mBAAmB,YAAY;AAClF;AACA,GAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,8DAA8D,YAAY;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6DAA6D,YAAY;AACzE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,iCAAI;AACf,iBAAiB,iCAAI;AACrB;;AAEA;AACA;AACA,qBAAqB,iCAAI;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iCAAI;AAC3B,MAAM;AACN,uBAAuB,iCAAI;AAC3B;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,iCAAiC,iCAAI;AACrC,qBAAqB,iCAAI;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEe,oEAAK,EAAC;AAC6B;;;;;;;;;;;;AC9lDlD,SAAS,mBAAO,CAAC,cAAI;AACrB,WAAW,mBAAO,CAAC,kBAAM;AACzB,SAAS,mBAAO,CAAC,cAAI;;AAErB;AACA,qBAAqB,KAAyC,GAAG,OAAuB,GAAG,SAAO;;AAElG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,KAAyC,oBAAoB,SAAE;AACnE;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;;AAEd;;AAEA,iBAAiB,gBAAgB;AACjC;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrKA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,mBAAO,CAAC,4BAAW;AACnC,UAAU,mBAAO,CAAC,kEAAe;AACjC,YAAY,mBAAO,CAAC,sBAAQ;AAC5B,UAAU,mBAAO,CAAC,kDAAM;AACxB,QAAQ,mBAAO,CAAC,yDAAS;AACzB,YAAY,mBAAO,CAAC,yDAAS;AAC7B,cAAc,mBAAO,CAAC,gFAAsB;AAC5C,cAAc,mBAAO,CAAC,gFAAsB;;AAE5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,qBAAqB,8CAA8C;AACtF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,IAAI;AACxB,mBAAmB,IAAI;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB,sBAAsB;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,kCAAkC;AACxD,wBAAwB,OAAO;AAC/B,+BAA+B,OAAO;AACtC,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,OAAO;AAC7B;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,kCAAkC;AACxD,wBAAwB,OAAO;AAC/B,+BAA+B,OAAO;AACtC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,kCAAkC;AACxD,wBAAwB,OAAO;AAC/B,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,OAAO;AAC7B;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;AC7YD,YAAY,mBAAO,CAAC,sBAAQ;;AAE5B;AACA;AACA,qBAAqB,mBAAO,CAAC,qEAAS;AACtC;AACA;AACA;AACA,6BAA6B,mBAAO,CAAC,qEAAS;AAC9C,iBAAiB;AACjB,6BAA6B,mBAAO,CAAC,6EAAa;AAClD;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;;;;AChBA,aAAa,mBAAO,CAAC,sBAAQ;AAC7B,gBAAgB,mBAAO,CAAC,4BAAW;AACnC,cAAc,mBAAO,CAAC,iFAAuB;;AAE7C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;;;;ACvEA,iBAAiB,mBAAO,CAAC,qEAAiB;AAC1C,cAAc,mBAAO,CAAC,iFAAuB;;AAE7C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+DAA+D,QAAQ;AACvE;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA,sFAAsF,QAAQ;AAC9F,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;;;;ACjCA,aAAa,mBAAO,CAAC,sBAAQ;AAC7B,gBAAgB,mBAAO,CAAC,4BAAW;AACnC,cAAc,mBAAO,CAAC,iFAAuB;;AAE7C;AACA,mBAAmB,mBAAO,CAAC,qEAAS;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;;;;ACvDA,QAAQ,mBAAO,CAAC,0DAAU;AAC1B,YAAY,mBAAO,CAAC,0DAAU;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;ACtEA,QAAQ,mBAAO,CAAC,0DAAU;;AAE1B;AACA;AACA;AACA,kBAAkB;;AAElB,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;AACZ;;AAEA;AACA,WAAW,mBAAO,CAAC,iEAAS;AAC5B,WAAW,mBAAO,CAAC,iEAAS;AAC5B,gBAAgB,mBAAO,CAAC,2EAAc;;AAEtC;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,E;;;;;;;;;;;AC/FA,UAAU,mBAAO,CAAC,kDAAM;AACxB,QAAQ,mBAAO,CAAC,0DAAU;AAC1B,YAAY,mBAAO,CAAC,0DAAU;;AAE9B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gHAAgH;AAChH,qCAAqC,aAAa;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA,oCAAoC;;AAEpC,yCAAyC,aAAa;AACtD;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,E;;;;;;;;;;;ACnJA,UAAU,mBAAO,CAAC,kDAAM;AACxB,QAAQ,mBAAO,CAAC,0DAAU;AAC1B;AACA,YAAY,mBAAO,CAAC,0DAAU;;AAE9B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gHAAgH;AAChH,yCAAyC,aAAa;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,aAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA,oCAAoC;;AAEpC,yCAAyC,aAAa;AACtD;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,aAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;AC1LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,YAAY,mBAAO,CAAC,sBAAQ;AAC5B,QAAQ,mBAAO,CAAC,0DAAU;;AAE1B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG,OAAO;AACV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA,aAAa,SAAS;AACtB;AACA,aAAa,SAAS;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC,mBAAmB,QAAQ;AAC3B;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,wCAAwC;AACxC,0CAA0C;AAC1C,2DAA2D;AAC3D;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA,oBAAoB;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,QAAQ;AACxB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,2BAA2B,6BAA6B;AACxD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;;AAEA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,0BAA0B,OAAO;AACjC,8BAA8B,OAAO;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,wCAAwC;AACxC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,4B;;;;;;;;;;;ACngDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,mBAAO,CAAC,0DAAU;AAC1B,YAAY,mBAAO,CAAC,sBAAQ;AAC5B,iBAAiB,mBAAO,CAAC,+DAAW;AACpC,YAAY,mBAAO,CAAC,6DAAa;AACjC,cAAc,mBAAO,CAAC,iFAAuB;AAC7C,qBAAqB,mBAAO,CAAC,6GAAqC;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,8EAA8E;AAC9E,oEAAoE;;AAEpE;AACA;AACA,SAAS;AACT,gCAAgC,uBAAuB;AACvD;AACA;AACA;;AAEA,uBAAuB,oBAAoB;AAC3C;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;AC1TD;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,kEAAc;AACvC,YAAY,mBAAO,CAAC,sBAAQ;;AAE5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oEAAoE;AACpE,mBAAmB;AACnB;;AAEA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,6CAA6C;AAC7C,wCAAwC;;AAExC,uCAAuC;AACvC;AACA,uBAAuB,iBAAiB;AACxC;AACA;;AAEA,0CAA0C;AAC1C;AACA,mBAAmB,eAAe;AAClC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B;AAC3B;;AAEA;AACA;;;;;;;;;;;;AClLA;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,kEAAc;AACvC,YAAY,mBAAO,CAAC,sBAAQ;AAC5B,gBAAgB,mBAAO,CAAC,4BAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sDAAsD;AACtD;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;AC3OA;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,kEAAc;AACvC,YAAY,mBAAO,CAAC,sBAAQ;;AAE5B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,eAAe,mBAAO,CAAC,qEAAW;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kDAAkD,UAAU;AAC5D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,8BAA8B;AACjD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;ACtLA;AACA,WAAW,mBAAO,CAAC,iEAAS;AAC5B,gBAAgB,mBAAO,CAAC,+DAAQ;AAChC,SAAS,mBAAO,CAAC,6DAAO;;AAExB;AACA;AACA,sBAAsB;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,sBAAsB;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,E;;;;;;;;;;;ACtBA;AACA;AACA;AACA;;AAEA,YAAY,mBAAO,CAAC,sBAAQ;;AAE5B;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,8CAA8C,YAAY;AAC1D;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,C;;;;;;;;;;;;AC3Ga;AACb,aAAa,mBAAO,CAAC,gDAAO;;AAE5B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;;;;;;;;;;;;;ACnDa;;AAEb;AACA;AACA,CAAC;;AAED;AACA;AACA;;;;;;;;;;;;;ACRA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC,8BAA8B;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,UAAU,yBAAyB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,qBAAqB;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU,aAAa;AACvB;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,WAAW;AACX;AACA,qCAAqC;AACrC;AACA;AACA,SAAS;AACT;AACA;AACA,gDAAgD;AAChD;AACA,WAAW;AACX;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2CAA2C,cAAc;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gDAAgD;AAChD;AACA,KAAK;AACL,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU,YAAY;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF;AACpF;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA,8DAA8D;;AAE9D;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;;AChhBa;AACb,WAAW,mBAAO,CAAC,cAAI;;AAEvB;AACA;AACA;AACA,EAAE;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;;;;;;;;;;;AChBA,OAAO,mCAAmC,GAAG,mBAAO,CAAC,8BAAY;;AAEjE;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED,kBAAkB;;;;;;;;;;;;ACnClB,iBAAiB,mBAAO,CAAC,sBAAQ;;;;;;;;;;;;;ACApB;;AAEb,SAAS,mBAAO,CAAC,cAAI;AACrB,SAAS,mBAAO,CAAC,kBAAM;AACvB,YAAY,mBAAO,CAAC,kBAAM;AAC1B,YAAY,mBAAO,CAAC,kBAAM;AAC1B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;;;;;;;;;;;;ACrFA;;AAEY;;AAEZ,aAAa,mBAAO,CAAC,sBAAQ;AAC7B;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC5EA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,oCAAoC;AACxD,0BAA0B,oCAAoC;AAC9D,0BAA0B,oCAAoC;AAC9D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,sBAAsB;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,sBAAsB;AACvC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;AC18CA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;ACNY;;AAEZ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACxHA;AACA;AACA;AACA,aAAa,mBAAO,CAAC,sBAAQ;AAC7B,cAAc,mBAAO,CAAC,+DAAc;AACpC;;AAEA,SAAS,mBAAO,CAAC,sBAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;;AClKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D,oBAAoB;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1DA;AACA;AACA;AACA;AACA,qCAAqC,mBAAO,CAAC,mEAAgB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,mBAAO,CAAC,oEAAe;AAC/D;;;;;;;;;;;;;;;;;;;;;;;;ACdA;AACA,sBAAsB,mBAAO,CAAC,6DAAa;;AAE3C;AACA;AACA;AACA;AACA;AACA,iBAAiB,mBAAO,CAAC,mEAAgB;AACzC;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,6CAA6C,OAAO;AACpD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA,CAAC;;AAED;;;;;;;;;;;;ACrMA;AACA,SAAS,mBAAO,CAAC,oCAAe;AAChC,UAAU,mBAAO,CAAC,sBAAQ;AAC1B,MAAM,mBAAO,CAAC,cAAI;AAClB,MAAM,mBAAO,CAAC,cAAI;AAClB,QAAQ,mBAAO,CAAC,kBAAM;AACtB;AACA,QAAQ,mBAAO,CAAC,kBAAM;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA,gCAAgC,2CAA2C;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA,4BAA4B,oBAAoB;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,4BAA4B,oBAAoB;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,oBAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACjqBa;AACb,WAAW,mBAAO,CAAC,cAAI;AACvB,YAAY,mBAAO,CAAC,gBAAK;AACzB,gBAAgB,mBAAO,CAAC,kFAAU;;AAElC,OAAO,IAAI;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iCAAiC,GAAG;AACpC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1Ia;;AAEb;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,mBAAO,CAAC,gEAAe;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;;;;;;;ACxBY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG,WAAW,iBAAiB;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG,WAAW,iBAAiB;AAC/B;;;;;;;;;;;;;ACxBa;;AAEb;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC;AACnC;AACA,KAAK,qCAAqC;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK,qCAAqC;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK,qCAAqC;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;;AC7Da;;AAEb;AACA,mBAAmB,mBAAO,CAAC,kEAAgB;AAC3C,CAAC;AACD,mBAAmB,mBAAO,CAAC,iEAAY;AACvC;;;;;;;;;;;;ACNA,SAAS,mBAAO,CAAC,2CAAM;AACvB,SAAS,mBAAO,CAAC,2CAAM;;AAEvB;AACA;AACA;;AAEA;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACzBA;AACA;;AAEA,aAAa,mBAAO,CAAC,sBAAQ;;AAE7B;AACA;AACA;;;;;;;;;;;;ACPA,UAAU,mBAAO,CAAC,qDAAW;AAC7B,kBAAkB,mBAAO,CAAC,qEAAmB;;AAE7C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC;AACnC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC5GA,UAAU,mBAAO,CAAC,qDAAW;AAC7B,kBAAkB,mBAAO,CAAC,qEAAmB;;AAE7C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACa;AACb,8CAA8C,cAAc;AAC5D,iBAAiB,mBAAO,CAAC,iEAAU;AACnC,WAAW,mBAAO,CAAC,yDAAM;AACzB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kFAAkF;AACnF;AACA;AACA,YAAY,YAAY,sBAAsB,EAAE;AAChD,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChFA;AACA;AACA;AACA;AACa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,6DAA6D;AAC9D;AACA;AACA,yBAAyB,YAAY,EAAE;AACvC,8BAA8B,oBAAoB;AAClD,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,gDAAgD;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;;;;;;;;;;;;;AClIA;AACA;AACA;AACA;AACa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjCa;AACb;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,kCAAkC;AAClC;AACA;AACA,iBAAiB;AACjB,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,kCAAkC;AAClC;AACA;AACA,iBAAiB;AACjB,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtRA;AACA;AACA;AACA;AACA;AACa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,WAAW,mBAAO,CAAC,yDAAM;AACzB,mBAAmB,mBAAO,CAAC,qEAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAO,CAAC,+EAAiB;AACjD;AACA;AACA;AACA;AACA,wBAAwB,mBAAO,CAAC,+EAAiB;AACjD;AACA;AACA;AACA;AACA,iBAAiB,mBAAO,CAAC,iEAAU;AACnC;AACA;AACA;AACA,uBAAuB,mBAAO,CAAC,6EAAgB;AAC/C;AACA;AACA,oBAAoB,mBAAO,CAAC,uEAAa;AACzC,SAAS,mBAAO,CAAC,2EAAe;AAChC,SAAS,mBAAO,CAAC,+EAAiB;AAClC;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA,kBAAkB,EAAE;AACpB,iBAAiB,EAAE;AACnB,iBAAiB,EAAE;AACnB,gBAAgB;AAChB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA,CAAC,gEAAgE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gEAAgE;AACjE;AACA;AACA;AACA,CAAC,2FAA2F;AAC5F;AACA;AACA;AACA,CAAC,2FAA2F;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,+EAA+E;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,qFAAqF;AACtF;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,oHAAoH,sBAAsB,wBAAwB,cAAc;AAChL;AACA;AACA,oHAAoH,sBAAsB;AAC1I;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4GAA4G,sBAAsB,wBAAwB,cAAc;AACxK;AACA;AACA,4GAA4G,sBAAsB;AAClI;AACA;AACA;AACA;AACA,8GAA8G,sBAAsB;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,oDAAoD;AACtI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,uBAAuB,yBAAyB,cAAc;AACxH;AACA;AACA,0DAA0D,uBAAuB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,eAAe,yBAAyB,cAAc;AAChH;AACA;AACA,0DAA0D,eAAe;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAAkG,iCAAiC;AACnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wCAAwC;AAC1E;AACA,2CAA2C,eAAe,MAAM,WAAW;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,wCAAwC;AAC9E;AACA;AACA;AACA;AACA;AACA,gDAAgD,eAAe;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,4CAA4C;AACtF;AACA;AACA;AACA,0CAA0C,wCAAwC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,OAAO,MAAM,WAAW,8BAA8B,uBAAuB;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wCAAwC;AAC1E;AACA,4CAA4C,eAAe,MAAM,WAAW;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,wCAAwC;AAC9E;AACA;AACA;AACA;AACA;AACA,iDAAiD,eAAe;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,4CAA4C;AACtF;AACA;AACA;AACA,0CAA0C,wCAAwC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,sBAAsB,IAAI,mBAAmB;AAC7G,iDAAiD,uBAAuB,MAAM,WAAW,QAAQ,wCAAwC,KAAK,MAAM;AACpJ;AACA;AACA,gDAAgD,WAAW;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yCAAyC;AACxE;AACA;AACA;AACA,+CAA+C,oBAAoB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA,yDAAyD;AACzD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,0EAA0E,KAAK;AAC/E,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA,oDAAoD;AACpD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,gCAAgC;AACxG;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC15BA;AACA;AACA;AACA;AACa;AACb,8CAA8C,cAAc;AAC5D,iBAAiB,mBAAO,CAAC,iEAAU;AACnC,WAAW,mBAAO,CAAC,yDAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sEAAsE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,qDAAqD;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,4CAA4C;AACrF;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChOA;AACA;AACA;AACA;AACa;AACb,8CAA8C,cAAc;AAC5D,iBAAiB,mBAAO,CAAC,iEAAU;AACnC,WAAW,mBAAO,CAAC,yDAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sEAAsE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,qDAAqD;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7LA;AACA;AACA;AACA;AACa;AACb,8CAA8C,cAAc;AAC5D,WAAW,mBAAO,CAAC,yDAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,6DAA6D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpPA;AACA;AACA;AACA;AACa;AACb,8CAA8C,cAAc;AAC5D,eAAe,mBAAO,CAAC,kBAAM;AAC7B,aAAa,mBAAO,CAAC,cAAI;AACzB,iBAAiB,mBAAO,CAAC,sBAAQ;AACjC,cAAc,mBAAO,CAAC,gBAAK;AAC3B,wBAAwB,mBAAO,CAAC,+EAAiB;AACjD,wBAAwB,mBAAO,CAAC,+EAAiB;AACjD;AACA;AACA;AACA,8CAA8C,aAAa;AAC3D;AACA;AACA;AACA,oDAAoD,aAAa;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oCAAoC,kBAAkB;AACtD,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrDA;AACA;AACA;AACA;AACa;AACb,8CAA8C,cAAc;AAC5D,cAAc,mBAAO,CAAC,gBAAK;AAC3B,wBAAwB,mBAAO,CAAC,+EAAiB;AACjD,wBAAwB,mBAAO,CAAC,+EAAiB;AACjD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oCAAoC,kBAAkB;AACtD,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvCA;AACA;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;;;;;;ACrBA,iBAAiB,mBAAO,CAAC,sEAAiB,E;;;;;;;;;;;ACA1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,mBAAO,CAAC,8EAAmB;AACjD,eAAe,mBAAO,CAAC,8EAAsB;AAC7C,YAAY,mBAAO,CAAC,gDAAO;;;AAG3B;AACA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C;;AAE1C;;AAEA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,qCAAqC;;AAErC;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;;;AAGA;AACA;AACA,qBAAqB,kBAAkB,kBAAkB,aAAa,EAAE;AACxE,qBAAqB,kBAAkB,yBAAyB,MAAM,EAAE;AACxE,qBAAqB,kBAAkB,uBAAuB,QAAQ,EAAE;AACxE,qBAAqB,kBAAkB,yBAAyB,MAAM,EAAE;AACxE,qBAAqB,kBAAkB,6BAA6B,EAAE;AACtE,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA,yBAAyB,oBAAoB;AAC7C,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA,yBAAyB,oBAAoB;AAC7C,KAAK;AACL,CAAC;;;AAGD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,mBAAO,CAAC,0DAAS;AAC7B;AACA,WAAW,mBAAO,CAAC,kBAAM;AACzB,mBAAmB,mBAAO,CAAC,sBAAQ;AACnC,WAAW,mBAAO,CAAC,kBAAM;AACzB,YAAY,mBAAO,CAAC,oBAAO;AAC3B,UAAU,mBAAO,CAAC,gBAAK;AACvB,aAAa,mBAAO,CAAC,sBAAQ;AAC7B,0BAA0B,mBAAO,CAAC,sFAAuB;AACzD;;AAEA;AACA;AACA,WAAW;AACX;AACA,MAAM,KAAK;AACX;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACxWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,mBAAO,CAAC,kBAAM;AACzB,YAAY,mBAAO,CAAC,0DAAS;AAC7B,mBAAmB,mBAAO,CAAC,sBAAQ;AACnC,qBAAqB,mBAAO,CAAC,4EAAkB;AAC/C,iBAAiB,mBAAO,CAAC,uFAA0B;AACnD,kBAAkB,mBAAO,CAAC,kEAAgB;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iDAAiD;AACjD,qDAAqD;AACrD,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA,6DAA6D;;AAE7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oEAAoE,QAAQ;AAC5E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,QAAQ;;AAElC;AACA,2BAA2B,QAAQ;;AAEnC;;AAEA;AACA;AACA;AACA,0CAA0C,+CAA+C,QAAQ;;AAEjG;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,qCAAqC,2BAA2B,EAAE;AAClE;;AAEA,iCAAiC,0BAA0B,EAAE;;AAE7D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yC;AACA,mC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mBAAmB;AACpC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,iFAAiF,QAAQ;;AAEzF;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;AAIA;AACA;AACA,qCAAqC,QAAQ;;AAE7C;AACA;AACA;AACA;AACA;;AAEA;AACA,iDAAiD,UAAU;AAC3D,2CAA2C,UAAU;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;AC/3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,0DAAY;AACrC,wBAAwB,mBAAO,CAAC,0DAAS;;AAEzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;;;;;;;;;;;;ACvRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,sBAAQ;AAC7B,WAAW,mBAAO,CAAC,kBAAM;AACzB,UAAU,mBAAO,CAAC,gBAAK;AACvB,mBAAmB,mBAAO,CAAC,sBAAQ;AACnC,0BAA0B,mBAAO,CAAC,sFAAuB;;AAEzD;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,MAAM,KAAK;AACX;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,8BAA8B;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,6BAA6B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6DAA6D;AAC7D,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;;;;;;;;;;;ACnhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,0DAAS;AAC9B,WAAW,mBAAO,CAAC,kBAAM;AACzB,mBAAmB,mBAAO,CAAC,sBAAQ;AACnC,6BAA6B,mBAAO,CAAC,4FAA0B;;AAE/D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,+BAA+B;AAChD;;AAEA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;AC5JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,mBAAO,CAAC,kBAAM;AACzB,mBAAmB,mBAAO,CAAC,sBAAQ;;AAEnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,0DAAS;AAC9B,YAAY,mBAAO,CAAC,0DAAS;AAC7B,WAAW,mBAAO,CAAC,kBAAM;AACzB,YAAY,mBAAO,CAAC,2EAAO;AAC3B,mBAAmB,mBAAO,CAAC,sBAAQ;AACnC,uBAAuB,mBAAO,CAAC,gFAAoB;;AAEnD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,8BAA8B;AAC9B,SAAS;AACT,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,uCAAuC;AAC9D;;AAEA;;;;;;;;;;;;AC/PA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,mBAAO,CAAC,sBAAQ;AACpB,6BAA6B,uCAAuC;;AAEpE;AACA;AACA,yCAAyC,yBAAyB;;AAElE;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,mBAAO,CAAC,2EAAO;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,gCAAgC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;ACjEA,iBAAiB,mBAAO,CAAC,kEAAiB;;;;;;;;;;;;ACA1C;AACA,qBAAqB,mBAAO,CAAC,8EAAmB;AAChD,qBAAqB,mBAAO,CAAC,8EAAmB;AAChD,qBAAqB,mBAAO,CAAC,8EAAmB;AAChD,qBAAqB,mBAAO,CAAC,4EAAkB;AAC/C,qBAAqB,mBAAO,CAAC,gFAAoB;AACjD,qBAAqB,mBAAO,CAAC,sFAAuB;AACpD,qBAAqB,mBAAO,CAAC,wEAAgB;AAC7C,qBAAqB,mBAAO,CAAC,sEAAe;AAC5C,qBAAqB,mBAAO,CAAC,8DAAW;AACxC;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,mBAAO,CAAC,6EAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;ACvLA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,iEAAI;;AAE/B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB,SAAS;AAC1B,4BAA4B;AAC5B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACzMA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,mBAAO,CAAC,oFAAc;AACzC,CAAC;AACD,mBAAmB,mBAAO,CAAC,8EAAW;AACtC;;;;;;;;;;;;ACTA;AACA;AACA;;AAEA,UAAU,mBAAO,CAAC,gBAAK;AACvB,WAAW,mBAAO,CAAC,kBAAM;;AAEzB;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,mBAAO,CAAC,6EAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,2CAA2C,yBAAyB;;AAEpE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC,IAAI;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,6BAA6B;AAC7B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC;;AAEtC;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,mBAAO,CAAC,cAAI;AAC3B,2CAA2C,mBAAmB;AAC9D;AACA;;AAEA;AACA;AACA,gBAAgB,mBAAO,CAAC,gBAAK;AAC7B;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvPA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACvJA;AACA;AACA;;AAEA;AACA;AACA,aAAa,mBAAO,CAAC,sBAAQ;AAC7B,mBAAmB,mBAAO,CAAC,sBAAQ;AACnC,wBAAwB,mBAAO,CAAC,+DAAc;;AAE9C;AACA,uCAAuC;;AAEvC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,gBAAgB;AAChB,gBAAgB;;AAEhB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAO,CAAC,kBAAM;;;;;;;;;;;;;AC9LF;;AAEZ;AACA,sCAAsC,qBAAa,OAAO,kBAAkB;AAC5E,UAAU,qBAAa;AACvB;AACA;AACA;AACA;;;;;;;;;;;;ACRA,SAAS,mBAAO,CAAC,cAAI;AACrB,WAAW,mBAAO,CAAC,kBAAM;AACzB,WAAW,mBAAO,CAAC,kBAAM;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA,2BAA2B;;AAE3B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB;AACzB;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;AC3LA;AACA,eAAe,mBAAO,CAAC,sEAAmB;AAC1C,eAAe,mBAAO,CAAC,0DAAa;AACpC;;;;;;;;;;;;ACHA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;ACZA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,YAAY,iCAAiC;AAC7C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,YAAY,iCAAiC;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;;AAEA,YAAY,iCAAiC;AAC7C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACtHY;AACZ;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;;;;;;;;;;;;;ACPY;AACZ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH,yCAAyC,OAAO;AAChD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC,iBAAiB;AACtD;AACA;AACA;AACA;;AAEA;AACA;AACA,mDAAmD,iBAAiB;AACpE;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,0BAA0B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,0BAA0B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B,iBAAiB;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B,iBAAiB;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;;AAEA,+BAA+B,iBAAiB;AAChD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qCAAqC,iBAAiB;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC,iBAAiB;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,6BAA6B;AAClE;AACA;AACA,QAAQ,2BAA2B;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,2BAA2B;AAC1E;AACA;AACA,QAAQ,6BAA6B;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,8BAA8B;AACnE;AACA;;AAEA;AACA,iBAAiB,2BAA2B;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,EAAE,mBAAO,CAAC,6DAAe;AACzB,CAAC;;;;;;;;;;;;ACzaD;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA,mE;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA,0E;;;;;;;;;;;ACRA,gBAAgB,mBAAO,CAAC,kFAAW;AACnC,iBAAiB,mBAAO,CAAC,0DAAY;AACrC,WAAW,mBAAO,CAAC,kBAAM;AACzB,wBAAwB,mBAAO,CAAC,6FAA2B;AAC3D,WAAW,mBAAO,CAAC,kBAAM;;AAEzB;AACA;AACA;AACA;AACA;;AAEA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,cAAc;AACd,aAAa;AACb,eAAe;AACf,eAAe;AACf,cAAc;AACd,iBAAiB;AACjB,eAAe;AACf,iBAAiB;AACjB,aAAa;AACb,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH,GAAG;AACH;AACA;AACA,GAAG;;AAEH,GAAG;AACH;AACA;AACA,GAAG;;AAEH,GAAG;AACH;AACA;AACA,GAAG;;AAEH,GAAG;AACH;AACA;AACA,GAAG;;AAEH,GAAG;AACH;AACA;AACA,GAAG;;AAEH,6BAA6B;AAC7B;AACA;AACA,GAAG;;AAEH,+BAA+B;AAC/B;AACA;AACA,GAAG;;AAEH;AACA,KAAK;AACL;AACA,KAAK;AACL,GAAG;AACH,iCAAiC;AACjC;AACA,KAAK;AACL;;AAEA;AACA,+BAA+B;AAC/B;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,oBAAoB;AACzC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;;AAEA;;AAEA;AACA,oBAAoB,yBAAyB;AAC7C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,qBAAqB,sEAAQ,kBAAkB,CAAC;AAChD;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;;AAEA;AACA,uBAAuB;AACvB,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB;AACxB,SAAS;AACT,8BAA8B;AAC9B;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,IAAI;AACf;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,0BAA0B;AACvD;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,mBAAmB,wBAAwB;AAC3C,0BAA0B,yBAAyB;AACnD;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACn5BA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,uBAAuB;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACvCa;;AAEb;AACA;AACA;AACA;;AAEA,gBAAgB,mBAAmB;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC3EY;AACZ;AACA;AACA;AACA,cAAc,mBAAO,CAAC,kDAAS;;AAE/B;;AAEA;;AAEA;AACA,uCAAuC,8DAAO;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA,uE;;;;;;;;;;;;;ACPY;AACZ,WAAW,mBAAO,CAAC,cAAI;AACvB,aAAa,mBAAO,CAAC,kBAAM;AAC3B,eAAe,mBAAO,CAAC,wDAAU;;AAEjC;;AAEA;AACA;AACA,2DAA2D,QAAQ;AACnE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAe,CAAC,yFAAc;AACtD,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,kFAAkF,mEAAQ,cAAc,CAAC;AACzG;AACA;AACA;;AAEA;;AAEA,yBAAyB;AACzB;;AAEA;;;;;;;;;;;;;ACpDY;;AAEZ;AACA;AACA,gBAAgB,mBAAO,CAAC,0DAAW;AACnC,eAAe,mBAAO,CAAC,wDAAU;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,KAAK;AACL,2CAA2C,SAAS;AACpD;AACA;;AAEA;AACA;;AAEA;AACA,kEAAkE,uBAAuB,gBAAgB,YAAY;AACrH;;AAEA;AACA;AACA,oEAAoE,cAAc,gBAAgB,OAAO;AACzG;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,oCAAoC,sBAAsB,0BAA0B,gBAAgB,aAAa;AAC/I;;;;;;;;;;;;;ACnEY;;AAEZ,gBAAgB,mBAAO,CAAC,kBAAM;AAC9B,kBAAkB,mBAAO,CAAC,gEAAc;AACxC,OAAO,4CAA4C,GAAG,mBAAO,CAAC,gEAAc;AAC5E,aAAa,mBAAO,CAAC,kBAAM;AAC3B,eAAe,mBAAO,CAAC,8DAAc;;AAErC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC;;AAElC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,mBAAO,CAAC,wEAAmB,GAAG,qCAAqC;AACvE;;AAEA;AACA;AACA;AACA,gBAAgB,mBAAO,CAAC,8DAAc;AACtC,mEAAmE,aAAa;AAChF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,sFAAsF,OAAO;AAC7F;AACA;AACA;AACA;AACA;;AAEA;AACA,uDAAuD,GAAG;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,6CAA6C,iCAAiC;AAC9E;AACA,iBAAiB,aAAa;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,IAAI;AAC/B;AACA,OAAO;AACP,KAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;ACpbA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA,kBAAkB,UAAU,GAAG,oBAAoB;AACnD,UAAU,UAAU,GAAG,oBAAoB;AAC3C;AACA;AACA;AACA;;AAEA,iBAAiB,uBAAuB;AACxC,cAAc,cAAc;;AAE5B;AACA,kBAAkB,UAAU,6BAA6B,QAAQ;;AAEjE,iCAAiC,UAAU,QAAQ,SAAS;;AAE5D;AACA,YAAY,cAAc,SAAS;AACnC;AACA;;AAEA;AACA;AACA,4CAA4C;AAC5C,UAAU,UAAU;AACpB;;AAEA,6CAA6C,UAAU;AACvD;AACA;AACA;AACA,kBAAkB,UAAU,GAAG,oBAAoB;AACnD,UAAU,UAAU,GAAG,oBAAoB;AAC3C;AACA,GAAG,UAAU;AACb;AACA;AACA;AACA,4FAA4F,UAAU,6BAA6B,SAAS;AAC5I;AACA;AACA;AACA,WAAW,UAAU,qBAAqB;AAC1C,UAAU,UAAU;AACpB;;;;;;;;;;;;;AChDY;AACZ,aAAa,mBAAO,CAAC,kBAAM;;AAE3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oCAAoC,aAAa;AACjD,WAAW;AACX,oCAAoC,YAAY;AAChD,WAAW;AACX;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,uEAAuE,IAAI;AAC3E;AACA;AACA,kCAAkC,IAAI;AACtC,WAAW;AACX;AACA,kCAAkC,yBAAyB,GAAG,qCAAqC;AACnG;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA,sBAAsB,mBAAO,CAAC,oFAAwB;AACtD;AACA;;AAEA;AACA,qCAAqC,GAAG;;AAExC,+BAA+B,UAAU;AACzC,+BAA+B,oBAAoB;AACnD,6BAA6B,UAAU;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;AClHA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACY;;AAEZ;AACA;;AAEA;AACA,uCAAuC,UAAU;AACjD,8CAA8C,UAAU;AACxD;AACA;;;;;;;;;;;;AC/BA;AACA;AACA;;;;;;;;;;;;;ACFA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACY;AACZ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa,eAAe;AAC5B;AACA;;AAEA;AACA;AACA,aAAa,eAAe;AAC5B;AACA;;AAEA;AACA,aAAa,eAAe;AAC5B,eAAe,eAAe;AAC9B;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACzDY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAO,CAAC,gEAAc;AACxC,gBAAgB,mBAAO,CAAC,0DAAW;;AAEnC;AACA;AACA;AACA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;AChEY;AACZ;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,GAAG;AACH;AACA;;;;;;;;;;;;;ACVY;AACZ;AACA;AACA,mBAAmB,mBAAO,CAAC,gEAAc;AACzC,oBAAoB,mBAAO,CAAC,iFAAc;AAC1C,kBAAkB,mBAAO,CAAC,gEAAc;AACxC,aAAa,mBAAO,CAAC,kBAAM;AAC3B,oBAAoB,mBAAO,CAAC,8DAAc;AAC1C,eAAe,mBAAO,CAAC,wDAAU;;AAEjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;;AAET;AACA,eAAe,mBAAO,CAAC,mEAAO;AAC9B;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,oBAAoB,iCAAiC;AACrD;AACA,oBAAoB,UAAU,SAAS,0BAA0B;AACjE;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA,iBAAiB,OAAO,IAAI,cAAc;AAC1C,SAAS;AACT,iBAAiB,OAAO,IAAI,cAAc;AAC1C;AACA,kBAAkB,EAAE;AACpB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,0DAA0D,2BAA2B;;AAErF;AACA;AACA;;AAEA;AACA,iCAAiC,OAAO,GAAG,eAAe,EAAE,iCAAiC;AAC7F;AACA;AACA;AACA;AACA,kDAAkD,OAAO,EAAE,eAAe;AAC1E,WAAW;AACX,WAAW;AACX;AACA;AACA,uCAAuC,4BAA4B;AACnE;AACA,yBAAyB,eAAe,GAAG,sBAAsB;AACjE;AACA;AACA,kBAAkB,+DAA+D;AACjF,SAAS;AACT;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC,yCAAyC;AAC1E;AACA;AACA;AACA,OAAO;;AAEP;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA,OAAO,IAAI;;AAEX;AACA;AACA;AACA;;AAEA;;AAEA,sDAAsD,cAAc;AACpE,oDAAoD,YAAY;AAChE,qDAAqD,aAAa;AAClE,wDAAwD,aAAa;AACrE,oDAAoD,YAAY;AAChE,qDAAqD,aAAa;;AAElE;AACA;AACA,yCAAyC,eAAe;AACxD,wDAAwD,eAAe;AACvE,yDAAyD;AACzD;AACA;;AAEA;AACA,WAAW,+EAA+E;AAC1F;AACA;;AAEA,2BAA2B,qDAAqD;AAChF;AACA,OAAO;;AAEP;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,EAAE;AAClB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,SAAS,GAAG,KAAK;AACnD;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,eAAe;;AAEpC;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,wBAAwB,MAAM;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,OAAO;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;AC3hBY;AACZ,gBAAgB,mBAAO,CAAC,0DAAW;AACnC,kBAAkB,mBAAO,CAAC,gEAAc;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP,iDAAiD,sBAAsB;;AAEvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;;AAEL;;AAEA;;AAEA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,QAAQ;AACR,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,sBAAsB,+BAA+B;AACrD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,6BAA6B,QAAQ,MAAM,UAAU;AACrD;AACA,OAAO;AACP,KAAK;;AAEL;AACA,mBAAmB,2BAA2B;;AAE9C;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;;AAEA;AACA,qBAAqB,mBAAO,CAAC,kEAAe;AAC5C;AACA;;AAEA;AACA;AACA,8BAA8B,kDAAkD;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACpVY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;;ACVA,8CAAa;AACb,qBAAqB,mBAAO,CAAC,gEAAe;;AAE5C;AACA;AACA,kBAAkB,cAAc;AAChC;;AAEA;AACA;AACA,kBAAkB,aAAa,EAAE,EAAE,KAAK;AACxC;;AAEA;AACA;AACA,kBAAkB,aAAa,EAAE,EAAE,QAAQ,EAAE,QAAQ,EAAE,OAAO;AAC9D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,oBAAoB,SAAS;AAC7B,qBAAqB,SAAS;AAC9B;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACpKD,kBAAkB,mBAAO,CAAC,iFAAc;AACxC,gBAAgB,mBAAO,CAAC,6EAAY;AACpC,WAAW,mBAAO,CAAC,2EAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,sBAAsB,oCAAoC;AAC1D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB,kCAAkC;AACvD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yEAAyE,aAAa;AACtF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,6BAA6B;AAC9C,iBAAiB,gCAAgC;AACjD;;AAEA;AACA;;AAEA;;AAEA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAsB;AACtB;AACA,GAAG;AACH;;;;;;;;;;;;;ACnUa;AACb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,mBAAmB,mBAAO,CAAC,+EAAa;;AAExC,qCAAqC;AACrC;AACA,QAAQ,KAAK;;AAEb;;AAEA;AACA;AACA,0BAA0B,SAAS;AACnC;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ,GAAG;AACH,EAAE;AACF;;AAEA,0CAA0C;AAC1C;AACA,QAAQ,KAAK;;AAEb;;AAEA;AACA;AACA,2CAA2C,SAAS;;AAEpD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC7Ca;AACb;AACA;AACA;AACA;AACA;AACA,8BAA8B,cAAc;AAC5C;AACA;AACA;AACA;AACA,mDAAmD,cAAc;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;;;;;ACrBa;AACb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,mBAAmB,mBAAO,CAAC,4DAAa;AACxC,gBAAgB,mBAAO,CAAC,yEAAU;;AAElC;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvBa;AACb,eAAe,mBAAO,CAAC,oDAAS;;AAEhC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,gBAAgB;AAChB;AACA;;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA,sG;;;;;;;;;;;ACRA;AACA,yBAAyB,iGAAO;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;;;ACjBa;AACb,kBAAkB,mBAAO,CAAC,6EAAY;AACtC,6BAA6B,mBAAO,CAAC,oFAAyB;AAC9D,mBAAmB,mBAAO,CAAC,4DAAa;;AAExC;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,gBAAgB,kBAAkB;AAClC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACtCa;AACb,kBAAkB,mBAAO,CAAC,0DAAY;;AAEtC;;AAEA;AACA;;;;;;;;;;;;;ACNa;AACb,oBAAoB,mBAAO,CAAC,iFAAc;AAC1C,kBAAkB,mBAAO,CAAC,6EAAY;AACtC,mBAAmB,mBAAO,CAAC,+EAAa;;AAExC;AACA;AACA;AACA;;AAEA;;AAEA,4BAA4B,8BAA8B,GAAG,KAAK;;AAElE;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3LY;AACZ,gBAAgB,mBAAO,CAAC,8DAAe;AACvC,WAAW,mBAAO,CAAC,cAAI;AACvB,gBAAgB,mBAAO,CAAC,8DAAe;AACvC,mBAAmB,mBAAO,CAAC,oEAAkB;AAC7C,eAAe,mBAAO,CAAC,8DAAc;AACrC,aAAa,mBAAO,CAAC,kBAAM;AAC3B,cAAc,mBAAO,CAAC,0DAAa;AACnC,mBAAmB,mBAAO,CAAC,oEAAkB;AAC7C,aAAa,mBAAO,CAAC,8CAAM;AAC3B,kBAAkB,mBAAO,CAAC,oEAAkB;AAC5C,oBAAoB,mBAAO,CAAC,8DAAc;AAC1C,qBAAqB,mBAAO,CAAC,0EAAqB;AAClD,OAAO,0BAA0B,GAAG,mBAAO,CAAC,oEAAkB;AAC9D,eAAe,mBAAO,CAAC,4DAAc;;AAErC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,SAAS,+BAA+B;AACxC;AACA;;AAEA;AACA;AACA,mBAAmB;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL,wCAAwC,gBAAgB;AACxD;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,8DAAO;AACxC,sDAAsD,mBAAO,CAAC,uFAAiB;AAC/E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,uEAAS;;AAEpC;AACA;AACA,iCAAiC,mBAAO,CAAC,mGAAuB,mBAAmB,8DAAO;;AAE1F;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe;AACf,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,yCAAyC;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;;AAEA;AACA;AACA,6CAA6C;AAC7C;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gDAAgD,yBAAyB;AACzE;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,4DAA4D,yBAAyB;AACrF;AACA,WAAW;AACX;AACA,WAAW;;AAEX;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,MAAM;AACnB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9rCa;AACb,8CAA8C,cAAc;AAC5D,+BAA+B,mBAAO,CAAC,sFAAsB;AAC7D,yBAAyB,mBAAO,CAAC,qEAAgB;AACjD,qBAAqB,mBAAO,CAAC,qDAAgB;AAC7C,wBAAwB,mBAAO,CAAC,oEAAiB;AACjD,4BAA4B,mBAAO,CAAC,4EAAqB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gBAAgB,GAAG,UAAU,GAAG,aAAa;AAC/E;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,GAAG;AACnD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,GAAG;AACnD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;ACnOa;AACb,8CAA8C,cAAc;AAC5D,yBAAyB,mBAAO,CAAC,qEAAgB;AACjD,+BAA+B,mBAAO,CAAC,sFAAsB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,uCAAuC;AAC/E;AACA,wCAAwC,qCAAqC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA,iCAAiC,gBAAgB,UAAU,yCAAyC;AACpG;AACA,sCAAsC,UAAU,GAAG,KAAK;AACxD;AACA,8CAA8C,eAAe;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,kBAAkB,uBAAuB;AACrH;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA,kGAAkG,UAAU;AAC5G;AACA,0EAA0E,GAAG;AAC7E;AACA,kEAAkE,aAAa,uDAAuD;AACtI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,gBAAgB;AACjE;AACA;AACA;AACA;AACA;AACA,iDAAiD,cAAc;AAC/D;AACA;AACA,iCAAiC,gBAAgB,UAAU,GAAG;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,aAAa,gBAAgB;AACtF;AACA;AACA;AACA;AACA,6DAA6D,aAAa,cAAc;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,aAAa,gBAAgB;AACtF;AACA;AACA;AACA;AACA,6DAA6D,aAAa,cAAc;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,aAAa;AACpC;AACA;AACA;AACA,0EAA0E,WAAW,MAAM,SAAS;AACpG;AACA;AACA,gFAAgF,GAAG;AACnF;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B,sBAAsB,GAAG,GAAG,KAAK;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6C;;;;;;;;;;;;AC3Ka;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,WAAW,aAAa;AACnF;AACA;AACA;AACA;AACA;AACA,qDAAqD,kBAAkB,WAAW;AAClF;AACA;AACA;AACA,yC;;;;;;;;;;;;ACvCa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,oBAAoB,mBAAO,CAAC,gEAAe;AAC3C;AACA;AACA;AACA,gCAAgC,mBAAO,CAAC,wFAA2B;AACnE;AACA,6BAA6B,mBAAO,CAAC,0DAAS;AAC9C,iC;;;;;;;;;;;;AChBa;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D,sCAAsC,mBAAO,CAAC,4DAAa;AAC3D,0BAA0B,mBAAO,CAAC,wEAAmB;AACrD;AACA,gCAAgC,UAAU,OAAO,qBAAqB;AACtE;AACA,WAAW,KAAK;AAChB,sCAAsC,SAAS;AAC/C,0CAA0C,0BAA0B;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,sBAAsB;AACjC;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,sBAAsB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mD;;;;;;;;;;;;AC3Ca;AACb,8CAA8C,cAAc;AAC5D,sBAAsB,mBAAO,CAAC,iEAAgB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2C;;;;;;;;;;;;ACba;AACb,8CAA8C,cAAc;AAC5D,wBAAwB,mBAAO,CAAC,8EAAmB;AACnD;AACA,iC;;;;;;;;;;;;ACJa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,2C;;;;;;;;;;;;ACRa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,6DAA6D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;AC1Ba;AACb,8CAA8C,cAAc;AAC5D,8BAA8B,mBAAO,CAAC,6EAAuB;AAC7D,yBAAyB,mBAAO,CAAC,mEAAkB;AACnD,4BAA4B,mBAAO,CAAC,yEAAqB;AACzD,qBAAqB,mBAAO,CAAC,qDAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,gBAAgB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,qC;;;;;;;;;;;;AChGa;AACb,8CAA8C,cAAc;AAC5D,sBAAsB,mBAAO,CAAC,6DAAiB;AAC/C,qBAAqB,mBAAO,CAAC,qDAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,eAAe,IAAI,WAAW;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB,GAAG,WAAW;AAC/D;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qBAAqB;AACnD;AACA;AACA;AACA;AACA;AACA,gCAAgC,qBAAqB,QAAQ,uBAAuB,KAAK,KAAK;AAC9F;AACA;AACA,gCAAgC,qBAAqB,iBAAiB,KAAK;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0C;;;;;;;;;;;;AC1Ga;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+C;;;;;;;;;;;;AC7Ba;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4C;;;;;;;;;;;;ACpBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,yBAAyB,mBAAO,CAAC,qEAAgB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,eAAe;AACf;AACA;AACA,4C;;;;;;;;;;;;ACnCA;AACA;AACA;AACa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,yBAAyB,mBAAO,CAAC,qEAAgB;AACjD,yBAAyB,mBAAO,CAAC,mEAAkB;AACnD,sBAAsB,mBAAO,CAAC,6DAAiB;AAC/C,mBAAmB,mBAAO,CAAC,uDAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sEAAsE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,WAAW;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,oBAAoB,IAAI,WAAW;AAC3G;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;;;;;;ACjJa;AACb,8CAA8C,cAAc;AAC5D,mBAAmB,mBAAO,CAAC,uDAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,iBAAiB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;;;;;;;;;ACpBa;AACb,8CAA8C,cAAc;AAC5D,sBAAsB,mBAAO,CAAC,6DAAiB;AAC/C,4BAA4B,mBAAO,CAAC,yEAAqB;AACzD,yBAAyB,mBAAO,CAAC,mEAAkB;AACnD,mBAAmB,mBAAO,CAAC,uDAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,YAAY;AACjE;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iBAAiB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uBAAuB;AACpD;AACA,yCAAyC,iBAAiB,GAAG,OAAO,IAAI,aAAa;AACrF;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,2CAA2C,iBAAiB,iBAAiB,MAAM;AACnF;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;ACtFa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,yBAAyB,mBAAO,CAAC,qEAAgB;AACjD,qBAAqB,mBAAO,CAAC,qDAAgB;AAC7C,mBAAmB,mBAAO,CAAC,uDAAY;AACvC,2BAA2B,mBAAO,CAAC,uEAAoB;AACvD,mBAAmB,mBAAO,CAAC,uDAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,uBAAuB;AACnG,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,uCAAuC,YAAY,GAAG,OAAO;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,iBAAiB,8BAA8B,OAAO,gBAAgB,YAAY;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,YAAY,GAAG,OAAO;AACjE;AACA,4HAA4H,iBAAiB,2BAA2B,OAAO,gBAAgB,YAAY;AAC3M;AACA;AACA;AACA;AACA,sDAAsD,iBAAiB,oCAAoC,OAAO,gBAAgB,YAAY;AAC9I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,YAAY,GAAG,UAAU,qEAAqE,YAAY,GAAG,UAAU;AAC5L;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,6C;;;;;;;;;;;;AC3Va;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA,qBAAqB,mBAAO,CAAC,qDAAgB;AAC7C,yBAAyB,mBAAO,CAAC,qEAAgB;AACjD;AACA,gBAAgB,qCAAqC,EAAE,oBAAoB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+GAA+G,iBAAiB,SAAS,2BAA2B;AACpK;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ,wBAAwB,UAAU,WAAW;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oGAAoG,OAAO;AAC3G;AACA;AACA,oC;;;;;;;;;;;;ACtOa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,yBAAyB,mBAAO,CAAC,qEAAgB;AACjD,iBAAiB,mBAAO,CAAC,sBAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yD;;;;;;;;;;;;AChDa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,iBAAiB,mBAAO,CAAC,uDAAY;AACrC;AACA;AACA,0BAA0B,mBAAO,CAAC,yEAAqB;AACvD;AACA;AACA,kBAAkB,mBAAO,CAAC,yDAAa;AACvC;AACA,uBAAuB,mBAAO,CAAC,mEAAkB;AACjD;AACA;AACA,yBAAyB,mBAAO,CAAC,uEAAoB;AACrD;AACA,4BAA4B,mBAAO,CAAC,6EAAuB;AAC3D;AACA;AACA,kBAAkB,mBAAO,CAAC,yDAAa;AACvC;AACA,yBAAyB,mBAAO,CAAC,uEAAoB;AACrD;AACA,mBAAmB,mBAAO,CAAC,2DAAc;AACzC;AACA;AACA,sBAAsB,mBAAO,CAAC,iEAAiB;AAC/C;AACA,8BAA8B,mBAAO,CAAC,uDAAY;AAClD;AACA,SAAS,mBAAO,CAAC,mEAAkB;AACnC,sCAAsC,mBAAO,CAAC,iGAAiC;AAC/E;AACA,6CAA6C;AAC7C,iC;;;;;;;;;;;;AC3Ca;AACb,8CAA8C,cAAc;AAC5D,sBAAsB,mBAAO,CAAC,6DAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mGAAmG,OAAO,aAAa;AACvH,gBAAgB,KAAK;AACrB;AACA;AACA;AACA,4GAA4G,OAAO;AACnH;AACA;AACA;AACA;AACA,0C;;;;;;;;;;;;AChDa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,kBAAkB,mBAAO,CAAC,qDAAa;AACvC,yBAAyB,mBAAO,CAAC,0DAAY;AAC7C,yBAAyB,mBAAO,CAAC,qEAAgB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iD;;;;;;;;;;;;ACrDa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,kBAAkB,mBAAO,CAAC,qDAAa;AACvC,qBAAqB,mBAAO,CAAC,qDAAgB;AAC7C,yBAAyB,mBAAO,CAAC,0DAAY;AAC7C,qBAAqB,mBAAO,CAAC,qDAAgB;AAC7C,yBAAyB,mBAAO,CAAC,qEAAgB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,kEAAkE,uBAAuB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,uBAAuB;AAC7F;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,yDAAyD,uBAAuB,gBAAgB,aAAa;AAC7G;AACA;AACA;AACA,qDAAqD,uBAAuB,iBAAiB,OAAO;AACpG;AACA;AACA;AACA;AACA,2DAA2D,uBAAuB;AAClF;AACA;AACA,8DAA8D,uBAAuB;AACrF;AACA,aAAa;AACb;AACA;AACA,uEAAuE,uBAAuB;AAC9F;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,qCAAqC,qBAAqB;AAC1D;AACA;AACA,wC;;;;;;;;;;;;AC/Ja;AACb,8CAA8C,cAAc;AAC5D,8BAA8B,mBAAO,CAAC,4EAAuB;AAC7D,sCAAsC,mBAAO,CAAC,4FAA+B;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6D;;;;;;;;;;;;AChBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,yBAAyB,mBAAO,CAAC,0DAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+C;;;;;;;;;;;;ACrDa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,yBAAyB,mBAAO,CAAC,0DAAY;AAC7C,kBAAkB,mBAAO,CAAC,qDAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uD;;;;;;;;;;;;ACnCa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,qBAAqB,mBAAO,CAAC,8DAAgB;AAC7C;AACA,8BAA8B,mBAAO,CAAC,gFAAyB;AAC/D;AACA,4BAA4B,mBAAO,CAAC,4EAAuB;AAC3D;AACA,0CAA0C,mBAAO,CAAC,wGAAqC;AACvF;AACA,SAAS,mBAAO,CAAC,4FAA+B;AAChD,iC;;;;;;;;;;;;ACda;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0DAA0D;AAC3D,qC;;;;;;;;;;;;ACXa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,iDAAiD;AAClD,kC;;;;;;;;;;;;ACZa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,aAAa,mBAAO,CAAC,8CAAM;AAC3B,sBAAsB,mBAAO,CAAC,6DAAiB;AAC/C,oBAAoB,mBAAO,CAAC,+DAAa;AACzC,2BAA2B,mBAAO,CAAC,6EAAoB;AACvD,yBAAyB,mBAAO,CAAC,qEAAgB;AACjD,iBAAiB,mBAAO,CAAC,yDAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,QAAQ;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,IAAI,KAAK,IAAI,KAAK,IAAI,iBAAiB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,mBAAmB,kCAAkC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;ACpVa;AACb,8CAA8C,cAAc;AAC5D,2BAA2B,mBAAO,CAAC,6EAAoB;AACvD;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4C;;;;;;;;;;;;ACjEa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4C;;;;;;;;;;;;ACxDa;AACb,8CAA8C,cAAc;AAC5D,kBAAkB,mBAAO,CAAC,+DAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mBAAO,CAAC,6EAAoB;AACrD;AACA,kBAAkB,mBAAO,CAAC,+DAAa;AACvC;AACA,eAAe,mBAAO,CAAC,yDAAU;AACjC;AACA,yBAAyB,mBAAO,CAAC,6EAAoB;AACrD;AACA;AACA,iC;;;;;;;;;;;;ACnBa;AACb,8CAA8C,cAAc;AAC5D,WAAW,mBAAO,CAAC,cAAI;AACvB,oBAAoB,mBAAO,CAAC,8FAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,IAAI;AAC1C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF;AACtF;AACA;AACA,wFAAwF;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iBAAiB,GAAG,UAAU;AACvD;AACA;AACA,aAAa;AACb;AACA,8CAA8C,UAAU,GAAG,gBAAgB,2BAA2B,EAAE;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,yBAAyB,iBAAiB,GAAG,UAAU;AACvD;AACA;AACA,aAAa;AACb;AACA,8CAA8C,UAAU,GAAG,gBAAgB,2BAA2B,EAAE;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,6C;;;;;;;;;;;;AC9La;AACb,8CAA8C,cAAc;AAC5D,0BAA0B,mBAAO,CAAC,kGAAqB;AACvD;AACA,iC;;;;;;;;;;;;ACJa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6C;;;;;;;;;;;;AC9Ba;AACb,8CAA8C,cAAc;AAC5D,yBAAyB,mBAAO,CAAC,qEAAgB;AACjD,gBAAgB,mBAAO,CAAC,qDAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uEAAuE,GAAG,uBAAuB;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO,eAAe,wBAAwB;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,OAAO,IAAI,EAAE;AACtE,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,EAAE;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2C;;;;;;;;;;;;AC7Ja;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,iC;;;;;;;;;;;;AC1Ba;AACb,8CAA8C,cAAc;AAC5D,gBAAgB,mBAAO,CAAC,qDAAU;AAClC,iBAAiB,mBAAO,CAAC,uDAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;;;;;;AC9Fa;AACb,8CAA8C,cAAc;AAC5D,wBAAwB,mBAAO,CAAC,6EAAmB;AACnD;AACA,eAAe,mBAAO,CAAC,2DAAU;AACjC;AACA,cAAc,mBAAO,CAAC,yDAAS;AAC/B;AACA,0BAA0B,mBAAO,CAAC,iFAAqB;AACvD;AACA,iC;;;;;;;;;;;;ACVa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,sBAAsB,mBAAO,CAAC,6DAAiB;AAC/C,SAAS,mBAAO,CAAC,sDAAQ;AACzB;AACA,iC;;;;;;;;;;;;ACRa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA,gC;;;;;;;;;;;;ACNa;AACb,8CAA8C,cAAc;AAC5D,WAAW,mBAAO,CAAC,+CAAG;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0C;;;;;;;;;;;;AC9Ca;AACb,8CAA8C,cAAc;AAC5D,oBAAoB,mBAAO,CAAC,6DAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0C;;;;;;;;;;;;ACda;AACb,8CAA8C,cAAc;AAC5D,oBAAoB,mBAAO,CAAC,6DAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+C;;;;;;;;;;;;ACda;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oDAAoD;AACnE,mBAAmB,UAAU,GAAG,UAAU;AAC1C;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;ACrCa;AACb,8CAA8C,cAAc;AAC5D,oBAAoB,mBAAO,CAAC,6DAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6C;;;;;;;;;;;;ACba;AACb,8CAA8C,cAAc;AAC5D,oBAAoB,mBAAO,CAAC,6DAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+C;;;;;;;;;;;;ACda;AACb,8CAA8C,cAAc;AAC5D,oBAAoB,mBAAO,CAAC,6DAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4C;;;;;;;;;;;;ACjBa;AACb,8CAA8C,cAAc;AAC5D,kBAAkB,mBAAO,CAAC,6DAAa;AACvC;AACA,uBAAuB,mBAAO,CAAC,uEAAkB;AACjD;AACA,uBAAuB,mBAAO,CAAC,uEAAkB;AACjD;AACA,yBAAyB,mBAAO,CAAC,2EAAoB;AACrD;AACA,0BAA0B,mBAAO,CAAC,6EAAqB;AACvD;AACA,4BAA4B,mBAAO,CAAC,iFAAuB;AAC3D;AACA,4BAA4B,mBAAO,CAAC,iFAAuB;AAC3D;AACA,iC;;;;;;;;;;;;AChBa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA,SAAS,mBAAO,CAAC,oDAAS;AAC1B;AACA;AACA;AACA,SAAS,mBAAO,CAAC,8DAAc;AAC/B;AACA;AACA;AACA,SAAS,mBAAO,CAAC,sDAAU;AAC3B;AACA;AACA;AACA,SAAS,mBAAO,CAAC,4DAAa;AAC9B;AACA;AACA;AACA,SAAS,mBAAO,CAAC,oDAAS;AAC1B,iC;;;;;;;;;;;;ACzBa;AACb,8CAA8C,cAAc;AAC5D,sBAAsB,mBAAO,CAAC,6DAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,EAAE;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+C;;;;;;;;;;;;ACrBa;AACb,8CAA8C,cAAc;AAC5D,4BAA4B,mBAAO,CAAC,gFAAuB;AAC3D;AACA,iC;;;;;;;;;;;;ACJa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;ACTa;AACb,8CAA8C,cAAc;AAC5D,yBAAyB,mBAAO,CAAC,kFAA6B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;;;;;;AChBa;AACb,8CAA8C,cAAc;AAC5D,iBAAiB,mBAAO,CAAC,8DAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;;;;;;;;;ACXa;AACb,8CAA8C,cAAc;AAC5D,iBAAiB,mBAAO,CAAC,8DAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,0C;;;;;;;;;;;;ACTa;AACb,8CAA8C,cAAc;AAC5D,iBAAiB,mBAAO,CAAC,0DAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;ACba;AACb,8CAA8C,cAAc;AAC5D,uBAAuB,mBAAO,CAAC,8EAAkB;AACjD;AACA,sBAAsB,mBAAO,CAAC,4EAAiB;AAC/C;AACA,oBAAoB,mBAAO,CAAC,wEAAe;AAC3C;AACA,eAAe,mBAAO,CAAC,8DAAU;AACjC;AACA,iC;;;;;;;;;;;;ACVa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA,iBAAiB,IAAI,KAAK,IAAI,KAAK,IAAI,iBAAiB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;AChCa;AACb,8CAA8C,cAAc;AAC5D,2BAA2B,mBAAO,CAAC,0EAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,yC;;;;;;;;;;;;ACjBa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4C;;;;;;;;;;;;ACVa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;;;;;;AClBa;AACb,8CAA8C,cAAc;AAC5D,6BAA6B,mBAAO,CAAC,6FAAwB;AAC7D;AACA,4BAA4B,mBAAO,CAAC,2FAAuB;AAC3D;AACA,iC;;;;;;;;;;;;ACNa;AACb,8CAA8C,cAAc;AAC5D,wBAAwB,mBAAO,CAAC,qFAA0B;AAC1D,iBAAiB,mBAAO,CAAC,uEAAmB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA,6DAA6D,aAAa;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+C;;;;;;;;;;;;ACjDa;AACb,8CAA8C,cAAc;AAC5D,wBAAwB,mBAAO,CAAC,qFAA0B;AAC1D,sBAAsB,mBAAO,CAAC,iEAAgB;AAC9C,iBAAiB,mBAAO,CAAC,uEAAmB;AAC5C;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,eAAe,gBAAgB;AAC/B;AACA,6DAA6D,aAAa;AAC1E;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,gD;;;;;;;;;;;;ACxBa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;;;;;ACTa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA,+FAA+F,OAAO;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mHAAmH,OAAO;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sHAAsH,OAAO;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mC;;;;;;;;;;;;ACpCa;AACb,8CAA8C,cAAc;AAC5D,qBAAqB,mBAAO,CAAC,8DAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kHAAkH;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;;;;;;;;;ACvBa;AACb,8CAA8C,cAAc;AAC5D,wBAAwB,mBAAO,CAAC,oEAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;;;;;;;;;ACVa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,sC;;;;;;;;;;;;ACda;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;ACTa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,SAAS,mBAAO,CAAC,oEAAc;AAC/B;AACA,SAAS,mBAAO,CAAC,8DAAW;AAC5B;AACA,aAAa,mBAAO,CAAC,kDAAQ;AAC7B;AACA,iBAAiB,mBAAO,CAAC,0DAAY;AACrC;AACA,aAAa,mBAAO,CAAC,kDAAQ;AAC7B;AACA,kBAAkB,mBAAO,CAAC,4DAAa;AACvC;AACA,kBAAkB,mBAAO,CAAC,4DAAa;AACvC;AACA,6BAA6B,mBAAO,CAAC,kFAAwB;AAC7D;AACA,mBAAmB,mBAAO,CAAC,8DAAc;AACzC;AACA,oBAAoB,mBAAO,CAAC,gEAAe;AAC3C;AACA,sBAAsB,mBAAO,CAAC,oEAAiB;AAC/C;AACA,mBAAmB,mBAAO,CAAC,8DAAc;AACzC;AACA;AACA;AACA,kBAAkB,mBAAO,CAAC,4DAAa;AACvC;AACA,oBAAoB,mBAAO,CAAC,gEAAe;AAC3C;AACA,qBAAqB,mBAAO,CAAC,kEAAgB;AAC7C;AACA,mBAAmB,mBAAO,CAAC,8DAAc;AACzC;AACA,iBAAiB,mBAAO,CAAC,0DAAY;AACrC;AACA,iBAAiB,mBAAO,CAAC,0DAAY;AACrC;AACA,cAAc,mBAAO,CAAC,oDAAS;AAC/B;AACA,oBAAoB,mBAAO,CAAC,gEAAe;AAC3C;AACA,mBAAmB,mBAAO,CAAC,8DAAc;AACzC;AACA,yBAAyB,mBAAO,CAAC,0EAAoB;AACrD;AACA,uBAAuB,mBAAO,CAAC,sEAAkB;AACjD;AACA,sBAAsB,mBAAO,CAAC,oEAAiB;AAC/C;AACA,sBAAsB,mBAAO,CAAC,oEAAiB;AAC/C;AACA,uBAAuB,mBAAO,CAAC,sEAAkB;AACjD;AACA,SAAS,mBAAO,CAAC,wDAAW;AAC5B,mBAAmB,mBAAO,CAAC,8DAAc;AACzC;AACA,oBAAoB,mBAAO,CAAC,gEAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wGAAwG,SAAS,oBAAoB;AACxJ;AACA;AACA,iC;;;;;;;;;;;;AC7Ea;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;ACda;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA,0C;;;;;;;;;;;;ACPa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gC;;;;;;;;;;;;ACrBa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,cAAc,GAAG,SAAS;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;;;;;;AC9Da;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA,KAAK;AACL;AACA,sC;;;;;;;;;;;;ACPa;AACb,8CAA8C,cAAc;AAC5D,qBAAqB,mBAAO,CAAC,+DAAe;AAC5C,2BAA2B,mBAAO,CAAC,mFAA4B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,qC;;;;;;;;;;;;AC9Ba;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D,sCAAsC,mBAAO,CAAC,4DAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;ACba;AACb,8CAA8C,cAAc;AAC5D,iBAAiB,mBAAO,CAAC,sEAAkB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;ACda;AACb,8CAA8C,cAAc;AAC5D,sBAAsB,mBAAO,CAAC,gEAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;;;;;;;;;ACVa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;;;;;;ACpCa;AACb,8CAA8C,cAAc;AAC5D,4BAA4B,mBAAO,CAAC,qFAA6B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,wHAAwH,QAAQ;AAChI;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,0C;;;;;;;;;;;;AClCa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;ACTa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,gC;;;;;;;;;;;;ACVa;AACb,8CAA8C,cAAc;AAC5D,wBAAwB,mBAAO,CAAC,oFAAyB;AACzD,iBAAiB,mBAAO,CAAC,uEAAsB;AAC/C,gBAAgB,mBAAO,CAAC,oDAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;AClCa;AACb,8CAA8C,cAAc;AAC5D,iBAAiB,mBAAO,CAAC,uEAAsB;AAC/C,qBAAqB,mBAAO,CAAC,8DAAc;AAC3C,gBAAgB,mBAAO,CAAC,oDAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,IAAI;AAC9C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qCAAqC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gD;;;;;;;;;;;;AChEa;AACb,8CAA8C,cAAc;AAC5D,iBAAiB,mBAAO,CAAC,uDAAW;AACpC,iBAAiB,mBAAO,CAAC,sEAAkB;AAC3C,eAAe,mBAAO,CAAC,kDAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,cAAc,EAAE;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA,kDAAkD;AAClD,WAAW,+EAA+E;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,aAAa,uBAAuB;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;;;;AC/Ia;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,kBAAkB,mBAAO,CAAC,qDAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,yEAAyE;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4EAA4E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,mEAAmE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD;AACrD;AACA;AACA;AACA;AACA,2C;;;;;;;;;;;;AC5Oa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,kBAAkB,mBAAO,CAAC,qDAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,6DAA6D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,qFAAqF;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kFAAkF;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4EAA4E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wFAAwF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,yEAAyE;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wFAAwF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8FAA8F;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gEAAgE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0GAA0G;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oGAAoG;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wFAAwF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8FAA8F;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4EAA4E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sEAAsE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0GAA0G;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gHAAgH;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kFAAkF;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,yEAAyE;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,2FAA2F;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,6GAA6G;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gEAAgE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,+HAA+H;AAChI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,iGAAiG;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,yEAAyE;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0GAA0G;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4EAA4E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,yEAAyE;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,yEAAyE;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sEAAsE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,mEAAmE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0DAA0D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0GAA0G;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sEAAsE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,6DAA6D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sEAAsE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,mEAAmE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gC;;;;;;;;;;;;AC7uDa;AACb,8CAA8C,cAAc;AAC5D;AACA,eAAe,mBAAO,CAAC,yEAAkB;AACzC;AACA,0BAA0B,mBAAO,CAAC,+FAA6B;AAC/D,iC;;;;;;;;;;;;ACNa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,yBAAyB,mBAAO,CAAC,qEAAgB;AACjD,sBAAsB,mBAAO,CAAC,6DAAiB;AAC/C,6BAA6B,mBAAO,CAAC,sEAAwB;AAC7D,kBAAkB,mBAAO,CAAC,qDAAa;AACvC,sBAAsB,mBAAO,CAAC,wDAAiB;AAC/C,qBAAqB,mBAAO,CAAC,qDAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,OAAO;AAC9E;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,KAAK,WAAW,mCAAmC,gBAAgB,oCAAoC;AACzJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8C;;;;;;;;;;;;AChKa;AACb,8CAA8C,cAAc;AAC5D,2BAA2B,mBAAO,CAAC,uFAAsB;AACzD;AACA,iC;;;;;;;;;;;;ACJa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D,yBAAyB,mBAAO,CAAC,0DAAY;AAC7C,oBAAoB,mBAAO,CAAC,wDAAW;AACvC,sBAAsB,mBAAO,CAAC,6DAAiB;AAC/C,6BAA6B,mBAAO,CAAC,sEAAwB;AAC7D,2CAA2C,mBAAO,CAAC,4EAAoB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;AACA,6EAA6E,kCAAkC;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,2BAA2B;AAC3D,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,4CAA4C;AAC1E,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;AC/Na;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,yBAAyB,mBAAO,CAAC,qEAAgB;AACjD,yBAAyB,mBAAO,CAAC,0DAAY;AAC7C,6BAA6B,mBAAO,CAAC,sEAAwB;AAC7D,qBAAqB,mBAAO,CAAC,qDAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,SAAS;AAChE;AACA;AACA,yFAAyF,SAAS;AAClG;AACA;AACA;AACA;AACA;AACA,+C;;;;;;;;;;;;AC9Ea;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D,yBAAyB,mBAAO,CAAC,0DAAY;AAC7C,qBAAqB,mBAAO,CAAC,qDAAgB;AAC7C,qBAAqB,mBAAO,CAAC,mEAAc;AAC3C,8BAA8B,mBAAO,CAAC,qFAAuB;AAC7D,gCAAgC,mBAAO,CAAC,oDAAO;AAC/C,iEAAiE;AACjE,4DAA4D;AAC5D,4DAA4D;AAC5D;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA,8DAA8D,iBAAiB,gBAAgB,aAAa;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,WAAW;AAClF;AACA,sFAAsF,WAAW,QAAQ,gCAAgC;AACzI;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,UAAU;AACnF;AACA;AACA,iFAAiF,WAAW,SAAS,EAAE;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,WAAW;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sD;;;;;;;;;;;;AC3Fa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,yBAAyB,mBAAO,CAAC,0DAAY;AAC7C,qBAAqB,mBAAO,CAAC,qDAAgB;AAC7C,kBAAkB,mBAAO,CAAC,qDAAa;AACvC,6BAA6B,mBAAO,CAAC,sEAAwB;AAC7D,yBAAyB,mBAAO,CAAC,kEAAoB;AACrD,qCAAqC,mBAAO,CAAC,mGAA8B;AAC3E,wBAAwB,mBAAO,CAAC,iEAAmB;AACnD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA,eAAe,2DAA2D;AAC1E;AACA;AACA;AACA,SAAS,0HAA0H;AACnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,oDAAoD,wCAAwC,gBAAgB,yCAAyC,uBAAuB,oBAAoB;AAChM;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,SAAS;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2C;;;;;;;;;;;;ACpPa;AACb,8CAA8C,cAAc;AAC5D,wBAAwB,mBAAO,CAAC,6EAAmB;AACnD;AACA,mBAAmB,mBAAO,CAAC,mEAAc;AACzC;AACA;AACA,iC;;;;;;;;;;;;;;;;;;;;;;;ACPa;AACb,8CAA8C,cAAc;AAC5D,qBAAqB,mBAAO,CAAC,qDAAgB;AAC7C,8BAA8B,mBAAO,CAAC,wGAAuB;AAC7D;AACA;AACA;AACA,eAAe,mCAAmC;AAClD;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA,wDAAwD,cAAc;AACtE;AACA;AACA;AACA;AACA;AACA,+C;;;;;;;;;;;;ACnBa;AACb,8CAA8C,cAAc;AAC5D,qBAAqB,mBAAO,CAAC,qDAAgB;AAC7C,yBAAyB,mBAAO,CAAC,qEAAgB;AACjD,sCAAsC,mBAAO,CAAC,4HAAuC;AACrF,iCAAiC,mBAAO,CAAC,gHAAiC;AAC1E,+BAA+B,mBAAO,CAAC,8GAAgC;AACvE,0BAA0B,mBAAO,CAAC,oGAA2B;AAC7D,iCAAiC,mBAAO,CAAC,kHAAkC;AAC3E;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,iCAAiC;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,QAAQ;AACxE;AACA;AACA;AACA,uKAAuK,QAAQ;AAC/K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,sBAAsB,MAAM,iBAAiB;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,wCAAwC;AACpG,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;AClLa;AACb,8CAA8C,cAAc;AAC5D,qBAAqB,mBAAO,CAAC,qDAAgB;AAC7C,yBAAyB,mBAAO,CAAC,kEAAoB;AACrD,6BAA6B,mBAAO,CAAC,sEAAwB;AAC7D,+BAA+B,mBAAO,CAAC,0EAA0B;AACjE,2BAA2B,mBAAO,CAAC,8GAAgC;AACnE,0BAA0B,mBAAO,CAAC,oGAA2B;AAC7D,qBAAqB,mBAAO,CAAC,sFAAc;AAC3C,8BAA8B,mBAAO,CAAC,sHAAoC;AAC1E,iCAAiC,mBAAO,CAAC,gHAAiC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,gFAAgF,kBAAkB,8CAA8C,gBAAgB,GAAG,yBAAyB;AAC5L;AACA,qBAAqB,EAAE;AACvB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,8JAA8J,yBAAyB;AACvL;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,+DAA+D,6CAA6C;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+C;;;;;;;;;;;;AC1Ha;AACb,8CAA8C,cAAc;AAC5D,qBAAqB,mBAAO,CAAC,qDAAgB;AAC7C,8BAA8B,mBAAO,CAAC,wGAAuB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,EAAE;AAC/E,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oD;;;;;;;;;;;;AC3Da;AACb;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,qBAAqB,mBAAO,CAAC,qDAAgB;AAC7C,yBAAyB,mBAAO,CAAC,qEAAgB;AACjD,yBAAyB,mBAAO,CAAC,kEAAoB;AACrD,8BAA8B,mBAAO,CAAC,sHAAoC;AAC1E,8BAA8B,mBAAO,CAAC,sHAAoC;AAC1E,iCAAiC,mBAAO,CAAC,gHAAiC;AAC1E,0BAA0B,mBAAO,CAAC,oGAA2B;AAC7D,yBAAyB,mBAAO,CAAC,gGAAyB;AAC1D,qBAAqB,mBAAO,CAAC,sFAAc;AAC3C,qCAAqC,mBAAO,CAAC,kIAA0C;AACvF,qBAAqB,mBAAO,CAAC,qDAAgB;AAC7C,qCAAqC,mBAAO,CAAC,wHAAqC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0DAA0D;AACzE,kBAAkB,YAAY,GAAG,cAAc,GAAG,cAAc,GAAG,aAAa;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,uBAAuB,yBAAyB;AAChD,wEAAwE,eAAe,QAAQ,OAAO;AACtG;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA,2BAA2B,sCAAsC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT,yGAAyG,KAAK;AAC9G,8DAA8D,KAAK;AACnE;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,SAAS;AACnC,0BAA0B,mCAAmC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,SAAS;AACT,mBAAmB,WAAW;AAC9B;AACA,SAAS;AACT,+CAA+C,KAAK;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,UAAU;AAC1F;AACA;AACA;AACA;AACA,eAAe,+CAA+C;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,+DAA+D,yBAAyB;AACxF;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,0HAA0H,kBAAkB,sCAAsC;AAClL,qEAAqE,yBAAyB;AAC9F;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,KAAK;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,KAAK,QAAQ,SAAS;AACzE;AACA;AACA,4DAA4D,KAAK;AACjE;AACA;AACA;AACA,iDAAiD,KAAK,QAAQ,QAAQ;AACtE;AACA;AACA,4DAA4D,KAAK;AACjE;AACA;AACA;AACA,gDAAgD,KAAK,QAAQ,QAAQ;AACrE;AACA;AACA,4DAA4D,KAAK;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,6CAA6C,SAAS;AACtD,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,aAAa;AAC5D;AACA;AACA,aAAa;AACb;AACA,sDAAsD,WAAW;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,yBAAyB;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,KAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,KAAK,yBAAyB,gCAAgC;AAClG;AACA;AACA;AACA,gCAAgC,KAAK,yBAAyB,gCAAgC;AAC9F;AACA;AACA;AACA;AACA,oCAAoC,KAAK,uBAAuB,2BAA2B;AAC3F;AACA;AACA;AACA,gCAAgC,KAAK,uBAAuB,2BAA2B;AACvF;AACA;AACA;AACA;AACA,oCAAoC,KAAK,sBAAsB,QAAQ;AACvE;AACA;AACA;AACA,gCAAgC,KAAK,sBAAsB,QAAQ;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,yBAAyB;AAC1E;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,KAAK,GAAG,KAAK;AACnC,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,4C;;;;;;;;;;;;AC1aa;AACb,8CAA8C,cAAc;AAC5D,qBAAqB,mBAAO,CAAC,qDAAgB;AAC7C,qBAAqB,mBAAO,CAAC,sFAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iD;;;;;;;;;;;;AC/Ha;AACb,8CAA8C,cAAc;AAC5D,qBAAqB,mBAAO,CAAC,qDAAgB;AAC7C,yBAAyB,mBAAO,CAAC,qEAAgB;AACjD,oBAAoB,mBAAO,CAAC,uFAAa;AACzC,iCAAiC,mBAAO,CAAC,kHAAkC;AAC3E,8BAA8B,mBAAO,CAAC,2GAAuB;AAC7D,iCAAiC,mBAAO,CAAC,gHAAiC;AAC1E;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E;AAC9E,mBAAmB,qBAAqB;AACxC;AACA,uFAAuF;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA,sEAAsE,QAAQ;AAC9E,+NAA+N,QAAQ;AACvO;AACA;AACA;AACA,mBAAmB,2EAA2E;AAC9F;AACA;AACA;AACA;AACA;AACA,4FAA4F,GAAG,+BAA+B,WAAW,GAAG,4BAA4B;AACxK;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,4DAA4D,GAAG;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,QAAQ;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oGAAoG,0BAA0B,uBAAuB;AACrJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA,yDAAyD,GAAG;AAC5D,uDAAuD,mBAAmB;AAC1E;AACA;AACA;AACA;AACA,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC,8DAA8D,QAAQ;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,GAAG;AACvE,eAAe,yBAAyB;AACxC,sBAAsB,eAAe,MAAM,OAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sDAAsD;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,GAAG;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,GAAG;AAC3D;AACA;AACA;AACA;AACA,yC;;;;;;;;;;;;AC9Na;AACb,8CAA8C,cAAc;AAC5D,qBAAqB,mBAAO,CAAC,qDAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+C;;;;;;;;;;;;ACjCa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,4CAA4C,qCAAqC;AAC9I,qC;;;;;;;;;;;;ACTa;AACb,8CAA8C,cAAc;AAC5D;AACA,qC;;;;;;;;;;;;ACHa;AACb,8CAA8C,cAAc;AAC5D,0BAA0B,mBAAO,CAAC,4FAAmB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uD;;;;;;;;;;;;ACVa;AACb,8CAA8C,cAAc;AAC5D,qBAAqB,mBAAO,CAAC,qDAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2C;;;;;;;;;;;;ACfa;AACb,8CAA8C,cAAc;AAC5D,0BAA0B,mBAAO,CAAC,4FAAmB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gD;;;;;;;;;;;;ACVa;AACb,8CAA8C,cAAc;AAC5D,0BAA0B,mBAAO,CAAC,4FAAmB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kD;;;;;;;;;;;;ACVa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAO,CAAC,4FAAmB;AACnD;AACA;AACA;AACA;AACA;AACA,+BAA+B,mBAAO,CAAC,0GAA0B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mBAAO,CAAC,sGAAwB;AAC7D;AACA;AACA;AACA;AACA;AACA,oCAAoC,mBAAO,CAAC,oHAA+B;AAC3E;AACA,iC;;;;;;;;;;;;AC5Ba;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,mBAAmB,mBAAO,CAAC,iGAAyB;AACpD;AACA,4BAA4B,mBAAO,CAAC,mHAAkC;AACtE;AACA,yBAAyB,mBAAO,CAAC,6GAA+B;AAChE;AACA,4BAA4B,mBAAO,CAAC,mHAAkC;AACtE;AACA;AACA,iCAAiC,mBAAO,CAAC,6HAAuC;AAChF;AACA,8BAA8B,mBAAO,CAAC,uHAAoC;AAC1E;AACA;AACA,sBAAsB,mBAAO,CAAC,6GAA+B;AAC7D;AACA;AACA,+BAA+B,mBAAO,CAAC,+GAAgC;AACvE;AACA,mCAAmC,mBAAO,CAAC,uHAAoC;AAC/E;AACA,8BAA8B,mBAAO,CAAC,6GAA+B;AACrE;AACA;AACA,mCAAmC,mBAAO,CAAC,iIAAyC;AACpF;AACA,yBAAyB,mBAAO,CAAC,6GAA+B;AAChE;AACA;AACA,SAAS,mBAAO,CAAC,yEAAU;AAC3B;AACA,2BAA2B,mBAAO,CAAC,uEAAS;AAC5C;AACA;AACA,4BAA4B,mBAAO,CAAC,qHAAmC;AACvE;AACA,4BAA4B,mBAAO,CAAC,qHAAmC;AACvE;AACA;AACA,kBAAkB,mBAAO,CAAC,yEAAa;AACvC;AACA,iC;;;;;;;;;;;;ACtDa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA,CAAC,+EAA+E;AAChF,4C;;;;;;;;;;;;ACRa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sD;;;;;;;;;;;;AC9Ba;AACb,8CAA8C,cAAc;AAC5D,qBAAqB,mBAAO,CAAC,qDAAgB;AAC7C,qBAAqB,mBAAO,CAAC,qDAAgB;AAC7C,qBAAqB,mBAAO,CAAC,qGAA6B;AAC1D,0BAA0B,mBAAO,CAAC,uGAA8B;AAChE,WAAW,yBAAyB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4BAA4B;AAC3C,kBAAkB,GAAG,GAAG,SAAS,GAAG,YAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0C;;;;;;;;;;;;ACzFa;AACb,WAAW,cAAc;AACzB,WAAW,SAAS;AACpB,WAAW,UAAU;AACrB,8CAA8C,cAAc;AAC5D,yBAAyB,mBAAO,CAAC,qEAAgB;AACjD,yBAAyB,mBAAO,CAAC,oGAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gD;;;;;;;;;;;;AC/Da;AACb,8CAA8C,cAAc;AAC5D,qBAAqB,mBAAO,CAAC,qDAAgB;AAC7C,wBAAwB,mBAAO,CAAC,iHAAmC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6C;;;;;;;;;;;;ACzCa;AACb,8CAA8C,cAAc;AAC5D,2BAA2B,mBAAO,CAAC,iEAAsB;AACzD,sBAAsB,mBAAO,CAAC,6DAAiB;AAC/C,yBAAyB,mBAAO,CAAC,gHAA8B;AAC/D,WAAW,kBAAkB;AAC7B,WAAW,yBAAyB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD,WAAW,uCAAuC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uD;;;;;;;;;;;;ACtBa;AACb,8CAA8C,cAAc;AAC5D,2BAA2B,mBAAO,CAAC,iEAAsB;AACzD,qBAAqB,mBAAO,CAAC,qDAAgB;AAC7C,sBAAsB,mBAAO,CAAC,6DAAiB;AAC/C,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD,WAAW,4BAA4B;AACvC;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,oD;;;;;;;;;;;;AC/Ba;AACb,8CAA8C,cAAc;AAC5D,sBAAsB,mBAAO,CAAC,6DAAiB;AAC/C,qBAAqB,mBAAO,CAAC,qDAAgB;AAC7C,mCAAmC,mBAAO,CAAC,qHAA4B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD,WAAW,4BAA4B;AACvC;AACA,gDAAgD;AAChD;AACA,uE;;;;;;;;;;;;ACjCa;AACb,8CAA8C,cAAc;AAC5D,oCAAoC,mBAAO,CAAC,2HAA+B;AAC3E;AACA,iCAAiC,mBAAO,CAAC,qHAA4B;AACrE;AACA,oDAAoD,mBAAO,CAAC,2JAA+C;AAC3G;AACA,iC;;;;;;;;;;;;ACRa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,6BAA6B,mBAAO,CAAC,2HAAmC;AACxE;AACA,0BAA0B,mBAAO,CAAC,2HAAmC;AACrE;AACA,uBAAuB,mBAAO,CAAC,+GAA6B;AAC5D;AACA;AACA,SAAS,mBAAO,CAAC,iFAAW;AAC5B,iC;;;;;;;;;;;;ACda;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wFAAwF;AACzF,+C;;;;;;;;;;;;ACjBa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wFAAwF;AACzF,+C;;;;;;;;;;;;ACda;AACb,8CAA8C,cAAc;AAC5D,qBAAqB,mBAAO,CAAC,qDAAgB;AAC7C,sCAAsC,mBAAO,CAAC,4HAAuC;AACrF,0BAA0B,mBAAO,CAAC,oGAA2B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kD;;;;;;;;;;;;AC3Ba;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,0C;;;;;;;;;;;;AChBa;AACb,8CAA8C,cAAc;AAC5D,oBAAoB,mBAAO,CAAC,0EAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oCAAoC,GAAG,SAAS;AAC9D;AACA,sD;;;;;;;;;;;;ACZa;AACb,8CAA8C,cAAc;AAC5D,oBAAoB,mBAAO,CAAC,0EAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,iD;;;;;;;;;;;;ACTa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA,CAAC,yEAAyE;AAC1E,0C;;;;;;;;;;;;ACRa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA,iDAAiD,YAAY;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,yEAAyE;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;;;;;;ACjCa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gD;;;;;;;;;;;;ACXa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,yEAAyE;AAC1E,iD;;;;;;;;;;;;ACba;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA,yC;;;;;;;;;;;;ACJa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,sBAAsB,mBAAO,CAAC,6DAAiB;AAC/C,0BAA0B,mBAAO,CAAC,+DAAqB;AACvD,qBAAqB,mBAAO,CAAC,qDAAgB;AAC7C,yBAAyB,mBAAO,CAAC,0DAAY;AAC7C,yBAAyB,mBAAO,CAAC,kEAAoB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,qBAAqB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,YAAY;AAC1E;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,aAAa,aAAa,YAAY;AAC7D,6EAA6E,IAAI;AACjF;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,uBAAuB,aAAa,aAAa,YAAY;AAC7D,+EAA+E,IAAI;AACnF;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,uBAAuB,aAAa,aAAa,YAAY;AAC7D,iFAAiF,IAAI;AACrF;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,uBAAuB,aAAa;AACpC,gFAAgF,IAAI;AACpF;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,uBAAuB,aAAa,aAAa,+BAA+B;AAChF;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,aAAa,aAAa,YAAY;AAC7D,uFAAuF,IAAI;AAC3F;AACA;AACA,mDAAmD,8BAA8B,kCAAkC;AACnH,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;;;;;;;;;ACnJa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,yBAAyB,mBAAO,CAAC,qEAAgB;AACjD,qBAAqB,mBAAO,CAAC,qDAAgB;AAC7C,+BAA+B,mBAAO,CAAC,qFAAwB;AAC/D,kBAAkB,mBAAO,CAAC,qDAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+C;;;;;;;;;;;;AC1Da;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kD;;;;;;;;;;;;ACfa;AACb,8CAA8C,cAAc;AAC5D,qBAAqB,mBAAO,CAAC,qDAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,kCAAkC;AAC5G;AACA,0EAA0E,kCAAkC,oBAAoB,YAAY;AAC5I;AACA;AACA;AACA;AACA,8EAA8E,kCAAkC,oBAAoB,YAAY;AAChJ;AACA;AACA,wEAAwE,kCAAkC,iBAAiB,YAAY;AACvI;AACA;AACA;AACA,sD;;;;;;;;;;;;AChCa;AACb,8CAA8C,cAAc;AAC5D,qBAAqB,mBAAO,CAAC,qDAAgB;AAC7C,qCAAqC,mBAAO,CAAC,iGAA8B;AAC3E,yBAAyB,mBAAO,CAAC,qEAAgB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,UAAU;AAC7C,qDAAqD,eAAe;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,aAAa;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gD;;;;;;;;;;;;ACnEa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,uBAAuB,mBAAO,CAAC,yEAAkB;AACjD;AACA,SAAS,mBAAO,CAAC,uFAAyB;AAC1C,SAAS,mBAAO,CAAC,qFAAwB;AACzC,qBAAqB,mBAAO,CAAC,qEAAgB;AAC7C;AACA,SAAS,mBAAO,CAAC,yFAA0B;AAC3C,SAAS,mBAAO,CAAC,yDAAU;AAC3B,SAAS,mBAAO,CAAC,uEAAiB;AAClC,SAAS,mBAAO,CAAC,6EAAoB;AACrC,SAAS,mBAAO,CAAC,iGAA8B;AAC/C,SAAS,mBAAO,CAAC,qFAAwB;AACzC,4BAA4B,mBAAO,CAAC,mFAAuB;AAC3D;AACA,iC;;;;;;;;;;;;ACnBa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4C;;;;;;;;;;;;ACda;AACb,8CAA8C,cAAc;AAC5D,sBAAsB,mBAAO,CAAC,6DAAiB;AAC/C,wBAAwB,mBAAO,CAAC,iEAAmB;AACnD,sCAAsC,mBAAO,CAAC,kGAAiC;AAC/E,0BAA0B,mBAAO,CAAC,gEAAqB;AACvD,qBAAqB,mBAAO,CAAC,qDAAgB;AAC7C,mBAAmB,mBAAO,CAAC,iEAAY;AACvC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,iCAAiC;AAChG;AACA;AACA;AACA;AACA,gFAAgF;AAChF,iGAAiG;AACjG;AACA;AACA,aAAa;AACb,SAAS,KAAK,aAAa;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF,aAAa;AACtG;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,+CAA+C,EAAE,SAAS,8CAA8C;AACxG;AACA;AACA,oDAAoD,iBAAiB,OAAO,iBAAiB,WAAW,gBAAgB,OAAO,YAAY,aAAa,yBAAyB,iBAAiB,cAAc;AAChN;AACA,sEAAsE,KAAK;AAC3E,KAAK;AACL;AACA;AACA,8CAA8C,QAAQ;AACtD,KAAK;AACL;AACA;AACA,+DAA+D,wCAAwC;AACvG,KAAK;AACL;AACA;AACA,wDAAwD,IAAI,SAAS,oDAAoD;AACzH;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,UAAU;AACzE;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,oC;;;;;;;;;;;;ACrJa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,SAAS,mBAAO,CAAC,iEAAY;AAC7B,SAAS,mBAAO,CAAC,iEAAY;AAC7B,iC;;;;;;;;;;;;ACPa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,wBAAwB,mBAAO,CAAC,cAAI;AACpC,wBAAwB,mBAAO,CAAC,cAAI;AACpC,0BAA0B,mBAAO,CAAC,kBAAM;AACxC,0BAA0B,mBAAO,CAAC,kBAAM;AACxC,2BAA2B,mBAAO,CAAC,gDAAO;AAC1C,sBAAsB,mBAAO,CAAC,6DAAiB;AAC/C,2BAA2B,mBAAO,CAAC,qEAAsB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;;;;;;ACzFa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,yBAAyB,mBAAO,CAAC,gBAAK;AACtC,6BAA6B,mBAAO,CAAC,sDAAU;AAC/C,6BAA6B,mBAAO,CAAC,sEAAwB;AAC7D,qBAAqB,mBAAO,CAAC,qDAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,wBAAwB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,gBAAgB;AAC3D,iDAAiD,6BAA6B,aAAa,kBAAkB,QAAQ,8BAA8B;AACnJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,6BAA6B,aAAa,kBAAkB,QAAQ,8BAA8B;AAC5J;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,kBAAkB,eAAe,wBAAwB;AACxH;AACA;AACA,2EAA2E,kBAAkB;AAC7F;AACA;AACA;AACA,kEAAkE,kBAAkB;AACpF;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,kBAAkB;AAC7E;AACA,aAAa;AACb;AACA,mEAAmE,kBAAkB;AACrF;AACA,aAAa;AACb,sDAAsD,uBAAuB,GAAG,kBAAkB;AAClG;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iEAAiE,UAAU;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,8DAA8D,UAAU,sBAAsB,8DAA8D;AAC5J;AACA;AACA;AACA,6DAA6D,UAAU;AACvE;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8C;;;;;;;;;;;;ACnNa;AACb,8CAA8C,cAAc;AAC5D,kBAAkB,mBAAO,CAAC,qDAAa;AACvC,yCAAyC,mBAAO,CAAC,uFAAkC;AACnF,qBAAqB,mBAAO,CAAC,qDAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,KAAK;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA,yGAAyG,KAAK;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA,wGAAwG,KAAK;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF,KAAK;AAC9F;AACA;AACA;AACA;AACA,mD;;;;;;;;;;;;ACzCa;AACb,8CAA8C,cAAc;AAC5D,kBAAkB,mBAAO,CAAC,qDAAa;AACvC,yBAAyB,mBAAO,CAAC,kEAAoB;AACrD,6BAA6B,mBAAO,CAAC,+DAAsB;AAC3D,yCAAyC,mBAAO,CAAC,uFAAkC;AACnF,qBAAqB,mBAAO,CAAC,qDAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,YAAY;AACnF;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA,wEAAwE,KAAK;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,yFAAyF,KAAK;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qGAAqG,wBAAwB;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oD;;;;;;;;;;;;AC3Ga;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA,0D;;;;;;;;;;;;ACPa;AACb;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,qBAAqB,mBAAO,CAAC,qDAAgB;AAC7C,8BAA8B,mBAAO,CAAC,iFAAyB;AAC/D,mCAAmC,mBAAO,CAAC,kFAA8B;AACzE,yBAAyB,mBAAO,CAAC,8DAAoB;AACrD,iBAAiB,mBAAO,CAAC,0DAAY;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA,0JAA0J,mBAAmB;AAC7K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,YAAY,aAAa,MAAM;AAC/G,4DAA4D,YAAY,GAAG,MAAM;AACjF;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+C;;;;;;;;;;;;ACzFa;AACb,8CAA8C,cAAc;AAC5D,8BAA8B,mBAAO,CAAC,iFAAyB;AAC/D,qBAAqB,mBAAO,CAAC,qDAAgB;AAC7C,8BAA8B,mBAAO,CAAC,4EAAuB;AAC7D,sBAAsB,mBAAO,CAAC,0EAA4B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,0C;;;;;;;;;;;;ACfa;AACb,8CAA8C,cAAc;AAC5D,uCAAuC,mBAAO,CAAC,uFAAkC;AACjF;AACA,uBAAuB,mBAAO,CAAC,6EAA6B;AAC5D;AACA,iCAAiC,mBAAO,CAAC,2EAA4B;AACrE;AACA,gCAAgC,mBAAO,CAAC,yEAA2B;AACnE;AACA,2BAA2B,mBAAO,CAAC,+DAAsB;AACzD;AACA,iC;;;;;;;;;;;;ACZa;AACb,8CAA8C,cAAc;AAC5D,2BAA2B,mBAAO,CAAC,iEAAsB;AACzD;AACA,uC;;;;;;;;;;;;;;;;;;;;;ACJA,qHAAsC;AAKtC,+FAA6F;AAE7F,qIAA6F;AAE7F,MAAM,IAAI,GACN,4CAAmB,EAAE;KACpB,MAAM,CAAC,aAAa,EAAE;IACnB,WAAW,EAAE,cAAc;IAC3B,KAAK,EAAE,GAAG;IACV,IAAI,EAAE,QAAQ;CACjB,CAAC;KACD,IAAI,CAAC;AAEV,MAAM,eAAe;IAGjB,YAAY,WAAwB;QAChC,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE;YACnB,WAAW,CAAC,KAAK,CAAC,kCAAkC,CAAC,CAAC;YACtD,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;SACnB;QAED,MAAM,aAAa,GAAG,8CAA6B,CAAC,WAAW,CAAC,CAAC;QACjE,IAAI,CAAC,wBAAwB,GAAG,IAAI,yCAAwB,CACxD,WAAW,EACX,IAAI,CAAC,WAAW,EAChB,aAAa,CAChB,CAAC;IACN,CAAC;IAEM,MAAM,CAAC,MAAkB;QAC5B,MAAM,aAAa,GAAG,IAAI,GAAG,CAAC,mBAAmB,CAAC,MAAM,CAAC,CAAC;QAC1D,MAAM,aAAa,GAAG,IAAI,GAAG,CAAC,mBAAmB,CAAC,MAAM,CAAC,CAAC;QAC1D,MAAM,aAAa,GAAI,IAAI,CAAC,wBAAwB,CAAC,YAAY,CAAC;YAC9D,MAAM,EAAE,aAAa;YACrB,MAAM,EAAE,aAAa;SACxB,CAAC,CAAC;QAEH,OAAQ,OAAO,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC;IAC3C,CAAC;IAEM,OAAO;QACV,OAAO,IAAI,CAAC,wBAAwB,CAAC,eAAe,EAAE,CAAC;IAC3D,CAAC;CACJ;AAED,MAAM,OAAO,GAAkB,MAAM,CAAC,MAAM,CAAC;IACzC,IAAI,EAAE,gBAAgB;IACtB,WAAW,EAAE,wBAAwB;IACrC,eAAe,EAAE,6BAA6B;IAC9C,OAAO,EAAE,IAAI;CAChB,EAAE,4CAAmB,EAAE,CAAC,IAAI,CAAC,CAAC;AAE/B,oCAAW,CAAC,OAAO,EAAE,CAAC,iBAAiB,EAAE,WAAW,EAAE,EAAE,CAAC,IAAI,eAAe,CAAC,WAAW,CAAC,CAAC;KACrF,IAAI,CAAC,CAAC,WAAW,EAAE,EAAE;IAClB,WAAW,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;AACpC,CAAC,CAAC;KACD,KAAK,CAAC,GAAG,CAAC,EAAE;IACT,sCAAsC;IACtC,OAAO,CAAC,KAAK,CAAC,cAAc,GAAG,EAAE,CAAC,CAAC;AACvC,CAAC,CAAC,CAAC;;;;;;;;;;;;ACjEP,mC;;;;;;;;;;;ACAA,wC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,0C;;;;;;;;;;;ACAA,oC;;;;;;;;;;;ACAA,sC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,gC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,+B;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,kC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,gC;;;;;;;;;;;ACAA,+B;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,uC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,gC;;;;;;;;;;;ACAA,gC;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,iC","file":"port-forwarder-hub.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./app.ts\");\n","/**\r\n * Base error for the HttpClient.\r\n */\r\nexport class HttpError extends Error {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.errorType = 'HttpError';\r\n    }\r\n}\r\nexport class HttpClientError extends HttpError {\r\n    constructor(reason) {\r\n        super(reason);\r\n        this.errorType = 'HttpClientError';\r\n        if (reason instanceof HttpClientError) {\r\n            return reason;\r\n        }\r\n        let message;\r\n        if (reason instanceof Error) {\r\n            message = reason.message;\r\n        }\r\n        else if (typeof reason === 'string') {\r\n            message = reason;\r\n        }\r\n        else {\r\n            message = '';\r\n        }\r\n        this.message = message;\r\n        this.name = 'HttpClientError';\r\n        if (typeof Error.captureStackTrace === 'function') {\r\n            Error.captureStackTrace(this, HttpClientError);\r\n        }\r\n    }\r\n}\r\nexport class HttpClientAuthenticationError extends HttpError {\r\n    constructor(response) {\r\n        super(`Request failed with status code ${response.status}.`);\r\n        this.response = response;\r\n        this.errorType = 'HttpClientAuthenticationError';\r\n        this.name = 'HttpClientAuthenticationError';\r\n        if (typeof Error.captureStackTrace === 'function') {\r\n            Error.captureStackTrace(this, HttpClientAuthenticationError);\r\n        }\r\n    }\r\n}\r\nexport class HttpClientResponseError extends HttpError {\r\n    constructor(response) {\r\n        super(`Request failed with status code ${response.status}.`);\r\n        this.response = response;\r\n        this.errorType = 'HttpClientResponseError';\r\n        this.name = 'HttpClientResponseError';\r\n        if (typeof Error.captureStackTrace === 'function') {\r\n            Error.captureStackTrace(this, HttpClientResponseError);\r\n        }\r\n    }\r\n}\r\nexport class HttpCancellationError extends HttpError {\r\n    constructor(reason = undefined) {\r\n        super(reason);\r\n        this.errorType = 'HttpCancellationError';\r\n        this.name = 'CancellationError';\r\n        if (typeof Error.captureStackTrace === 'function') {\r\n            Error.captureStackTrace(this, HttpCancellationError);\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=Errors.js.map","import { toAbortSignal } from './toAbortSignal';\r\nimport { createTimeoutTokenSource } from './createTimeoutTokenSource';\r\nimport { HttpCancellationError, HttpClientResponseError, HttpClientError, HttpClientAuthenticationError, } from './Errors';\r\nimport { Request, fetch } from './fetch';\r\n// TODO: Implement disposal of requests\r\nexport class FetchRequest {\r\n    constructor(logger, configuration, request, init, cancellationToken) {\r\n        var _a;\r\n        this.logger = logger;\r\n        this.configuration = configuration;\r\n        this.request = request;\r\n        this.init = init;\r\n        this.cancellationToken = cancellationToken;\r\n        this.retry = 0;\r\n        this.input = this.request instanceof URL ? this.request.toString() : this.request;\r\n        // We extract the method for logging purposes.\r\n        let method = 'GET';\r\n        if (typeof this.input !== 'string') {\r\n            method = this.input.method;\r\n        }\r\n        if ((_a = this.init) === null || _a === void 0 ? void 0 : _a.method) {\r\n            method = this.init.method;\r\n        }\r\n        this.method = method;\r\n        // We also extract the url\r\n        this.url = typeof this.input === 'string' ? this.input : this.input.url;\r\n    }\r\n    then(onfulfilled, onrejected) {\r\n        return this.fetch().then(onfulfilled, onrejected);\r\n    }\r\n    async text() {\r\n        const response = await this.fetchWithCancellationCheck();\r\n        return await response.text();\r\n    }\r\n    async json() {\r\n        const response = await this.fetchWithCancellationCheck();\r\n        return await response.json();\r\n    }\r\n    async arrayBuffer() {\r\n        const response = await this.fetchWithCancellationCheck();\r\n        return await response.arrayBuffer();\r\n    }\r\n    async blob() {\r\n        const response = await this.fetchWithCancellationCheck();\r\n        return await response.blob();\r\n    }\r\n    async formData() {\r\n        const response = await this.fetchWithCancellationCheck();\r\n        return await response.formData();\r\n    }\r\n    async value() {\r\n        return (await this.json());\r\n    }\r\n    async fetch() {\r\n        var _a;\r\n        this.logger.verbose(`${this.method} - fetch start`);\r\n        if ((_a = this.cancellationToken) === null || _a === void 0 ? void 0 : _a.isCancellationRequested) {\r\n            throw new HttpCancellationError();\r\n        }\r\n        const transformedRequest = await this.prepareRequest();\r\n        this.ongoingPromise = this.retryRequest(transformedRequest);\r\n        return await this.ongoingPromise;\r\n    }\r\n    async fetchWithCancellationCheck() {\r\n        var _a;\r\n        const response = await this.fetch();\r\n        if ((_a = this.cancellationToken) === null || _a === void 0 ? void 0 : _a.isCancellationRequested) {\r\n            throw new HttpCancellationError();\r\n        }\r\n        return response;\r\n    }\r\n    async makeRequest(request) {\r\n        let response;\r\n        try {\r\n            response = await fetch(request);\r\n            this.logger.verbose(`${this.method} - fetch response. (url=${this.url};status=${response.status})`);\r\n        }\r\n        catch (err) {\r\n            if (err.name === 'AbortError') {\r\n                this.logger.verbose(`${this.method} - fetch cancelled. (url=${this.url};cancelled=true)`);\r\n                throw new HttpCancellationError(err.message);\r\n            }\r\n            this.logger.verbose(`${this.method} - fetch failed. (url=${this.url};reason=${err.message};failed=true)`);\r\n            throw new HttpClientError(err);\r\n        }\r\n        if (this.configuration.throwOnErrorStatus &&\r\n            (response.status === 401 || response.status === 403)) {\r\n            throw new HttpClientAuthenticationError(response);\r\n        }\r\n        if (this.configuration.throwOnErrorStatus && !response.ok) {\r\n            throw new HttpClientResponseError(response);\r\n        }\r\n        return response;\r\n    }\r\n    async retryRequest(originalRequest) {\r\n        try {\r\n            return await this.makeRequest(originalRequest);\r\n        }\r\n        catch (err) {\r\n            if (!this.shouldRetry(err)) {\r\n                throw err;\r\n            }\r\n            const transformedRequest = await this.prepareRetryRequest(originalRequest, err.response);\r\n            await this.delayRetry(err);\r\n            this.retry++;\r\n            return await this.retryRequest(transformedRequest);\r\n        }\r\n    }\r\n    shouldRetry(error) {\r\n        if (this.retry >= this.configuration.retryCount) {\r\n            return false;\r\n        }\r\n        if (error instanceof HttpClientResponseError &&\r\n            error.response &&\r\n            this.configuration.retryStatusCodes.includes(error.response.status)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    delayRetry(error) {\r\n        // We'll use the retry count based delay as minimum\r\n        let delay = this.retry * 1000;\r\n        if (error instanceof HttpClientResponseError) {\r\n            const response = error.response;\r\n            // Retry-After header specifies how long to wait after a 503, 429, or 301.\r\n            // The value can either be a number of seconds or a Date.\r\n            //\r\n            // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After\r\n            //\r\n            const retryAfter = response.headers.get('Retry-After');\r\n            if (retryAfter !== null) {\r\n                let after = Number(retryAfter);\r\n                if (!isNaN(after)) {\r\n                    after *= 1000;\r\n                }\r\n                else {\r\n                    after = Math.max(Date.parse(retryAfter) - Date.now(), 0);\r\n                }\r\n                if (!isNaN(after)) {\r\n                    delay = Math.max(delay, after);\r\n                }\r\n            }\r\n        }\r\n        return new Promise((resolve) => {\r\n            // tslint:disable-next-line: no-string-based-set-timeout\r\n            setTimeout(resolve, delay);\r\n        });\r\n    }\r\n    async prepareRequest() {\r\n        var _a;\r\n        let request = new Request(this.input, Object.assign({ credentials: 'same-origin' }, this.init));\r\n        if (this.configuration.beforeRequest) {\r\n            request = await this.configuration.beforeRequest(request);\r\n        }\r\n        // We create new timeout cancellation token per retry\r\n        const cancellationToken = (_a = this.cancellationToken) !== null && _a !== void 0 ? _a : createTimeoutTokenSource(this.configuration.timeout).token;\r\n        return new Request(request, { signal: toAbortSignal(cancellationToken) });\r\n    }\r\n    async prepareRetryRequest(originalRequest, requestError) {\r\n        var _a;\r\n        let transformedRequest = originalRequest;\r\n        if (this.configuration.beforeRetry) {\r\n            const beforeRetryHookResult = await this.configuration.beforeRetry(originalRequest, requestError, this.retry);\r\n            if (Array.isArray(beforeRetryHookResult)) {\r\n                this.retry = beforeRetryHookResult[1];\r\n                transformedRequest = beforeRetryHookResult[0];\r\n            }\r\n            else {\r\n                transformedRequest = beforeRetryHookResult;\r\n            }\r\n        }\r\n        // We create new timeout cancellation token per retry\r\n        const cancellationToken = (_a = this.cancellationToken) !== null && _a !== void 0 ? _a : createTimeoutTokenSource(this.configuration.timeout).token;\r\n        return new Request(transformedRequest, { signal: toAbortSignal(cancellationToken) });\r\n    }\r\n}\r\n//# sourceMappingURL=FetchRequest.js.map","import { CancellationTokenSource } from 'vscode-jsonrpc';\r\nexport function createTimeoutTokenSource(timeout) {\r\n    const tokenSource = new CancellationTokenSource();\r\n    const timeoutHandle = setTimeout(() => {\r\n        tokenSource.cancel();\r\n    }, timeout);\r\n    return {\r\n        cancel: tokenSource.cancel.bind(tokenSource),\r\n        dispose() {\r\n            clearTimeout(timeoutHandle);\r\n            tokenSource.dispose();\r\n        },\r\n        token: tokenSource.token,\r\n    };\r\n}\r\n//# sourceMappingURL=createTimeoutTokenSource.js.map","import { default as nodeFetch, Request as NodeRequest } from 'node-fetch';\r\nimport { AbortController as NodeAbortController } from 'abort-controller';\r\nconst __mock_value = {\r\n    fetch: undefined,\r\n    Request: undefined,\r\n    AbortController: undefined,\r\n};\r\nconst { fetch: browserFetch, Request: BrowserRequest, AbortController: BrowserAbortController } = typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : __mock_value;\r\nexport var fetch = browserFetch !== null && browserFetch !== void 0 ? browserFetch : nodeFetch;\r\nexport var Request = BrowserRequest !== null && BrowserRequest !== void 0 ? BrowserRequest : NodeRequest;\r\nexport var AbortController = BrowserAbortController !== null && BrowserAbortController !== void 0 ? BrowserAbortController : NodeAbortController;\r\n//# sourceMappingURL=fetch.js.map","import { FetchRequest } from './FetchRequest';\r\nconst globals = {\r\n    requestNumber: 1,\r\n};\r\nconst defaultConfiguration = {\r\n    timeout: 30 * 1000,\r\n    throwOnErrorStatus: true,\r\n    beforeRequest: undefined,\r\n    beforeRetry: undefined,\r\n    retryCount: 2,\r\n    retryStatusCodes: [429, 500, 503],\r\n};\r\nexport class HttpClient {\r\n    constructor(logger, configuration = {}) {\r\n        this.logger = logger;\r\n        this.configuration = Object.assign(Object.assign({}, defaultConfiguration), configuration);\r\n    }\r\n    fetch(input, init, cancellationToken) {\r\n        return new FetchRequest(this.logger.withName(`FetchRequest:${globals.requestNumber++}`), this.configuration, input, init, cancellationToken);\r\n    }\r\n    method(method, input, init, cancellationToken) {\r\n        return this.fetch(input, Object.assign(Object.assign({}, init), { method }), cancellationToken);\r\n    }\r\n    get(input, init, cancellationToken) {\r\n        return this.method('GET', input, init, cancellationToken);\r\n    }\r\n    post(input, init, cancellationToken) {\r\n        return this.method('POST', input, init, cancellationToken);\r\n    }\r\n    put(input, init, cancellationToken) {\r\n        return this.method('PUT', input, init, cancellationToken);\r\n    }\r\n    patch(input, init, cancellationToken) {\r\n        return this.method('PATCH', input, init, cancellationToken);\r\n    }\r\n    head(input, init, cancellationToken) {\r\n        return this.method('HEAD', input, init, cancellationToken);\r\n    }\r\n    delete(input, init, cancellationToken) {\r\n        return this.method('DELETE', input, init, cancellationToken);\r\n    }\r\n}\r\n//# sourceMappingURL=http-client.js.map","export { HttpClient } from './http-client';\r\nexport * from './Errors';\r\n//# sourceMappingURL=index.js.map","import { AbortController } from './fetch';\r\nexport function toAbortSignal(cancellationToken) {\r\n    const controller = new AbortController();\r\n    if (cancellationToken.isCancellationRequested) {\r\n        controller.abort();\r\n    }\r\n    const disposable = cancellationToken.onCancellationRequested(() => {\r\n        disposable.dispose();\r\n        controller.abort();\r\n    });\r\n    return controller.signal;\r\n}\r\n//# sourceMappingURL=toAbortSignal.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst minimatch = require(\"minimatch\");\r\nconst interfaces_1 = require(\"./interfaces\");\r\nclass GlobPatternTraceFilter {\r\n    constructor(globToVerbosity) {\r\n        this.globToVerbosity = globToVerbosity;\r\n        this.traceSourceVerbosityCache = new Map();\r\n    }\r\n    getTraceVerbosity(source) {\r\n        let traceVerbosity = this.traceSourceVerbosityCache.get(source);\r\n        // If we don't have a cached verbosity for this source, find the verbosity and cache it\r\n        if (typeof traceVerbosity === 'undefined') {\r\n            traceVerbosity = 0;\r\n            if (this.globToVerbosity) {\r\n                for (let traceGlob in this.globToVerbosity) {\r\n                    if (minimatch(source, traceGlob)) {\r\n                        traceVerbosity =\r\n                            interfaces_1.LogLevel[this.globToVerbosity[traceGlob]];\r\n                    }\r\n                }\r\n            }\r\n            this.traceSourceVerbosityCache.set(source, traceVerbosity);\r\n        }\r\n        return traceVerbosity;\r\n    }\r\n    shouldTrace(source, logLevel, id) {\r\n        return this.getTraceVerbosity(source) <= logLevel;\r\n    }\r\n}\r\nexports.GlobPatternTraceFilter = GlobPatternTraceFilter;\r\nif (typeof Error.prepareStackTrace === 'function') {\r\n    // Save the stack frames as a property on all errors before preparing the stack trace string.\r\n    const originalPrepareStackTrace = Error.prepareStackTrace;\r\n    Error.prepareStackTrace = function prepareVslsStack(e, s) {\r\n        e.vslsStack = s;\r\n        return originalPrepareStackTrace(e, s);\r\n    };\r\n}\r\n;\r\n//# sourceMappingURL=GlobalPatternTraceFilter.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst LogLevel_1 = require(\"./interfaces/LogLevel\");\r\n/**\r\n * Base implementation of the ILogger interface.\r\n */\r\nclass LoggerBase {\r\n    constructor(name) {\r\n        this.name = name;\r\n    }\r\n    error(message, ...args) {\r\n        this.log(LogLevel_1.LogLevel.Error, message, ...args);\r\n        return this;\r\n    }\r\n    warning(message, ...args) {\r\n        this.log(LogLevel_1.LogLevel.Warning, message, ...args);\r\n        return this;\r\n    }\r\n    info(message, ...args) {\r\n        this.log(LogLevel_1.LogLevel.Info, message, ...args);\r\n        return this;\r\n    }\r\n    verbose(message, ...args) {\r\n        this.log(LogLevel_1.LogLevel.Debug, message, ...args);\r\n        return this;\r\n    }\r\n    createChild(name) {\r\n        return this.withName(this.name + ':' + name);\r\n    }\r\n}\r\nexports.LoggerBase = LoggerBase;\r\n/**\r\n * A logger implementation that use a callback to log the values.\r\n */\r\nclass Logger extends LoggerBase {\r\n    constructor(name, logCallback) {\r\n        super(name);\r\n        this.logCallback = logCallback;\r\n    }\r\n    log(logLevel, message, ...args) {\r\n        this.logCallback(logLevel, message, ...args);\r\n        return this;\r\n    }\r\n    withName(name) {\r\n        return new Logger(name, this.logCallback);\r\n    }\r\n}\r\nexports.Logger = Logger;\r\n;\r\n//# sourceMappingURL=Logger.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst LogValueType_1 = require(\"./interfaces/LogValueType\");\r\nclass LoggerSettings {\r\n}\r\nexports.LoggerSettings = LoggerSettings;\r\n/**\r\n * If disable obfuscation is enabled/disabled.\r\n */\r\nLoggerSettings.disableObfuscation = false;\r\nLoggerSettings.obfuscateProperties = {\r\n    email: LogValueType_1.LogValueType.Email,\r\n    name: LogValueType_1.LogValueType.Text,\r\n    token: LogValueType_1.LogValueType.Text,\r\n    sessionToken: LogValueType_1.LogValueType.Text,\r\n};\r\n//# sourceMappingURL=LoggerSettings.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nconst js_sha256_1 = require(\"js-sha256\");\r\nclass Privacy {\r\n    static setKey(privacyKeyBase64) {\r\n        Privacy.privacyKey = privacyKeyBase64;\r\n    }\r\n    static getShortHash(value, length = 8, unkeyed = false) {\r\n        return this.getHash(value, unkeyed).substr(0, length);\r\n    }\r\n    static getHash(value, unkeyed = false) {\r\n        if (!value) {\r\n            return '<null>';\r\n        }\r\n        let hasher;\r\n        if (unkeyed) {\r\n            hasher = js_sha256_1.sha256.create();\r\n        }\r\n        else {\r\n            if (!Privacy.privacyKey) {\r\n                return '<redacted>';\r\n            }\r\n            hasher = js_sha256_1.sha256.hmac.create(Privacy.privacyKey);\r\n        }\r\n        return hasher\r\n            .update(value)\r\n            .hex();\r\n    }\r\n    /** Get sha256 hash of UTF8 encoded value. Undefined or null value is treated as empty string. */\r\n    static getSha256Hash(value, maxLength) {\r\n        const result = js_sha256_1.sha256.create().update(new TextEncoder().encode(value || '')).toString();\r\n        return typeof maxLength === 'number' && maxLength > 0 && result.length > maxLength ? result.substr(0, maxLength) : result;\r\n    }\r\n}\r\nexports.Privacy = Privacy;\r\n;\r\n//# sourceMappingURL=Privacy.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass TraceFilters {\r\n    constructor(filters = []) {\r\n        this.filters = filters;\r\n    }\r\n    shouldTrace(source, logLevel, id) {\r\n        return this.filters.every(t => t.shouldTrace(source, logLevel, id));\r\n    }\r\n}\r\nexports.TraceFilters = TraceFilters;\r\n//# sourceMappingURL=TraceFilters.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst dateformat = require(\"dateformat\");\r\nconst path = require(\"path\");\r\nconst Privacy_1 = require(\"./Privacy\");\r\nconst LoggerSettings_1 = require(\"./LoggerSettings\");\r\nconst LogLevel_1 = require(\"./interfaces/LogLevel\");\r\nconst LogValueType_1 = require(\"./interfaces/LogValueType\");\r\nconst utils_1 = require(\"./utils\");\r\nconst renderObjectToString = (object) => {\r\n    if (typeof object === undefined) {\r\n        return '<undefined>';\r\n    }\r\n    if (typeof object === null) {\r\n        return '<null>';\r\n    }\r\n    if (typeof object === 'string') {\r\n        return `\"${object}\"`;\r\n    }\r\n    if (typeof object === 'number') {\r\n        return `#${object}`;\r\n    }\r\n    if (typeof object === 'boolean') {\r\n        return `${object}`;\r\n    }\r\n    if (object instanceof Symbol) {\r\n        return object.toString();\r\n    }\r\n    if (object instanceof Error) {\r\n        return utils_1.errorToString(object);\r\n    }\r\n    try {\r\n        return TraceFormat.stringify(object);\r\n    }\r\n    catch (_a) {\r\n        try {\r\n            return object.toString();\r\n        }\r\n        catch (e) {\r\n            return '<unknown type>';\r\n        }\r\n    }\r\n};\r\nclass TraceFormat {\r\n    static formatDate(time, mask) {\r\n        return dateformat(time, mask || 'yyyy-mm-dd HH:MM:ss.l ', /*utc*/ true);\r\n    }\r\n    static formatEvent(time, source, logLevel, id, message, ...args) {\r\n        let eventTypeChar;\r\n        switch (logLevel) {\r\n            case LogLevel_1.LogLevel.Critical:\r\n                eventTypeChar = 'C';\r\n                break;\r\n            case LogLevel_1.LogLevel.Error:\r\n                eventTypeChar = 'E';\r\n                break;\r\n            case LogLevel_1.LogLevel.Warning:\r\n                eventTypeChar = 'W';\r\n                break;\r\n            case LogLevel_1.LogLevel.Info:\r\n                eventTypeChar = 'I';\r\n                break;\r\n            case LogLevel_1.LogLevel.Debug:\r\n                eventTypeChar = 'V';\r\n                break;\r\n            default:\r\n                eventTypeChar = '?';\r\n                break;\r\n        }\r\n        const dateString = time === null ? '' : TraceFormat.formatDate(time);\r\n        if (message.length > TraceFormat.maxMessageLength) {\r\n            message = message.substr(0, TraceFormat.maxMessageLength) + '...';\r\n        }\r\n        let line;\r\n        if (id !== 0) {\r\n            line = `[${dateString}${source} ${eventTypeChar}] (${id}) ${message}`;\r\n        }\r\n        else {\r\n            line = `[${dateString}${source} ${eventTypeChar}] ${message}`;\r\n        }\r\n        const renderedObjects = args\r\n            .map(renderObjectToString)\r\n            .map((str, i) => {\r\n            return `> object #${i}: ${str}`;\r\n        });\r\n        line += renderedObjects.join('\\n');\r\n        return line;\r\n    }\r\n    static parseEventId(formattedMessage) {\r\n        let m = formattedMessage.match(/\\] \\(([0-9]+)\\)/);\r\n        return m ? parseInt(m[1], 10) : 0;\r\n    }\r\n    static formatPath(value) {\r\n        if (!value) {\r\n            return '<null>';\r\n        }\r\n        else if (LoggerSettings_1.LoggerSettings.disableObfuscation) {\r\n            return value;\r\n        }\r\n        // Obfuscate the directory and file names, but preserve the extension\r\n        // and whether it's an absolute or relative path.\r\n        const directoryHash = Privacy_1.Privacy.getShortHash(path.dirname(value));\r\n        const extension = path.extname(value);\r\n        const fileHash = Privacy_1.Privacy.getShortHash(path.basename(value, extension));\r\n        const slashIndex = value.replace('\\\\', '/').indexOf('/');\r\n        if (slashIndex === 2 && value[1] === ':') {\r\n            // Windows style absolute path\r\n            return `<?:${value[2]}${directoryHash}${value[2]}${fileHash}${extension}>`;\r\n        }\r\n        else if (slashIndex === 0) {\r\n            // Unix style absolute path\r\n            return `<${value[0]}${directoryHash}${value[0]}${fileHash}${extension}>`;\r\n        }\r\n        else if (slashIndex > 0) {\r\n            // Relative path\r\n            return `<${directoryHash}${value[slashIndex]}${fileHash}${extension}>`;\r\n        }\r\n        else {\r\n            // Simple file name\r\n            return `<${fileHash}${extension}>`;\r\n        }\r\n    }\r\n    static formatEmail(value) {\r\n        if (!value) {\r\n            return '<null>';\r\n        }\r\n        else if (LoggerSettings_1.LoggerSettings.disableObfuscation) {\r\n            return value;\r\n        }\r\n        const emailHash = Privacy_1.Privacy.getShortHash(value);\r\n        return `<${emailHash.substr(0, 4)}@${emailHash.substr(4)}>`;\r\n    }\r\n    static formatText(value) {\r\n        if (!value) {\r\n            return '<null>';\r\n        }\r\n        else if (LoggerSettings_1.LoggerSettings.disableObfuscation) {\r\n            return value;\r\n        }\r\n        const valueHash = Privacy_1.Privacy.getShortHash(value);\r\n        return `<${value.length}:${valueHash}>`;\r\n    }\r\n    static stringify(value) {\r\n        if (LoggerSettings_1.LoggerSettings.disableObfuscation) {\r\n            return JSON.stringify(value, null, 2);\r\n        }\r\n        return JSON.stringify(value, (key, value) => {\r\n            if (value instanceof Error) {\r\n                return utils_1.errorToString(value);\r\n            }\r\n            const logValueType = LoggerSettings_1.LoggerSettings.obfuscateProperties[key];\r\n            if (logValueType) {\r\n                switch (logValueType) {\r\n                    case LogValueType_1.LogValueType.Text:\r\n                        return TraceFormat.formatText(value);\r\n                    case LogValueType_1.LogValueType.Email:\r\n                        return TraceFormat.formatEmail(value);\r\n                    case LogValueType_1.LogValueType.Path:\r\n                        return TraceFormat.formatPath(value);\r\n                }\r\n            }\r\n            return value;\r\n        }, 2);\r\n    }\r\n}\r\nexports.TraceFormat = TraceFormat;\r\nTraceFormat.maxMessageLength = 5120;\r\n//# sourceMappingURL=TraceFormat.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst TraceFormat_1 = require(\"./TraceFormat\");\r\n/**\r\n * Base class for a listener for events from a TraceSource.\r\n */\r\nclass TraceListener {\r\n    constructor() {\r\n        this.filter = null;\r\n    }\r\n    traceEvent(source, logLevel, id, message, ...args) {\r\n        if (!this.filter || this.filter.shouldTrace(source, logLevel, id)) {\r\n            this.writeEvent(source, logLevel, id, message, ...args);\r\n        }\r\n    }\r\n    writeLine(source, line, includeTimestamp) {\r\n        if (includeTimestamp) {\r\n            line = `[${TraceFormat_1.TraceFormat.formatDate(new Date())} ${source}] ${line}`;\r\n        }\r\n        this.writeTo(line);\r\n    }\r\n}\r\nexports.TraceListener = TraceListener;\r\n//# sourceMappingURL=TraceListener.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst events_1 = require(\"events\");\r\nconst interfaces_1 = require(\"./interfaces\");\r\n/**\r\n * Source for tracing events that associates a name with every event.\r\n */\r\nclass TraceSource extends events_1.EventEmitter {\r\n    constructor(name) {\r\n        super();\r\n        this.name = name;\r\n    }\r\n    /**\r\n     * Creates a new TraceSource with listeners copied from the existing TraceSource.\r\n     */\r\n    withName(name) {\r\n        const newTraceSource = new TraceSource(name);\r\n        this.eventNames().forEach((eventName) => {\r\n            this.listeners(eventName).forEach((listener) => {\r\n                newTraceSource.on(eventName, listener);\r\n            });\r\n        });\r\n        return newTraceSource;\r\n    }\r\n    /**\r\n     * Same as `withName` but the child trace inherits the parent name\r\n     * as the prefix of the it's name, e.g. `parent-name:name`.\r\n     * Useful to define additional context when same component frequently\r\n     * used in many places.\r\n     * Another user-case is to define a package-wide main trace and use\r\n     * the method to create loggers that are child of the main one.\r\n     */\r\n    createChild(name) {\r\n        return this.withName(`${this.name}:${name}`);\r\n    }\r\n    addTraceListener(listener) {\r\n        this.on(TraceSource.eventEventName, listener.traceEvent.bind(listener));\r\n        this.on(TraceSource.lineEventName, listener.writeLine.bind(listener));\r\n        if (listener.flushEvents) {\r\n            this.on(TraceSource.flushEventName, listener.flushEvents.bind(listener));\r\n        }\r\n    }\r\n    async flushEvents() {\r\n        await Promise.all(this.listeners(TraceSource.flushEventName).map(f => Promise.resolve(f())));\r\n    }\r\n    writeLine(line) {\r\n        this.emit(TraceSource.lineEventName, this.name, line);\r\n    }\r\n    log(logLevel, message, ...args) {\r\n        this.traceEvent(logLevel, 0, message, ...args);\r\n        return this;\r\n    }\r\n    traceEvent(logLevel, id, message, ...args) {\r\n        this.emit(TraceSource.eventEventName, this.name, logLevel, id, message, ...args);\r\n    }\r\n    errorEvent(id, message, ...args) {\r\n        this.traceEvent(interfaces_1.LogLevel.Error, id, message, ...args);\r\n    }\r\n    warningEvent(id, message, ...args) {\r\n        this.traceEvent(interfaces_1.LogLevel.Warning, id, message, ...args);\r\n    }\r\n    infoEvent(id, message, ...args) {\r\n        this.traceEvent(interfaces_1.LogLevel.Info, id, message, ...args);\r\n    }\r\n    error(message, ...args) {\r\n        this.traceEvent(interfaces_1.LogLevel.Error, 0, message, ...args);\r\n        return this;\r\n    }\r\n    warning(message, ...args) {\r\n        this.traceEvent(interfaces_1.LogLevel.Warning, 0, message, ...args);\r\n        return this;\r\n    }\r\n    info(message, ...args) {\r\n        this.traceEvent(interfaces_1.LogLevel.Info, 0, message, ...args);\r\n        return this;\r\n    }\r\n    verbose(message, ...args) {\r\n        this.traceEvent(interfaces_1.LogLevel.Debug, 0, message, ...args);\r\n        return this;\r\n    }\r\n}\r\nexports.TraceSource = TraceSource;\r\nTraceSource.lineEventName = 'line';\r\nTraceSource.eventEventName = 'event';\r\nTraceSource.flushEventName = 'flush';\r\n//# sourceMappingURL=TraceSource.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass VerbosityTraceFilter {\r\n    constructor(verbosity) {\r\n        this.verbosity = verbosity;\r\n    }\r\n    shouldTrace(source, logLevel, id) {\r\n        return this.verbosity === undefined || this.verbosity <= logLevel;\r\n    }\r\n}\r\nexports.VerbosityTraceFilter = VerbosityTraceFilter;\r\n//# sourceMappingURL=VerbosityTraceFilter.js.map","\"use strict\";\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Interfaces.\r\n */\r\n__export(require(\"./interfaces\"));\r\n/**\r\n * Listeners.\r\n */\r\n__export(require(\"./listeners\"));\r\n/**\r\n * Loggers.\r\n */\r\n__export(require(\"./loggers\"));\r\n/**\r\n * Utils.\r\n */\r\n__export(require(\"./utils\"));\r\n/**\r\n * Mocks.\r\n */\r\n__export(require(\"./mocks\"));\r\n/**\r\n * Misc.\r\n */\r\nvar LoggerSettings_1 = require(\"./LoggerSettings\");\r\nexports.LoggerSettings = LoggerSettings_1.LoggerSettings;\r\nvar GlobalPatternTraceFilter_1 = require(\"./GlobalPatternTraceFilter\");\r\nexports.GlobPatternTraceFilter = GlobalPatternTraceFilter_1.GlobPatternTraceFilter;\r\nvar VerbosityTraceFilter_1 = require(\"./VerbosityTraceFilter\");\r\nexports.VerbosityTraceFilter = VerbosityTraceFilter_1.VerbosityTraceFilter;\r\nvar TraceListener_1 = require(\"./TraceListener\");\r\nexports.TraceListener = TraceListener_1.TraceListener;\r\nvar TraceFormat_1 = require(\"./TraceFormat\");\r\nexports.TraceFormat = TraceFormat_1.TraceFormat;\r\nvar TraceSource_1 = require(\"./TraceSource\");\r\nexports.TraceSource = TraceSource_1.TraceSource;\r\nvar TraceFilters_1 = require(\"./TraceFilters\");\r\nexports.TraceFilters = TraceFilters_1.TraceFilters;\r\nvar Logger_1 = require(\"./Logger\");\r\nexports.Logger = Logger_1.Logger;\r\nexports.LoggerBase = Logger_1.LoggerBase;\r\nvar Privacy_1 = require(\"./Privacy\");\r\nexports.Privacy = Privacy_1.Privacy;\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * The severity level of a log message.\r\n */\r\nvar LogLevel;\r\n(function (LogLevel) {\r\n    LogLevel[LogLevel[\"Trace\"] = 1] = \"Trace\";\r\n    LogLevel[LogLevel[\"Debug\"] = 2] = \"Debug\";\r\n    LogLevel[LogLevel[\"Info\"] = 3] = \"Info\";\r\n    LogLevel[LogLevel[\"Warning\"] = 4] = \"Warning\";\r\n    LogLevel[LogLevel[\"Error\"] = 5] = \"Error\";\r\n    LogLevel[LogLevel[\"Critical\"] = 6] = \"Critical\";\r\n    LogLevel[LogLevel[\"Off\"] = 7] = \"Off\";\r\n})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));\r\n;\r\n//# sourceMappingURL=LogLevel.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * The log value types we support.\r\n */\r\nvar LogValueType;\r\n(function (LogValueType) {\r\n    LogValueType[LogValueType[\"None\"] = 0] = \"None\";\r\n    LogValueType[LogValueType[\"Text\"] = 1] = \"Text\";\r\n    LogValueType[LogValueType[\"Path\"] = 2] = \"Path\";\r\n    LogValueType[LogValueType[\"Email\"] = 3] = \"Email\";\r\n})(LogValueType = exports.LogValueType || (exports.LogValueType = {}));\r\n;\r\n//# sourceMappingURL=LogValueType.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar LogLevel_1 = require(\"./LogLevel\");\r\nexports.LogLevel = LogLevel_1.LogLevel;\r\nvar LogValueType_1 = require(\"./LogValueType\");\r\nexports.LogValueType = LogValueType_1.LogValueType;\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst LogLevel_1 = require(\"../interfaces/LogLevel\");\r\nconst loggers_1 = require(\"../loggers\");\r\nconst ConsoleTraceListener_1 = require(\"./ConsoleTraceListener\");\r\n/**\r\n * A trace listener using the `console`.\r\n */\r\nclass BrowserConsoleTraceListener extends ConsoleTraceListener_1.ConsoleTraceListener {\r\n    constructor(consoleReference = new loggers_1.DebugConsoleLogger()) {\r\n        super(consoleReference);\r\n    }\r\n    writeEvent(source, logLevel, id, message, ...args) {\r\n        switch (logLevel) {\r\n            case LogLevel_1.LogLevel.Critical:\r\n            case LogLevel_1.LogLevel.Error: {\r\n                return this.consoleReference.error(source, message, ...args);\r\n            }\r\n            case LogLevel_1.LogLevel.Warning: {\r\n                return this.consoleReference.warn(source, message, ...args);\r\n            }\r\n            case LogLevel_1.LogLevel.Debug: {\r\n                return (this.consoleReference.debug)\r\n                    ? this.consoleReference.debug(source, message, ...args)\r\n                    : this.consoleReference.info(source, message, ...args);\r\n            }\r\n            default: {\r\n                return this.consoleReference.info(source, message, ...args);\r\n            }\r\n        }\r\n    }\r\n    ;\r\n}\r\nexports.BrowserConsoleTraceListener = BrowserConsoleTraceListener;\r\n;\r\n//# sourceMappingURL=BrowserConsoleTraceLogger.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst LogLevel_1 = require(\"../interfaces/LogLevel\");\r\nconst TraceFormat_1 = require(\"../TraceFormat\");\r\nconst TraceListener_1 = require(\"../TraceListener\");\r\n/**\r\n * A trace listener using the `console`.\r\n */\r\nclass ConsoleTraceListener extends TraceListener_1.TraceListener {\r\n    constructor(consoleReference = console) {\r\n        super();\r\n        this.consoleReference = consoleReference;\r\n    }\r\n    writeTo(line) {\r\n        this.consoleReference.log(line);\r\n    }\r\n    writeEvent(source, logLevel, id, message, ...args) {\r\n        const line = TraceFormat_1.TraceFormat.formatEvent(null, source, logLevel, id, message, ...args);\r\n        switch (logLevel) {\r\n            case LogLevel_1.LogLevel.Critical:\r\n            case LogLevel_1.LogLevel.Error: {\r\n                return this.consoleReference.error(line);\r\n            }\r\n            case LogLevel_1.LogLevel.Warning: {\r\n                return this.consoleReference.warn(line);\r\n            }\r\n            case LogLevel_1.LogLevel.Debug: {\r\n                return (this.consoleReference.debug)\r\n                    ? this.consoleReference.debug(line)\r\n                    : this.consoleReference.log(line);\r\n            }\r\n            default: {\r\n                return this.consoleReference.log(line);\r\n            }\r\n        }\r\n    }\r\n    ;\r\n}\r\nexports.ConsoleTraceListener = ConsoleTraceListener;\r\n;\r\n//# sourceMappingURL=ConsoleTraceListener.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst TraceFormat_1 = require(\"../TraceFormat\");\r\nconst TraceListener_1 = require(\"../TraceListener\");\r\n/**\r\n * A memory trace listener.\r\n */\r\nclass MemoryTraceListener extends TraceListener_1.TraceListener {\r\n    constructor(maxLogSize) {\r\n        super();\r\n        this.allLogs = [];\r\n        this.logsByLevel = new Map();\r\n        this.maxLogSize = maxLogSize || 128;\r\n    }\r\n    getLogs(logLevel) {\r\n        if (logLevel) {\r\n            const logs = this.logsByLevel.get(logLevel);\r\n            return logs ? logs.map(i => i) : [];\r\n        }\r\n        return this.allLogs.map(i => i);\r\n    }\r\n    writeTo(line) {\r\n        this.addLine(line);\r\n    }\r\n    addLine(line, logLevel) {\r\n        this.allLogs.push(line);\r\n        if (this.allLogs.length > this.maxLogSize) {\r\n            this.allLogs.splice(0, 1);\r\n        }\r\n        if (logLevel) {\r\n            const logEntries = this.logsByLevel.get(logLevel);\r\n            if (!logEntries) {\r\n                this.logsByLevel.set(logLevel, [line]);\r\n            }\r\n            else {\r\n                logEntries.push(line);\r\n                if (logEntries.length > this.maxLogSize) {\r\n                    logEntries.splice(0, 1);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    writeEvent(source, logLevel, id, message, ...args) {\r\n        const line = TraceFormat_1.TraceFormat.formatEvent(new Date(), source, logLevel, id, message, ...args);\r\n        this.addLine(line, logLevel);\r\n    }\r\n    ;\r\n}\r\nexports.MemoryTraceListener = MemoryTraceListener;\r\n;\r\n//# sourceMappingURL=MemoryTraceListener.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst TraceFormat_1 = require(\"../TraceFormat\");\r\nconst TraceListener_1 = require(\"../TraceListener\");\r\nclass OutputTraceListener extends TraceListener_1.TraceListener {\r\n    constructor(outputChannelName, includeTimestamp) {\r\n        super();\r\n        this.includeTimestamp = includeTimestamp;\r\n        this.channel = null;\r\n        this.channelName = outputChannelName;\r\n    }\r\n    writeTo(line) {\r\n        if (this.channel != null) {\r\n            this.channel.appendLine(line);\r\n        }\r\n    }\r\n    writeEvent(source, logLevel, id, message, ...args) {\r\n        const line = TraceFormat_1.TraceFormat.formatEvent(this.includeTimestamp ? new Date() : null, source, logLevel, id, message, ...args);\r\n        this.writeTo(line);\r\n    }\r\n    addOutputChannel(focus) {\r\n        if (this.channel != null) {\r\n            return;\r\n        }\r\n        // Defer import of 'vscode' package.\r\n        const vscodeModule = require('vscode');\r\n        this.channel = vscodeModule.window.createOutputChannel(this.channelName);\r\n        if (focus) {\r\n            // Keep OutputChannel in focus\r\n            this.channel.show(true);\r\n        }\r\n    }\r\n    removeOutputChannel() {\r\n        if (this.channel == null) {\r\n            return;\r\n        }\r\n        this.channel.clear();\r\n        this.channel.dispose();\r\n        this.channel = null;\r\n    }\r\n}\r\nexports.OutputTraceListener = OutputTraceListener;\r\n;\r\n//# sourceMappingURL=OutputTraceListener.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar BrowserConsoleTraceLogger_1 = require(\"./BrowserConsoleTraceLogger\");\r\nexports.BrowserConsoleTraceListener = BrowserConsoleTraceLogger_1.BrowserConsoleTraceListener;\r\nvar ConsoleTraceListener_1 = require(\"./ConsoleTraceListener\");\r\nexports.ConsoleTraceListener = ConsoleTraceListener_1.ConsoleTraceListener;\r\nvar OutputTraceListener_1 = require(\"./OutputTraceListener\");\r\nexports.OutputTraceListener = OutputTraceListener_1.OutputTraceListener;\r\nvar MemoryTraceListener_1 = require(\"./MemoryTraceListener\");\r\nexports.MemoryTraceListener = MemoryTraceListener_1.MemoryTraceListener;\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst debug_1 = require(\"debug\");\r\n/**\r\n * Console logger on top of debug package.\r\n */\r\nclass DebugConsoleLogger {\r\n    constructor(console = globalThis.console) {\r\n        this.console = console;\r\n        this.tracesCache = {};\r\n        /**\r\n         * Method to create an `debug` trace isntance with the specified trace level.\r\n         * Caches the create traces for reuse to reduce GC churn.\r\n         */\r\n        this.createTrace = (source, type, consoleFunction) => {\r\n            const traceKey = `${source}:${type}`;\r\n            const cachedTrace = this.tracesCache[traceKey];\r\n            if (cachedTrace) {\r\n                return cachedTrace;\r\n            }\r\n            const trace = debug_1.default(traceKey);\r\n            trace.log = consoleFunction;\r\n            this.tracesCache[traceKey] = trace;\r\n            return trace;\r\n        };\r\n        this.log = (source, message, ...args) => {\r\n            return this.info(source, message, ...args);\r\n        };\r\n        this.info = (source, message, ...args) => {\r\n            this.createTrace(source, 'info', this.console.info)(message, ...args);\r\n        };\r\n        this.debug = (source, message, ...args) => {\r\n            const method = (this.console.debug)\r\n                ? this.console.debug\r\n                : this.console.log;\r\n            this.createTrace(source, 'trace', method)(message, ...args);\r\n        };\r\n        this.warn = (source, message, ...args) => {\r\n            this.createTrace(source, 'warn', this.console.warn)(source, message, ...args);\r\n        };\r\n        this.error = (source, message, ...args) => {\r\n            this.createTrace(source, 'error', this.console.error)(source, message, ...args);\r\n        };\r\n    }\r\n}\r\nexports.DebugConsoleLogger = DebugConsoleLogger;\r\nDebugConsoleLogger.enable = (path) => {\r\n    debug_1.default.enable(path);\r\n};\r\n//# sourceMappingURL=DebugConsoleLogger.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar DebugConsoleLogger_1 = require(\"./DebugConsoleLogger\");\r\nexports.DebugConsoleLogger = DebugConsoleLogger_1.DebugConsoleLogger;\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst DEFAULT_OPTIONS = {\r\n    info: () => { },\r\n    log: () => { },\r\n    debug: () => { },\r\n    warn: () => { },\r\n    error: () => { },\r\n};\r\nclass ConsoleLoggerMock {\r\n    constructor(options = {}) {\r\n        this.log = (...args) => {\r\n            throw new Error('The `log` method is not implemented');\r\n        };\r\n        this.info = (...args) => {\r\n            throw new Error('The `info` method is not implemented');\r\n        };\r\n        this.debug = (...args) => {\r\n            throw new Error('The `debug` method is not implemented');\r\n        };\r\n        this.warn = (...args) => {\r\n            throw new Error('The `warn` method is not implemented');\r\n        };\r\n        this.error = (...args) => {\r\n            throw new Error('The `error` method is not implemented');\r\n        };\r\n        this.optionsWithDefaults = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\r\n        this.log = this.optionsWithDefaults.log;\r\n        this.info = this.optionsWithDefaults.info;\r\n        this.warn = this.optionsWithDefaults.warn;\r\n        this.debug = this.optionsWithDefaults.debug;\r\n        this.error = this.optionsWithDefaults.error;\r\n    }\r\n}\r\nexports.ConsoleLoggerMock = ConsoleLoggerMock;\r\n;\r\n//# sourceMappingURL=TraceLoggerMock.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar TraceLoggerMock_1 = require(\"./TraceLoggerMock\");\r\nexports.ConsoleLoggerMock = TraceLoggerMock_1.ConsoleLoggerMock;\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst source_map_support_1 = require(\"source-map-support\");\r\n/**\r\n * Converts an error object to a string, including stack trace with source map transformations.\r\n */\r\nfunction errorToString(e) {\r\n    if (!e) {\r\n        return null;\r\n    }\r\n    let s = e.message || 'Unknown error';\r\n    const code = e.code;\r\n    if (code) {\r\n        s += ' code:' + code;\r\n    }\r\n    // Try to use source map information to map the stack frames back to original sources.\r\n    let stack = null;\r\n    if (e.vslsStack) {\r\n        try {\r\n            stack = e.vslsStack.map((frame) => '  at ' + source_map_support_1.wrapCallSite(frame)).join('\\n');\r\n        }\r\n        catch (e) { }\r\n    }\r\n    if (!stack) {\r\n        stack = e.stack || null;\r\n    }\r\n    if (stack) {\r\n        s += '\\n' + stack;\r\n    }\r\n    return s;\r\n}\r\nexports.errorToString = errorToString;\r\n;\r\n//# sourceMappingURL=errorToString.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar errorToString_1 = require(\"./errorToString\");\r\nexports.errorToString = errorToString_1.errorToString;\r\n//# sourceMappingURL=index.js.map","'use strict';\nmodule.exports = balanced;\nfunction balanced(a, b, str) {\n  if (a instanceof RegExp) a = maybeMatch(a, str);\n  if (b instanceof RegExp) b = maybeMatch(b, str);\n\n  var r = range(a, b, str);\n\n  return r && {\n    start: r[0],\n    end: r[1],\n    pre: str.slice(0, r[0]),\n    body: str.slice(r[0] + a.length, r[1]),\n    post: str.slice(r[1] + b.length)\n  };\n}\n\nfunction maybeMatch(reg, str) {\n  var m = str.match(reg);\n  return m ? m[0] : null;\n}\n\nbalanced.range = range;\nfunction range(a, b, str) {\n  var begs, beg, left, right, result;\n  var ai = str.indexOf(a);\n  var bi = str.indexOf(b, ai + 1);\n  var i = ai;\n\n  if (ai >= 0 && bi > 0) {\n    begs = [];\n    left = str.length;\n\n    while (i >= 0 && !result) {\n      if (i == ai) {\n        begs.push(i);\n        ai = str.indexOf(a, i + 1);\n      } else if (begs.length == 1) {\n        result = [ begs.pop(), bi ];\n      } else {\n        beg = begs.pop();\n        if (beg < left) {\n          left = beg;\n          right = bi;\n        }\n\n        bi = str.indexOf(b, i + 1);\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi;\n    }\n\n    if (begs.length) {\n      result = [ left, right ];\n    }\n  }\n\n  return result;\n}\n","var concatMap = require('concat-map');\nvar balanced = require('balanced-match');\n\nmodule.exports = expandTop;\n\nvar escSlash = '\\0SLASH'+Math.random()+'\\0';\nvar escOpen = '\\0OPEN'+Math.random()+'\\0';\nvar escClose = '\\0CLOSE'+Math.random()+'\\0';\nvar escComma = '\\0COMMA'+Math.random()+'\\0';\nvar escPeriod = '\\0PERIOD'+Math.random()+'\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str\n    ? parseInt(str, 10)\n    : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash)\n            .split('\\\\{').join(escOpen)\n            .split('\\\\}').join(escClose)\n            .split('\\\\,').join(escComma)\n            .split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\')\n            .split(escOpen).join('{')\n            .split(escClose).join('}')\n            .split(escComma).join(',')\n            .split(escPeriod).join('.');\n}\n\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str)\n    return [''];\n\n  var parts = [];\n  var m = balanced('{', '}', str);\n\n  if (!m)\n    return str.split(',');\n\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n\n  p[p.length-1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length-1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str)\n    return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction identity(e) {\n  return e;\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n\n  var m = balanced('{', '}', str);\n  if (!m || /\\$$/.test(m.pre)) return [str];\n\n  var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isSequence = isNumericSequence || isAlphaSequence;\n  var isOptions = m.body.indexOf(',') >= 0;\n  if (!isSequence && !isOptions) {\n    // {a},b}\n    if (m.post.match(/,.*\\}/)) {\n      str = m.pre + '{' + m.body + escClose + m.post;\n      return expand(str);\n    }\n    return [str];\n  }\n\n  var n;\n  if (isSequence) {\n    n = m.body.split(/\\.\\./);\n  } else {\n    n = parseCommaParts(m.body);\n    if (n.length === 1) {\n      // x{{a,b}}y ==> x{a}y x{b}y\n      n = expand(n[0], false).map(embrace);\n      if (n.length === 1) {\n        var post = m.post.length\n          ? expand(m.post, false)\n          : [''];\n        return post.map(function(p) {\n          return m.pre + n[0] + p;\n        });\n      }\n    }\n  }\n\n  // at this point, n is the parts, and we know it's not a comma set\n  // with a single entry.\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length\n    ? expand(m.post, false)\n    : [''];\n\n  var N;\n\n  if (isSequence) {\n    var x = numeric(n[0]);\n    var y = numeric(n[1]);\n    var width = Math.max(n[0].length, n[1].length)\n    var incr = n.length == 3\n      ? Math.abs(numeric(n[2]))\n      : 1;\n    var test = lte;\n    var reverse = y < x;\n    if (reverse) {\n      incr *= -1;\n      test = gte;\n    }\n    var pad = n.some(isPadded);\n\n    N = [];\n\n    for (var i = x; test(i, y); i += incr) {\n      var c;\n      if (isAlphaSequence) {\n        c = String.fromCharCode(i);\n        if (c === '\\\\')\n          c = '';\n      } else {\n        c = String(i);\n        if (pad) {\n          var need = width - c.length;\n          if (need > 0) {\n            var z = new Array(need + 1).join('0');\n            if (i < 0)\n              c = '-' + z + c.slice(1);\n            else\n              c = z + c;\n          }\n        }\n      }\n      N.push(c);\n    }\n  } else {\n    N = concatMap(n, function(el) { return expand(el, false) });\n  }\n\n  for (var j = 0; j < N.length; j++) {\n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre + N[j] + post[k];\n      if (!isTop || isSequence || expansion)\n        expansions.push(expansion);\n    }\n  }\n\n  return expansions;\n}\n\n","var toString = Object.prototype.toString\n\nvar isModern = (\n  typeof Buffer.alloc === 'function' &&\n  typeof Buffer.allocUnsafe === 'function' &&\n  typeof Buffer.from === 'function'\n)\n\nfunction isArrayBuffer (input) {\n  return toString.call(input).slice(8, -1) === 'ArrayBuffer'\n}\n\nfunction fromArrayBuffer (obj, byteOffset, length) {\n  byteOffset >>>= 0\n\n  var maxLength = obj.byteLength - byteOffset\n\n  if (maxLength < 0) {\n    throw new RangeError(\"'offset' is out of bounds\")\n  }\n\n  if (length === undefined) {\n    length = maxLength\n  } else {\n    length >>>= 0\n\n    if (length > maxLength) {\n      throw new RangeError(\"'length' is out of bounds\")\n    }\n  }\n\n  return isModern\n    ? Buffer.from(obj.slice(byteOffset, byteOffset + length))\n    : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)))\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  return isModern\n    ? Buffer.from(string, encoding)\n    : new Buffer(string, encoding)\n}\n\nfunction bufferFrom (value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (isArrayBuffer(value)) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  return isModern\n    ? Buffer.from(value)\n    : new Buffer(value)\n}\n\nmodule.exports = bufferFrom\n","module.exports = function (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        var x = fn(xs[i], i);\n        if (isArray(x)) res.push.apply(res, x);\n        else res.push(x);\n    }\n    return res;\n};\n\nvar isArray = Array.isArray || function (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n};\n","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n","/**\n * Detect Electron renderer / nwjs process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {\n\tmodule.exports = require('./browser.js');\n} else {\n\tmodule.exports = require('./node.js');\n}\n","/**\n * Module dependencies.\n */\n\nconst tty = require('tty');\nconst util = require('util');\n\n/**\n * This is the Node.js implementation of `debug()`.\n */\n\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.destroy = util.deprecate(\n\t() => {},\n\t'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'\n);\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\ntry {\n\t// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)\n\t// eslint-disable-next-line import/no-extraneous-dependencies\n\tconst supportsColor = require('supports-color');\n\n\tif (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n\t\texports.colors = [\n\t\t\t20,\n\t\t\t21,\n\t\t\t26,\n\t\t\t27,\n\t\t\t32,\n\t\t\t33,\n\t\t\t38,\n\t\t\t39,\n\t\t\t40,\n\t\t\t41,\n\t\t\t42,\n\t\t\t43,\n\t\t\t44,\n\t\t\t45,\n\t\t\t56,\n\t\t\t57,\n\t\t\t62,\n\t\t\t63,\n\t\t\t68,\n\t\t\t69,\n\t\t\t74,\n\t\t\t75,\n\t\t\t76,\n\t\t\t77,\n\t\t\t78,\n\t\t\t79,\n\t\t\t80,\n\t\t\t81,\n\t\t\t92,\n\t\t\t93,\n\t\t\t98,\n\t\t\t99,\n\t\t\t112,\n\t\t\t113,\n\t\t\t128,\n\t\t\t129,\n\t\t\t134,\n\t\t\t135,\n\t\t\t148,\n\t\t\t149,\n\t\t\t160,\n\t\t\t161,\n\t\t\t162,\n\t\t\t163,\n\t\t\t164,\n\t\t\t165,\n\t\t\t166,\n\t\t\t167,\n\t\t\t168,\n\t\t\t169,\n\t\t\t170,\n\t\t\t171,\n\t\t\t172,\n\t\t\t173,\n\t\t\t178,\n\t\t\t179,\n\t\t\t184,\n\t\t\t185,\n\t\t\t196,\n\t\t\t197,\n\t\t\t198,\n\t\t\t199,\n\t\t\t200,\n\t\t\t201,\n\t\t\t202,\n\t\t\t203,\n\t\t\t204,\n\t\t\t205,\n\t\t\t206,\n\t\t\t207,\n\t\t\t208,\n\t\t\t209,\n\t\t\t214,\n\t\t\t215,\n\t\t\t220,\n\t\t\t221\n\t\t];\n\t}\n} catch (error) {\n\t// Swallow - we only care if `supports-color` is available; it doesn't have to be.\n}\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(key => {\n\treturn /^debug_/i.test(key);\n}).reduce((obj, key) => {\n\t// Camel-case\n\tconst prop = key\n\t\t.substring(6)\n\t\t.toLowerCase()\n\t\t.replace(/_([a-z])/g, (_, k) => {\n\t\t\treturn k.toUpperCase();\n\t\t});\n\n\t// Coerce string value into JS value\n\tlet val = process.env[key];\n\tif (/^(yes|on|true|enabled)$/i.test(val)) {\n\t\tval = true;\n\t} else if (/^(no|off|false|disabled)$/i.test(val)) {\n\t\tval = false;\n\t} else if (val === 'null') {\n\t\tval = null;\n\t} else {\n\t\tval = Number(val);\n\t}\n\n\tobj[prop] = val;\n\treturn obj;\n}, {});\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n\treturn 'colors' in exports.inspectOpts ?\n\t\tBoolean(exports.inspectOpts.colors) :\n\t\ttty.isatty(process.stderr.fd);\n}\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\tconst {namespace: name, useColors} = this;\n\n\tif (useColors) {\n\t\tconst c = this.color;\n\t\tconst colorCode = '\\u001B[3' + (c < 8 ? c : '8;5;' + c);\n\t\tconst prefix = `  ${colorCode};1m${name} \\u001B[0m`;\n\n\t\targs[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n\t\targs.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\\u001B[0m');\n\t} else {\n\t\targs[0] = getDate() + name + ' ' + args[0];\n\t}\n}\n\nfunction getDate() {\n\tif (exports.inspectOpts.hideDate) {\n\t\treturn '';\n\t}\n\treturn new Date().toISOString() + ' ';\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to stderr.\n */\n\nfunction log(...args) {\n\treturn process.stderr.write(util.format(...args) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\tif (namespaces) {\n\t\tprocess.env.DEBUG = namespaces;\n\t} else {\n\t\t// If you set a process.env field to null or undefined, it gets cast to the\n\t\t// string 'null' or 'undefined'. Just delete instead.\n\t\tdelete process.env.DEBUG;\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n\treturn process.env.DEBUG;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init(debug) {\n\tdebug.inspectOpts = {};\n\n\tconst keys = Object.keys(exports.inspectOpts);\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tdebug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nformatters.o = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts)\n\t\t.split('\\n')\n\t\t.map(str => str.trim())\n\t\t.join(' ');\n};\n\n/**\n * Map %O to `util.inspect()`, allowing multiple lines if needed.\n */\n\nformatters.O = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts);\n};\n","'use strict';\n\nmodule.exports = (flag, argv = process.argv) => {\n\tconst prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');\n\tconst position = argv.indexOf(prefix + flag);\n\tconst terminatorPosition = argv.indexOf('--');\n\treturn position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);\n};\n","module.exports = minimatch\nminimatch.Minimatch = Minimatch\n\nvar path = { sep: '/' }\ntry {\n  path = require('path')\n} catch (er) {}\n\nvar GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}\nvar expand = require('brace-expansion')\n\nvar plTypes = {\n  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},\n  '?': { open: '(?:', close: ')?' },\n  '+': { open: '(?:', close: ')+' },\n  '*': { open: '(?:', close: ')*' },\n  '@': { open: '(?:', close: ')' }\n}\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nvar qmark = '[^/]'\n\n// * => any number of characters\nvar star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nvar twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nvar twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'\n\n// characters that need to be escaped in RegExp.\nvar reSpecials = charSet('().*{}+?[]^$\\\\!')\n\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet (s) {\n  return s.split('').reduce(function (set, c) {\n    set[c] = true\n    return set\n  }, {})\n}\n\n// normalizes slashes.\nvar slashSplit = /\\/+/\n\nminimatch.filter = filter\nfunction filter (pattern, options) {\n  options = options || {}\n  return function (p, i, list) {\n    return minimatch(p, pattern, options)\n  }\n}\n\nfunction ext (a, b) {\n  a = a || {}\n  b = b || {}\n  var t = {}\n  Object.keys(b).forEach(function (k) {\n    t[k] = b[k]\n  })\n  Object.keys(a).forEach(function (k) {\n    t[k] = a[k]\n  })\n  return t\n}\n\nminimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return minimatch\n\n  var orig = minimatch\n\n  var m = function minimatch (p, pattern, options) {\n    return orig.minimatch(p, pattern, ext(def, options))\n  }\n\n  m.Minimatch = function Minimatch (pattern, options) {\n    return new orig.Minimatch(pattern, ext(def, options))\n  }\n\n  return m\n}\n\nMinimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return Minimatch\n  return minimatch.defaults(def).Minimatch\n}\n\nfunction minimatch (p, pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  // \"\" only matches \"\"\n  if (pattern.trim() === '') return p === ''\n\n  return new Minimatch(pattern, options).match(p)\n}\n\nfunction Minimatch (pattern, options) {\n  if (!(this instanceof Minimatch)) {\n    return new Minimatch(pattern, options)\n  }\n\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n  pattern = pattern.trim()\n\n  // windows support: need to use /, not \\\n  if (path.sep !== '/') {\n    pattern = pattern.split(path.sep).join('/')\n  }\n\n  this.options = options\n  this.set = []\n  this.pattern = pattern\n  this.regexp = null\n  this.negate = false\n  this.comment = false\n  this.empty = false\n\n  // make the set of regexps etc.\n  this.make()\n}\n\nMinimatch.prototype.debug = function () {}\n\nMinimatch.prototype.make = make\nfunction make () {\n  // don't do it more than once.\n  if (this._made) return\n\n  var pattern = this.pattern\n  var options = this.options\n\n  // empty patterns and comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    this.comment = true\n    return\n  }\n  if (!pattern) {\n    this.empty = true\n    return\n  }\n\n  // step 1: figure out negation, etc.\n  this.parseNegate()\n\n  // step 2: expand braces\n  var set = this.globSet = this.braceExpand()\n\n  if (options.debug) this.debug = console.error\n\n  this.debug(this.pattern, set)\n\n  // step 3: now we have a set, so turn each one into a series of path-portion\n  // matching patterns.\n  // These will be regexps, except in the case of \"**\", which is\n  // set to the GLOBSTAR object for globstar behavior,\n  // and will not contain any / characters\n  set = this.globParts = set.map(function (s) {\n    return s.split(slashSplit)\n  })\n\n  this.debug(this.pattern, set)\n\n  // glob --> regexps\n  set = set.map(function (s, si, set) {\n    return s.map(this.parse, this)\n  }, this)\n\n  this.debug(this.pattern, set)\n\n  // filter out everything that didn't compile properly.\n  set = set.filter(function (s) {\n    return s.indexOf(false) === -1\n  })\n\n  this.debug(this.pattern, set)\n\n  this.set = set\n}\n\nMinimatch.prototype.parseNegate = parseNegate\nfunction parseNegate () {\n  var pattern = this.pattern\n  var negate = false\n  var options = this.options\n  var negateOffset = 0\n\n  if (options.nonegate) return\n\n  for (var i = 0, l = pattern.length\n    ; i < l && pattern.charAt(i) === '!'\n    ; i++) {\n    negate = !negate\n    negateOffset++\n  }\n\n  if (negateOffset) this.pattern = pattern.substr(negateOffset)\n  this.negate = negate\n}\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function (pattern, options) {\n  return braceExpand(pattern, options)\n}\n\nMinimatch.prototype.braceExpand = braceExpand\n\nfunction braceExpand (pattern, options) {\n  if (!options) {\n    if (this instanceof Minimatch) {\n      options = this.options\n    } else {\n      options = {}\n    }\n  }\n\n  pattern = typeof pattern === 'undefined'\n    ? this.pattern : pattern\n\n  if (typeof pattern === 'undefined') {\n    throw new TypeError('undefined pattern')\n  }\n\n  if (options.nobrace ||\n    !pattern.match(/\\{.*\\}/)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse\nvar SUBPARSE = {}\nfunction parse (pattern, isSub) {\n  if (pattern.length > 1024 * 64) {\n    throw new TypeError('pattern is too long')\n  }\n\n  var options = this.options\n\n  // shortcuts\n  if (!options.noglobstar && pattern === '**') return GLOBSTAR\n  if (pattern === '') return ''\n\n  var re = ''\n  var hasMagic = !!options.nocase\n  var escaping = false\n  // ? => one single character\n  var patternListStack = []\n  var negativeLists = []\n  var stateChar\n  var inClass = false\n  var reClassStart = -1\n  var classStart = -1\n  // . and .. never match anything that doesn't start with .,\n  // even when options.dot is set.\n  var patternStart = pattern.charAt(0) === '.' ? '' // anything\n  // not (start or / followed by . or .. followed by / or end)\n  : options.dot ? '(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))'\n  : '(?!\\\\.)'\n  var self = this\n\n  function clearStateChar () {\n    if (stateChar) {\n      // we had some state-tracking character\n      // that wasn't consumed by this pass.\n      switch (stateChar) {\n        case '*':\n          re += star\n          hasMagic = true\n        break\n        case '?':\n          re += qmark\n          hasMagic = true\n        break\n        default:\n          re += '\\\\' + stateChar\n        break\n      }\n      self.debug('clearStateChar %j %j', stateChar, re)\n      stateChar = false\n    }\n  }\n\n  for (var i = 0, len = pattern.length, c\n    ; (i < len) && (c = pattern.charAt(i))\n    ; i++) {\n    this.debug('%s\\t%s %s %j', pattern, i, re, c)\n\n    // skip over any that are escaped.\n    if (escaping && reSpecials[c]) {\n      re += '\\\\' + c\n      escaping = false\n      continue\n    }\n\n    switch (c) {\n      case '/':\n        // completely not allowed, even escaped.\n        // Should already be path-split by now.\n        return false\n\n      case '\\\\':\n        clearStateChar()\n        escaping = true\n      continue\n\n      // the various stateChar values\n      // for the \"extglob\" stuff.\n      case '?':\n      case '*':\n      case '+':\n      case '@':\n      case '!':\n        this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c)\n\n        // all of those are literals inside a class, except that\n        // the glob [!a] means [^a] in regexp\n        if (inClass) {\n          this.debug('  in class')\n          if (c === '!' && i === classStart + 1) c = '^'\n          re += c\n          continue\n        }\n\n        // if we already have a stateChar, then it means\n        // that there was something like ** or +? in there.\n        // Handle the stateChar, then proceed with this one.\n        self.debug('call clearStateChar %j', stateChar)\n        clearStateChar()\n        stateChar = c\n        // if extglob is disabled, then +(asdf|foo) isn't a thing.\n        // just clear the statechar *now*, rather than even diving into\n        // the patternList stuff.\n        if (options.noext) clearStateChar()\n      continue\n\n      case '(':\n        if (inClass) {\n          re += '('\n          continue\n        }\n\n        if (!stateChar) {\n          re += '\\\\('\n          continue\n        }\n\n        patternListStack.push({\n          type: stateChar,\n          start: i - 1,\n          reStart: re.length,\n          open: plTypes[stateChar].open,\n          close: plTypes[stateChar].close\n        })\n        // negation is (?:(?!js)[^/]*)\n        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'\n        this.debug('plType %j %j', stateChar, re)\n        stateChar = false\n      continue\n\n      case ')':\n        if (inClass || !patternListStack.length) {\n          re += '\\\\)'\n          continue\n        }\n\n        clearStateChar()\n        hasMagic = true\n        var pl = patternListStack.pop()\n        // negation is (?:(?!js)[^/]*)\n        // The others are (?:<pattern>)<type>\n        re += pl.close\n        if (pl.type === '!') {\n          negativeLists.push(pl)\n        }\n        pl.reEnd = re.length\n      continue\n\n      case '|':\n        if (inClass || !patternListStack.length || escaping) {\n          re += '\\\\|'\n          escaping = false\n          continue\n        }\n\n        clearStateChar()\n        re += '|'\n      continue\n\n      // these are mostly the same in regexp and glob\n      case '[':\n        // swallow any state-tracking char before the [\n        clearStateChar()\n\n        if (inClass) {\n          re += '\\\\' + c\n          continue\n        }\n\n        inClass = true\n        classStart = i\n        reClassStart = re.length\n        re += c\n      continue\n\n      case ']':\n        //  a right bracket shall lose its special\n        //  meaning and represent itself in\n        //  a bracket expression if it occurs\n        //  first in the list.  -- POSIX.2 2.8.3.2\n        if (i === classStart + 1 || !inClass) {\n          re += '\\\\' + c\n          escaping = false\n          continue\n        }\n\n        // handle the case where we left a class open.\n        // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n        if (inClass) {\n          // split where the last [ was, make sure we don't have\n          // an invalid re. if so, re-walk the contents of the\n          // would-be class to re-translate any characters that\n          // were passed through as-is\n          // TODO: It would probably be faster to determine this\n          // without a try/catch and a new RegExp, but it's tricky\n          // to do safely.  For now, this is safe and works.\n          var cs = pattern.substring(classStart + 1, i)\n          try {\n            RegExp('[' + cs + ']')\n          } catch (er) {\n            // not a valid class!\n            var sp = this.parse(cs, SUBPARSE)\n            re = re.substr(0, reClassStart) + '\\\\[' + sp[0] + '\\\\]'\n            hasMagic = hasMagic || sp[1]\n            inClass = false\n            continue\n          }\n        }\n\n        // finish up the class.\n        hasMagic = true\n        inClass = false\n        re += c\n      continue\n\n      default:\n        // swallow any state char that wasn't consumed\n        clearStateChar()\n\n        if (escaping) {\n          // no need\n          escaping = false\n        } else if (reSpecials[c]\n          && !(c === '^' && inClass)) {\n          re += '\\\\'\n        }\n\n        re += c\n\n    } // switch\n  } // for\n\n  // handle the case where we left a class open.\n  // \"[abc\" is valid, equivalent to \"\\[abc\"\n  if (inClass) {\n    // split where the last [ was, and escape it\n    // this is a huge pita.  We now have to re-walk\n    // the contents of the would-be class to re-translate\n    // any characters that were passed through as-is\n    cs = pattern.substr(classStart + 1)\n    sp = this.parse(cs, SUBPARSE)\n    re = re.substr(0, reClassStart) + '\\\\[' + sp[0]\n    hasMagic = hasMagic || sp[1]\n  }\n\n  // handle the case where we had a +( thing at the *end*\n  // of the pattern.\n  // each pattern list stack adds 3 chars, and we need to go through\n  // and escape any | chars that were passed through as-is for the regexp.\n  // Go through and escape them, taking care not to double-escape any\n  // | chars that were already escaped.\n  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n    var tail = re.slice(pl.reStart + pl.open.length)\n    this.debug('setting tail', re, pl)\n    // maybe some even number of \\, then maybe 1 \\, followed by a |\n    tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, function (_, $1, $2) {\n      if (!$2) {\n        // the | isn't already escaped, so escape it.\n        $2 = '\\\\'\n      }\n\n      // need to escape all those slashes *again*, without escaping the\n      // one that we need for escaping the | character.  As it works out,\n      // escaping an even number of slashes can be done by simply repeating\n      // it exactly after itself.  That's why this trick works.\n      //\n      // I am sorry that you have to see this.\n      return $1 + $1 + $2 + '|'\n    })\n\n    this.debug('tail=%j\\n   %s', tail, tail, pl, re)\n    var t = pl.type === '*' ? star\n      : pl.type === '?' ? qmark\n      : '\\\\' + pl.type\n\n    hasMagic = true\n    re = re.slice(0, pl.reStart) + t + '\\\\(' + tail\n  }\n\n  // handle trailing things that only matter at the very end.\n  clearStateChar()\n  if (escaping) {\n    // trailing \\\\\n    re += '\\\\\\\\'\n  }\n\n  // only need to apply the nodot start if the re starts with\n  // something that could conceivably capture a dot\n  var addPatternStart = false\n  switch (re.charAt(0)) {\n    case '.':\n    case '[':\n    case '(': addPatternStart = true\n  }\n\n  // Hack to work around lack of negative lookbehind in JS\n  // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n  // like 'a.xyz.yz' doesn't match.  So, the first negative\n  // lookahead, has to look ALL the way ahead, to the end of\n  // the pattern.\n  for (var n = negativeLists.length - 1; n > -1; n--) {\n    var nl = negativeLists[n]\n\n    var nlBefore = re.slice(0, nl.reStart)\n    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)\n    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)\n    var nlAfter = re.slice(nl.reEnd)\n\n    nlLast += nlAfter\n\n    // Handle nested stuff like *(*.js|!(*.json)), where open parens\n    // mean that we should *not* include the ) in the bit that is considered\n    // \"after\" the negated section.\n    var openParensBefore = nlBefore.split('(').length - 1\n    var cleanAfter = nlAfter\n    for (i = 0; i < openParensBefore; i++) {\n      cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '')\n    }\n    nlAfter = cleanAfter\n\n    var dollar = ''\n    if (nlAfter === '' && isSub !== SUBPARSE) {\n      dollar = '$'\n    }\n    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast\n    re = newRe\n  }\n\n  // if the re is not \"\" at this point, then we need to make sure\n  // it doesn't match against an empty path part.\n  // Otherwise a/* will match a/, which it should not.\n  if (re !== '' && hasMagic) {\n    re = '(?=.)' + re\n  }\n\n  if (addPatternStart) {\n    re = patternStart + re\n  }\n\n  // parsing just a piece of a larger pattern.\n  if (isSub === SUBPARSE) {\n    return [re, hasMagic]\n  }\n\n  // skip the regexp for non-magical patterns\n  // unescape anything in it, though, so that it'll be\n  // an exact match against a file etc.\n  if (!hasMagic) {\n    return globUnescape(pattern)\n  }\n\n  var flags = options.nocase ? 'i' : ''\n  try {\n    var regExp = new RegExp('^' + re + '$', flags)\n  } catch (er) {\n    // If it was an invalid regular expression, then it can't match\n    // anything.  This trick looks for a character after the end of\n    // the string, which is of course impossible, except in multi-line\n    // mode, but it's not a /m regex.\n    return new RegExp('$.')\n  }\n\n  regExp._glob = pattern\n  regExp._src = re\n\n  return regExp\n}\n\nminimatch.makeRe = function (pattern, options) {\n  return new Minimatch(pattern, options || {}).makeRe()\n}\n\nMinimatch.prototype.makeRe = makeRe\nfunction makeRe () {\n  if (this.regexp || this.regexp === false) return this.regexp\n\n  // at this point, this.set is a 2d array of partial\n  // pattern strings, or \"**\".\n  //\n  // It's better to use .match().  This function shouldn't\n  // be used, really, but it's pretty convenient sometimes,\n  // when you just want to work with a regex.\n  var set = this.set\n\n  if (!set.length) {\n    this.regexp = false\n    return this.regexp\n  }\n  var options = this.options\n\n  var twoStar = options.noglobstar ? star\n    : options.dot ? twoStarDot\n    : twoStarNoDot\n  var flags = options.nocase ? 'i' : ''\n\n  var re = set.map(function (pattern) {\n    return pattern.map(function (p) {\n      return (p === GLOBSTAR) ? twoStar\n      : (typeof p === 'string') ? regExpEscape(p)\n      : p._src\n    }).join('\\\\\\/')\n  }).join('|')\n\n  // must match entire pattern\n  // ending in a * or ** will make it less strict.\n  re = '^(?:' + re + ')$'\n\n  // can match anything, as long as it's not this.\n  if (this.negate) re = '^(?!' + re + ').*$'\n\n  try {\n    this.regexp = new RegExp(re, flags)\n  } catch (ex) {\n    this.regexp = false\n  }\n  return this.regexp\n}\n\nminimatch.match = function (list, pattern, options) {\n  options = options || {}\n  var mm = new Minimatch(pattern, options)\n  list = list.filter(function (f) {\n    return mm.match(f)\n  })\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\n\nMinimatch.prototype.match = match\nfunction match (f, partial) {\n  this.debug('match', f, this.pattern)\n  // short-circuit in the case of busted things.\n  // comments, etc.\n  if (this.comment) return false\n  if (this.empty) return f === ''\n\n  if (f === '/' && partial) return true\n\n  var options = this.options\n\n  // windows: need to use /, not \\\n  if (path.sep !== '/') {\n    f = f.split(path.sep).join('/')\n  }\n\n  // treat the test path as a set of pathparts.\n  f = f.split(slashSplit)\n  this.debug(this.pattern, 'split', f)\n\n  // just ONE of the pattern sets in this.set needs to match\n  // in order for it to be valid.  If negating, then just one\n  // match means that we have failed.\n  // Either way, return on the first hit.\n\n  var set = this.set\n  this.debug(this.pattern, 'set', set)\n\n  // Find the basename of the path by looking for the last non-empty segment\n  var filename\n  var i\n  for (i = f.length - 1; i >= 0; i--) {\n    filename = f[i]\n    if (filename) break\n  }\n\n  for (i = 0; i < set.length; i++) {\n    var pattern = set[i]\n    var file = f\n    if (options.matchBase && pattern.length === 1) {\n      file = [filename]\n    }\n    var hit = this.matchOne(file, pattern, partial)\n    if (hit) {\n      if (options.flipNegate) return true\n      return !this.negate\n    }\n  }\n\n  // didn't get any hits.  this is success if it's a negative\n  // pattern, failure otherwise.\n  if (options.flipNegate) return false\n  return this.negate\n}\n\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\n  var options = this.options\n\n  this.debug('matchOne',\n    { 'this': this, file: file, pattern: pattern })\n\n  this.debug('matchOne', file.length, pattern.length)\n\n  for (var fi = 0,\n      pi = 0,\n      fl = file.length,\n      pl = pattern.length\n      ; (fi < fl) && (pi < pl)\n      ; fi++, pi++) {\n    this.debug('matchOne loop')\n    var p = pattern[pi]\n    var f = file[fi]\n\n    this.debug(pattern, p, f)\n\n    // should be impossible.\n    // some invalid regexp stuff in the set.\n    if (p === false) return false\n\n    if (p === GLOBSTAR) {\n      this.debug('GLOBSTAR', [pattern, p, f])\n\n      // \"**\"\n      // a/**/b/**/c would match the following:\n      // a/b/x/y/z/c\n      // a/x/y/z/b/c\n      // a/b/x/b/x/c\n      // a/b/c\n      // To do this, take the rest of the pattern after\n      // the **, and see if it would match the file remainder.\n      // If so, return success.\n      // If not, the ** \"swallows\" a segment, and try again.\n      // This is recursively awful.\n      //\n      // a/**/b/**/c matching a/b/x/y/z/c\n      // - a matches a\n      // - doublestar\n      //   - matchOne(b/x/y/z/c, b/**/c)\n      //     - b matches b\n      //     - doublestar\n      //       - matchOne(x/y/z/c, c) -> no\n      //       - matchOne(y/z/c, c) -> no\n      //       - matchOne(z/c, c) -> no\n      //       - matchOne(c, c) yes, hit\n      var fr = fi\n      var pr = pi + 1\n      if (pr === pl) {\n        this.debug('** at the end')\n        // a ** at the end will just swallow the rest.\n        // We have found a match.\n        // however, it will not swallow /.x, unless\n        // options.dot is set.\n        // . and .. are *never* matched by **, for explosively\n        // exponential reasons.\n        for (; fi < fl; fi++) {\n          if (file[fi] === '.' || file[fi] === '..' ||\n            (!options.dot && file[fi].charAt(0) === '.')) return false\n        }\n        return true\n      }\n\n      // ok, let's see if we can swallow whatever we can.\n      while (fr < fl) {\n        var swallowee = file[fr]\n\n        this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n        // XXX remove this slice.  Just pass the start index.\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n          this.debug('globstar found match!', fr, fl, swallowee)\n          // found a match.\n          return true\n        } else {\n          // can't swallow \".\" or \"..\" ever.\n          // can only swallow \".foo\" when explicitly asked.\n          if (swallowee === '.' || swallowee === '..' ||\n            (!options.dot && swallowee.charAt(0) === '.')) {\n            this.debug('dot detected!', file, fr, pattern, pr)\n            break\n          }\n\n          // ** swallows a segment, and continue.\n          this.debug('globstar swallow a segment, and continue')\n          fr++\n        }\n      }\n\n      // no match was found.\n      // However, in partial mode, we can't say this is necessarily over.\n      // If there's more *pattern* left, then\n      if (partial) {\n        // ran out of file\n        this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n        if (fr === fl) return true\n      }\n      return false\n    }\n\n    // something other than **\n    // non-magic patterns just have to match exactly\n    // patterns with magic have been turned into regexps.\n    var hit\n    if (typeof p === 'string') {\n      if (options.nocase) {\n        hit = f.toLowerCase() === p.toLowerCase()\n      } else {\n        hit = f === p\n      }\n      this.debug('string match', p, f, hit)\n    } else {\n      hit = f.match(p)\n      this.debug('pattern match', p, f, hit)\n    }\n\n    if (!hit) return false\n  }\n\n  // Note: ending in / means that we'll get a final \"\"\n  // at the end of the pattern.  This can only match a\n  // corresponding \"\" at the end of the file.\n  // If the file ends in /, then it can only match a\n  // a pattern that ends in /, unless the pattern just\n  // doesn't have any more for it. But, a/b/ should *not*\n  // match \"a/b/*\", even though \"\" matches against the\n  // [^/]*? pattern, except in partial mode, where it might\n  // simply not be reached yet.\n  // However, a/b/ should still satisfy a/*\n\n  // now either we fell off the end of the pattern, or we're done.\n  if (fi === fl && pi === pl) {\n    // ran out of pattern and filename at the same time.\n    // an exact hit!\n    return true\n  } else if (fi === fl) {\n    // ran out of file, but still had pattern left.\n    // this is ok if we're doing the match as part of\n    // a glob fs traversal.\n    return partial\n  } else if (pi === pl) {\n    // ran out of pattern, still have file left.\n    // this is only acceptable if we're on the very last\n    // empty segment of a file with a trailing slash.\n    // a/* should match a/b/\n    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')\n    return emptyFileEnd\n  }\n\n  // should be unreachable.\n  throw new Error('wtf?')\n}\n\n// replace stuff like \\* with *\nfunction globUnescape (s) {\n  return s.replace(/\\\\(.)/g, '$1')\n}\n\nfunction regExpEscape (s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n}\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","var SourceMapConsumer = require('source-map').SourceMapConsumer;\nvar path = require('path');\n\nvar fs;\ntry {\n  fs = require('fs');\n  if (!fs.existsSync || !fs.readFileSync) {\n    // fs doesn't have all methods we need\n    fs = null;\n  }\n} catch (err) {\n  /* nop */\n}\n\nvar bufferFrom = require('buffer-from');\n\n// Only install once if called multiple times\nvar errorFormatterInstalled = false;\nvar uncaughtShimInstalled = false;\n\n// If true, the caches are reset before a stack trace formatting operation\nvar emptyCacheBetweenOperations = false;\n\n// Supports {browser, node, auto}\nvar environment = \"auto\";\n\n// Maps a file path to a string containing the file contents\nvar fileContentsCache = {};\n\n// Maps a file path to a source map for that file\nvar sourceMapCache = {};\n\n// Regex for detecting source maps\nvar reSourceMap = /^data:application\\/json[^,]+base64,/;\n\n// Priority list of retrieve handlers\nvar retrieveFileHandlers = [];\nvar retrieveMapHandlers = [];\n\nfunction isInBrowser() {\n  if (environment === \"browser\")\n    return true;\n  if (environment === \"node\")\n    return false;\n  return ((typeof window !== 'undefined') && (typeof XMLHttpRequest === 'function') && !(window.require && window.module && window.process && window.process.type === \"renderer\"));\n}\n\nfunction hasGlobalProcessEventEmitter() {\n  return ((typeof process === 'object') && (process !== null) && (typeof process.on === 'function'));\n}\n\nfunction handlerExec(list) {\n  return function(arg) {\n    for (var i = 0; i < list.length; i++) {\n      var ret = list[i](arg);\n      if (ret) {\n        return ret;\n      }\n    }\n    return null;\n  };\n}\n\nvar retrieveFile = handlerExec(retrieveFileHandlers);\n\nretrieveFileHandlers.push(function(path) {\n  // Trim the path to make sure there is no extra whitespace.\n  path = path.trim();\n  if (/^file:/.test(path)) {\n    // existsSync/readFileSync can't handle file protocol, but once stripped, it works\n    path = path.replace(/file:\\/\\/\\/(\\w:)?/, function(protocol, drive) {\n      return drive ?\n        '' : // file:///C:/dir/file -> C:/dir/file\n        '/'; // file:///root-dir/file -> /root-dir/file\n    });\n  }\n  if (path in fileContentsCache) {\n    return fileContentsCache[path];\n  }\n\n  var contents = '';\n  try {\n    if (!fs) {\n      // Use SJAX if we are in the browser\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', path, /** async */ false);\n      xhr.send(null);\n      if (xhr.readyState === 4 && xhr.status === 200) {\n        contents = xhr.responseText;\n      }\n    } else if (fs.existsSync(path)) {\n      // Otherwise, use the filesystem\n      contents = fs.readFileSync(path, 'utf8');\n    }\n  } catch (er) {\n    /* ignore any errors */\n  }\n\n  return fileContentsCache[path] = contents;\n});\n\n// Support URLs relative to a directory, but be careful about a protocol prefix\n// in case we are in the browser (i.e. directories may start with \"http://\" or \"file:///\")\nfunction supportRelativeURL(file, url) {\n  if (!file) return url;\n  var dir = path.dirname(file);\n  var match = /^\\w+:\\/\\/[^\\/]*/.exec(dir);\n  var protocol = match ? match[0] : '';\n  var startPath = dir.slice(protocol.length);\n  if (protocol && /^\\/\\w\\:/.test(startPath)) {\n    // handle file:///C:/ paths\n    protocol += '/';\n    return protocol + path.resolve(dir.slice(protocol.length), url).replace(/\\\\/g, '/');\n  }\n  return protocol + path.resolve(dir.slice(protocol.length), url);\n}\n\nfunction retrieveSourceMapURL(source) {\n  var fileData;\n\n  if (isInBrowser()) {\n     try {\n       var xhr = new XMLHttpRequest();\n       xhr.open('GET', source, false);\n       xhr.send(null);\n       fileData = xhr.readyState === 4 ? xhr.responseText : null;\n\n       // Support providing a sourceMappingURL via the SourceMap header\n       var sourceMapHeader = xhr.getResponseHeader(\"SourceMap\") ||\n                             xhr.getResponseHeader(\"X-SourceMap\");\n       if (sourceMapHeader) {\n         return sourceMapHeader;\n       }\n     } catch (e) {\n     }\n  }\n\n  // Get the URL of the source map\n  fileData = retrieveFile(source);\n  var re = /(?:\\/\\/[@#][\\s]*sourceMappingURL=([^\\s'\"]+)[\\s]*$)|(?:\\/\\*[@#][\\s]*sourceMappingURL=([^\\s*'\"]+)[\\s]*(?:\\*\\/)[\\s]*$)/mg;\n  // Keep executing the search to find the *last* sourceMappingURL to avoid\n  // picking up sourceMappingURLs from comments, strings, etc.\n  var lastMatch, match;\n  while (match = re.exec(fileData)) lastMatch = match;\n  if (!lastMatch) return null;\n  return lastMatch[1];\n};\n\n// Can be overridden by the retrieveSourceMap option to install. Takes a\n// generated source filename; returns a {map, optional url} object, or null if\n// there is no source map.  The map field may be either a string or the parsed\n// JSON object (ie, it must be a valid argument to the SourceMapConsumer\n// constructor).\nvar retrieveSourceMap = handlerExec(retrieveMapHandlers);\nretrieveMapHandlers.push(function(source) {\n  var sourceMappingURL = retrieveSourceMapURL(source);\n  if (!sourceMappingURL) return null;\n\n  // Read the contents of the source map\n  var sourceMapData;\n  if (reSourceMap.test(sourceMappingURL)) {\n    // Support source map URL as a data url\n    var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(',') + 1);\n    sourceMapData = bufferFrom(rawData, \"base64\").toString();\n    sourceMappingURL = source;\n  } else {\n    // Support source map URLs relative to the source URL\n    sourceMappingURL = supportRelativeURL(source, sourceMappingURL);\n    sourceMapData = retrieveFile(sourceMappingURL);\n  }\n\n  if (!sourceMapData) {\n    return null;\n  }\n\n  return {\n    url: sourceMappingURL,\n    map: sourceMapData\n  };\n});\n\nfunction mapSourcePosition(position) {\n  var sourceMap = sourceMapCache[position.source];\n  if (!sourceMap) {\n    // Call the (overrideable) retrieveSourceMap function to get the source map.\n    var urlAndMap = retrieveSourceMap(position.source);\n    if (urlAndMap) {\n      sourceMap = sourceMapCache[position.source] = {\n        url: urlAndMap.url,\n        map: new SourceMapConsumer(urlAndMap.map)\n      };\n\n      // Load all sources stored inline with the source map into the file cache\n      // to pretend like they are already loaded. They may not exist on disk.\n      if (sourceMap.map.sourcesContent) {\n        sourceMap.map.sources.forEach(function(source, i) {\n          var contents = sourceMap.map.sourcesContent[i];\n          if (contents) {\n            var url = supportRelativeURL(sourceMap.url, source);\n            fileContentsCache[url] = contents;\n          }\n        });\n      }\n    } else {\n      sourceMap = sourceMapCache[position.source] = {\n        url: null,\n        map: null\n      };\n    }\n  }\n\n  // Resolve the source URL relative to the URL of the source map\n  if (sourceMap && sourceMap.map && typeof sourceMap.map.originalPositionFor === 'function') {\n    var originalPosition = sourceMap.map.originalPositionFor(position);\n\n    // Only return the original position if a matching line was found. If no\n    // matching line is found then we return position instead, which will cause\n    // the stack trace to print the path and line for the compiled file. It is\n    // better to give a precise location in the compiled file than a vague\n    // location in the original file.\n    if (originalPosition.source !== null) {\n      originalPosition.source = supportRelativeURL(\n        sourceMap.url, originalPosition.source);\n      return originalPosition;\n    }\n  }\n\n  return position;\n}\n\n// Parses code generated by FormatEvalOrigin(), a function inside V8:\n// https://code.google.com/p/v8/source/browse/trunk/src/messages.js\nfunction mapEvalOrigin(origin) {\n  // Most eval() calls are in this format\n  var match = /^eval at ([^(]+) \\((.+):(\\d+):(\\d+)\\)$/.exec(origin);\n  if (match) {\n    var position = mapSourcePosition({\n      source: match[2],\n      line: +match[3],\n      column: match[4] - 1\n    });\n    return 'eval at ' + match[1] + ' (' + position.source + ':' +\n      position.line + ':' + (position.column + 1) + ')';\n  }\n\n  // Parse nested eval() calls using recursion\n  match = /^eval at ([^(]+) \\((.+)\\)$/.exec(origin);\n  if (match) {\n    return 'eval at ' + match[1] + ' (' + mapEvalOrigin(match[2]) + ')';\n  }\n\n  // Make sure we still return useful information if we didn't find anything\n  return origin;\n}\n\n// This is copied almost verbatim from the V8 source code at\n// https://code.google.com/p/v8/source/browse/trunk/src/messages.js. The\n// implementation of wrapCallSite() used to just forward to the actual source\n// code of CallSite.prototype.toString but unfortunately a new release of V8\n// did something to the prototype chain and broke the shim. The only fix I\n// could find was copy/paste.\nfunction CallSiteToString() {\n  var fileName;\n  var fileLocation = \"\";\n  if (this.isNative()) {\n    fileLocation = \"native\";\n  } else {\n    fileName = this.getScriptNameOrSourceURL();\n    if (!fileName && this.isEval()) {\n      fileLocation = this.getEvalOrigin();\n      fileLocation += \", \";  // Expecting source position to follow.\n    }\n\n    if (fileName) {\n      fileLocation += fileName;\n    } else {\n      // Source code does not originate from a file and is not native, but we\n      // can still get the source position inside the source string, e.g. in\n      // an eval string.\n      fileLocation += \"<anonymous>\";\n    }\n    var lineNumber = this.getLineNumber();\n    if (lineNumber != null) {\n      fileLocation += \":\" + lineNumber;\n      var columnNumber = this.getColumnNumber();\n      if (columnNumber) {\n        fileLocation += \":\" + columnNumber;\n      }\n    }\n  }\n\n  var line = \"\";\n  var functionName = this.getFunctionName();\n  var addSuffix = true;\n  var isConstructor = this.isConstructor();\n  var isMethodCall = !(this.isToplevel() || isConstructor);\n  if (isMethodCall) {\n    var typeName = this.getTypeName();\n    // Fixes shim to be backward compatable with Node v0 to v4\n    if (typeName === \"[object Object]\") {\n      typeName = \"null\";\n    }\n    var methodName = this.getMethodName();\n    if (functionName) {\n      if (typeName && functionName.indexOf(typeName) != 0) {\n        line += typeName + \".\";\n      }\n      line += functionName;\n      if (methodName && functionName.indexOf(\".\" + methodName) != functionName.length - methodName.length - 1) {\n        line += \" [as \" + methodName + \"]\";\n      }\n    } else {\n      line += typeName + \".\" + (methodName || \"<anonymous>\");\n    }\n  } else if (isConstructor) {\n    line += \"new \" + (functionName || \"<anonymous>\");\n  } else if (functionName) {\n    line += functionName;\n  } else {\n    line += fileLocation;\n    addSuffix = false;\n  }\n  if (addSuffix) {\n    line += \" (\" + fileLocation + \")\";\n  }\n  return line;\n}\n\nfunction cloneCallSite(frame) {\n  var object = {};\n  Object.getOwnPropertyNames(Object.getPrototypeOf(frame)).forEach(function(name) {\n    object[name] = /^(?:is|get)/.test(name) ? function() { return frame[name].call(frame); } : frame[name];\n  });\n  object.toString = CallSiteToString;\n  return object;\n}\n\nfunction wrapCallSite(frame, state) {\n  // provides interface backward compatibility\n  if (state === undefined) {\n    state = { nextPosition: null, curPosition: null }\n  }\n  if(frame.isNative()) {\n    state.curPosition = null;\n    return frame;\n  }\n\n  // Most call sites will return the source file from getFileName(), but code\n  // passed to eval() ending in \"//# sourceURL=...\" will return the source file\n  // from getScriptNameOrSourceURL() instead\n  var source = frame.getFileName() || frame.getScriptNameOrSourceURL();\n  if (source) {\n    var line = frame.getLineNumber();\n    var column = frame.getColumnNumber() - 1;\n\n    // Fix position in Node where some (internal) code is prepended.\n    // See https://github.com/evanw/node-source-map-support/issues/36\n    // Header removed in node at ^10.16 || >=11.11.0\n    // v11 is not an LTS candidate, we can just test the one version with it.\n    // Test node versions for: 10.16-19, 10.20+, 12-19, 20-99, 100+, or 11.11\n    var noHeader = /^v(10\\.1[6-9]|10\\.[2-9][0-9]|10\\.[0-9]{3,}|1[2-9]\\d*|[2-9]\\d|\\d{3,}|11\\.11)/;\n    var headerLength = noHeader.test(process.version) ? 0 : 62;\n    if (line === 1 && column > headerLength && !isInBrowser() && !frame.isEval()) {\n      column -= headerLength;\n    }\n\n    var position = mapSourcePosition({\n      source: source,\n      line: line,\n      column: column\n    });\n    state.curPosition = position;\n    frame = cloneCallSite(frame);\n    var originalFunctionName = frame.getFunctionName;\n    frame.getFunctionName = function() {\n      if (state.nextPosition == null) {\n        return originalFunctionName();\n      }\n      return state.nextPosition.name || originalFunctionName();\n    };\n    frame.getFileName = function() { return position.source; };\n    frame.getLineNumber = function() { return position.line; };\n    frame.getColumnNumber = function() { return position.column + 1; };\n    frame.getScriptNameOrSourceURL = function() { return position.source; };\n    return frame;\n  }\n\n  // Code called using eval() needs special handling\n  var origin = frame.isEval() && frame.getEvalOrigin();\n  if (origin) {\n    origin = mapEvalOrigin(origin);\n    frame = cloneCallSite(frame);\n    frame.getEvalOrigin = function() { return origin; };\n    return frame;\n  }\n\n  // If we get here then we were unable to change the source position\n  return frame;\n}\n\n// This function is part of the V8 stack trace API, for more info see:\n// https://v8.dev/docs/stack-trace-api\nfunction prepareStackTrace(error, stack) {\n  if (emptyCacheBetweenOperations) {\n    fileContentsCache = {};\n    sourceMapCache = {};\n  }\n\n  var name = error.name || 'Error';\n  var message = error.message || '';\n  var errorString = name + \": \" + message;\n\n  var state = { nextPosition: null, curPosition: null };\n  var processedStack = [];\n  for (var i = stack.length - 1; i >= 0; i--) {\n    processedStack.push('\\n    at ' + wrapCallSite(stack[i], state));\n    state.nextPosition = state.curPosition;\n  }\n  state.curPosition = state.nextPosition = null;\n  return errorString + processedStack.reverse().join('');\n}\n\n// Generate position and snippet of original source with pointer\nfunction getErrorSource(error) {\n  var match = /\\n    at [^(]+ \\((.*):(\\d+):(\\d+)\\)/.exec(error.stack);\n  if (match) {\n    var source = match[1];\n    var line = +match[2];\n    var column = +match[3];\n\n    // Support the inline sourceContents inside the source map\n    var contents = fileContentsCache[source];\n\n    // Support files on disk\n    if (!contents && fs && fs.existsSync(source)) {\n      try {\n        contents = fs.readFileSync(source, 'utf8');\n      } catch (er) {\n        contents = '';\n      }\n    }\n\n    // Format the line from the original source code like node does\n    if (contents) {\n      var code = contents.split(/(?:\\r\\n|\\r|\\n)/)[line - 1];\n      if (code) {\n        return source + ':' + line + '\\n' + code + '\\n' +\n          new Array(column).join(' ') + '^';\n      }\n    }\n  }\n  return null;\n}\n\nfunction printErrorAndExit (error) {\n  var source = getErrorSource(error);\n\n  // Ensure error is printed synchronously and not truncated\n  if (process.stderr._handle && process.stderr._handle.setBlocking) {\n    process.stderr._handle.setBlocking(true);\n  }\n\n  if (source) {\n    console.error();\n    console.error(source);\n  }\n\n  console.error(error.stack);\n  process.exit(1);\n}\n\nfunction shimEmitUncaughtException () {\n  var origEmit = process.emit;\n\n  process.emit = function (type) {\n    if (type === 'uncaughtException') {\n      var hasStack = (arguments[1] && arguments[1].stack);\n      var hasListeners = (this.listeners(type).length > 0);\n\n      if (hasStack && !hasListeners) {\n        return printErrorAndExit(arguments[1]);\n      }\n    }\n\n    return origEmit.apply(this, arguments);\n  };\n}\n\nvar originalRetrieveFileHandlers = retrieveFileHandlers.slice(0);\nvar originalRetrieveMapHandlers = retrieveMapHandlers.slice(0);\n\nexports.wrapCallSite = wrapCallSite;\nexports.getErrorSource = getErrorSource;\nexports.mapSourcePosition = mapSourcePosition;\nexports.retrieveSourceMap = retrieveSourceMap;\n\nexports.install = function(options) {\n  options = options || {};\n\n  if (options.environment) {\n    environment = options.environment;\n    if ([\"node\", \"browser\", \"auto\"].indexOf(environment) === -1) {\n      throw new Error(\"environment \" + environment + \" was unknown. Available options are {auto, browser, node}\")\n    }\n  }\n\n  // Allow sources to be found by methods other than reading the files\n  // directly from disk.\n  if (options.retrieveFile) {\n    if (options.overrideRetrieveFile) {\n      retrieveFileHandlers.length = 0;\n    }\n\n    retrieveFileHandlers.unshift(options.retrieveFile);\n  }\n\n  // Allow source maps to be found by methods other than reading the files\n  // directly from disk.\n  if (options.retrieveSourceMap) {\n    if (options.overrideRetrieveSourceMap) {\n      retrieveMapHandlers.length = 0;\n    }\n\n    retrieveMapHandlers.unshift(options.retrieveSourceMap);\n  }\n\n  // Support runtime transpilers that include inline source maps\n  if (options.hookRequire && !isInBrowser()) {\n    var Module;\n    try {\n      Module = require('module');\n    } catch (err) {\n      // NOP: Loading in catch block to convert webpack error to warning.\n    }\n    var $compile = Module.prototype._compile;\n\n    if (!$compile.__sourceMapSupport) {\n      Module.prototype._compile = function(content, filename) {\n        fileContentsCache[filename] = content;\n        sourceMapCache[filename] = undefined;\n        return $compile.call(this, content, filename);\n      };\n\n      Module.prototype._compile.__sourceMapSupport = true;\n    }\n  }\n\n  // Configure options\n  if (!emptyCacheBetweenOperations) {\n    emptyCacheBetweenOperations = 'emptyCacheBetweenOperations' in options ?\n      options.emptyCacheBetweenOperations : false;\n  }\n\n  // Install the error reformatter\n  if (!errorFormatterInstalled) {\n    errorFormatterInstalled = true;\n    Error.prepareStackTrace = prepareStackTrace;\n  }\n\n  if (!uncaughtShimInstalled) {\n    var installHandler = 'handleUncaughtExceptions' in options ?\n      options.handleUncaughtExceptions : true;\n\n    // Provide the option to not install the uncaught exception handler. This is\n    // to support other uncaught exception handlers (in test frameworks, for\n    // example). If this handler is not installed and there are no other uncaught\n    // exception handlers, uncaught exceptions will be caught by node's built-in\n    // exception handler and the process will still be terminated. However, the\n    // generated JavaScript code will be shown above the stack trace instead of\n    // the original source code.\n    if (installHandler && hasGlobalProcessEventEmitter()) {\n      uncaughtShimInstalled = true;\n      shimEmitUncaughtException();\n    }\n  }\n};\n\nexports.resetRetrieveHandlers = function() {\n  retrieveFileHandlers.length = 0;\n  retrieveMapHandlers.length = 0;\n\n  retrieveFileHandlers = originalRetrieveFileHandlers.slice(0);\n  retrieveMapHandlers = originalRetrieveMapHandlers.slice(0);\n\n  retrieveSourceMap = handlerExec(retrieveMapHandlers);\n  retrieveFile = handlerExec(retrieveFileHandlers);\n}\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar has = Object.prototype.hasOwnProperty;\nvar hasNativeMap = typeof Map !== \"undefined\";\n\n/**\n * A data structure which is a combination of an array and a set. Adding a new\n * member is O(1), testing for membership is O(1), and finding the index of an\n * element is O(1). Removing elements from the set is not supported. Only\n * strings are supported for membership.\n */\nfunction ArraySet() {\n  this._array = [];\n  this._set = hasNativeMap ? new Map() : Object.create(null);\n}\n\n/**\n * Static method for creating ArraySet instances from an existing array.\n */\nArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n  var set = new ArraySet();\n  for (var i = 0, len = aArray.length; i < len; i++) {\n    set.add(aArray[i], aAllowDuplicates);\n  }\n  return set;\n};\n\n/**\n * Return how many unique items are in this ArraySet. If duplicates have been\n * added, than those do not count towards the size.\n *\n * @returns Number\n */\nArraySet.prototype.size = function ArraySet_size() {\n  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;\n};\n\n/**\n * Add the given string to this set.\n *\n * @param String aStr\n */\nArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);\n  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);\n  var idx = this._array.length;\n  if (!isDuplicate || aAllowDuplicates) {\n    this._array.push(aStr);\n  }\n  if (!isDuplicate) {\n    if (hasNativeMap) {\n      this._set.set(aStr, idx);\n    } else {\n      this._set[sStr] = idx;\n    }\n  }\n};\n\n/**\n * Is the given string a member of this set?\n *\n * @param String aStr\n */\nArraySet.prototype.has = function ArraySet_has(aStr) {\n  if (hasNativeMap) {\n    return this._set.has(aStr);\n  } else {\n    var sStr = util.toSetString(aStr);\n    return has.call(this._set, sStr);\n  }\n};\n\n/**\n * What is the index of the given string in the array?\n *\n * @param String aStr\n */\nArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n  if (hasNativeMap) {\n    var idx = this._set.get(aStr);\n    if (idx >= 0) {\n        return idx;\n    }\n  } else {\n    var sStr = util.toSetString(aStr);\n    if (has.call(this._set, sStr)) {\n      return this._set[sStr];\n    }\n  }\n\n  throw new Error('\"' + aStr + '\" is not in the set.');\n};\n\n/**\n * What is the element at the given index?\n *\n * @param Number aIdx\n */\nArraySet.prototype.at = function ArraySet_at(aIdx) {\n  if (aIdx >= 0 && aIdx < this._array.length) {\n    return this._array[aIdx];\n  }\n  throw new Error('No element indexed by ' + aIdx);\n};\n\n/**\n * Returns the array representation of this set (which has the proper indices\n * indicated by indexOf). Note that this is a copy of the internal array used\n * for storing the members so that no one can mess with internal state.\n */\nArraySet.prototype.toArray = function ArraySet_toArray() {\n  return this._array.slice();\n};\n\nexports.ArraySet = ArraySet;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nvar base64 = require('./base64');\n\n// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n// length quantities we use in the source map spec, the first bit is the sign,\n// the next four bits are the actual value, and the 6th bit is the\n// continuation bit. The continuation bit tells us whether there are more\n// digits in this value following this digit.\n//\n//   Continuation\n//   |    Sign\n//   |    |\n//   V    V\n//   101011\n\nvar VLQ_BASE_SHIFT = 5;\n\n// binary: 100000\nvar VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\n// binary: 011111\nvar VLQ_BASE_MASK = VLQ_BASE - 1;\n\n// binary: 100000\nvar VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n/**\n * Converts from a two-complement value to a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n */\nfunction toVLQSigned(aValue) {\n  return aValue < 0\n    ? ((-aValue) << 1) + 1\n    : (aValue << 1) + 0;\n}\n\n/**\n * Converts to a two-complement value from a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n */\nfunction fromVLQSigned(aValue) {\n  var isNegative = (aValue & 1) === 1;\n  var shifted = aValue >> 1;\n  return isNegative\n    ? -shifted\n    : shifted;\n}\n\n/**\n * Returns the base 64 VLQ encoded value.\n */\nexports.encode = function base64VLQ_encode(aValue) {\n  var encoded = \"\";\n  var digit;\n\n  var vlq = toVLQSigned(aValue);\n\n  do {\n    digit = vlq & VLQ_BASE_MASK;\n    vlq >>>= VLQ_BASE_SHIFT;\n    if (vlq > 0) {\n      // There are still more digits in this value, so we must make sure the\n      // continuation bit is marked.\n      digit |= VLQ_CONTINUATION_BIT;\n    }\n    encoded += base64.encode(digit);\n  } while (vlq > 0);\n\n  return encoded;\n};\n\n/**\n * Decodes the next base 64 VLQ value from the given string and returns the\n * value and the rest of the string via the out parameter.\n */\nexports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n  var strLen = aStr.length;\n  var result = 0;\n  var shift = 0;\n  var continuation, digit;\n\n  do {\n    if (aIndex >= strLen) {\n      throw new Error(\"Expected more digits in base 64 VLQ value.\");\n    }\n\n    digit = base64.decode(aStr.charCodeAt(aIndex++));\n    if (digit === -1) {\n      throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\n    }\n\n    continuation = !!(digit & VLQ_CONTINUATION_BIT);\n    digit &= VLQ_BASE_MASK;\n    result = result + (digit << shift);\n    shift += VLQ_BASE_SHIFT;\n  } while (continuation);\n\n  aOutParam.value = fromVLQSigned(result);\n  aOutParam.rest = aIndex;\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n\n/**\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n */\nexports.encode = function (number) {\n  if (0 <= number && number < intToCharMap.length) {\n    return intToCharMap[number];\n  }\n  throw new TypeError(\"Must be between 0 and 63: \" + number);\n};\n\n/**\n * Decode a single base 64 character code digit to an integer. Returns -1 on\n * failure.\n */\nexports.decode = function (charCode) {\n  var bigA = 65;     // 'A'\n  var bigZ = 90;     // 'Z'\n\n  var littleA = 97;  // 'a'\n  var littleZ = 122; // 'z'\n\n  var zero = 48;     // '0'\n  var nine = 57;     // '9'\n\n  var plus = 43;     // '+'\n  var slash = 47;    // '/'\n\n  var littleOffset = 26;\n  var numberOffset = 52;\n\n  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n  if (bigA <= charCode && charCode <= bigZ) {\n    return (charCode - bigA);\n  }\n\n  // 26 - 51: abcdefghijklmnopqrstuvwxyz\n  if (littleA <= charCode && charCode <= littleZ) {\n    return (charCode - littleA + littleOffset);\n  }\n\n  // 52 - 61: 0123456789\n  if (zero <= charCode && charCode <= nine) {\n    return (charCode - zero + numberOffset);\n  }\n\n  // 62: +\n  if (charCode == plus) {\n    return 62;\n  }\n\n  // 63: /\n  if (charCode == slash) {\n    return 63;\n  }\n\n  // Invalid base64 digit.\n  return -1;\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nexports.GREATEST_LOWER_BOUND = 1;\nexports.LEAST_UPPER_BOUND = 2;\n\n/**\n * Recursive implementation of binary search.\n *\n * @param aLow Indices here and lower do not contain the needle.\n * @param aHigh Indices here and higher do not contain the needle.\n * @param aNeedle The element being searched for.\n * @param aHaystack The non-empty array being searched.\n * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n */\nfunction recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n  // This function terminates when one of the following is true:\n  //\n  //   1. We find the exact element we are looking for.\n  //\n  //   2. We did not find the exact element, but we can return the index of\n  //      the next-closest element.\n  //\n  //   3. We did not find the exact element, and there is no next-closest\n  //      element than the one we are searching for, so we return -1.\n  var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n  var cmp = aCompare(aNeedle, aHaystack[mid], true);\n  if (cmp === 0) {\n    // Found the element we are looking for.\n    return mid;\n  }\n  else if (cmp > 0) {\n    // Our needle is greater than aHaystack[mid].\n    if (aHigh - mid > 1) {\n      // The element is in the upper half.\n      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // The exact needle element was not found in this haystack. Determine if\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return aHigh < aHaystack.length ? aHigh : -1;\n    } else {\n      return mid;\n    }\n  }\n  else {\n    // Our needle is less than aHaystack[mid].\n    if (mid - aLow > 1) {\n      // The element is in the lower half.\n      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return mid;\n    } else {\n      return aLow < 0 ? -1 : aLow;\n    }\n  }\n}\n\n/**\n * This is an implementation of binary search which will always try and return\n * the index of the closest element if there is no exact hit. This is because\n * mappings between original and generated line/col pairs are single points,\n * and there is an implicit region between each of them, so a miss just means\n * that you aren't on the very start of a region.\n *\n * @param aNeedle The element you are looking for.\n * @param aHaystack The array that is being searched.\n * @param aCompare A function which takes the needle and an element in the\n *     array and returns -1, 0, or 1 depending on whether the needle is less\n *     than, equal to, or greater than the element, respectively.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n */\nexports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n  if (aHaystack.length === 0) {\n    return -1;\n  }\n\n  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,\n                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n  if (index < 0) {\n    return -1;\n  }\n\n  // We have found either the exact element, or the next-closest element than\n  // the one we are searching for. However, there may be more than one such\n  // element. Make sure we always return the smallest of these.\n  while (index - 1 >= 0) {\n    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n      break;\n    }\n    --index;\n  }\n\n  return index;\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2014 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\n\n/**\n * Determine whether mappingB is after mappingA with respect to generated\n * position.\n */\nfunction generatedPositionAfter(mappingA, mappingB) {\n  // Optimized for most common case\n  var lineA = mappingA.generatedLine;\n  var lineB = mappingB.generatedLine;\n  var columnA = mappingA.generatedColumn;\n  var columnB = mappingB.generatedColumn;\n  return lineB > lineA || lineB == lineA && columnB >= columnA ||\n         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n}\n\n/**\n * A data structure to provide a sorted view of accumulated mappings in a\n * performance conscious manner. It trades a neglibable overhead in general\n * case for a large speedup in case of mappings being added in order.\n */\nfunction MappingList() {\n  this._array = [];\n  this._sorted = true;\n  // Serves as infimum\n  this._last = {generatedLine: -1, generatedColumn: 0};\n}\n\n/**\n * Iterate through internal items. This method takes the same arguments that\n * `Array.prototype.forEach` takes.\n *\n * NOTE: The order of the mappings is NOT guaranteed.\n */\nMappingList.prototype.unsortedForEach =\n  function MappingList_forEach(aCallback, aThisArg) {\n    this._array.forEach(aCallback, aThisArg);\n  };\n\n/**\n * Add the given source mapping.\n *\n * @param Object aMapping\n */\nMappingList.prototype.add = function MappingList_add(aMapping) {\n  if (generatedPositionAfter(this._last, aMapping)) {\n    this._last = aMapping;\n    this._array.push(aMapping);\n  } else {\n    this._sorted = false;\n    this._array.push(aMapping);\n  }\n};\n\n/**\n * Returns the flat, sorted array of mappings. The mappings are sorted by\n * generated position.\n *\n * WARNING: This method returns internal data without copying, for\n * performance. The return value must NOT be mutated, and should be treated as\n * an immutable borrow. If you want to take ownership, you must make your own\n * copy.\n */\nMappingList.prototype.toArray = function MappingList_toArray() {\n  if (!this._sorted) {\n    this._array.sort(util.compareByGeneratedPositionsInflated);\n    this._sorted = true;\n  }\n  return this._array;\n};\n\nexports.MappingList = MappingList;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n// It turns out that some (most?) JavaScript engines don't self-host\n// `Array.prototype.sort`. This makes sense because C++ will likely remain\n// faster than JS when doing raw CPU-intensive sorting. However, when using a\n// custom comparator function, calling back and forth between the VM's C++ and\n// JIT'd JS is rather slow *and* loses JIT type information, resulting in\n// worse generated code for the comparator function than would be optimal. In\n// fact, when sorting with a comparator, these costs outweigh the benefits of\n// sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n// a ~3500ms mean speed-up in `bench/bench.html`.\n\n/**\n * Swap the elements indexed by `x` and `y` in the array `ary`.\n *\n * @param {Array} ary\n *        The array.\n * @param {Number} x\n *        The index of the first item.\n * @param {Number} y\n *        The index of the second item.\n */\nfunction swap(ary, x, y) {\n  var temp = ary[x];\n  ary[x] = ary[y];\n  ary[y] = temp;\n}\n\n/**\n * Returns a random integer within the range `low .. high` inclusive.\n *\n * @param {Number} low\n *        The lower bound on the range.\n * @param {Number} high\n *        The upper bound on the range.\n */\nfunction randomIntInRange(low, high) {\n  return Math.round(low + (Math.random() * (high - low)));\n}\n\n/**\n * The Quick Sort algorithm.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n * @param {Number} p\n *        Start index of the array\n * @param {Number} r\n *        End index of the array\n */\nfunction doQuickSort(ary, comparator, p, r) {\n  // If our lower bound is less than our upper bound, we (1) partition the\n  // array into two pieces and (2) recurse on each half. If it is not, this is\n  // the empty array and our base case.\n\n  if (p < r) {\n    // (1) Partitioning.\n    //\n    // The partitioning chooses a pivot between `p` and `r` and moves all\n    // elements that are less than or equal to the pivot to the before it, and\n    // all the elements that are greater than it after it. The effect is that\n    // once partition is done, the pivot is in the exact place it will be when\n    // the array is put in sorted order, and it will not need to be moved\n    // again. This runs in O(n) time.\n\n    // Always choose a random pivot so that an input array which is reverse\n    // sorted does not cause O(n^2) running time.\n    var pivotIndex = randomIntInRange(p, r);\n    var i = p - 1;\n\n    swap(ary, pivotIndex, r);\n    var pivot = ary[r];\n\n    // Immediately after `j` is incremented in this loop, the following hold\n    // true:\n    //\n    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n    //\n    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n    for (var j = p; j < r; j++) {\n      if (comparator(ary[j], pivot) <= 0) {\n        i += 1;\n        swap(ary, i, j);\n      }\n    }\n\n    swap(ary, i + 1, j);\n    var q = i + 1;\n\n    // (2) Recurse on each half.\n\n    doQuickSort(ary, comparator, p, q - 1);\n    doQuickSort(ary, comparator, q + 1, r);\n  }\n}\n\n/**\n * Sort the given array in-place with the given comparator function.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n */\nexports.quickSort = function (ary, comparator) {\n  doQuickSort(ary, comparator, 0, ary.length - 1);\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar binarySearch = require('./binary-search');\nvar ArraySet = require('./array-set').ArraySet;\nvar base64VLQ = require('./base64-vlq');\nvar quickSort = require('./quick-sort').quickSort;\n\nfunction SourceMapConsumer(aSourceMap, aSourceMapURL) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  return sourceMap.sections != null\n    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)\n    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);\n}\n\nSourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);\n}\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nSourceMapConsumer.prototype._version = 3;\n\n// `__generatedMappings` and `__originalMappings` are arrays that hold the\n// parsed mapping coordinates from the source map's \"mappings\" attribute. They\n// are lazily instantiated, accessed via the `_generatedMappings` and\n// `_originalMappings` getters respectively, and we only parse the mappings\n// and create these arrays once queried for a source location. We jump through\n// these hoops because there can be many thousands of mappings, and parsing\n// them is expensive, so we only want to do it if we must.\n//\n// Each object in the arrays is of the form:\n//\n//     {\n//       generatedLine: The line number in the generated code,\n//       generatedColumn: The column number in the generated code,\n//       source: The path to the original source file that generated this\n//               chunk of code,\n//       originalLine: The line number in the original source that\n//                     corresponds to this chunk of generated code,\n//       originalColumn: The column number in the original source that\n//                       corresponds to this chunk of generated code,\n//       name: The name of the original symbol which generated this chunk of\n//             code.\n//     }\n//\n// All properties except for `generatedLine` and `generatedColumn` can be\n// `null`.\n//\n// `_generatedMappings` is ordered by the generated positions.\n//\n// `_originalMappings` is ordered by the original positions.\n\nSourceMapConsumer.prototype.__generatedMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    if (!this.__generatedMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__generatedMappings;\n  }\n});\n\nSourceMapConsumer.prototype.__originalMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    if (!this.__originalMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__originalMappings;\n  }\n});\n\nSourceMapConsumer.prototype._charIsMappingSeparator =\n  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n    var c = aStr.charAt(index);\n    return c === \";\" || c === \",\";\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    throw new Error(\"Subclasses must implement _parseMappings\");\n  };\n\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\n\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\n/**\n * Iterate over each mapping between an original source/line/column and a\n * generated line/column in this source map.\n *\n * @param Function aCallback\n *        The function that is called with each mapping.\n * @param Object aContext\n *        Optional. If specified, this object will be the value of `this` every\n *        time that `aCallback` is called.\n * @param aOrder\n *        Either `SourceMapConsumer.GENERATED_ORDER` or\n *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n *        iterate over the mappings sorted by the generated file's line/column\n *        order or the original's source/line/column order, respectively. Defaults to\n *        `SourceMapConsumer.GENERATED_ORDER`.\n */\nSourceMapConsumer.prototype.eachMapping =\n  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n    var context = aContext || null;\n    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n    var mappings;\n    switch (order) {\n    case SourceMapConsumer.GENERATED_ORDER:\n      mappings = this._generatedMappings;\n      break;\n    case SourceMapConsumer.ORIGINAL_ORDER:\n      mappings = this._originalMappings;\n      break;\n    default:\n      throw new Error(\"Unknown order of iteration.\");\n    }\n\n    var sourceRoot = this.sourceRoot;\n    mappings.map(function (mapping) {\n      var source = mapping.source === null ? null : this._sources.at(mapping.source);\n      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);\n      return {\n        source: source,\n        generatedLine: mapping.generatedLine,\n        generatedColumn: mapping.generatedColumn,\n        originalLine: mapping.originalLine,\n        originalColumn: mapping.originalColumn,\n        name: mapping.name === null ? null : this._names.at(mapping.name)\n      };\n    }, this).forEach(aCallback, context);\n  };\n\n/**\n * Returns all generated line and column information for the original source,\n * line, and column provided. If no column is provided, returns all mappings\n * corresponding to a either the line we are searching for or the next\n * closest line that has any mappings. Otherwise, returns all mappings\n * corresponding to the given line and either the column we are searching for\n * or the next closest column that has any offsets.\n *\n * The only argument is an object with the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number is 1-based.\n *   - column: Optional. the column number in the original source.\n *    The column number is 0-based.\n *\n * and an array of objects is returned, each with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *    line number is 1-based.\n *   - column: The column number in the generated source, or null.\n *    The column number is 0-based.\n */\nSourceMapConsumer.prototype.allGeneratedPositionsFor =\n  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n    var line = util.getArg(aArgs, 'line');\n\n    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n    // returns the index of the closest mapping less than the needle. By\n    // setting needle.originalColumn to 0, we thus find the last mapping for\n    // the given line, provided such a mapping exists.\n    var needle = {\n      source: util.getArg(aArgs, 'source'),\n      originalLine: line,\n      originalColumn: util.getArg(aArgs, 'column', 0)\n    };\n\n    needle.source = this._findSourceIndex(needle.source);\n    if (needle.source < 0) {\n      return [];\n    }\n\n    var mappings = [];\n\n    var index = this._findMapping(needle,\n                                  this._originalMappings,\n                                  \"originalLine\",\n                                  \"originalColumn\",\n                                  util.compareByOriginalPositions,\n                                  binarySearch.LEAST_UPPER_BOUND);\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (aArgs.column === undefined) {\n        var originalLine = mapping.originalLine;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we found. Since\n        // mappings are sorted, this is guaranteed to find all mappings for\n        // the line we found.\n        while (mapping && mapping.originalLine === originalLine) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      } else {\n        var originalColumn = mapping.originalColumn;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we were searching for.\n        // Since mappings are sorted, this is guaranteed to find all mappings for\n        // the line we are searching for.\n        while (mapping &&\n               mapping.originalLine === line &&\n               mapping.originalColumn == originalColumn) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      }\n    }\n\n    return mappings;\n  };\n\nexports.SourceMapConsumer = SourceMapConsumer;\n\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The first parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referrenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */\nfunction BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sources = util.getArg(sourceMap, 'sources');\n  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n  // requires the array) to play nice here.\n  var names = util.getArg(sourceMap, 'names', []);\n  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n  var mappings = util.getArg(sourceMap, 'mappings');\n  var file = util.getArg(sourceMap, 'file', null);\n\n  // Once again, Sass deviates from the spec and supplies the version as a\n  // string rather than a number, so we use loose equality checking here.\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  if (sourceRoot) {\n    sourceRoot = util.normalize(sourceRoot);\n  }\n\n  sources = sources\n    .map(String)\n    // Some source maps produce relative source paths like \"./foo.js\" instead of\n    // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n    // See bugzil.la/1090768.\n    .map(util.normalize)\n    // Always ensure that absolute sources are internally stored relative to\n    // the source root, if the source root is absolute. Not doing this would\n    // be particularly problematic when the source root is a prefix of the\n    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n    .map(function (source) {\n      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)\n        ? util.relative(sourceRoot, source)\n        : source;\n    });\n\n  // Pass `true` below to allow duplicate names and sources. While source maps\n  // are intended to be compressed and deduplicated, the TypeScript compiler\n  // sometimes generates source maps with duplicates in them. See Github issue\n  // #72 and bugzil.la/889492.\n  this._names = ArraySet.fromArray(names.map(String), true);\n  this._sources = ArraySet.fromArray(sources, true);\n\n  this._absoluteSources = this._sources.toArray().map(function (s) {\n    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);\n  });\n\n  this.sourceRoot = sourceRoot;\n  this.sourcesContent = sourcesContent;\n  this._mappings = mappings;\n  this._sourceMapURL = aSourceMapURL;\n  this.file = file;\n}\n\nBasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n\n/**\n * Utility function to find the index of a source.  Returns -1 if not\n * found.\n */\nBasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {\n  var relativeSource = aSource;\n  if (this.sourceRoot != null) {\n    relativeSource = util.relative(this.sourceRoot, relativeSource);\n  }\n\n  if (this._sources.has(relativeSource)) {\n    return this._sources.indexOf(relativeSource);\n  }\n\n  // Maybe aSource is an absolute URL as returned by |sources|.  In\n  // this case we can't simply undo the transform.\n  var i;\n  for (i = 0; i < this._absoluteSources.length; ++i) {\n    if (this._absoluteSources[i] == aSource) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n\n/**\n * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n *\n * @param SourceMapGenerator aSourceMap\n *        The source map that will be consumed.\n * @param String aSourceMapURL\n *        The URL at which the source map can be found (optional)\n * @returns BasicSourceMapConsumer\n */\nBasicSourceMapConsumer.fromSourceMap =\n  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {\n    var smc = Object.create(BasicSourceMapConsumer.prototype);\n\n    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n    smc.sourceRoot = aSourceMap._sourceRoot;\n    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),\n                                                            smc.sourceRoot);\n    smc.file = aSourceMap._file;\n    smc._sourceMapURL = aSourceMapURL;\n    smc._absoluteSources = smc._sources.toArray().map(function (s) {\n      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);\n    });\n\n    // Because we are modifying the entries (by converting string sources and\n    // names to indices into the sources and names ArraySets), we have to make\n    // a copy of the entry or else bad things happen. Shared mutable state\n    // strikes again! See github issue #191.\n\n    var generatedMappings = aSourceMap._mappings.toArray().slice();\n    var destGeneratedMappings = smc.__generatedMappings = [];\n    var destOriginalMappings = smc.__originalMappings = [];\n\n    for (var i = 0, length = generatedMappings.length; i < length; i++) {\n      var srcMapping = generatedMappings[i];\n      var destMapping = new Mapping;\n      destMapping.generatedLine = srcMapping.generatedLine;\n      destMapping.generatedColumn = srcMapping.generatedColumn;\n\n      if (srcMapping.source) {\n        destMapping.source = sources.indexOf(srcMapping.source);\n        destMapping.originalLine = srcMapping.originalLine;\n        destMapping.originalColumn = srcMapping.originalColumn;\n\n        if (srcMapping.name) {\n          destMapping.name = names.indexOf(srcMapping.name);\n        }\n\n        destOriginalMappings.push(destMapping);\n      }\n\n      destGeneratedMappings.push(destMapping);\n    }\n\n    quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n\n    return smc;\n  };\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nBasicSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    return this._absoluteSources.slice();\n  }\n});\n\n/**\n * Provide the JIT with a nice shape / hidden class.\n */\nfunction Mapping() {\n  this.generatedLine = 0;\n  this.generatedColumn = 0;\n  this.source = null;\n  this.originalLine = null;\n  this.originalColumn = null;\n  this.name = null;\n}\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nBasicSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    var generatedLine = 1;\n    var previousGeneratedColumn = 0;\n    var previousOriginalLine = 0;\n    var previousOriginalColumn = 0;\n    var previousSource = 0;\n    var previousName = 0;\n    var length = aStr.length;\n    var index = 0;\n    var cachedSegments = {};\n    var temp = {};\n    var originalMappings = [];\n    var generatedMappings = [];\n    var mapping, str, segment, end, value;\n\n    while (index < length) {\n      if (aStr.charAt(index) === ';') {\n        generatedLine++;\n        index++;\n        previousGeneratedColumn = 0;\n      }\n      else if (aStr.charAt(index) === ',') {\n        index++;\n      }\n      else {\n        mapping = new Mapping();\n        mapping.generatedLine = generatedLine;\n\n        // Because each offset is encoded relative to the previous one,\n        // many segments often have the same encoding. We can exploit this\n        // fact by caching the parsed variable length fields of each segment,\n        // allowing us to avoid a second parse if we encounter the same\n        // segment again.\n        for (end = index; end < length; end++) {\n          if (this._charIsMappingSeparator(aStr, end)) {\n            break;\n          }\n        }\n        str = aStr.slice(index, end);\n\n        segment = cachedSegments[str];\n        if (segment) {\n          index += str.length;\n        } else {\n          segment = [];\n          while (index < end) {\n            base64VLQ.decode(aStr, index, temp);\n            value = temp.value;\n            index = temp.rest;\n            segment.push(value);\n          }\n\n          if (segment.length === 2) {\n            throw new Error('Found a source, but no line and column');\n          }\n\n          if (segment.length === 3) {\n            throw new Error('Found a source and line, but no column');\n          }\n\n          cachedSegments[str] = segment;\n        }\n\n        // Generated column.\n        mapping.generatedColumn = previousGeneratedColumn + segment[0];\n        previousGeneratedColumn = mapping.generatedColumn;\n\n        if (segment.length > 1) {\n          // Original source.\n          mapping.source = previousSource + segment[1];\n          previousSource += segment[1];\n\n          // Original line.\n          mapping.originalLine = previousOriginalLine + segment[2];\n          previousOriginalLine = mapping.originalLine;\n          // Lines are stored 0-based\n          mapping.originalLine += 1;\n\n          // Original column.\n          mapping.originalColumn = previousOriginalColumn + segment[3];\n          previousOriginalColumn = mapping.originalColumn;\n\n          if (segment.length > 4) {\n            // Original name.\n            mapping.name = previousName + segment[4];\n            previousName += segment[4];\n          }\n        }\n\n        generatedMappings.push(mapping);\n        if (typeof mapping.originalLine === 'number') {\n          originalMappings.push(mapping);\n        }\n      }\n    }\n\n    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);\n    this.__generatedMappings = generatedMappings;\n\n    quickSort(originalMappings, util.compareByOriginalPositions);\n    this.__originalMappings = originalMappings;\n  };\n\n/**\n * Find the mapping that best matches the hypothetical \"needle\" mapping that\n * we are searching for in the given \"haystack\" of mappings.\n */\nBasicSourceMapConsumer.prototype._findMapping =\n  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,\n                                         aColumnName, aComparator, aBias) {\n    // To return the position we are searching for, we must first find the\n    // mapping for the given position and then return the opposite position it\n    // points to. Because the mappings are sorted, we can use binary search to\n    // find the best mapping.\n\n    if (aNeedle[aLineName] <= 0) {\n      throw new TypeError('Line must be greater than or equal to 1, got '\n                          + aNeedle[aLineName]);\n    }\n    if (aNeedle[aColumnName] < 0) {\n      throw new TypeError('Column must be greater than or equal to 0, got '\n                          + aNeedle[aColumnName]);\n    }\n\n    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n  };\n\n/**\n * Compute the last column for each generated mapping. The last column is\n * inclusive.\n */\nBasicSourceMapConsumer.prototype.computeColumnSpans =\n  function SourceMapConsumer_computeColumnSpans() {\n    for (var index = 0; index < this._generatedMappings.length; ++index) {\n      var mapping = this._generatedMappings[index];\n\n      // Mappings do not contain a field for the last generated columnt. We\n      // can come up with an optimistic estimate, however, by assuming that\n      // mappings are contiguous (i.e. given two consecutive mappings, the\n      // first mapping ends where the second one starts).\n      if (index + 1 < this._generatedMappings.length) {\n        var nextMapping = this._generatedMappings[index + 1];\n\n        if (mapping.generatedLine === nextMapping.generatedLine) {\n          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n          continue;\n        }\n      }\n\n      // The last mapping for each line spans the entire line.\n      mapping.lastGeneratedColumn = Infinity;\n    }\n  };\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.  The line number\n *     is 1-based.\n *   - column: The column number in the generated source.  The column\n *     number is 0-based.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the original source, or null.  The\n *     column number is 0-based.\n *   - name: The original identifier, or null.\n */\nBasicSourceMapConsumer.prototype.originalPositionFor =\n  function SourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._generatedMappings,\n      \"generatedLine\",\n      \"generatedColumn\",\n      util.compareByGeneratedPositionsDeflated,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._generatedMappings[index];\n\n      if (mapping.generatedLine === needle.generatedLine) {\n        var source = util.getArg(mapping, 'source', null);\n        if (source !== null) {\n          source = this._sources.at(source);\n          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);\n        }\n        var name = util.getArg(mapping, 'name', null);\n        if (name !== null) {\n          name = this._names.at(name);\n        }\n        return {\n          source: source,\n          line: util.getArg(mapping, 'originalLine', null),\n          column: util.getArg(mapping, 'originalColumn', null),\n          name: name\n        };\n      }\n    }\n\n    return {\n      source: null,\n      line: null,\n      column: null,\n      name: null\n    };\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nBasicSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function BasicSourceMapConsumer_hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n      return false;\n    }\n    return this.sourcesContent.length >= this._sources.size() &&\n      !this.sourcesContent.some(function (sc) { return sc == null; });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nBasicSourceMapConsumer.prototype.sourceContentFor =\n  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n      return null;\n    }\n\n    var index = this._findSourceIndex(aSource);\n    if (index >= 0) {\n      return this.sourcesContent[index];\n    }\n\n    var relativeSource = aSource;\n    if (this.sourceRoot != null) {\n      relativeSource = util.relative(this.sourceRoot, relativeSource);\n    }\n\n    var url;\n    if (this.sourceRoot != null\n        && (url = util.urlParse(this.sourceRoot))) {\n      // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n      // many users. We can help them out when they expect file:// URIs to\n      // behave like it would if they were running a local HTTP server. See\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n      var fileUriAbsPath = relativeSource.replace(/^file:\\/\\//, \"\");\n      if (url.scheme == \"file\"\n          && this._sources.has(fileUriAbsPath)) {\n        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]\n      }\n\n      if ((!url.path || url.path == \"/\")\n          && this._sources.has(\"/\" + relativeSource)) {\n        return this.sourcesContent[this._sources.indexOf(\"/\" + relativeSource)];\n      }\n    }\n\n    // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + relativeSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number\n *     is 1-based.\n *   - column: The column number in the original source.  The column\n *     number is 0-based.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the generated source, or null.\n *     The column number is 0-based.\n */\nBasicSourceMapConsumer.prototype.generatedPositionFor =\n  function SourceMapConsumer_generatedPositionFor(aArgs) {\n    var source = util.getArg(aArgs, 'source');\n    source = this._findSourceIndex(source);\n    if (source < 0) {\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    }\n\n    var needle = {\n      source: source,\n      originalLine: util.getArg(aArgs, 'line'),\n      originalColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._originalMappings,\n      \"originalLine\",\n      \"originalColumn\",\n      util.compareByOriginalPositions,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (mapping.source === needle.source) {\n        return {\n          line: util.getArg(mapping, 'generatedLine', null),\n          column: util.getArg(mapping, 'generatedColumn', null),\n          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n        };\n      }\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  };\n\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The first parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */\nfunction IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sections = util.getArg(sourceMap, 'sections');\n\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n\n  var lastOffset = {\n    line: -1,\n    column: 0\n  };\n  this._sections = sections.map(function (s) {\n    if (s.url) {\n      // The url field will require support for asynchronicity.\n      // See https://github.com/mozilla/source-map/issues/16\n      throw new Error('Support for url field in sections not implemented.');\n    }\n    var offset = util.getArg(s, 'offset');\n    var offsetLine = util.getArg(offset, 'line');\n    var offsetColumn = util.getArg(offset, 'column');\n\n    if (offsetLine < lastOffset.line ||\n        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\n      throw new Error('Section offsets must be ordered and non-overlapping.');\n    }\n    lastOffset = offset;\n\n    return {\n      generatedOffset: {\n        // The offset fields are 0-based, but we use 1-based indices when\n        // encoding/decoding from VLQ.\n        generatedLine: offsetLine + 1,\n        generatedColumn: offsetColumn + 1\n      },\n      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)\n    }\n  });\n}\n\nIndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nIndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nIndexedSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    var sources = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\n        sources.push(this._sections[i].consumer.sources[j]);\n      }\n    }\n    return sources;\n  }\n});\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.  The line number\n *     is 1-based.\n *   - column: The column number in the generated source.  The column\n *     number is 0-based.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the original source, or null.  The\n *     column number is 0-based.\n *   - name: The original identifier, or null.\n */\nIndexedSourceMapConsumer.prototype.originalPositionFor =\n  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    // Find the section containing the generated position we're trying to map\n    // to an original position.\n    var sectionIndex = binarySearch.search(needle, this._sections,\n      function(needle, section) {\n        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n        if (cmp) {\n          return cmp;\n        }\n\n        return (needle.generatedColumn -\n                section.generatedOffset.generatedColumn);\n      });\n    var section = this._sections[sectionIndex];\n\n    if (!section) {\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    }\n\n    return section.consumer.originalPositionFor({\n      line: needle.generatedLine -\n        (section.generatedOffset.generatedLine - 1),\n      column: needle.generatedColumn -\n        (section.generatedOffset.generatedLine === needle.generatedLine\n         ? section.generatedOffset.generatedColumn - 1\n         : 0),\n      bias: aArgs.bias\n    });\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nIndexedSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n    return this._sections.every(function (s) {\n      return s.consumer.hasContentsOfAllSources();\n    });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nIndexedSourceMapConsumer.prototype.sourceContentFor =\n  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      var content = section.consumer.sourceContentFor(aSource, true);\n      if (content) {\n        return content;\n      }\n    }\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number\n *     is 1-based.\n *   - column: The column number in the original source.  The column\n *     number is 0-based.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *     line number is 1-based. \n *   - column: The column number in the generated source, or null.\n *     The column number is 0-based.\n */\nIndexedSourceMapConsumer.prototype.generatedPositionFor =\n  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      // Only consider this section if the requested source is in the list of\n      // sources of the consumer.\n      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {\n        continue;\n      }\n      var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n      if (generatedPosition) {\n        var ret = {\n          line: generatedPosition.line +\n            (section.generatedOffset.generatedLine - 1),\n          column: generatedPosition.column +\n            (section.generatedOffset.generatedLine === generatedPosition.line\n             ? section.generatedOffset.generatedColumn - 1\n             : 0)\n        };\n        return ret;\n      }\n    }\n\n    return {\n      line: null,\n      column: null\n    };\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nIndexedSourceMapConsumer.prototype._parseMappings =\n  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    this.__generatedMappings = [];\n    this.__originalMappings = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n      var sectionMappings = section.consumer._generatedMappings;\n      for (var j = 0; j < sectionMappings.length; j++) {\n        var mapping = sectionMappings[j];\n\n        var source = section.consumer._sources.at(mapping.source);\n        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);\n        this._sources.add(source);\n        source = this._sources.indexOf(source);\n\n        var name = null;\n        if (mapping.name) {\n          name = section.consumer._names.at(mapping.name);\n          this._names.add(name);\n          name = this._names.indexOf(name);\n        }\n\n        // The mappings coming from the consumer for the section have\n        // generated positions relative to the start of the section, so we\n        // need to offset them to be relative to the start of the concatenated\n        // generated file.\n        var adjustedMapping = {\n          source: source,\n          generatedLine: mapping.generatedLine +\n            (section.generatedOffset.generatedLine - 1),\n          generatedColumn: mapping.generatedColumn +\n            (section.generatedOffset.generatedLine === mapping.generatedLine\n            ? section.generatedOffset.generatedColumn - 1\n            : 0),\n          originalLine: mapping.originalLine,\n          originalColumn: mapping.originalColumn,\n          name: name\n        };\n\n        this.__generatedMappings.push(adjustedMapping);\n        if (typeof adjustedMapping.originalLine === 'number') {\n          this.__originalMappings.push(adjustedMapping);\n        }\n      }\n    }\n\n    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n    quickSort(this.__originalMappings, util.compareByOriginalPositions);\n  };\n\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar base64VLQ = require('./base64-vlq');\nvar util = require('./util');\nvar ArraySet = require('./array-set').ArraySet;\nvar MappingList = require('./mapping-list').MappingList;\n\n/**\n * An instance of the SourceMapGenerator represents a source map which is\n * being built incrementally. You may pass an object with the following\n * properties:\n *\n *   - file: The filename of the generated source.\n *   - sourceRoot: A root for all relative URLs in this source map.\n */\nfunction SourceMapGenerator(aArgs) {\n  if (!aArgs) {\n    aArgs = {};\n  }\n  this._file = util.getArg(aArgs, 'file', null);\n  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\n  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n  this._mappings = new MappingList();\n  this._sourcesContents = null;\n}\n\nSourceMapGenerator.prototype._version = 3;\n\n/**\n * Creates a new SourceMapGenerator based on a SourceMapConsumer\n *\n * @param aSourceMapConsumer The SourceMap.\n */\nSourceMapGenerator.fromSourceMap =\n  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n    var sourceRoot = aSourceMapConsumer.sourceRoot;\n    var generator = new SourceMapGenerator({\n      file: aSourceMapConsumer.file,\n      sourceRoot: sourceRoot\n    });\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      var newMapping = {\n        generated: {\n          line: mapping.generatedLine,\n          column: mapping.generatedColumn\n        }\n      };\n\n      if (mapping.source != null) {\n        newMapping.source = mapping.source;\n        if (sourceRoot != null) {\n          newMapping.source = util.relative(sourceRoot, newMapping.source);\n        }\n\n        newMapping.original = {\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        };\n\n        if (mapping.name != null) {\n          newMapping.name = mapping.name;\n        }\n      }\n\n      generator.addMapping(newMapping);\n    });\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var sourceRelative = sourceFile;\n      if (sourceRoot !== null) {\n        sourceRelative = util.relative(sourceRoot, sourceFile);\n      }\n\n      if (!generator._sources.has(sourceRelative)) {\n        generator._sources.add(sourceRelative);\n      }\n\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        generator.setSourceContent(sourceFile, content);\n      }\n    });\n    return generator;\n  };\n\n/**\n * Add a single mapping from original source line and column to the generated\n * source's line and column for this source map being created. The mapping\n * object should have the following properties:\n *\n *   - generated: An object with the generated line and column positions.\n *   - original: An object with the original line and column positions.\n *   - source: The original source file (relative to the sourceRoot).\n *   - name: An optional original token name for this mapping.\n */\nSourceMapGenerator.prototype.addMapping =\n  function SourceMapGenerator_addMapping(aArgs) {\n    var generated = util.getArg(aArgs, 'generated');\n    var original = util.getArg(aArgs, 'original', null);\n    var source = util.getArg(aArgs, 'source', null);\n    var name = util.getArg(aArgs, 'name', null);\n\n    if (!this._skipValidation) {\n      this._validateMapping(generated, original, source, name);\n    }\n\n    if (source != null) {\n      source = String(source);\n      if (!this._sources.has(source)) {\n        this._sources.add(source);\n      }\n    }\n\n    if (name != null) {\n      name = String(name);\n      if (!this._names.has(name)) {\n        this._names.add(name);\n      }\n    }\n\n    this._mappings.add({\n      generatedLine: generated.line,\n      generatedColumn: generated.column,\n      originalLine: original != null && original.line,\n      originalColumn: original != null && original.column,\n      source: source,\n      name: name\n    });\n  };\n\n/**\n * Set the source content for a source file.\n */\nSourceMapGenerator.prototype.setSourceContent =\n  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n    var source = aSourceFile;\n    if (this._sourceRoot != null) {\n      source = util.relative(this._sourceRoot, source);\n    }\n\n    if (aSourceContent != null) {\n      // Add the source content to the _sourcesContents map.\n      // Create a new _sourcesContents map if the property is null.\n      if (!this._sourcesContents) {\n        this._sourcesContents = Object.create(null);\n      }\n      this._sourcesContents[util.toSetString(source)] = aSourceContent;\n    } else if (this._sourcesContents) {\n      // Remove the source file from the _sourcesContents map.\n      // If the _sourcesContents map is empty, set the property to null.\n      delete this._sourcesContents[util.toSetString(source)];\n      if (Object.keys(this._sourcesContents).length === 0) {\n        this._sourcesContents = null;\n      }\n    }\n  };\n\n/**\n * Applies the mappings of a sub-source-map for a specific source file to the\n * source map being generated. Each mapping to the supplied source file is\n * rewritten using the supplied source map. Note: The resolution for the\n * resulting mappings is the minimium of this map and the supplied map.\n *\n * @param aSourceMapConsumer The source map to be applied.\n * @param aSourceFile Optional. The filename of the source file.\n *        If omitted, SourceMapConsumer's file property will be used.\n * @param aSourceMapPath Optional. The dirname of the path to the source map\n *        to be applied. If relative, it is relative to the SourceMapConsumer.\n *        This parameter is needed when the two source maps aren't in the same\n *        directory, and the source map to be applied contains relative source\n *        paths. If so, those relative source paths need to be rewritten\n *        relative to the SourceMapGenerator.\n */\nSourceMapGenerator.prototype.applySourceMap =\n  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n    var sourceFile = aSourceFile;\n    // If aSourceFile is omitted, we will use the file property of the SourceMap\n    if (aSourceFile == null) {\n      if (aSourceMapConsumer.file == null) {\n        throw new Error(\n          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +\n          'or the source map\\'s \"file\" property. Both were omitted.'\n        );\n      }\n      sourceFile = aSourceMapConsumer.file;\n    }\n    var sourceRoot = this._sourceRoot;\n    // Make \"sourceFile\" relative if an absolute Url is passed.\n    if (sourceRoot != null) {\n      sourceFile = util.relative(sourceRoot, sourceFile);\n    }\n    // Applying the SourceMap can add and remove items from the sources and\n    // the names array.\n    var newSources = new ArraySet();\n    var newNames = new ArraySet();\n\n    // Find mappings for the \"sourceFile\"\n    this._mappings.unsortedForEach(function (mapping) {\n      if (mapping.source === sourceFile && mapping.originalLine != null) {\n        // Check if it can be mapped by the source map, then update the mapping.\n        var original = aSourceMapConsumer.originalPositionFor({\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        });\n        if (original.source != null) {\n          // Copy mapping\n          mapping.source = original.source;\n          if (aSourceMapPath != null) {\n            mapping.source = util.join(aSourceMapPath, mapping.source)\n          }\n          if (sourceRoot != null) {\n            mapping.source = util.relative(sourceRoot, mapping.source);\n          }\n          mapping.originalLine = original.line;\n          mapping.originalColumn = original.column;\n          if (original.name != null) {\n            mapping.name = original.name;\n          }\n        }\n      }\n\n      var source = mapping.source;\n      if (source != null && !newSources.has(source)) {\n        newSources.add(source);\n      }\n\n      var name = mapping.name;\n      if (name != null && !newNames.has(name)) {\n        newNames.add(name);\n      }\n\n    }, this);\n    this._sources = newSources;\n    this._names = newNames;\n\n    // Copy sourcesContents of applied map.\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aSourceMapPath != null) {\n          sourceFile = util.join(aSourceMapPath, sourceFile);\n        }\n        if (sourceRoot != null) {\n          sourceFile = util.relative(sourceRoot, sourceFile);\n        }\n        this.setSourceContent(sourceFile, content);\n      }\n    }, this);\n  };\n\n/**\n * A mapping can have one of the three levels of data:\n *\n *   1. Just the generated position.\n *   2. The Generated position, original position, and original source.\n *   3. Generated and original position, original source, as well as a name\n *      token.\n *\n * To maintain consistency, we validate that any new mapping being added falls\n * in to one of these categories.\n */\nSourceMapGenerator.prototype._validateMapping =\n  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,\n                                              aName) {\n    // When aOriginal is truthy but has empty values for .line and .column,\n    // it is most likely a programmer error. In this case we throw a very\n    // specific error message to try to guide them the right way.\n    // For example: https://github.com/Polymer/polymer-bundler/pull/519\n    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {\n        throw new Error(\n            'original.line and original.column are not numbers -- you probably meant to omit ' +\n            'the original mapping entirely and only map the generated position. If so, pass ' +\n            'null for the original mapping instead of an object with empty or null values.'\n        );\n    }\n\n    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n        && aGenerated.line > 0 && aGenerated.column >= 0\n        && !aOriginal && !aSource && !aName) {\n      // Case 1.\n      return;\n    }\n    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n             && aOriginal && 'line' in aOriginal && 'column' in aOriginal\n             && aGenerated.line > 0 && aGenerated.column >= 0\n             && aOriginal.line > 0 && aOriginal.column >= 0\n             && aSource) {\n      // Cases 2 and 3.\n      return;\n    }\n    else {\n      throw new Error('Invalid mapping: ' + JSON.stringify({\n        generated: aGenerated,\n        source: aSource,\n        original: aOriginal,\n        name: aName\n      }));\n    }\n  };\n\n/**\n * Serialize the accumulated mappings in to the stream of base 64 VLQs\n * specified by the source map format.\n */\nSourceMapGenerator.prototype._serializeMappings =\n  function SourceMapGenerator_serializeMappings() {\n    var previousGeneratedColumn = 0;\n    var previousGeneratedLine = 1;\n    var previousOriginalColumn = 0;\n    var previousOriginalLine = 0;\n    var previousName = 0;\n    var previousSource = 0;\n    var result = '';\n    var next;\n    var mapping;\n    var nameIdx;\n    var sourceIdx;\n\n    var mappings = this._mappings.toArray();\n    for (var i = 0, len = mappings.length; i < len; i++) {\n      mapping = mappings[i];\n      next = ''\n\n      if (mapping.generatedLine !== previousGeneratedLine) {\n        previousGeneratedColumn = 0;\n        while (mapping.generatedLine !== previousGeneratedLine) {\n          next += ';';\n          previousGeneratedLine++;\n        }\n      }\n      else {\n        if (i > 0) {\n          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n            continue;\n          }\n          next += ',';\n        }\n      }\n\n      next += base64VLQ.encode(mapping.generatedColumn\n                                 - previousGeneratedColumn);\n      previousGeneratedColumn = mapping.generatedColumn;\n\n      if (mapping.source != null) {\n        sourceIdx = this._sources.indexOf(mapping.source);\n        next += base64VLQ.encode(sourceIdx - previousSource);\n        previousSource = sourceIdx;\n\n        // lines are stored 0-based in SourceMap spec version 3\n        next += base64VLQ.encode(mapping.originalLine - 1\n                                   - previousOriginalLine);\n        previousOriginalLine = mapping.originalLine - 1;\n\n        next += base64VLQ.encode(mapping.originalColumn\n                                   - previousOriginalColumn);\n        previousOriginalColumn = mapping.originalColumn;\n\n        if (mapping.name != null) {\n          nameIdx = this._names.indexOf(mapping.name);\n          next += base64VLQ.encode(nameIdx - previousName);\n          previousName = nameIdx;\n        }\n      }\n\n      result += next;\n    }\n\n    return result;\n  };\n\nSourceMapGenerator.prototype._generateSourcesContent =\n  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n    return aSources.map(function (source) {\n      if (!this._sourcesContents) {\n        return null;\n      }\n      if (aSourceRoot != null) {\n        source = util.relative(aSourceRoot, source);\n      }\n      var key = util.toSetString(source);\n      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)\n        ? this._sourcesContents[key]\n        : null;\n    }, this);\n  };\n\n/**\n * Externalize the source map.\n */\nSourceMapGenerator.prototype.toJSON =\n  function SourceMapGenerator_toJSON() {\n    var map = {\n      version: this._version,\n      sources: this._sources.toArray(),\n      names: this._names.toArray(),\n      mappings: this._serializeMappings()\n    };\n    if (this._file != null) {\n      map.file = this._file;\n    }\n    if (this._sourceRoot != null) {\n      map.sourceRoot = this._sourceRoot;\n    }\n    if (this._sourcesContents) {\n      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n    }\n\n    return map;\n  };\n\n/**\n * Render the source map being generated to a string.\n */\nSourceMapGenerator.prototype.toString =\n  function SourceMapGenerator_toString() {\n    return JSON.stringify(this.toJSON());\n  };\n\nexports.SourceMapGenerator = SourceMapGenerator;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;\nvar util = require('./util');\n\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nvar REGEX_NEWLINE = /(\\r?\\n)/;\n\n// Newline character code for charCodeAt() comparisons\nvar NEWLINE_CODE = 10;\n\n// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nvar isSourceNode = \"$$$isSourceNode$$$\";\n\n/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source's filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */\nfunction SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n  this.children = [];\n  this.sourceContents = {};\n  this.line = aLine == null ? null : aLine;\n  this.column = aColumn == null ? null : aColumn;\n  this.source = aSource == null ? null : aSource;\n  this.name = aName == null ? null : aName;\n  this[isSourceNode] = true;\n  if (aChunks != null) this.add(aChunks);\n}\n\n/**\n * Creates a SourceNode from generated code and a SourceMapConsumer.\n *\n * @param aGeneratedCode The generated code\n * @param aSourceMapConsumer The SourceMap for the generated code\n * @param aRelativePath Optional. The path that relative sources in the\n *        SourceMapConsumer should be relative to.\n */\nSourceNode.fromStringWithSourceMap =\n  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n    // The SourceNode we want to fill with the generated code\n    // and the SourceMap\n    var node = new SourceNode();\n\n    // All even indices of this array are one line of the generated code,\n    // while all odd indices are the newlines between two adjacent lines\n    // (since `REGEX_NEWLINE` captures its match).\n    // Processed fragments are accessed by calling `shiftNextLine`.\n    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n    var remainingLinesIndex = 0;\n    var shiftNextLine = function() {\n      var lineContents = getNextLine();\n      // The last line of a file might not have a newline.\n      var newLine = getNextLine() || \"\";\n      return lineContents + newLine;\n\n      function getNextLine() {\n        return remainingLinesIndex < remainingLines.length ?\n            remainingLines[remainingLinesIndex++] : undefined;\n      }\n    };\n\n    // We need to remember the position of \"remainingLines\"\n    var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n\n    // The generate SourceNodes we need a code range.\n    // To extract it current and last mapping is used.\n    // Here we store the last mapping.\n    var lastMapping = null;\n\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      if (lastMapping !== null) {\n        // We add the code from \"lastMapping\" to \"mapping\":\n        // First check if there is a new line in between.\n        if (lastGeneratedLine < mapping.generatedLine) {\n          // Associate first line with \"lastMapping\"\n          addMappingWithCode(lastMapping, shiftNextLine());\n          lastGeneratedLine++;\n          lastGeneratedColumn = 0;\n          // The remaining code is added without mapping\n        } else {\n          // There is no new line in between.\n          // Associate the code between \"lastGeneratedColumn\" and\n          // \"mapping.generatedColumn\" with \"lastMapping\"\n          var nextLine = remainingLines[remainingLinesIndex] || '';\n          var code = nextLine.substr(0, mapping.generatedColumn -\n                                        lastGeneratedColumn);\n          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -\n                                              lastGeneratedColumn);\n          lastGeneratedColumn = mapping.generatedColumn;\n          addMappingWithCode(lastMapping, code);\n          // No more remaining code, continue\n          lastMapping = mapping;\n          return;\n        }\n      }\n      // We add the generated code until the first mapping\n      // to the SourceNode without any mapping.\n      // Each line is added as separate string.\n      while (lastGeneratedLine < mapping.generatedLine) {\n        node.add(shiftNextLine());\n        lastGeneratedLine++;\n      }\n      if (lastGeneratedColumn < mapping.generatedColumn) {\n        var nextLine = remainingLines[remainingLinesIndex] || '';\n        node.add(nextLine.substr(0, mapping.generatedColumn));\n        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\n        lastGeneratedColumn = mapping.generatedColumn;\n      }\n      lastMapping = mapping;\n    }, this);\n    // We have processed all mappings.\n    if (remainingLinesIndex < remainingLines.length) {\n      if (lastMapping) {\n        // Associate the remaining code in the current line with \"lastMapping\"\n        addMappingWithCode(lastMapping, shiftNextLine());\n      }\n      // and add the remaining lines without any mapping\n      node.add(remainingLines.splice(remainingLinesIndex).join(\"\"));\n    }\n\n    // Copy sourcesContent into SourceNode\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aRelativePath != null) {\n          sourceFile = util.join(aRelativePath, sourceFile);\n        }\n        node.setSourceContent(sourceFile, content);\n      }\n    });\n\n    return node;\n\n    function addMappingWithCode(mapping, code) {\n      if (mapping === null || mapping.source === undefined) {\n        node.add(code);\n      } else {\n        var source = aRelativePath\n          ? util.join(aRelativePath, mapping.source)\n          : mapping.source;\n        node.add(new SourceNode(mapping.originalLine,\n                                mapping.originalColumn,\n                                source,\n                                code,\n                                mapping.name));\n      }\n    }\n  };\n\n/**\n * Add a chunk of generated JS to this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.add = function SourceNode_add(aChunk) {\n  if (Array.isArray(aChunk)) {\n    aChunk.forEach(function (chunk) {\n      this.add(chunk);\n    }, this);\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    if (aChunk) {\n      this.children.push(aChunk);\n    }\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Add a chunk of generated JS to the beginning of this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n  if (Array.isArray(aChunk)) {\n    for (var i = aChunk.length-1; i >= 0; i--) {\n      this.prepend(aChunk[i]);\n    }\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    this.children.unshift(aChunk);\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Walk over the tree of JS snippets in this node and its children. The\n * walking function is called once for each snippet of JS and is passed that\n * snippet and the its original associated source's line/column location.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walk = function SourceNode_walk(aFn) {\n  var chunk;\n  for (var i = 0, len = this.children.length; i < len; i++) {\n    chunk = this.children[i];\n    if (chunk[isSourceNode]) {\n      chunk.walk(aFn);\n    }\n    else {\n      if (chunk !== '') {\n        aFn(chunk, { source: this.source,\n                     line: this.line,\n                     column: this.column,\n                     name: this.name });\n      }\n    }\n  }\n};\n\n/**\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n * each of `this.children`.\n *\n * @param aSep The separator.\n */\nSourceNode.prototype.join = function SourceNode_join(aSep) {\n  var newChildren;\n  var i;\n  var len = this.children.length;\n  if (len > 0) {\n    newChildren = [];\n    for (i = 0; i < len-1; i++) {\n      newChildren.push(this.children[i]);\n      newChildren.push(aSep);\n    }\n    newChildren.push(this.children[i]);\n    this.children = newChildren;\n  }\n  return this;\n};\n\n/**\n * Call String.prototype.replace on the very right-most source snippet. Useful\n * for trimming whitespace from the end of a source node, etc.\n *\n * @param aPattern The pattern to replace.\n * @param aReplacement The thing to replace the pattern with.\n */\nSourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n  var lastChild = this.children[this.children.length - 1];\n  if (lastChild[isSourceNode]) {\n    lastChild.replaceRight(aPattern, aReplacement);\n  }\n  else if (typeof lastChild === 'string') {\n    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n  }\n  else {\n    this.children.push(''.replace(aPattern, aReplacement));\n  }\n  return this;\n};\n\n/**\n * Set the source content for a source file. This will be added to the SourceMapGenerator\n * in the sourcesContent field.\n *\n * @param aSourceFile The filename of the source file\n * @param aSourceContent The content of the source file\n */\nSourceNode.prototype.setSourceContent =\n  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n  };\n\n/**\n * Walk over the tree of SourceNodes. The walking function is called for each\n * source file content and is passed the filename and source content.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walkSourceContents =\n  function SourceNode_walkSourceContents(aFn) {\n    for (var i = 0, len = this.children.length; i < len; i++) {\n      if (this.children[i][isSourceNode]) {\n        this.children[i].walkSourceContents(aFn);\n      }\n    }\n\n    var sources = Object.keys(this.sourceContents);\n    for (var i = 0, len = sources.length; i < len; i++) {\n      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n    }\n  };\n\n/**\n * Return the string representation of this source node. Walks over the tree\n * and concatenates all the various snippets together to one string.\n */\nSourceNode.prototype.toString = function SourceNode_toString() {\n  var str = \"\";\n  this.walk(function (chunk) {\n    str += chunk;\n  });\n  return str;\n};\n\n/**\n * Returns the string representation of this source node along with a source\n * map.\n */\nSourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n  var generated = {\n    code: \"\",\n    line: 1,\n    column: 0\n  };\n  var map = new SourceMapGenerator(aArgs);\n  var sourceMappingActive = false;\n  var lastOriginalSource = null;\n  var lastOriginalLine = null;\n  var lastOriginalColumn = null;\n  var lastOriginalName = null;\n  this.walk(function (chunk, original) {\n    generated.code += chunk;\n    if (original.source !== null\n        && original.line !== null\n        && original.column !== null) {\n      if(lastOriginalSource !== original.source\n         || lastOriginalLine !== original.line\n         || lastOriginalColumn !== original.column\n         || lastOriginalName !== original.name) {\n        map.addMapping({\n          source: original.source,\n          original: {\n            line: original.line,\n            column: original.column\n          },\n          generated: {\n            line: generated.line,\n            column: generated.column\n          },\n          name: original.name\n        });\n      }\n      lastOriginalSource = original.source;\n      lastOriginalLine = original.line;\n      lastOriginalColumn = original.column;\n      lastOriginalName = original.name;\n      sourceMappingActive = true;\n    } else if (sourceMappingActive) {\n      map.addMapping({\n        generated: {\n          line: generated.line,\n          column: generated.column\n        }\n      });\n      lastOriginalSource = null;\n      sourceMappingActive = false;\n    }\n    for (var idx = 0, length = chunk.length; idx < length; idx++) {\n      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n        generated.line++;\n        generated.column = 0;\n        // Mappings end at eol\n        if (idx + 1 === length) {\n          lastOriginalSource = null;\n          sourceMappingActive = false;\n        } else if (sourceMappingActive) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n      } else {\n        generated.column++;\n      }\n    }\n  });\n  this.walkSourceContents(function (sourceFile, sourceContent) {\n    map.setSourceContent(sourceFile, sourceContent);\n  });\n\n  return { code: generated.code, map: map };\n};\n\nexports.SourceNode = SourceNode;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  } else {\n    throw new Error('\"' + aName + '\" is a required argument.');\n  }\n}\nexports.getArg = getArg;\n\nvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.-]*)(?::(\\d+))?(.*)$/;\nvar dataUrlRegexp = /^data:.+\\,.+$/;\n\nfunction urlParse(aUrl) {\n  var match = aUrl.match(urlRegexp);\n  if (!match) {\n    return null;\n  }\n  return {\n    scheme: match[1],\n    auth: match[2],\n    host: match[3],\n    port: match[4],\n    path: match[5]\n  };\n}\nexports.urlParse = urlParse;\n\nfunction urlGenerate(aParsedUrl) {\n  var url = '';\n  if (aParsedUrl.scheme) {\n    url += aParsedUrl.scheme + ':';\n  }\n  url += '//';\n  if (aParsedUrl.auth) {\n    url += aParsedUrl.auth + '@';\n  }\n  if (aParsedUrl.host) {\n    url += aParsedUrl.host;\n  }\n  if (aParsedUrl.port) {\n    url += \":\" + aParsedUrl.port\n  }\n  if (aParsedUrl.path) {\n    url += aParsedUrl.path;\n  }\n  return url;\n}\nexports.urlGenerate = urlGenerate;\n\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */\nfunction normalize(aPath) {\n  var path = aPath;\n  var url = urlParse(aPath);\n  if (url) {\n    if (!url.path) {\n      return aPath;\n    }\n    path = url.path;\n  }\n  var isAbsolute = exports.isAbsolute(path);\n\n  var parts = path.split(/\\/+/);\n  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n    part = parts[i];\n    if (part === '.') {\n      parts.splice(i, 1);\n    } else if (part === '..') {\n      up++;\n    } else if (up > 0) {\n      if (part === '') {\n        // The first part is blank if the path is absolute. Trying to go\n        // above the root is a no-op. Therefore we can remove all '..' parts\n        // directly after the root.\n        parts.splice(i + 1, up);\n        up = 0;\n      } else {\n        parts.splice(i, 2);\n        up--;\n      }\n    }\n  }\n  path = parts.join('/');\n\n  if (path === '') {\n    path = isAbsolute ? '/' : '.';\n  }\n\n  if (url) {\n    url.path = path;\n    return urlGenerate(url);\n  }\n  return path;\n}\nexports.normalize = normalize;\n\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */\nfunction join(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n  if (aPath === \"\") {\n    aPath = \".\";\n  }\n  var aPathUrl = urlParse(aPath);\n  var aRootUrl = urlParse(aRoot);\n  if (aRootUrl) {\n    aRoot = aRootUrl.path || '/';\n  }\n\n  // `join(foo, '//www.example.org')`\n  if (aPathUrl && !aPathUrl.scheme) {\n    if (aRootUrl) {\n      aPathUrl.scheme = aRootUrl.scheme;\n    }\n    return urlGenerate(aPathUrl);\n  }\n\n  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n    return aPath;\n  }\n\n  // `join('http://', 'www.example.com')`\n  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n    aRootUrl.host = aPath;\n    return urlGenerate(aRootUrl);\n  }\n\n  var joined = aPath.charAt(0) === '/'\n    ? aPath\n    : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n  if (aRootUrl) {\n    aRootUrl.path = joined;\n    return urlGenerate(aRootUrl);\n  }\n  return joined;\n}\nexports.join = join;\n\nexports.isAbsolute = function (aPath) {\n  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);\n};\n\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */\nfunction relative(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n\n  aRoot = aRoot.replace(/\\/$/, '');\n\n  // It is possible for the path to be above the root. In this case, simply\n  // checking whether the root is a prefix of the path won't work. Instead, we\n  // need to remove components from the root one by one, until either we find\n  // a prefix that fits, or we run out of components to remove.\n  var level = 0;\n  while (aPath.indexOf(aRoot + '/') !== 0) {\n    var index = aRoot.lastIndexOf(\"/\");\n    if (index < 0) {\n      return aPath;\n    }\n\n    // If the only part of the root that is left is the scheme (i.e. http://,\n    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n    // have exhausted all components, so the path is not relative to the root.\n    aRoot = aRoot.slice(0, index);\n    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n      return aPath;\n    }\n\n    ++level;\n  }\n\n  // Make sure we add a \"../\" for each component we removed from the root.\n  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n}\nexports.relative = relative;\n\nvar supportsNullProto = (function () {\n  var obj = Object.create(null);\n  return !('__proto__' in obj);\n}());\n\nfunction identity (s) {\n  return s;\n}\n\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return '$' + aStr;\n  }\n\n  return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  var length = s.length;\n\n  if (length < 9 /* \"__proto__\".length */) {\n    return false;\n  }\n\n  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 9) !== 95  /* '_' */) {\n    return false;\n  }\n\n  for (var i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */\nfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n  var cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByOriginalPositions = compareByOriginalPositions;\n\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */\nfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 === null) {\n    return 1; // aStr2 !== null\n  }\n\n  if (aStr2 === null) {\n    return -1; // aStr1 !== null\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n\n/**\n * Strip any JSON XSSI avoidance prefix from the string (as documented\n * in the source maps specification), and then parse the string as\n * JSON.\n */\nfunction parseSourceMapInput(str) {\n  return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, ''));\n}\nexports.parseSourceMapInput = parseSourceMapInput;\n\n/**\n * Compute the URL of a source given the the source root, the source's\n * URL, and the source map's URL.\n */\nfunction computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\n  sourceURL = sourceURL || '';\n\n  if (sourceRoot) {\n    // This follows what Chrome does.\n    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {\n      sourceRoot += '/';\n    }\n    // The spec says:\n    //   Line 4: An optional source root, useful for relocating source\n    //   files on a server or removing repeated values in the\n    //   sources entry.  This value is prepended to the individual\n    //   entries in the source field.\n    sourceURL = sourceRoot + sourceURL;\n  }\n\n  // Historically, SourceMapConsumer did not take the sourceMapURL as\n  // a parameter.  This mode is still somewhat supported, which is why\n  // this code block is conditional.  However, it's preferable to pass\n  // the source map URL to SourceMapConsumer, so that this function\n  // can implement the source URL resolution algorithm as outlined in\n  // the spec.  This block is basically the equivalent of:\n  //    new URL(sourceURL, sourceMapURL).toString()\n  // ... except it avoids using URL, which wasn't available in the\n  // older releases of node still supported by this library.\n  //\n  // The spec says:\n  //   If the sources are not absolute URLs after prepending of the\n  //   sourceRoot, the sources are resolved relative to the\n  //   SourceMap (like resolving script src in a html document).\n  if (sourceMapURL) {\n    var parsed = urlParse(sourceMapURL);\n    if (!parsed) {\n      throw new Error(\"sourceMapURL could not be parsed\");\n    }\n    if (parsed.path) {\n      // Strip the last path component, but keep the \"/\".\n      var index = parsed.path.lastIndexOf('/');\n      if (index >= 0) {\n        parsed.path = parsed.path.substring(0, index + 1);\n      }\n    }\n    sourceURL = join(urlGenerate(parsed), sourceURL);\n  }\n\n  return normalize(sourceURL);\n}\nexports.computeSourceURL = computeSourceURL;\n","/*\n * Copyright 2009-2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE.txt or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nexports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;\nexports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;\nexports.SourceNode = require('./lib/source-node').SourceNode;\n","'use strict';\nconst os = require('os');\nconst tty = require('tty');\nconst hasFlag = require('has-flag');\n\nconst {env} = process;\n\nlet forceColor;\nif (hasFlag('no-color') ||\n\thasFlag('no-colors') ||\n\thasFlag('color=false') ||\n\thasFlag('color=never')) {\n\tforceColor = 0;\n} else if (hasFlag('color') ||\n\thasFlag('colors') ||\n\thasFlag('color=true') ||\n\thasFlag('color=always')) {\n\tforceColor = 1;\n}\n\nif ('FORCE_COLOR' in env) {\n\tif (env.FORCE_COLOR === 'true') {\n\t\tforceColor = 1;\n\t} else if (env.FORCE_COLOR === 'false') {\n\t\tforceColor = 0;\n\t} else {\n\t\tforceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);\n\t}\n}\n\nfunction translateLevel(level) {\n\tif (level === 0) {\n\t\treturn false;\n\t}\n\n\treturn {\n\t\tlevel,\n\t\thasBasic: true,\n\t\thas256: level >= 2,\n\t\thas16m: level >= 3\n\t};\n}\n\nfunction supportsColor(haveStream, streamIsTTY) {\n\tif (forceColor === 0) {\n\t\treturn 0;\n\t}\n\n\tif (hasFlag('color=16m') ||\n\t\thasFlag('color=full') ||\n\t\thasFlag('color=truecolor')) {\n\t\treturn 3;\n\t}\n\n\tif (hasFlag('color=256')) {\n\t\treturn 2;\n\t}\n\n\tif (haveStream && !streamIsTTY && forceColor === undefined) {\n\t\treturn 0;\n\t}\n\n\tconst min = forceColor || 0;\n\n\tif (env.TERM === 'dumb') {\n\t\treturn min;\n\t}\n\n\tif (process.platform === 'win32') {\n\t\t// Windows 10 build 10586 is the first Windows release that supports 256 colors.\n\t\t// Windows 10 build 14931 is the first release that supports 16m/TrueColor.\n\t\tconst osRelease = os.release().split('.');\n\t\tif (\n\t\t\tNumber(osRelease[0]) >= 10 &&\n\t\t\tNumber(osRelease[2]) >= 10586\n\t\t) {\n\t\t\treturn Number(osRelease[2]) >= 14931 ? 3 : 2;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\tif ('CI' in env) {\n\t\tif (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn min;\n\t}\n\n\tif ('TEAMCITY_VERSION' in env) {\n\t\treturn /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;\n\t}\n\n\tif ('GITHUB_ACTIONS' in env) {\n\t\treturn 1;\n\t}\n\n\tif (env.COLORTERM === 'truecolor') {\n\t\treturn 3;\n\t}\n\n\tif ('TERM_PROGRAM' in env) {\n\t\tconst version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);\n\n\t\tswitch (env.TERM_PROGRAM) {\n\t\t\tcase 'iTerm.app':\n\t\t\t\treturn version >= 3 ? 3 : 2;\n\t\t\tcase 'Apple_Terminal':\n\t\t\t\treturn 2;\n\t\t\t// No default\n\t\t}\n\t}\n\n\tif (/-256(color)?$/i.test(env.TERM)) {\n\t\treturn 2;\n\t}\n\n\tif (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {\n\t\treturn 1;\n\t}\n\n\tif ('COLORTERM' in env) {\n\t\treturn 1;\n\t}\n\n\treturn min;\n}\n\nfunction getSupportLevel(stream) {\n\tconst level = supportsColor(stream, stream && stream.isTTY);\n\treturn translateLevel(level);\n}\n\nmodule.exports = {\n\tsupportsColor: getSupportLevel,\n\tstdout: translateLevel(supportsColor(true, tty.isatty(1))),\n\tstderr: translateLevel(supportsColor(true, tty.isatty(2)))\n};\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// tracing\r\nvar logFileTraceListener_1 = require(\"./logFileTraceListener\");\r\nexports.LogFileTraceListener = logFileTraceListener_1.LogFileTraceListener;\r\n// log locations\r\nvar logLocations_1 = require(\"./logLocations\");\r\nexports.LogLocations = logLocations_1.LogLocations;\r\n// telemetry\r\nvar LogFilter_1 = require(\"./telemetry/LogFilter\");\r\nexports.TelemetryLogFilter = LogFilter_1.LogFilter;\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst path = __importStar(require(\"path-browserify\"));\r\nconst fs = __importStar(require(\"fs\"));\r\nconst util = __importStar(require(\"util\"));\r\nconst os = __importStar(require(\"os\"));\r\nconst telemetryStrings_1 = require(\"./telemetry/telemetryStrings\");\r\nconst logLocations_1 = require(\"./logLocations\");\r\nconst vso_telemetry_1 = require(\"@vs/vso-telemetry\");\r\nconst vso_logging_1 = require(\"@vs/vso-logging\");\r\nconst mkdirAsync = util.promisify(fs.mkdir);\r\nconst openAsync = util.promisify(fs.open);\r\nconst writeAsync = util.promisify(fs.write);\r\nclass LogFileTraceListener extends vso_logging_1.TraceListener {\r\n    constructor(processName, logDirectory = LogFileTraceListener.defaultLogDirectory, fileDescriptor) {\r\n        super();\r\n        this.processName = processName;\r\n        this.logDirectory = logDirectory;\r\n        this.fileDescriptor = fileDescriptor;\r\n        this.writePromise = Promise.resolve();\r\n        this.canWriteLogs = true;\r\n        this.openLogFileAsync = async (index = 0) => {\r\n            // if 5th attempt - report to telemetry and forbit writing to local logs.\r\n            if (index === 5) {\r\n                this.canWriteLogs = false;\r\n                vso_telemetry_1.Telemetry.sendFault(telemetryStrings_1.TelemetryEventNames.NAME_LOGS_FILE_FAILED, vso_telemetry_1.FaultType.Error, 'Name Log File Failed - Reached maximum number of attempts.');\r\n                return;\r\n            }\r\n            const datePrefix = new Date()\r\n                .toISOString()\r\n                .replace(/T/, '_')\r\n                .replace(/:|-/g, '')\r\n                .replace(/\\..+/, '');\r\n            // Ensure a unique file name, in case another log session started around the same time.\r\n            const indexFileName = path.join(this.logDirectory, `${datePrefix}_${Date.now()}${index}_${this.processName}.log`);\r\n            try {\r\n                const fileDescriptor = await openAsync(indexFileName, 'ax'); // Append, fail if exists\r\n                this.fileDescriptor = fileDescriptor;\r\n                this.fileName = indexFileName;\r\n            }\r\n            catch (err) {\r\n                if (err.code === 'EEXIST') {\r\n                    // try the nex index\r\n                    await this.openLogFileAsync(index + 1);\r\n                }\r\n                else {\r\n                    this.canWriteLogs = false;\r\n                    vso_telemetry_1.Telemetry.sendFault(telemetryStrings_1.TelemetryEventNames.OPEN_LOGS_FAILED, vso_telemetry_1.FaultType.Error, `Name Log File Failed. ${err.message}`, err);\r\n                }\r\n            }\r\n            return indexFileName;\r\n        };\r\n        this.flushEvents = () => {\r\n            return this.writePromise;\r\n        };\r\n    }\r\n    static get defaultLogDirectory() {\r\n        return logLocations_1.LogLocations.clientLogFilePath;\r\n    }\r\n    get logFileName() {\r\n        return this.fileName;\r\n    }\r\n    /**\r\n     * Opens the log file. Await this method before using the trace listener.\r\n     */\r\n    async openAsync() {\r\n        try {\r\n            await mkdirAsync(this.logDirectory);\r\n        }\r\n        catch (e) { }\r\n        return await this.openLogFileAsync();\r\n    }\r\n    writeTo(line) {\r\n        fs.writeFileSync(this.fileDescriptor, line + os.EOL);\r\n    }\r\n    writeEvent(source, logLevel, id, message, ...args) {\r\n        if (this.canWriteLogs === false) {\r\n            return;\r\n        }\r\n        const line = vso_logging_1.TraceFormat.formatEvent(new Date(), source, logLevel, id, message, ...args);\r\n        this.writePromise = this.writePromise.then(() => {\r\n            writeAsync(this.fileDescriptor, line + os.EOL).catch((e) => {\r\n                this.canWriteLogs = false;\r\n                // do not reject if error, but log the event to telemetry\r\n                vso_telemetry_1.Telemetry.sendFault(telemetryStrings_1.TelemetryEventNames.WRITE_LOGS_FAILED, vso_telemetry_1.FaultType.Error, e.message, e);\r\n            });\r\n        });\r\n    }\r\n}\r\nexports.LogFileTraceListener = LogFileTraceListener;\r\n//# sourceMappingURL=logFileTraceListener.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass LogLocations {\r\n}\r\nexports.LogLocations = LogLocations;\r\n//# sourceMappingURL=logLocations.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vso_logging_1 = require(\"@vs/vso-logging\");\r\nconst logFileTraceListener_1 = require(\"../logFileTraceListener\");\r\n// This filter logs all sent telemetry events to a file.\r\nclass LogFilter {\r\n    constructor() {\r\n        this.trace = new vso_logging_1.TraceSource('Telemetry');\r\n    }\r\n    async init() {\r\n        const logFileTraceListener = new logFileTraceListener_1.LogFileTraceListener('VSCodeTelemetry');\r\n        await logFileTraceListener.openAsync();\r\n        this.trace.addTraceListener(logFileTraceListener);\r\n    }\r\n    shouldSend(eventName, properties, measures) {\r\n        const telemetryEvent = {\r\n            eventName,\r\n            properties,\r\n            measures,\r\n        };\r\n        this.trace.info(JSON.stringify(telemetryEvent, null, 2));\r\n        return true;\r\n    }\r\n}\r\nexports.LogFilter = LogFilter;\r\n//# sourceMappingURL=LogFilter.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass TelemetryEventNames {\r\n}\r\nexports.TelemetryEventNames = TelemetryEventNames;\r\nTelemetryEventNames.FAULT_PREFIX = 'Fault/';\r\nTelemetryEventNames.NAME_LOGS_FILE_FAILED = TelemetryEventNames.FAULT_PREFIX + 'name-logfile-failed';\r\nTelemetryEventNames.OPEN_LOGS_FAILED = TelemetryEventNames.FAULT_PREFIX + 'open-logs-failed';\r\nTelemetryEventNames.WRITE_LOGS_FAILED = TelemetryEventNames.FAULT_PREFIX + 'write-logs-failed';\r\n//# sourceMappingURL=telemetryStrings.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vso_rpc_ssh_1 = require(\"@vs/vso-rpc-ssh\");\r\nconst vs_ssh_1 = require(\"@vs/vs-ssh\");\r\nclass MutliChannelRpcSocketServer {\r\n    constructor(trace, serverFactory) {\r\n        this.rpcServer = new vso_rpc_ssh_1.MultiChannelRpcServer(trace.withName('RpcServer'));\r\n        this.server = serverFactory(this.rpcServer);\r\n    }\r\n    async accept(socket) {\r\n        const transportStream = new vs_ssh_1.NodeStream(socket);\r\n        const [messageConnectInfo] = await this.rpcServer.acceptStream(transportStream);\r\n        return messageConnectInfo;\r\n    }\r\n    async dispose() {\r\n        if (this.server && typeof this.server.dispose === 'function') {\r\n            await Promise.resolve(this.server.dispose());\r\n        }\r\n    }\r\n}\r\nexports.MutliChannelRpcSocketServer = MutliChannelRpcSocketServer;\r\n//# sourceMappingURL=MutliChannelRpcSocketServer.js.map","\"use strict\";\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__export(require(\"./MutliChannelRpcSocketServer\"));\r\n__export(require(\"./serverUtils\"));\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst net = require(\"net\");\r\nconst os = require(\"os\");\r\nconst fs = require(\"fs\");\r\nconst vscs_utils_1 = require(\"@vs/vscs-utils\");\r\nconst vso_node_utils_1 = require(\"@vs/vso-node-utils\");\r\nasync function startSocketServer(options) {\r\n    if (!options.port && !options.pipe) {\r\n        throw Error('You need to specify a port or a pipe name');\r\n    }\r\n    const { traceSource, getLogs, socketServerFactory, serverHost = {} } = options;\r\n    const keepAliveTime = options.keepAliveTime || 10000;\r\n    const hostedServer = {\r\n        keepAliveCount: 0,\r\n        rpcConnectionCount: 0,\r\n        options,\r\n        stop: (reason) => stopRpcServer(reason),\r\n    };\r\n    const keepAlive = (time) => {\r\n        const delay = time || keepAliveTime;\r\n        ++hostedServer.keepAliveCount;\r\n        traceSource.verbose(`keepAlive start -> time:${delay}`);\r\n        vscs_utils_1.wait(delay).then(() => {\r\n            --hostedServer.keepAliveCount;\r\n            traceSource.verbose(`keepAlive end -> count:${hostedServer.keepAliveCount + hostedServer.rpcConnectionCount}`);\r\n            if ((hostedServer.keepAliveCount + hostedServer.rpcConnectionCount) === 0) {\r\n                if (options.autoExit) {\r\n                    traceSource.info(`shutting down due to inactivity...`);\r\n                    stopRpcServer(99);\r\n                }\r\n                else if (typeof serverHost.keepAliveTriggered === 'function') {\r\n                    serverHost.keepAliveTriggered(hostedServer);\r\n                }\r\n            }\r\n        });\r\n    };\r\n    // initialize\r\n    const socketServer = socketServerFactory(keepAlive, traceSource);\r\n    const clients = [];\r\n    let server;\r\n    // our stop rpc server callback\r\n    const stopRpcServer = async (reasonOrExitCode) => {\r\n        // close the socket server\r\n        if (server) {\r\n            const closed = new vscs_utils_1.Signal();\r\n            traceSource.writeLine(`closing socket server...`);\r\n            clients.forEach(socket => socket.destroy());\r\n            server.close((err) => {\r\n                closed.resolve();\r\n                traceSource.writeLine(`server closed err:${err !== null && err !== void 0 ? err : 'n/a'}`);\r\n            });\r\n            await closed.promise;\r\n        }\r\n        traceSource.writeLine(`stopping rpc server...`);\r\n        try {\r\n            await socketServer.dispose();\r\n        }\r\n        catch (err) {\r\n            traceSource.error(`failed to dispose server`, err);\r\n        }\r\n        traceSource.info(`rpc server stopped`);\r\n        if (typeof serverHost.serverStopped === 'function') {\r\n            serverHost.serverStopped(reasonOrExitCode, hostedServer);\r\n        }\r\n    };\r\n    let listenCallback;\r\n    if (options.port) {\r\n        listenCallback = (retry) => {\r\n            const port = options.port + retry;\r\n            server.listen(port, 'localhost');\r\n        };\r\n    }\r\n    else {\r\n        listenCallback = (retry) => {\r\n            const pipe = retry === 0 ? options.pipe : `${options.pipe}-${retry}`;\r\n            const pipePath = options.isRawPipe ? pipe : vso_node_utils_1.getPipePath(pipe);\r\n            if (os.platform() !== \"win32\" && fs.existsSync(pipePath)) {\r\n                traceSource.warning(`pipe:${pipePath} already exist, attempting to delete it`);\r\n                try {\r\n                    fs.unlinkSync(pipePath);\r\n                }\r\n                catch (err) {\r\n                    traceSource.error(`failed to delete existing pipe:`, err);\r\n                }\r\n            }\r\n            server.listen(pipePath);\r\n        };\r\n    }\r\n    // create a server to listen for rpc connections\r\n    server = net.createServer(function (socket) {\r\n        clients.push(socket);\r\n        socket.on('close', function () {\r\n            clients.splice(clients.indexOf(socket), 1);\r\n        });\r\n        socketServer.accept(socket).then((rpcConnection) => {\r\n            rpcConnection.listen();\r\n            // request to get the latest logs\r\n            rpcConnection.onRequest('logService.getLogs', (requestId, logLevel) => {\r\n                return typeof getLogs === 'function' ? getLogs(logLevel) : [];\r\n            });\r\n            const disposables = [];\r\n            ++hostedServer.rpcConnectionCount;\r\n            traceSource.info(`rpc created count:${hostedServer.rpcConnectionCount}`);\r\n            const removeRpc = (event) => {\r\n                // stop both closee/disposed notifications in case both event are trigered\r\n                disposables.forEach(d => d.dispose());\r\n                --hostedServer.rpcConnectionCount;\r\n                traceSource.info(`rpc event:${event} count:${hostedServer.rpcConnectionCount}`);\r\n                keepAlive();\r\n            };\r\n            // subscribe to closed/disposed events\r\n            disposables.push(rpcConnection.onDispose(e => removeRpc('disposed')));\r\n            disposables.push(rpcConnection.onClose(e => removeRpc('closed')));\r\n        }).catch(err => {\r\n            traceSource.info(`failed to accept socket`, err);\r\n        });\r\n    });\r\n    const maxRetries = options.maxRetries || 20;\r\n    let retry = 0;\r\n    server.on('error', (e) => {\r\n        traceSource.error(`socket server err:${e}`);\r\n        if (e.code === 'EADDRINUSE') {\r\n            ++retry;\r\n            if (retry >= maxRetries) {\r\n                if (typeof serverHost.serverStopped === 'function') {\r\n                    serverHost.serverStopped(e, hostedServer);\r\n                }\r\n            }\r\n            else {\r\n                traceSource.info(`listening retry:${retry}`);\r\n                listenCallback(retry);\r\n            }\r\n        }\r\n    });\r\n    server.on('listening', () => {\r\n        const serverAddress = server.address();\r\n        traceSource.info(`rpc server listening on address:${JSON.stringify(serverAddress)}`);\r\n        if (options.isAdmin) {\r\n            if (typeof serverAddress) {\r\n                traceSource.info(`change pipe permission...`);\r\n                try {\r\n                    fs.chmodSync(String(serverAddress), '777');\r\n                }\r\n                catch (e) {\r\n                    traceSource.info(`failed to change pipe permission.`, e);\r\n                }\r\n            }\r\n        }\r\n    });\r\n    listenCallback(0);\r\n    keepAlive();\r\n    return hostedServer;\r\n}\r\nexports.startSocketServer = startSocketServer;\r\n//# sourceMappingURL=serverUtils.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst fs = require(\"fs\");\r\nconst util = require(\"util\");\r\nconst fse = require(\"fs-extra\");\r\nconst mkdirAsync = util.promisify(fs.mkdir);\r\nconst openAsync = util.promisify(fs.open);\r\nconst closeAsync = util.promisify(fs.close);\r\nconst writeAsync = util.promisify(fs.write);\r\nconst chmodAsync = util.promisify(fs.chmod);\r\nconst existsAsync = util.promisify(fs.exists);\r\nconst accessAsync = util.promisify(fs.access);\r\nconst readdirAsync = util.promisify(fs.readdir);\r\nconst unlinkAsync = util.promisify(fs.unlink);\r\nclass NodeFileAccess {\r\n    constructor() {\r\n        this.existsAsync = existsAsync;\r\n        this.chmodAsync = chmodAsync;\r\n        this.accessAsync = accessAsync;\r\n    }\r\n    mkdirAsync(path) {\r\n        return mkdirAsync(path);\r\n    }\r\n    mkdirSync(path) {\r\n        fs.mkdirSync(path);\r\n    }\r\n    openFileAsync(filePath, openMode) {\r\n        return openAsync(filePath, openMode);\r\n    }\r\n    openSync(filePath, flags) {\r\n        return fs.openSync(filePath, flags);\r\n    }\r\n    openAsync(filePath, openMode) {\r\n        return openAsync(filePath, openMode);\r\n    }\r\n    closeSync(fileDescriptor) {\r\n        fs.closeSync(fileDescriptor);\r\n    }\r\n    closeAsync(fileDescriptor) {\r\n        return closeAsync(fileDescriptor);\r\n    }\r\n    writeAsync(fileDescriptor, contents) {\r\n        return writeAsync(fileDescriptor, contents);\r\n    }\r\n    writeFile(filePath, data, callback) {\r\n        if (typeof callback !== 'undefined') {\r\n            fs.writeFile(filePath, data, callback);\r\n        }\r\n        else {\r\n            return fse.writeFile(filePath, data);\r\n        }\r\n    }\r\n    writeFileAsync(filePath, data) {\r\n        return fse.writeFile(filePath, data);\r\n    }\r\n    appendFileSync(fileDescriptor, data, options) {\r\n        fs.appendFileSync(fileDescriptor, data, options);\r\n    }\r\n    chmod(path, mode, callback) {\r\n        fs.chmod(path, mode, callback);\r\n    }\r\n    stat(path, callback) {\r\n        fs.stat(path, callback);\r\n    }\r\n    statSync(path) {\r\n        return fs.statSync(path);\r\n    }\r\n    lstatSync(path) {\r\n        return fs.lstatSync(path);\r\n    }\r\n    lstat(path, callback) {\r\n        fs.lstat(path, callback);\r\n    }\r\n    existsSync(filePath) {\r\n        return fs.existsSync(filePath);\r\n    }\r\n    readdirSync(path) {\r\n        return fs.readdirSync(path);\r\n    }\r\n    readdirAsync(path) {\r\n        return readdirAsync(path);\r\n    }\r\n    readFileSync(filePath, options) {\r\n        if (typeof options !== 'undefined') {\r\n            return fs.readFileSync(filePath, options);\r\n        }\r\n        else {\r\n            return fs.readFileSync(filePath);\r\n        }\r\n    }\r\n    readFile(filePath, options, callback) {\r\n        if (typeof callback !== 'undefined' && typeof options !== 'undefined') {\r\n            fs.readFile(filePath, options, callback);\r\n        }\r\n        else {\r\n            return fse.readFile(filePath);\r\n        }\r\n    }\r\n    unlink(path, callback) {\r\n        fs.unlink(path, callback);\r\n    }\r\n    unlinkSync(path) {\r\n        fs.unlinkSync(path);\r\n    }\r\n    unlinkAsync(path) {\r\n        return unlinkAsync(path);\r\n    }\r\n    // FSE\r\n    copySync(sourcePath, targetPath) {\r\n        fse.copySync(sourcePath, targetPath);\r\n    }\r\n    readdir(path, callback) {\r\n        if (typeof callback !== 'undefined') {\r\n            fse.readdir(path, callback);\r\n        }\r\n        else {\r\n            return fse.readdir(path);\r\n        }\r\n    }\r\n    remove(dir) {\r\n        return fse.remove(dir);\r\n    }\r\n    renameSync(sourcePath, targetPath) {\r\n        fse.renameSync(sourcePath, targetPath);\r\n    }\r\n    ensureDir(path) {\r\n        return fse.ensureDir(path);\r\n    }\r\n    ensureDirAsync(path) {\r\n        return fse.ensureDir(path);\r\n    }\r\n    writeFileSync(path, data) {\r\n        fse.writeFileSync(path, data);\r\n    }\r\n    pathExistsSync(path) {\r\n        return fse.pathExistsSync(path);\r\n    }\r\n    access(path) {\r\n        return fse.access(path);\r\n    }\r\n    copyFileSync(src, dest) {\r\n        return fse.copyFileSync(src, dest);\r\n    }\r\n    copyFile(src, dest) {\r\n        return fse.copyFile(src, dest);\r\n    }\r\n    readJson(file) {\r\n        return fse.readJson(file);\r\n    }\r\n    writeJson(file, data, options) {\r\n        return fse.writeJson(file, data, options);\r\n    }\r\n    createReadStream(path) {\r\n        return fse.createReadStream(path);\r\n    }\r\n    createWriteStream(path) {\r\n        return fse.createWriteStream(path);\r\n    }\r\n    pathExists(path) {\r\n        return fse.pathExists(path);\r\n    }\r\n}\r\nexports.fileAccess = new NodeFileAccess();\r\n//# sourceMappingURL=NodeFileAccess.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst NodeFileAccess_1 = require(\"./NodeFileAccess\");\r\nconst path = require(\"path\");\r\n/**\r\n * Return the last files on a directory ordered by the timestamp\r\n * @param dirPath The directory path to look for.\r\n * @param maxFiles Optional max number of files to return.\r\n * @returns Array of files sorted by their timestamp.\r\n */\r\nasync function getLastFiles(dirPath, maxFiles) {\r\n    const files = (await NodeFileAccess_1.fileAccess\r\n        .readdirAsync(dirPath))\r\n        .map(function (name) {\r\n        const time = NodeFileAccess_1.fileAccess.statSync(path.join(dirPath, name)).mtime.getTime();\r\n        return { name, time };\r\n    })\r\n        .sort(function (a, b) {\r\n        return b.time - a.time;\r\n    })\r\n        .map(function (file) {\r\n        return path.join(dirPath, file.name);\r\n    });\r\n    if (maxFiles && files.length > maxFiles) {\r\n        return files.slice(0, maxFiles);\r\n    }\r\n    return files;\r\n}\r\nexports.getLastFiles = getLastFiles;\r\n//# sourceMappingURL=fileUtils.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst os = require(\"os\");\r\nfunction getPipePath(pipeName) {\r\n    if (process.platform === 'win32') {\r\n        return `\\\\\\\\.\\\\pipe\\\\${pipeName}`;\r\n    }\r\n    else {\r\n        // .NET Core on Mac/Linux uses this pattern for pipe paths. Reference:\r\n        // https://github.com/dotnet/corefx/blob/master/src/System.IO.Pipes/src/System/IO/Pipes/PipeStream.Unix.cs\r\n        return `${os.tmpdir()}/CoreFxPipe_${pipeName}`;\r\n    }\r\n}\r\nexports.getPipePath = getPipePath;\r\n//# sourceMappingURL=getPipePath.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst os = require(\"os\");\r\nconst osPlatform_1 = require(\"./osPlatform\");\r\nfunction getPlatformProperty() {\r\n    switch (os.platform()) {\r\n        case osPlatform_1.OSPlatform.WINDOWS:\r\n            return 'windows';\r\n        case osPlatform_1.OSPlatform.MACOS:\r\n            return 'osx';\r\n        case osPlatform_1.OSPlatform.LINUX:\r\n        default:\r\n            return 'linux';\r\n    }\r\n}\r\nexports.getPlatformProperty = getPlatformProperty;\r\n//# sourceMappingURL=getPlatformProperty.js.map","\"use strict\";\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar getPipePath_1 = require(\"./getPipePath\");\r\nexports.getPipePath = getPipePath_1.getPipePath;\r\nvar lockFileUtils_1 = require(\"./lockFileUtils\");\r\nexports.lockAgent = lockFileUtils_1.lockAgent;\r\nvar processUtils_1 = require(\"./processUtils\");\r\nexports.execAgent = processUtils_1.execAgent;\r\nexports.sudoExecAgent = processUtils_1.sudoExecAgent;\r\n__export(require(\"./fileUtils\"));\r\nvar NodeFileAccess_1 = require(\"./NodeFileAccess\");\r\nexports.fileAccess = NodeFileAccess_1.fileAccess;\r\nvar getPlatformProperty_1 = require(\"./getPlatformProperty\");\r\nexports.getPlatformProperty = getPlatformProperty_1.getPlatformProperty;\r\nvar socketUtils_1 = require(\"./socketUtils\");\r\nexports.startSocketSession = socketUtils_1.startSocketSession;\r\nexports.startSocketSessionOnPort = socketUtils_1.startSocketSessionOnPort;\r\nexports.startSocketSessionOnPipe = socketUtils_1.startSocketSessionOnPipe;\r\nvar osPlatform_1 = require(\"./osPlatform\");\r\nexports.OSPlatform = osPlatform_1.OSPlatform;\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst lockFile = require(\"lockfile\");\r\nconst vso_logging_1 = require(\"@vs/vso-logging\");\r\nasync function lockAgent(path, lockSuccessCallback, logger) {\r\n    const lockOptions = {\r\n        stale: 60 * 1000,\r\n        retries: 60,\r\n        retryWait: 1000,\r\n    };\r\n    const pathLock = path + '.lock';\r\n    // Check if the file is already locked\r\n    const isLocked = await new Promise((resolve) => {\r\n        lockFile.check(pathLock, lockOptions, (err, locked) => resolve(!!locked));\r\n    });\r\n    if (isLocked) {\r\n        logger.verbose('Agent is being started by another vscode instance. Waiting for completion...');\r\n    }\r\n    logger.verbose(`Agent lock on:${vso_logging_1.TraceFormat.formatPath(pathLock)}`);\r\n    // Acquire a new lock\r\n    await new Promise((resolve, reject) => lockFile.lock(pathLock, lockOptions, (err) => {\r\n        if (err) {\r\n            logger.error('Failed to lock the agent');\r\n            reject(err);\r\n        }\r\n        else {\r\n            resolve(true);\r\n        }\r\n    }));\r\n    try {\r\n        if (!isLocked) {\r\n            await lockSuccessCallback();\r\n            logger.verbose(`Finished agent startup...`);\r\n        }\r\n    }\r\n    finally {\r\n        // No need to wait for unlocking to finish\r\n        lockFile.unlock(pathLock, () => {\r\n            logger.verbose(`Agent unlocked`);\r\n        });\r\n    }\r\n}\r\nexports.lockAgent = lockAgent;\r\n//# sourceMappingURL=lockFileUtils.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/** Defines values that may be returned by Node's `os.platform()` API. */\r\nvar OSPlatform;\r\n(function (OSPlatform) {\r\n    OSPlatform[\"MACOS\"] = \"darwin\";\r\n    OSPlatform[\"WINDOWS\"] = \"win32\";\r\n    OSPlatform[\"LINUX\"] = \"linux\";\r\n})(OSPlatform = exports.OSPlatform || (exports.OSPlatform = {}));\r\n//# sourceMappingURL=osPlatform.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst os = require(\"os\");\r\nconst path = require(\"path\");\r\nconst fs = require(\"fs\");\r\nconst child_process = require(\"child_process\");\r\nconst sudo = require(\"sudo-prompt\");\r\nconst osPlatform_1 = require(\"./osPlatform\");\r\nfunction sudoExecAgent(agentPath, args, envVars, sudoWindowName) {\r\n    return new Promise((resolve, reject) => {\r\n        const sudoCallback = (error, _stdout, stderr) => {\r\n            if (error) {\r\n                reject(`sudo exec failed - message: ${error.message} - stack: ${error.stack}`);\r\n            }\r\n            else if (stderr) {\r\n                reject(`sudo exec failed - stderr: ${stderr}`);\r\n            }\r\n            resolve(undefined);\r\n        };\r\n        execAgentInternal(agentPath, args, envVars, sudoWindowName, sudoCallback);\r\n    });\r\n}\r\nexports.sudoExecAgent = sudoExecAgent;\r\nfunction execAgent(agentPath, args, envVars) {\r\n    return execAgentInternal(agentPath, args, envVars);\r\n}\r\nexports.execAgent = execAgent;\r\nfunction execAgentInternal(agentPath, args, envVars, sudoWindowName, sudoCallback) {\r\n    // Clone process.env before setting additional environment variables\r\n    // that should be applied only to the child agent process\r\n    const childProcessEnv = Object.assign({}, process.env);\r\n    if (envVars) {\r\n        Object.keys(envVars).forEach(key => childProcessEnv[key] = envVars[key]);\r\n    }\r\n    if (os.platform() === osPlatform_1.OSPlatform.WINDOWS) {\r\n        // Try to use `cmd.exe`, if found in the expected place.\r\n        // Node's child_process.exec() uses %ComSpec% by default, but when set to other shells that can cause problems.\r\n        const cmdExePath = path.join(process.env.SystemRoot || 'C:\\\\WINDOWS', 'system32', 'cmd.exe');\r\n        let shell;\r\n        try {\r\n            fs.statSync(cmdExePath);\r\n            shell = cmdExePath;\r\n        }\r\n        catch (_a) {\r\n            shell = process.env.ComSpec || 'cmd.exe';\r\n        }\r\n        const command = `start /B \"\" \"${agentPath}\" ${args.join(' ')}`;\r\n        if (sudoWindowName) {\r\n            sudo.exec(command, { name: sudoWindowName, env: envVars }, sudoCallback);\r\n            return;\r\n        }\r\n        return child_process.exec(command, { env: childProcessEnv, shell, windowsHide: true });\r\n    }\r\n    else {\r\n        const sh = `/bin/sh -c '\"${agentPath}\" ${args.join(' ')}' &`;\r\n        if (sudoWindowName) {\r\n            sudo.exec(`ELECTRON_RUN_AS_NODE=1 /bin/sh -c '\"${agentPath}\" ${args.join(' ')}' &`, { name: sudoWindowName, env: envVars }, sudoCallback);\r\n            return;\r\n        }\r\n        return child_process.exec(sh, { env: childProcessEnv, windowsHide: true });\r\n    }\r\n}\r\n//# sourceMappingURL=processUtils.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst net = require(\"net\");\r\nconst getPipePath_1 = require(\"./getPipePath\");\r\nasync function startSocketSession(socketFactory) {\r\n    let socket;\r\n    const tcpConnect = new Promise((resolve, reject) => {\r\n        let connected = false;\r\n        socket = socketFactory(() => {\r\n            resolve();\r\n            connected = true;\r\n        });\r\n        socket.on('close', () => {\r\n            if (!connected) {\r\n                reject(new Error('connection closed'));\r\n            }\r\n        });\r\n        socket.on('error', error => {\r\n            if (!connected) {\r\n                reject(error);\r\n            }\r\n        });\r\n    });\r\n    await tcpConnect;\r\n    return socket;\r\n}\r\nexports.startSocketSession = startSocketSession;\r\nfunction startSocketSessionOnPort(port) {\r\n    return startSocketSession((listener) => net.createConnection(port, '127.0.0.1', listener));\r\n}\r\nexports.startSocketSessionOnPort = startSocketSessionOnPort;\r\nfunction startSocketSessionOnPipe(pipe, isRawPipe) {\r\n    return startSocketSession((listener) => net.createConnection(isRawPipe ? pipe : getPipePath_1.getPipePath(pipe), listener));\r\n}\r\nexports.startSocketSessionOnPipe = startSocketSessionOnPipe;\r\n//# sourceMappingURL=socketUtils.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContextAPI = void 0;\nvar context_base_1 = require(\"@opentelemetry/context-base\");\nvar global_utils_1 = require(\"./global-utils\");\nvar NOOP_CONTEXT_MANAGER = new context_base_1.NoopContextManager();\n/**\n * Singleton object which represents the entry point to the OpenTelemetry Context API\n */\nvar ContextAPI = /** @class */ (function () {\n    /** Empty private constructor prevents end users from constructing a new instance of the API */\n    function ContextAPI() {\n    }\n    /** Get the singleton instance of the Context API */\n    ContextAPI.getInstance = function () {\n        if (!this._instance) {\n            this._instance = new ContextAPI();\n        }\n        return this._instance;\n    };\n    /**\n     * Set the current context manager. Returns the initialized context manager\n     */\n    ContextAPI.prototype.setGlobalContextManager = function (contextManager) {\n        if (global_utils_1._global[global_utils_1.GLOBAL_CONTEXT_MANAGER_API_KEY]) {\n            // global context manager has already been set\n            return this._getContextManager();\n        }\n        global_utils_1._global[global_utils_1.GLOBAL_CONTEXT_MANAGER_API_KEY] = global_utils_1.makeGetter(global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION, contextManager, NOOP_CONTEXT_MANAGER);\n        return contextManager;\n    };\n    /**\n     * Get the currently active context\n     */\n    ContextAPI.prototype.active = function () {\n        return this._getContextManager().active();\n    };\n    /**\n     * Execute a function with an active context\n     *\n     * @param context context to be active during function execution\n     * @param fn function to execute in a context\n     */\n    ContextAPI.prototype.with = function (context, fn) {\n        return this._getContextManager().with(context, fn);\n    };\n    /**\n     * Bind a context to a target function or event emitter\n     *\n     * @param target function or event emitter to bind\n     * @param context context to bind to the event emitter or function. Defaults to the currently active context\n     */\n    ContextAPI.prototype.bind = function (target, context) {\n        if (context === void 0) { context = this.active(); }\n        return this._getContextManager().bind(target, context);\n    };\n    ContextAPI.prototype._getContextManager = function () {\n        var _a, _b;\n        return ((_b = (_a = global_utils_1._global[global_utils_1.GLOBAL_CONTEXT_MANAGER_API_KEY]) === null || _a === void 0 ? void 0 : _a.call(global_utils_1._global, global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION)) !== null && _b !== void 0 ? _b : NOOP_CONTEXT_MANAGER);\n    };\n    /** Disable and remove the global context manager */\n    ContextAPI.prototype.disable = function () {\n        this._getContextManager().disable();\n        delete global_utils_1._global[global_utils_1.GLOBAL_CONTEXT_MANAGER_API_KEY];\n    };\n    return ContextAPI;\n}());\nexports.ContextAPI = ContextAPI;\n//# sourceMappingURL=context.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.API_BACKWARDS_COMPATIBILITY_VERSION = exports.makeGetter = exports._global = exports.GLOBAL_TRACE_API_KEY = exports.GLOBAL_PROPAGATION_API_KEY = exports.GLOBAL_METRICS_API_KEY = exports.GLOBAL_CONTEXT_MANAGER_API_KEY = void 0;\nvar platform_1 = require(\"../platform\");\nexports.GLOBAL_CONTEXT_MANAGER_API_KEY = Symbol.for('io.opentelemetry.js.api.context');\nexports.GLOBAL_METRICS_API_KEY = Symbol.for('io.opentelemetry.js.api.metrics');\nexports.GLOBAL_PROPAGATION_API_KEY = Symbol.for('io.opentelemetry.js.api.propagation');\nexports.GLOBAL_TRACE_API_KEY = Symbol.for('io.opentelemetry.js.api.trace');\nexports._global = platform_1._globalThis;\n/**\n * Make a function which accepts a version integer and returns the instance of an API if the version\n * is compatible, or a fallback version (usually NOOP) if it is not.\n *\n * @param requiredVersion Backwards compatibility version which is required to return the instance\n * @param instance Instance which should be returned if the required version is compatible\n * @param fallback Fallback instance, usually NOOP, which will be returned if the required version is not compatible\n */\nfunction makeGetter(requiredVersion, instance, fallback) {\n    return function (version) {\n        return version === requiredVersion ? instance : fallback;\n    };\n}\nexports.makeGetter = makeGetter;\n/**\n * A number which should be incremented each time a backwards incompatible\n * change is made to the API. This number is used when an API package\n * attempts to access the global API to ensure it is getting a compatible\n * version. If the global API is not compatible with the API package\n * attempting to get it, a NOOP API implementation will be returned.\n */\nexports.API_BACKWARDS_COMPATIBILITY_VERSION = 2;\n//# sourceMappingURL=global-utils.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MetricsAPI = void 0;\nvar NoopMeterProvider_1 = require(\"../metrics/NoopMeterProvider\");\nvar global_utils_1 = require(\"./global-utils\");\n/**\n * Singleton object which represents the entry point to the OpenTelemetry Metrics API\n */\nvar MetricsAPI = /** @class */ (function () {\n    /** Empty private constructor prevents end users from constructing a new instance of the API */\n    function MetricsAPI() {\n    }\n    /** Get the singleton instance of the Metrics API */\n    MetricsAPI.getInstance = function () {\n        if (!this._instance) {\n            this._instance = new MetricsAPI();\n        }\n        return this._instance;\n    };\n    /**\n     * Set the current global meter. Returns the initialized global meter provider.\n     */\n    MetricsAPI.prototype.setGlobalMeterProvider = function (provider) {\n        if (global_utils_1._global[global_utils_1.GLOBAL_METRICS_API_KEY]) {\n            // global meter provider has already been set\n            return this.getMeterProvider();\n        }\n        global_utils_1._global[global_utils_1.GLOBAL_METRICS_API_KEY] = global_utils_1.makeGetter(global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION, provider, NoopMeterProvider_1.NOOP_METER_PROVIDER);\n        return provider;\n    };\n    /**\n     * Returns the global meter provider.\n     */\n    MetricsAPI.prototype.getMeterProvider = function () {\n        var _a, _b;\n        return ((_b = (_a = global_utils_1._global[global_utils_1.GLOBAL_METRICS_API_KEY]) === null || _a === void 0 ? void 0 : _a.call(global_utils_1._global, global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION)) !== null && _b !== void 0 ? _b : NoopMeterProvider_1.NOOP_METER_PROVIDER);\n    };\n    /**\n     * Returns a meter from the global meter provider.\n     */\n    MetricsAPI.prototype.getMeter = function (name, version) {\n        return this.getMeterProvider().getMeter(name, version);\n    };\n    /** Remove the global meter provider */\n    MetricsAPI.prototype.disable = function () {\n        delete global_utils_1._global[global_utils_1.GLOBAL_METRICS_API_KEY];\n    };\n    return MetricsAPI;\n}());\nexports.MetricsAPI = MetricsAPI;\n//# sourceMappingURL=metrics.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PropagationAPI = void 0;\nvar NoopTextMapPropagator_1 = require(\"../context/propagation/NoopTextMapPropagator\");\nvar TextMapPropagator_1 = require(\"../context/propagation/TextMapPropagator\");\nvar global_utils_1 = require(\"./global-utils\");\n/**\n * Singleton object which represents the entry point to the OpenTelemetry Propagation API\n */\nvar PropagationAPI = /** @class */ (function () {\n    /** Empty private constructor prevents end users from constructing a new instance of the API */\n    function PropagationAPI() {\n    }\n    /** Get the singleton instance of the Propagator API */\n    PropagationAPI.getInstance = function () {\n        if (!this._instance) {\n            this._instance = new PropagationAPI();\n        }\n        return this._instance;\n    };\n    /**\n     * Set the current propagator. Returns the initialized propagator\n     */\n    PropagationAPI.prototype.setGlobalPropagator = function (propagator) {\n        if (global_utils_1._global[global_utils_1.GLOBAL_PROPAGATION_API_KEY]) {\n            // global propagator has already been set\n            return this._getGlobalPropagator();\n        }\n        global_utils_1._global[global_utils_1.GLOBAL_PROPAGATION_API_KEY] = global_utils_1.makeGetter(global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION, propagator, NoopTextMapPropagator_1.NOOP_TEXT_MAP_PROPAGATOR);\n        return propagator;\n    };\n    /**\n     * Inject context into a carrier to be propagated inter-process\n     *\n     * @param context Context carrying tracing data to inject\n     * @param carrier carrier to inject context into\n     * @param setter Function used to set values on the carrier\n     */\n    PropagationAPI.prototype.inject = function (context, carrier, setter) {\n        if (setter === void 0) { setter = TextMapPropagator_1.defaultTextMapSetter; }\n        return this._getGlobalPropagator().inject(context, carrier, setter);\n    };\n    /**\n     * Extract context from a carrier\n     *\n     * @param context Context which the newly created context will inherit from\n     * @param carrier Carrier to extract context from\n     * @param getter Function used to extract keys from a carrier\n     */\n    PropagationAPI.prototype.extract = function (context, carrier, getter) {\n        if (getter === void 0) { getter = TextMapPropagator_1.defaultTextMapGetter; }\n        return this._getGlobalPropagator().extract(context, carrier, getter);\n    };\n    /** Remove the global propagator */\n    PropagationAPI.prototype.disable = function () {\n        delete global_utils_1._global[global_utils_1.GLOBAL_PROPAGATION_API_KEY];\n    };\n    PropagationAPI.prototype._getGlobalPropagator = function () {\n        var _a, _b;\n        return ((_b = (_a = global_utils_1._global[global_utils_1.GLOBAL_PROPAGATION_API_KEY]) === null || _a === void 0 ? void 0 : _a.call(global_utils_1._global, global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION)) !== null && _b !== void 0 ? _b : NoopTextMapPropagator_1.NOOP_TEXT_MAP_PROPAGATOR);\n    };\n    return PropagationAPI;\n}());\nexports.PropagationAPI = PropagationAPI;\n//# sourceMappingURL=propagation.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TraceAPI = void 0;\nvar NoopTracerProvider_1 = require(\"../trace/NoopTracerProvider\");\nvar ProxyTracerProvider_1 = require(\"../trace/ProxyTracerProvider\");\nvar spancontext_utils_1 = require(\"../trace/spancontext-utils\");\nvar global_utils_1 = require(\"./global-utils\");\n/**\n * Singleton object which represents the entry point to the OpenTelemetry Tracing API\n */\nvar TraceAPI = /** @class */ (function () {\n    /** Empty private constructor prevents end users from constructing a new instance of the API */\n    function TraceAPI() {\n        this._proxyTracerProvider = new ProxyTracerProvider_1.ProxyTracerProvider();\n        this.isSpanContextValid = spancontext_utils_1.isSpanContextValid;\n    }\n    /** Get the singleton instance of the Trace API */\n    TraceAPI.getInstance = function () {\n        if (!this._instance) {\n            this._instance = new TraceAPI();\n        }\n        return this._instance;\n    };\n    /**\n     * Set the current global tracer. Returns the initialized global tracer provider\n     */\n    TraceAPI.prototype.setGlobalTracerProvider = function (provider) {\n        if (global_utils_1._global[global_utils_1.GLOBAL_TRACE_API_KEY]) {\n            // global tracer provider has already been set\n            return this.getTracerProvider();\n        }\n        this._proxyTracerProvider.setDelegate(provider);\n        global_utils_1._global[global_utils_1.GLOBAL_TRACE_API_KEY] = global_utils_1.makeGetter(global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION, this._proxyTracerProvider, NoopTracerProvider_1.NOOP_TRACER_PROVIDER);\n        return this.getTracerProvider();\n    };\n    /**\n     * Returns the global tracer provider.\n     */\n    TraceAPI.prototype.getTracerProvider = function () {\n        var _a, _b;\n        return ((_b = (_a = global_utils_1._global[global_utils_1.GLOBAL_TRACE_API_KEY]) === null || _a === void 0 ? void 0 : _a.call(global_utils_1._global, global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION)) !== null && _b !== void 0 ? _b : this._proxyTracerProvider);\n    };\n    /**\n     * Returns a tracer from the global tracer provider.\n     */\n    TraceAPI.prototype.getTracer = function (name, version) {\n        return this.getTracerProvider().getTracer(name, version);\n    };\n    /** Remove the global tracer provider */\n    TraceAPI.prototype.disable = function () {\n        delete global_utils_1._global[global_utils_1.GLOBAL_TRACE_API_KEY];\n        this._proxyTracerProvider = new ProxyTracerProvider_1.ProxyTracerProvider();\n    };\n    return TraceAPI;\n}());\nexports.TraceAPI = TraceAPI;\n//# sourceMappingURL=trace.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=Baggage.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EntryTtl = void 0;\n/**\n * EntryTtl is an integer that represents number of hops an entry can propagate.\n *\n * For now, ONLY special values (0 and -1) are supported.\n */\nvar EntryTtl;\n(function (EntryTtl) {\n    /**\n     * NO_PROPAGATION is considered to have local context and is used within the\n     * process it created.\n     */\n    EntryTtl[EntryTtl[\"NO_PROPAGATION\"] = 0] = \"NO_PROPAGATION\";\n    /** UNLIMITED_PROPAGATION can propagate unlimited hops. */\n    EntryTtl[EntryTtl[\"UNLIMITED_PROPAGATION\"] = -1] = \"UNLIMITED_PROPAGATION\";\n})(EntryTtl = exports.EntryTtl || (exports.EntryTtl = {}));\n//# sourceMappingURL=EntryValue.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=Exception.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=Logger.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=Time.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.setBaggage = exports.getBaggage = exports.isInstrumentationSuppressed = exports.unsuppressInstrumentation = exports.suppressInstrumentation = exports.getParentSpanContext = exports.setExtractedSpanContext = exports.setActiveSpan = exports.getActiveSpan = void 0;\nvar context_base_1 = require(\"@opentelemetry/context-base\");\nvar __1 = require(\"../\");\n/**\n * Active span key\n */\nvar ACTIVE_SPAN_KEY = context_base_1.createContextKey('OpenTelemetry Context Key ACTIVE_SPAN');\n/**\n * Shared key for indicating if instrumentation should be suppressed beyond\n * this current scope.\n */\nvar SUPPRESS_INSTRUMENTATION_KEY = context_base_1.createContextKey('OpenTelemetry Context Key SUPPRESS_INSTRUMENTATION');\n/**\n * Baggage key\n */\nvar BAGGAGE_KEY = context_base_1.createContextKey('OpenTelemetry Baggage Key');\n/**\n * Return the active span if one exists\n *\n * @param context context to get span from\n */\nfunction getActiveSpan(context) {\n    return context.getValue(ACTIVE_SPAN_KEY) || undefined;\n}\nexports.getActiveSpan = getActiveSpan;\n/**\n * Set the active span on a context\n *\n * @param context context to use as parent\n * @param span span to set active\n */\nfunction setActiveSpan(context, span) {\n    return context.setValue(ACTIVE_SPAN_KEY, span);\n}\nexports.setActiveSpan = setActiveSpan;\n/**\n * Wrap extracted span context in a NoopSpan and set as active span in a new\n * context\n *\n * @param context context to set active span on\n * @param spanContext span context to be wrapped\n */\nfunction setExtractedSpanContext(context, spanContext) {\n    return setActiveSpan(context, new __1.NoopSpan(spanContext));\n}\nexports.setExtractedSpanContext = setExtractedSpanContext;\n/**\n * Get the span context of the parent span if it exists,\n * or the extracted span context if there is no active\n * span.\n *\n * @param context context to get values from\n */\nfunction getParentSpanContext(context) {\n    var _a;\n    return (_a = getActiveSpan(context)) === null || _a === void 0 ? void 0 : _a.context();\n}\nexports.getParentSpanContext = getParentSpanContext;\n/**\n * Sets value on context to indicate that instrumentation should\n * be suppressed beyond this current scope.\n *\n * @param context context to set the suppress instrumentation value on.\n */\nfunction suppressInstrumentation(context) {\n    return context.setValue(SUPPRESS_INSTRUMENTATION_KEY, true);\n}\nexports.suppressInstrumentation = suppressInstrumentation;\n/**\n * Sets value on context to indicate that instrumentation should\n * no-longer be suppressed beyond this current scope.\n *\n * @param context context to set the suppress instrumentation value on.\n */\nfunction unsuppressInstrumentation(context) {\n    return context.setValue(SUPPRESS_INSTRUMENTATION_KEY, false);\n}\nexports.unsuppressInstrumentation = unsuppressInstrumentation;\n/**\n * Return current suppress instrumentation value for the given context,\n * if it exists.\n *\n * @param context context check for the suppress instrumentation value.\n */\nfunction isInstrumentationSuppressed(context) {\n    return Boolean(context.getValue(SUPPRESS_INSTRUMENTATION_KEY));\n}\nexports.isInstrumentationSuppressed = isInstrumentationSuppressed;\n/**\n * @param {Context} Context that manage all context values\n * @returns {Baggage} Extracted baggage from the context\n */\nfunction getBaggage(context) {\n    return context.getValue(BAGGAGE_KEY) || undefined;\n}\nexports.getBaggage = getBaggage;\n/**\n * @param {Context} Context that manage all context values\n * @param {Baggage} baggage that will be set in the actual context\n */\nfunction setBaggage(context, baggage) {\n    return context.setValue(BAGGAGE_KEY, baggage);\n}\nexports.setBaggage = setBaggage;\n//# sourceMappingURL=context.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NOOP_TEXT_MAP_PROPAGATOR = exports.NoopTextMapPropagator = void 0;\n/**\n * No-op implementations of {@link TextMapPropagator}.\n */\nvar NoopTextMapPropagator = /** @class */ (function () {\n    function NoopTextMapPropagator() {\n    }\n    /** Noop inject function does nothing */\n    NoopTextMapPropagator.prototype.inject = function (_context, _carrier) { };\n    /** Noop extract function does nothing and returns the input context */\n    NoopTextMapPropagator.prototype.extract = function (context, _carrier) {\n        return context;\n    };\n    NoopTextMapPropagator.prototype.fields = function () {\n        return [];\n    };\n    return NoopTextMapPropagator;\n}());\nexports.NoopTextMapPropagator = NoopTextMapPropagator;\nexports.NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator();\n//# sourceMappingURL=NoopTextMapPropagator.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.defaultTextMapSetter = exports.defaultTextMapGetter = void 0;\nexports.defaultTextMapGetter = {\n    get: function (carrier, key) {\n        if (carrier == null) {\n            return undefined;\n        }\n        return carrier[key];\n    },\n    keys: function (carrier) {\n        if (carrier == null) {\n            return [];\n        }\n        return Object.keys(carrier);\n    },\n};\nexports.defaultTextMapSetter = {\n    set: function (carrier, key, value) {\n        if (carrier == null) {\n            return;\n        }\n        carrier[key] = value;\n    },\n};\n//# sourceMappingURL=TextMapPropagator.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.propagation = exports.metrics = exports.trace = exports.context = void 0;\n__exportStar(require(\"./common/Exception\"), exports);\n__exportStar(require(\"./common/Logger\"), exports);\n__exportStar(require(\"./common/Time\"), exports);\n__exportStar(require(\"./context/context\"), exports);\n__exportStar(require(\"./context/propagation/TextMapPropagator\"), exports);\n__exportStar(require(\"./context/propagation/NoopTextMapPropagator\"), exports);\n__exportStar(require(\"./baggage/Baggage\"), exports);\n__exportStar(require(\"./baggage/EntryValue\"), exports);\n__exportStar(require(\"./metrics/BatchObserverResult\"), exports);\n__exportStar(require(\"./metrics/BoundInstrument\"), exports);\n__exportStar(require(\"./metrics/Meter\"), exports);\n__exportStar(require(\"./metrics/MeterProvider\"), exports);\n__exportStar(require(\"./metrics/Metric\"), exports);\n__exportStar(require(\"./metrics/NoopMeter\"), exports);\n__exportStar(require(\"./metrics/NoopMeterProvider\"), exports);\n__exportStar(require(\"./metrics/Observation\"), exports);\n__exportStar(require(\"./metrics/ObserverResult\"), exports);\n__exportStar(require(\"./trace/attributes\"), exports);\n__exportStar(require(\"./trace/Event\"), exports);\n__exportStar(require(\"./trace/link_context\"), exports);\n__exportStar(require(\"./trace/link\"), exports);\n__exportStar(require(\"./trace/NoopLogger\"), exports);\n__exportStar(require(\"./trace/NoopSpan\"), exports);\n__exportStar(require(\"./trace/NoopTracer\"), exports);\n__exportStar(require(\"./trace/NoopTracerProvider\"), exports);\n__exportStar(require(\"./trace/ProxyTracer\"), exports);\n__exportStar(require(\"./trace/ProxyTracerProvider\"), exports);\n__exportStar(require(\"./trace/Sampler\"), exports);\n__exportStar(require(\"./trace/SamplingResult\"), exports);\n__exportStar(require(\"./trace/span_context\"), exports);\n__exportStar(require(\"./trace/span_kind\"), exports);\n__exportStar(require(\"./trace/span\"), exports);\n__exportStar(require(\"./trace/SpanOptions\"), exports);\n__exportStar(require(\"./trace/status\"), exports);\n__exportStar(require(\"./trace/TimedEvent\"), exports);\n__exportStar(require(\"./trace/trace_flags\"), exports);\n__exportStar(require(\"./trace/trace_state\"), exports);\n__exportStar(require(\"./trace/tracer_provider\"), exports);\n__exportStar(require(\"./trace/tracer\"), exports);\nvar spancontext_utils_1 = require(\"./trace/spancontext-utils\");\nObject.defineProperty(exports, \"INVALID_SPANID\", { enumerable: true, get: function () { return spancontext_utils_1.INVALID_SPANID; } });\nObject.defineProperty(exports, \"INVALID_TRACEID\", { enumerable: true, get: function () { return spancontext_utils_1.INVALID_TRACEID; } });\nObject.defineProperty(exports, \"INVALID_SPAN_CONTEXT\", { enumerable: true, get: function () { return spancontext_utils_1.INVALID_SPAN_CONTEXT; } });\nObject.defineProperty(exports, \"isSpanContextValid\", { enumerable: true, get: function () { return spancontext_utils_1.isSpanContextValid; } });\nObject.defineProperty(exports, \"isValidTraceId\", { enumerable: true, get: function () { return spancontext_utils_1.isValidTraceId; } });\nObject.defineProperty(exports, \"isValidSpanId\", { enumerable: true, get: function () { return spancontext_utils_1.isValidSpanId; } });\nvar context_base_1 = require(\"@opentelemetry/context-base\");\nObject.defineProperty(exports, \"ROOT_CONTEXT\", { enumerable: true, get: function () { return context_base_1.ROOT_CONTEXT; } });\nObject.defineProperty(exports, \"createContextKey\", { enumerable: true, get: function () { return context_base_1.createContextKey; } });\nvar context_1 = require(\"./api/context\");\n/** Entrypoint for context API */\nexports.context = context_1.ContextAPI.getInstance();\nvar trace_1 = require(\"./api/trace\");\n/** Entrypoint for trace API */\nexports.trace = trace_1.TraceAPI.getInstance();\nvar metrics_1 = require(\"./api/metrics\");\n/** Entrypoint for metrics API */\nexports.metrics = metrics_1.MetricsAPI.getInstance();\nvar propagation_1 = require(\"./api/propagation\");\n/** Entrypoint for propagation API */\nexports.propagation = propagation_1.PropagationAPI.getInstance();\nexports.default = {\n    trace: exports.trace,\n    metrics: exports.metrics,\n    context: exports.context,\n    propagation: exports.propagation,\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=BatchObserverResult.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=BoundInstrument.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=Meter.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=MeterProvider.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ValueType = void 0;\n/** The Type of value. It describes how the data is reported. */\nvar ValueType;\n(function (ValueType) {\n    ValueType[ValueType[\"INT\"] = 0] = \"INT\";\n    ValueType[ValueType[\"DOUBLE\"] = 1] = \"DOUBLE\";\n})(ValueType = exports.ValueType || (exports.ValueType = {}));\n//# sourceMappingURL=Metric.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NOOP_BATCH_OBSERVER = exports.NOOP_SUM_OBSERVER_METRIC = exports.NOOP_UP_DOWN_SUM_OBSERVER_METRIC = exports.NOOP_VALUE_OBSERVER_METRIC = exports.NOOP_BOUND_BASE_OBSERVER = exports.NOOP_VALUE_RECORDER_METRIC = exports.NOOP_BOUND_VALUE_RECORDER = exports.NOOP_COUNTER_METRIC = exports.NOOP_BOUND_COUNTER = exports.NOOP_METER = exports.NoopBoundBaseObserver = exports.NoopBoundValueRecorder = exports.NoopBoundCounter = exports.NoopBatchObserver = exports.NoopBaseObserverMetric = exports.NoopValueRecorderMetric = exports.NoopCounterMetric = exports.NoopMetric = exports.NoopMeter = void 0;\n/**\n * NoopMeter is a noop implementation of the {@link Meter} interface. It reuses\n * constant NoopMetrics for all of its methods.\n */\nvar NoopMeter = /** @class */ (function () {\n    function NoopMeter() {\n    }\n    /**\n     * Returns constant noop value recorder.\n     * @param name the name of the metric.\n     * @param [options] the metric options.\n     */\n    NoopMeter.prototype.createValueRecorder = function (_name, _options) {\n        return exports.NOOP_VALUE_RECORDER_METRIC;\n    };\n    /**\n     * Returns a constant noop counter.\n     * @param name the name of the metric.\n     * @param [options] the metric options.\n     */\n    NoopMeter.prototype.createCounter = function (_name, _options) {\n        return exports.NOOP_COUNTER_METRIC;\n    };\n    /**\n     * Returns a constant noop UpDownCounter.\n     * @param name the name of the metric.\n     * @param [options] the metric options.\n     */\n    NoopMeter.prototype.createUpDownCounter = function (_name, _options) {\n        return exports.NOOP_COUNTER_METRIC;\n    };\n    /**\n     * Returns constant noop value observer.\n     * @param name the name of the metric.\n     * @param [options] the metric options.\n     * @param [callback] the value observer callback\n     */\n    NoopMeter.prototype.createValueObserver = function (_name, _options, _callback) {\n        return exports.NOOP_VALUE_OBSERVER_METRIC;\n    };\n    /**\n     * Returns constant noop sum observer.\n     * @param name the name of the metric.\n     * @param [options] the metric options.\n     * @param [callback] the sum observer callback\n     */\n    NoopMeter.prototype.createSumObserver = function (_name, _options, _callback) {\n        return exports.NOOP_SUM_OBSERVER_METRIC;\n    };\n    /**\n     * Returns constant noop up down sum observer.\n     * @param name the name of the metric.\n     * @param [options] the metric options.\n     * @param [callback] the up down sum observer callback\n     */\n    NoopMeter.prototype.createUpDownSumObserver = function (_name, _options, _callback) {\n        return exports.NOOP_UP_DOWN_SUM_OBSERVER_METRIC;\n    };\n    /**\n     * Returns constant noop batch observer.\n     * @param name the name of the metric.\n     * @param callback the batch observer callback\n     */\n    NoopMeter.prototype.createBatchObserver = function (_callback) {\n        return exports.NOOP_BATCH_OBSERVER;\n    };\n    return NoopMeter;\n}());\nexports.NoopMeter = NoopMeter;\nvar NoopMetric = /** @class */ (function () {\n    function NoopMetric(instrument) {\n        this._instrument = instrument;\n    }\n    /**\n     * Returns a Bound Instrument associated with specified Labels.\n     * It is recommended to keep a reference to the Bound Instrument instead of\n     * always calling this method for every operations.\n     * @param labels key-values pairs that are associated with a specific metric\n     *     that you want to record.\n     */\n    NoopMetric.prototype.bind = function (_labels) {\n        return this._instrument;\n    };\n    /**\n     * Removes the Binding from the metric, if it is present.\n     * @param labels key-values pairs that are associated with a specific metric.\n     */\n    NoopMetric.prototype.unbind = function (_labels) {\n        return;\n    };\n    /**\n     * Clears all timeseries from the Metric.\n     */\n    NoopMetric.prototype.clear = function () {\n        return;\n    };\n    return NoopMetric;\n}());\nexports.NoopMetric = NoopMetric;\nvar NoopCounterMetric = /** @class */ (function (_super) {\n    __extends(NoopCounterMetric, _super);\n    function NoopCounterMetric() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NoopCounterMetric.prototype.add = function (value, labels) {\n        this.bind(labels).add(value);\n    };\n    return NoopCounterMetric;\n}(NoopMetric));\nexports.NoopCounterMetric = NoopCounterMetric;\nvar NoopValueRecorderMetric = /** @class */ (function (_super) {\n    __extends(NoopValueRecorderMetric, _super);\n    function NoopValueRecorderMetric() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NoopValueRecorderMetric.prototype.record = function (value, labels) {\n        this.bind(labels).record(value);\n    };\n    return NoopValueRecorderMetric;\n}(NoopMetric));\nexports.NoopValueRecorderMetric = NoopValueRecorderMetric;\nvar NoopBaseObserverMetric = /** @class */ (function (_super) {\n    __extends(NoopBaseObserverMetric, _super);\n    function NoopBaseObserverMetric() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NoopBaseObserverMetric.prototype.observation = function () {\n        return {\n            observer: this,\n            value: 0,\n        };\n    };\n    return NoopBaseObserverMetric;\n}(NoopMetric));\nexports.NoopBaseObserverMetric = NoopBaseObserverMetric;\nvar NoopBatchObserver = /** @class */ (function () {\n    function NoopBatchObserver() {\n    }\n    return NoopBatchObserver;\n}());\nexports.NoopBatchObserver = NoopBatchObserver;\nvar NoopBoundCounter = /** @class */ (function () {\n    function NoopBoundCounter() {\n    }\n    NoopBoundCounter.prototype.add = function (_value) {\n        return;\n    };\n    return NoopBoundCounter;\n}());\nexports.NoopBoundCounter = NoopBoundCounter;\nvar NoopBoundValueRecorder = /** @class */ (function () {\n    function NoopBoundValueRecorder() {\n    }\n    NoopBoundValueRecorder.prototype.record = function (_value, _baggage, _spanContext) {\n        return;\n    };\n    return NoopBoundValueRecorder;\n}());\nexports.NoopBoundValueRecorder = NoopBoundValueRecorder;\nvar NoopBoundBaseObserver = /** @class */ (function () {\n    function NoopBoundBaseObserver() {\n    }\n    NoopBoundBaseObserver.prototype.update = function (_value) { };\n    return NoopBoundBaseObserver;\n}());\nexports.NoopBoundBaseObserver = NoopBoundBaseObserver;\nexports.NOOP_METER = new NoopMeter();\nexports.NOOP_BOUND_COUNTER = new NoopBoundCounter();\nexports.NOOP_COUNTER_METRIC = new NoopCounterMetric(exports.NOOP_BOUND_COUNTER);\nexports.NOOP_BOUND_VALUE_RECORDER = new NoopBoundValueRecorder();\nexports.NOOP_VALUE_RECORDER_METRIC = new NoopValueRecorderMetric(exports.NOOP_BOUND_VALUE_RECORDER);\nexports.NOOP_BOUND_BASE_OBSERVER = new NoopBoundBaseObserver();\nexports.NOOP_VALUE_OBSERVER_METRIC = new NoopBaseObserverMetric(exports.NOOP_BOUND_BASE_OBSERVER);\nexports.NOOP_UP_DOWN_SUM_OBSERVER_METRIC = new NoopBaseObserverMetric(exports.NOOP_BOUND_BASE_OBSERVER);\nexports.NOOP_SUM_OBSERVER_METRIC = new NoopBaseObserverMetric(exports.NOOP_BOUND_BASE_OBSERVER);\nexports.NOOP_BATCH_OBSERVER = new NoopBatchObserver();\n//# sourceMappingURL=NoopMeter.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NOOP_METER_PROVIDER = exports.NoopMeterProvider = void 0;\nvar NoopMeter_1 = require(\"./NoopMeter\");\n/**\n * An implementation of the {@link MeterProvider} which returns an impotent Meter\n * for all calls to `getMeter`\n */\nvar NoopMeterProvider = /** @class */ (function () {\n    function NoopMeterProvider() {\n    }\n    NoopMeterProvider.prototype.getMeter = function (_name, _version) {\n        return NoopMeter_1.NOOP_METER;\n    };\n    return NoopMeterProvider;\n}());\nexports.NoopMeterProvider = NoopMeterProvider;\nexports.NOOP_METER_PROVIDER = new NoopMeterProvider();\n//# sourceMappingURL=NoopMeterProvider.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=Observation.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=ObserverResult.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./node\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports._globalThis = void 0;\n/** only globals that common to node and browsers are allowed */\n// eslint-disable-next-line node/no-unsupported-features/es-builtins\nexports._globalThis = typeof globalThis === 'object' ? globalThis : global;\n//# sourceMappingURL=globalThis.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./globalThis\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=Event.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NoopLogger = void 0;\n/** No-op implementation of Logger */\nvar NoopLogger = /** @class */ (function () {\n    function NoopLogger() {\n    }\n    // By default does nothing\n    NoopLogger.prototype.debug = function (_message) {\n        var _args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            _args[_i - 1] = arguments[_i];\n        }\n    };\n    // By default does nothing\n    NoopLogger.prototype.error = function (_message) {\n        var _args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            _args[_i - 1] = arguments[_i];\n        }\n    };\n    // By default does nothing\n    NoopLogger.prototype.warn = function (_message) {\n        var _args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            _args[_i - 1] = arguments[_i];\n        }\n    };\n    // By default does nothing\n    NoopLogger.prototype.info = function (_message) {\n        var _args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            _args[_i - 1] = arguments[_i];\n        }\n    };\n    return NoopLogger;\n}());\nexports.NoopLogger = NoopLogger;\n//# sourceMappingURL=NoopLogger.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NOOP_SPAN = exports.NoopSpan = void 0;\nvar spancontext_utils_1 = require(\"./spancontext-utils\");\n/**\n * The NoopSpan is the default {@link Span} that is used when no Span\n * implementation is available. All operations are no-op including context\n * propagation.\n */\nvar NoopSpan = /** @class */ (function () {\n    function NoopSpan(_spanContext) {\n        if (_spanContext === void 0) { _spanContext = spancontext_utils_1.INVALID_SPAN_CONTEXT; }\n        this._spanContext = _spanContext;\n    }\n    // Returns a SpanContext.\n    NoopSpan.prototype.context = function () {\n        return this._spanContext;\n    };\n    // By default does nothing\n    NoopSpan.prototype.setAttribute = function (_key, _value) {\n        return this;\n    };\n    // By default does nothing\n    NoopSpan.prototype.setAttributes = function (_attributes) {\n        return this;\n    };\n    // By default does nothing\n    NoopSpan.prototype.addEvent = function (_name, _attributes) {\n        return this;\n    };\n    // By default does nothing\n    NoopSpan.prototype.setStatus = function (_status) {\n        return this;\n    };\n    // By default does nothing\n    NoopSpan.prototype.updateName = function (_name) {\n        return this;\n    };\n    // By default does nothing\n    NoopSpan.prototype.end = function (_endTime) { };\n    // isRecording always returns false for noopSpan.\n    NoopSpan.prototype.isRecording = function () {\n        return false;\n    };\n    // By default does nothing\n    NoopSpan.prototype.recordException = function (_exception, _time) { };\n    return NoopSpan;\n}());\nexports.NoopSpan = NoopSpan;\nexports.NOOP_SPAN = new NoopSpan();\n//# sourceMappingURL=NoopSpan.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NOOP_TRACER = exports.NoopTracer = void 0;\nvar NoopSpan_1 = require(\"./NoopSpan\");\nvar spancontext_utils_1 = require(\"./spancontext-utils\");\nvar context_1 = require(\"../context/context\");\n/**\n * No-op implementations of {@link Tracer}.\n */\nvar NoopTracer = /** @class */ (function () {\n    function NoopTracer() {\n    }\n    NoopTracer.prototype.getCurrentSpan = function () {\n        return NoopSpan_1.NOOP_SPAN;\n    };\n    // startSpan starts a noop span.\n    NoopTracer.prototype.startSpan = function (name, options, context) {\n        var root = Boolean(options === null || options === void 0 ? void 0 : options.root);\n        if (root) {\n            return NoopSpan_1.NOOP_SPAN;\n        }\n        var parentFromContext = context && context_1.getParentSpanContext(context);\n        if (isSpanContext(parentFromContext) &&\n            spancontext_utils_1.isSpanContextValid(parentFromContext)) {\n            return new NoopSpan_1.NoopSpan(parentFromContext);\n        }\n        else {\n            return NoopSpan_1.NOOP_SPAN;\n        }\n    };\n    NoopTracer.prototype.withSpan = function (span, fn) {\n        return fn();\n    };\n    NoopTracer.prototype.bind = function (target, _span) {\n        return target;\n    };\n    return NoopTracer;\n}());\nexports.NoopTracer = NoopTracer;\nfunction isSpanContext(spanContext) {\n    return (typeof spanContext === 'object' &&\n        typeof spanContext['spanId'] === 'string' &&\n        typeof spanContext['traceId'] === 'string' &&\n        typeof spanContext['traceFlags'] === 'number');\n}\nexports.NOOP_TRACER = new NoopTracer();\n//# sourceMappingURL=NoopTracer.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NOOP_TRACER_PROVIDER = exports.NoopTracerProvider = void 0;\nvar NoopTracer_1 = require(\"./NoopTracer\");\n/**\n * An implementation of the {@link TracerProvider} which returns an impotent\n * Tracer for all calls to `getTracer`.\n *\n * All operations are no-op.\n */\nvar NoopTracerProvider = /** @class */ (function () {\n    function NoopTracerProvider() {\n    }\n    NoopTracerProvider.prototype.getTracer = function (_name, _version) {\n        return NoopTracer_1.NOOP_TRACER;\n    };\n    return NoopTracerProvider;\n}());\nexports.NoopTracerProvider = NoopTracerProvider;\nexports.NOOP_TRACER_PROVIDER = new NoopTracerProvider();\n//# sourceMappingURL=NoopTracerProvider.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProxyTracer = void 0;\nvar NoopTracer_1 = require(\"./NoopTracer\");\n/**\n * Proxy tracer provided by the proxy tracer provider\n */\nvar ProxyTracer = /** @class */ (function () {\n    function ProxyTracer(_provider, name, version) {\n        this._provider = _provider;\n        this.name = name;\n        this.version = version;\n    }\n    ProxyTracer.prototype.getCurrentSpan = function () {\n        return this._getTracer().getCurrentSpan();\n    };\n    ProxyTracer.prototype.startSpan = function (name, options) {\n        return this._getTracer().startSpan(name, options);\n    };\n    ProxyTracer.prototype.withSpan = function (span, fn) {\n        return this._getTracer().withSpan(span, fn);\n    };\n    ProxyTracer.prototype.bind = function (target, span) {\n        return this._getTracer().bind(target, span);\n    };\n    /**\n     * Try to get a tracer from the proxy tracer provider.\n     * If the proxy tracer provider has no delegate, return a noop tracer.\n     */\n    ProxyTracer.prototype._getTracer = function () {\n        if (this._delegate) {\n            return this._delegate;\n        }\n        var tracer = this._provider.getDelegateTracer(this.name, this.version);\n        if (!tracer) {\n            return NoopTracer_1.NOOP_TRACER;\n        }\n        this._delegate = tracer;\n        return this._delegate;\n    };\n    return ProxyTracer;\n}());\nexports.ProxyTracer = ProxyTracer;\n//# sourceMappingURL=ProxyTracer.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProxyTracerProvider = void 0;\nvar ProxyTracer_1 = require(\"./ProxyTracer\");\nvar NoopTracerProvider_1 = require(\"./NoopTracerProvider\");\n/**\n * Tracer provider which provides {@link ProxyTracer}s.\n *\n * Before a delegate is set, tracers provided are NoOp.\n *   When a delegate is set, traces are provided from the delegate.\n *   When a delegate is set after tracers have already been provided,\n *   all tracers already provided will use the provided delegate implementation.\n */\nvar ProxyTracerProvider = /** @class */ (function () {\n    function ProxyTracerProvider() {\n    }\n    /**\n     * Get a {@link ProxyTracer}\n     */\n    ProxyTracerProvider.prototype.getTracer = function (name, version) {\n        var _a;\n        return ((_a = this.getDelegateTracer(name, version)) !== null && _a !== void 0 ? _a : new ProxyTracer_1.ProxyTracer(this, name, version));\n    };\n    ProxyTracerProvider.prototype.getDelegate = function () {\n        var _a;\n        return (_a = this._delegate) !== null && _a !== void 0 ? _a : NoopTracerProvider_1.NOOP_TRACER_PROVIDER;\n    };\n    /**\n     * Set the delegate tracer provider\n     */\n    ProxyTracerProvider.prototype.setDelegate = function (delegate) {\n        this._delegate = delegate;\n    };\n    ProxyTracerProvider.prototype.getDelegateTracer = function (name, version) {\n        var _a;\n        return (_a = this._delegate) === null || _a === void 0 ? void 0 : _a.getTracer(name, version);\n    };\n    return ProxyTracerProvider;\n}());\nexports.ProxyTracerProvider = ProxyTracerProvider;\n//# sourceMappingURL=ProxyTracerProvider.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=Sampler.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SamplingDecision = void 0;\n/**\n * A sampling decision that determines how a {@link Span} will be recorded\n * and collected.\n */\nvar SamplingDecision;\n(function (SamplingDecision) {\n    /**\n     * `Span.isRecording() === false`, span will not be recorded and all events\n     * and attributes will be dropped.\n     */\n    SamplingDecision[SamplingDecision[\"NOT_RECORD\"] = 0] = \"NOT_RECORD\";\n    /**\n     * `Span.isRecording() === true`, but `Sampled` flag in {@link TraceFlags}\n     * MUST NOT be set.\n     */\n    SamplingDecision[SamplingDecision[\"RECORD\"] = 1] = \"RECORD\";\n    /**\n     * `Span.isRecording() === true` AND `Sampled` flag in {@link TraceFlags}\n     * MUST be set.\n     */\n    SamplingDecision[SamplingDecision[\"RECORD_AND_SAMPLED\"] = 2] = \"RECORD_AND_SAMPLED\";\n})(SamplingDecision = exports.SamplingDecision || (exports.SamplingDecision = {}));\n//# sourceMappingURL=SamplingResult.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=SpanOptions.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=TimedEvent.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=attributes.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=link.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=link_context.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=span.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=span_context.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SpanKind = void 0;\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar SpanKind;\n(function (SpanKind) {\n    /** Default value. Indicates that the span is used internally. */\n    SpanKind[SpanKind[\"INTERNAL\"] = 0] = \"INTERNAL\";\n    /**\n     * Indicates that the span covers server-side handling of an RPC or other\n     * remote request.\n     */\n    SpanKind[SpanKind[\"SERVER\"] = 1] = \"SERVER\";\n    /**\n     * Indicates that the span covers the client-side wrapper around an RPC or\n     * other remote request.\n     */\n    SpanKind[SpanKind[\"CLIENT\"] = 2] = \"CLIENT\";\n    /**\n     * Indicates that the span describes producer sending a message to a\n     * broker. Unlike client and server, there is no direct critical path latency\n     * relationship between producer and consumer spans.\n     */\n    SpanKind[SpanKind[\"PRODUCER\"] = 3] = \"PRODUCER\";\n    /**\n     * Indicates that the span describes consumer receiving a message from a\n     * broker. Unlike client and server, there is no direct critical path latency\n     * relationship between producer and consumer spans.\n     */\n    SpanKind[SpanKind[\"CONSUMER\"] = 4] = \"CONSUMER\";\n})(SpanKind = exports.SpanKind || (exports.SpanKind = {}));\n//# sourceMappingURL=span_kind.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isSpanContextValid = exports.isValidSpanId = exports.isValidTraceId = exports.INVALID_SPAN_CONTEXT = exports.INVALID_TRACEID = exports.INVALID_SPANID = void 0;\nvar trace_flags_1 = require(\"./trace_flags\");\nvar VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;\nvar VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;\nexports.INVALID_SPANID = '0000000000000000';\nexports.INVALID_TRACEID = '00000000000000000000000000000000';\nexports.INVALID_SPAN_CONTEXT = {\n    traceId: exports.INVALID_TRACEID,\n    spanId: exports.INVALID_SPANID,\n    traceFlags: trace_flags_1.TraceFlags.NONE,\n};\nfunction isValidTraceId(traceId) {\n    return VALID_TRACEID_REGEX.test(traceId) && traceId !== exports.INVALID_TRACEID;\n}\nexports.isValidTraceId = isValidTraceId;\nfunction isValidSpanId(spanId) {\n    return VALID_SPANID_REGEX.test(spanId) && spanId !== exports.INVALID_SPANID;\n}\nexports.isValidSpanId = isValidSpanId;\n/**\n * Returns true if this {@link SpanContext} is valid.\n * @return true if this {@link SpanContext} is valid.\n */\nfunction isSpanContextValid(spanContext) {\n    return (isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId));\n}\nexports.isSpanContextValid = isSpanContextValid;\n//# sourceMappingURL=spancontext-utils.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StatusCode = void 0;\n/**\n * An enumeration of status codes.\n */\nvar StatusCode;\n(function (StatusCode) {\n    /**\n     * The operation has been validated by an Application developer or\n     * Operator to have completed successfully.\n     */\n    StatusCode[StatusCode[\"OK\"] = 0] = \"OK\";\n    /**\n     * The default status.\n     */\n    StatusCode[StatusCode[\"UNSET\"] = 1] = \"UNSET\";\n    /**\n     * The operation contains an error.\n     */\n    StatusCode[StatusCode[\"ERROR\"] = 2] = \"ERROR\";\n})(StatusCode = exports.StatusCode || (exports.StatusCode = {}));\n//# sourceMappingURL=status.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TraceFlags = void 0;\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar TraceFlags;\n(function (TraceFlags) {\n    /** Represents no flag set. */\n    TraceFlags[TraceFlags[\"NONE\"] = 0] = \"NONE\";\n    /** Bit to represent whether trace is sampled in trace flags. */\n    TraceFlags[TraceFlags[\"SAMPLED\"] = 1] = \"SAMPLED\";\n})(TraceFlags = exports.TraceFlags || (exports.TraceFlags = {}));\n//# sourceMappingURL=trace_flags.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=trace_state.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=tracer.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=tracer_provider.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NoopContextManager = void 0;\nvar context_1 = require(\"./context\");\nvar NoopContextManager = /** @class */ (function () {\n    function NoopContextManager() {\n    }\n    NoopContextManager.prototype.active = function () {\n        return context_1.ROOT_CONTEXT;\n    };\n    NoopContextManager.prototype.with = function (_context, fn) {\n        return fn();\n    };\n    NoopContextManager.prototype.bind = function (target, _context) {\n        return target;\n    };\n    NoopContextManager.prototype.enable = function () {\n        return this;\n    };\n    NoopContextManager.prototype.disable = function () {\n        return this;\n    };\n    return NoopContextManager;\n}());\nexports.NoopContextManager = NoopContextManager;\n//# sourceMappingURL=NoopContextManager.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createContextKey = exports.ROOT_CONTEXT = exports.BaseContext = void 0;\nvar BaseContext = /** @class */ (function () {\n    /**\n     * Construct a new context which inherits values from an optional parent context.\n     *\n     * @param parentContext a context from which to inherit values\n     */\n    function BaseContext(parentContext) {\n        this._currentContext = parentContext ? new Map(parentContext) : new Map();\n    }\n    /**\n     * Get a value from the context.\n     *\n     * @param key key which identifies a context value\n     */\n    BaseContext.prototype.getValue = function (key) {\n        return this._currentContext.get(key);\n    };\n    /**\n     * Create a new context which inherits from this context and has\n     * the given key set to the given value.\n     *\n     * @param key context key for which to set the value\n     * @param value value to set for the given key\n     */\n    BaseContext.prototype.setValue = function (key, value) {\n        var context = new BaseContext(this._currentContext);\n        context._currentContext.set(key, value);\n        return context;\n    };\n    /**\n     * Return a new context which inherits from this context but does\n     * not contain a value for the given key.\n     *\n     * @param key context key for which to clear a value\n     */\n    BaseContext.prototype.deleteValue = function (key) {\n        var context = new BaseContext(this._currentContext);\n        context._currentContext.delete(key);\n        return context;\n    };\n    return BaseContext;\n}());\nexports.BaseContext = BaseContext;\n/** The root context is used as the default parent context when there is no active context */\nexports.ROOT_CONTEXT = new BaseContext();\n/** Get a key to uniquely identify a context value */\nfunction createContextKey(description) {\n    return Symbol.for(description);\n}\nexports.createContextKey = createContextKey;\n//# sourceMappingURL=context.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar context_1 = require(\"./context\");\nObject.defineProperty(exports, \"createContextKey\", { enumerable: true, get: function () { return context_1.createContextKey; } });\nObject.defineProperty(exports, \"ROOT_CONTEXT\", { enumerable: true, get: function () { return context_1.ROOT_CONTEXT; } });\n__exportStar(require(\"./NoopContextManager\"), exports);\n__exportStar(require(\"./types\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=types.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ExportResultCode = void 0;\nvar ExportResultCode;\n(function (ExportResultCode) {\n    ExportResultCode[ExportResultCode[\"SUCCESS\"] = 0] = \"SUCCESS\";\n    ExportResultCode[ExportResultCode[\"FAILED\"] = 1] = \"FAILED\";\n})(ExportResultCode = exports.ExportResultCode || (exports.ExportResultCode = {}));\n//# sourceMappingURL=ExportResult.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HttpBaggage = exports.MAX_TOTAL_LENGTH = exports.MAX_PER_NAME_VALUE_PAIRS = exports.MAX_NAME_VALUE_PAIRS = exports.BAGGAGE_HEADER = void 0;\nconst api_1 = require(\"@opentelemetry/api\");\nconst KEY_PAIR_SEPARATOR = '=';\nconst PROPERTIES_SEPARATOR = ';';\nconst ITEMS_SEPARATOR = ',';\n// Name of the http header used to propagate the baggage\nexports.BAGGAGE_HEADER = 'baggage';\n// Maximum number of name-value pairs allowed by w3c spec\nexports.MAX_NAME_VALUE_PAIRS = 180;\n// Maximum number of bytes per a single name-value pair allowed by w3c spec\nexports.MAX_PER_NAME_VALUE_PAIRS = 4096;\n// Maximum total length of all name-value pairs allowed by w3c spec\nexports.MAX_TOTAL_LENGTH = 8192;\n/**\n * Propagates {@link Baggage} through Context format propagation.\n *\n * Based on the Baggage specification:\n * https://w3c.github.io/baggage/\n */\nclass HttpBaggage {\n    inject(context, carrier, setter) {\n        const baggage = api_1.getBaggage(context);\n        if (!baggage)\n            return;\n        const keyPairs = this._getKeyPairs(baggage)\n            .filter((pair) => {\n            return pair.length <= exports.MAX_PER_NAME_VALUE_PAIRS;\n        })\n            .slice(0, exports.MAX_NAME_VALUE_PAIRS);\n        const headerValue = this._serializeKeyPairs(keyPairs);\n        if (headerValue.length > 0) {\n            setter.set(carrier, exports.BAGGAGE_HEADER, headerValue);\n        }\n    }\n    _serializeKeyPairs(keyPairs) {\n        return keyPairs.reduce((hValue, current) => {\n            const value = `${hValue}${hValue != '' ? ITEMS_SEPARATOR : ''}${current}`;\n            return value.length > exports.MAX_TOTAL_LENGTH ? hValue : value;\n        }, '');\n    }\n    _getKeyPairs(baggage) {\n        return Object.keys(baggage).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(baggage[key].value)}`);\n    }\n    extract(context, carrier, getter) {\n        const headerValue = getter.get(carrier, exports.BAGGAGE_HEADER);\n        if (!headerValue)\n            return context;\n        const baggage = {};\n        if (headerValue.length == 0) {\n            return context;\n        }\n        const pairs = headerValue.split(ITEMS_SEPARATOR);\n        pairs.forEach(entry => {\n            const keyPair = this._parsePairKeyValue(entry);\n            if (keyPair) {\n                baggage[keyPair.key] = { value: keyPair.value };\n            }\n        });\n        if (Object.entries(baggage).length === 0) {\n            return context;\n        }\n        return api_1.setBaggage(context, baggage);\n    }\n    _parsePairKeyValue(entry) {\n        const valueProps = entry.split(PROPERTIES_SEPARATOR);\n        if (valueProps.length <= 0)\n            return;\n        const keyPairPart = valueProps.shift();\n        if (!keyPairPart)\n            return;\n        const keyPair = keyPairPart.split(KEY_PAIR_SEPARATOR);\n        if (keyPair.length != 2)\n            return;\n        const key = decodeURIComponent(keyPair[0].trim());\n        let value = decodeURIComponent(keyPair[1].trim());\n        if (valueProps.length > 0) {\n            value =\n                value + PROPERTIES_SEPARATOR + valueProps.join(PROPERTIES_SEPARATOR);\n        }\n        return { key, value };\n    }\n    fields() {\n        return [exports.BAGGAGE_HEADER];\n    }\n}\nexports.HttpBaggage = HttpBaggage;\n//# sourceMappingURL=HttpBaggage.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConsoleLogger = void 0;\nconst types_1 = require(\"./types\");\nconst platform_1 = require(\"../platform\");\nclass ConsoleLogger {\n    constructor(level = platform_1.getEnv().OTEL_LOG_LEVEL) {\n        if (level >= types_1.LogLevel.DEBUG) {\n            this.debug = (...args) => {\n                console.debug(...args);\n            };\n        }\n        if (level >= types_1.LogLevel.INFO) {\n            this.info = (...args) => {\n                console.info(...args);\n            };\n        }\n        if (level >= types_1.LogLevel.WARN) {\n            this.warn = (...args) => {\n                console.warn(...args);\n            };\n        }\n        if (level >= types_1.LogLevel.ERROR) {\n            this.error = (...args) => {\n                console.error(...args);\n            };\n        }\n    }\n    debug(_message, ..._args) { }\n    error(_message, ..._args) { }\n    warn(_message, ..._args) { }\n    info(_message, ..._args) { }\n}\nexports.ConsoleLogger = ConsoleLogger;\n//# sourceMappingURL=ConsoleLogger.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NoopLogger = void 0;\n/** No-op implementation of Logger */\nclass NoopLogger {\n    // By default does nothing\n    debug(_message, ..._args) { }\n    // By default does nothing\n    error(_message, ..._args) { }\n    // By default does nothing\n    warn(_message, ..._args) { }\n    // By default does nothing\n    info(_message, ..._args) { }\n}\nexports.NoopLogger = NoopLogger;\n//# sourceMappingURL=NoopLogger.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isAttributeValue = exports.sanitizeAttributes = void 0;\nfunction sanitizeAttributes(attributes) {\n    const out = {};\n    if (attributes == null || typeof attributes !== 'object') {\n        return out;\n    }\n    for (const [k, v] of Object.entries(attributes)) {\n        if (isAttributeValue(v)) {\n            if (Array.isArray(v)) {\n                out[k] = v.slice();\n            }\n            else {\n                out[k] = v;\n            }\n        }\n    }\n    return out;\n}\nexports.sanitizeAttributes = sanitizeAttributes;\nfunction isAttributeValue(val) {\n    if (val == null) {\n        return true;\n    }\n    if (Array.isArray(val)) {\n        return isHomogeneousAttributeValueArray(val);\n    }\n    return isValidPrimitiveAttributeValue(val);\n}\nexports.isAttributeValue = isAttributeValue;\nfunction isHomogeneousAttributeValueArray(arr) {\n    let type;\n    for (const element of arr) {\n        // null/undefined elements are allowed\n        if (element == null)\n            continue;\n        if (!type) {\n            if (isValidPrimitiveAttributeValue(element)) {\n                type = typeof element;\n                continue;\n            }\n            // encountered an invalid primitive\n            return false;\n        }\n        if (typeof element === type) {\n            continue;\n        }\n        return false;\n    }\n    return true;\n}\nfunction isValidPrimitiveAttributeValue(val) {\n    switch (typeof val) {\n        case 'number':\n            return true;\n        case 'boolean':\n            return true;\n        case 'string':\n            return true;\n    }\n    return false;\n}\n//# sourceMappingURL=attributes.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.globalErrorHandler = exports.setGlobalErrorHandler = void 0;\nconst logging_error_handler_1 = require(\"./logging-error-handler\");\n/** The global error handler delegate */\nlet delegateHandler = logging_error_handler_1.loggingErrorHandler();\n/**\n * Set the global error handler\n * @param {ErrorHandler} handler\n */\nfunction setGlobalErrorHandler(handler) {\n    delegateHandler = handler;\n}\nexports.setGlobalErrorHandler = setGlobalErrorHandler;\n/**\n * Return the global error handler\n * @param {Exception} ex\n */\nexports.globalErrorHandler = (ex) => {\n    try {\n        delegateHandler(ex);\n    }\n    catch (_a) { } // eslint-disable-line no-empty\n};\n//# sourceMappingURL=global-error-handler.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.loggingErrorHandler = void 0;\nconst ConsoleLogger_1 = require(\"./ConsoleLogger\");\nconst types_1 = require(\"./types\");\n/**\n * Returns a function that logs an error using the provided logger, or a\n * console logger if one was not provided.\n * @param {Logger} logger\n */\nfunction loggingErrorHandler(logger) {\n    logger = logger !== null && logger !== void 0 ? logger : new ConsoleLogger_1.ConsoleLogger(types_1.LogLevel.ERROR);\n    return (ex) => {\n        logger.error(stringifyException(ex));\n    };\n}\nexports.loggingErrorHandler = loggingErrorHandler;\n/**\n * Converts an exception into a string representation\n * @param {Exception} ex\n */\nfunction stringifyException(ex) {\n    if (typeof ex === 'string') {\n        return ex;\n    }\n    else {\n        return JSON.stringify(flattenException(ex));\n    }\n}\n/**\n * Flattens an exception into key-value pairs by traversing the prototype chain\n * and coercing values to strings. Duplicate properties will not be overwritten;\n * the first insert wins.\n */\nfunction flattenException(ex) {\n    const result = {};\n    let current = ex;\n    while (current !== null) {\n        Object.getOwnPropertyNames(current).forEach(propertyName => {\n            if (result[propertyName])\n                return;\n            const value = current[propertyName];\n            if (value) {\n                result[propertyName] = String(value);\n            }\n        });\n        current = Object.getPrototypeOf(current);\n    }\n    return result;\n}\n//# sourceMappingURL=logging-error-handler.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isTimeInput = exports.isTimeInputHrTime = exports.hrTimeToMicroseconds = exports.hrTimeToMilliseconds = exports.hrTimeToNanoseconds = exports.hrTimeToTimeStamp = exports.hrTimeDuration = exports.timeInputToHrTime = exports.hrTime = void 0;\nconst platform_1 = require(\"../platform\");\nconst NANOSECOND_DIGITS = 9;\nconst SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);\n/**\n * Converts a number to HrTime\n * @param epochMillis\n */\nfunction numberToHrtime(epochMillis) {\n    const epochSeconds = epochMillis / 1000;\n    // Decimals only.\n    const seconds = Math.trunc(epochSeconds);\n    // Round sub-nanosecond accuracy to nanosecond.\n    const nanos = Number((epochSeconds - seconds).toFixed(NANOSECOND_DIGITS)) *\n        SECOND_TO_NANOSECONDS;\n    return [seconds, nanos];\n}\nfunction getTimeOrigin() {\n    let timeOrigin = platform_1.otperformance.timeOrigin;\n    if (typeof timeOrigin !== 'number') {\n        const perf = platform_1.otperformance;\n        timeOrigin = perf.timing && perf.timing.fetchStart;\n    }\n    return timeOrigin;\n}\n/**\n * Returns an hrtime calculated via performance component.\n * @param performanceNow\n */\nfunction hrTime(performanceNow) {\n    const timeOrigin = numberToHrtime(getTimeOrigin());\n    const now = numberToHrtime(typeof performanceNow === 'number' ? performanceNow : platform_1.otperformance.now());\n    let seconds = timeOrigin[0] + now[0];\n    let nanos = timeOrigin[1] + now[1];\n    // Nanoseconds\n    if (nanos > SECOND_TO_NANOSECONDS) {\n        nanos -= SECOND_TO_NANOSECONDS;\n        seconds += 1;\n    }\n    return [seconds, nanos];\n}\nexports.hrTime = hrTime;\n/**\n *\n * Converts a TimeInput to an HrTime, defaults to _hrtime().\n * @param time\n */\nfunction timeInputToHrTime(time) {\n    // process.hrtime\n    if (isTimeInputHrTime(time)) {\n        return time;\n    }\n    else if (typeof time === 'number') {\n        // Must be a performance.now() if it's smaller than process start time.\n        if (time < getTimeOrigin()) {\n            return hrTime(time);\n        }\n        else {\n            // epoch milliseconds or performance.timeOrigin\n            return numberToHrtime(time);\n        }\n    }\n    else if (time instanceof Date) {\n        return [time.getTime(), 0];\n    }\n    else {\n        throw TypeError('Invalid input type');\n    }\n}\nexports.timeInputToHrTime = timeInputToHrTime;\n/**\n * Returns a duration of two hrTime.\n * @param startTime\n * @param endTime\n */\nfunction hrTimeDuration(startTime, endTime) {\n    let seconds = endTime[0] - startTime[0];\n    let nanos = endTime[1] - startTime[1];\n    // overflow\n    if (nanos < 0) {\n        seconds -= 1;\n        // negate\n        nanos += SECOND_TO_NANOSECONDS;\n    }\n    return [seconds, nanos];\n}\nexports.hrTimeDuration = hrTimeDuration;\n/**\n * Convert hrTime to timestamp, for example \"2019-05-14T17:00:00.000123456Z\"\n * @param hrTime\n */\nfunction hrTimeToTimeStamp(hrTime) {\n    const precision = NANOSECOND_DIGITS;\n    const tmp = `${'0'.repeat(precision)}${hrTime[1]}Z`;\n    const nanoString = tmp.substr(tmp.length - precision - 1);\n    const date = new Date(hrTime[0] * 1000).toISOString();\n    return date.replace('000Z', nanoString);\n}\nexports.hrTimeToTimeStamp = hrTimeToTimeStamp;\n/**\n * Convert hrTime to nanoseconds.\n * @param hrTime\n */\nfunction hrTimeToNanoseconds(hrTime) {\n    return hrTime[0] * SECOND_TO_NANOSECONDS + hrTime[1];\n}\nexports.hrTimeToNanoseconds = hrTimeToNanoseconds;\n/**\n * Convert hrTime to milliseconds.\n * @param hrTime\n */\nfunction hrTimeToMilliseconds(hrTime) {\n    return Math.round(hrTime[0] * 1e3 + hrTime[1] / 1e6);\n}\nexports.hrTimeToMilliseconds = hrTimeToMilliseconds;\n/**\n * Convert hrTime to microseconds.\n * @param hrTime\n */\nfunction hrTimeToMicroseconds(hrTime) {\n    return Math.round(hrTime[0] * 1e6 + hrTime[1] / 1e3);\n}\nexports.hrTimeToMicroseconds = hrTimeToMicroseconds;\n/**\n * check if time is HrTime\n * @param value\n */\nfunction isTimeInputHrTime(value) {\n    return (Array.isArray(value) &&\n        value.length === 2 &&\n        typeof value[0] === 'number' &&\n        typeof value[1] === 'number');\n}\nexports.isTimeInputHrTime = isTimeInputHrTime;\n/**\n * check if input value is a correct types.TimeInput\n * @param value\n */\nfunction isTimeInput(value) {\n    return (isTimeInputHrTime(value) ||\n        typeof value === 'number' ||\n        value instanceof Date);\n}\nexports.isTimeInput = isTimeInput;\n//# sourceMappingURL=time.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LogLevel = void 0;\nvar LogLevel;\n(function (LogLevel) {\n    LogLevel[LogLevel[\"ERROR\"] = 0] = \"ERROR\";\n    LogLevel[LogLevel[\"WARN\"] = 1] = \"WARN\";\n    LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\n    LogLevel[LogLevel[\"DEBUG\"] = 3] = \"DEBUG\";\n})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));\n//# sourceMappingURL=types.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HttpTraceContext = exports.parseTraceParent = exports.TRACE_STATE_HEADER = exports.TRACE_PARENT_HEADER = void 0;\nconst api_1 = require(\"@opentelemetry/api\");\nconst TraceState_1 = require(\"../../trace/TraceState\");\nexports.TRACE_PARENT_HEADER = 'traceparent';\nexports.TRACE_STATE_HEADER = 'tracestate';\nconst VERSION = '00';\nconst VERSION_PART_COUNT = 4; // Version 00 only allows the specific 4 fields.\nconst VERSION_REGEX = /^(?!ff)[\\da-f]{2}$/;\nconst TRACE_ID_REGEX = /^(?![0]{32})[\\da-f]{32}$/;\nconst PARENT_ID_REGEX = /^(?![0]{16})[\\da-f]{16}$/;\nconst FLAGS_REGEX = /^[\\da-f]{2}$/;\n/**\n * Parses information from the [traceparent] span tag and converts it into {@link SpanContext}\n * @param traceParent - A meta property that comes from server.\n *     It should be dynamically generated server side to have the server's request trace Id,\n *     a parent span Id that was set on the server's request span,\n *     and the trace flags to indicate the server's sampling decision\n *     (01 = sampled, 00 = not sampled).\n *     for example: '{version}-{traceId}-{spanId}-{sampleDecision}'\n *     For more information see {@link https://www.w3.org/TR/trace-context/}\n */\nfunction parseTraceParent(traceParent) {\n    const trimmed = traceParent.trim();\n    const traceParentParts = trimmed.split('-');\n    // Current version must be structured correctly.\n    // For future versions, we can grab just the parts we do support.\n    if (traceParentParts[0] === VERSION &&\n        traceParentParts.length !== VERSION_PART_COUNT) {\n        return null;\n    }\n    const [version, traceId, parentId, flags] = traceParentParts;\n    const isValidParent = VERSION_REGEX.test(version) &&\n        TRACE_ID_REGEX.test(traceId) &&\n        PARENT_ID_REGEX.test(parentId) &&\n        FLAGS_REGEX.test(flags);\n    if (!isValidParent) {\n        return null;\n    }\n    return {\n        traceId: traceId,\n        spanId: parentId,\n        traceFlags: parseInt(flags, 16),\n    };\n}\nexports.parseTraceParent = parseTraceParent;\n/**\n * Propagates {@link SpanContext} through Trace Context format propagation.\n *\n * Based on the Trace Context specification:\n * https://www.w3.org/TR/trace-context/\n */\nclass HttpTraceContext {\n    inject(context, carrier, setter) {\n        const spanContext = api_1.getParentSpanContext(context);\n        if (!spanContext)\n            return;\n        const traceParent = `${VERSION}-${spanContext.traceId}-${spanContext.spanId}-0${Number(spanContext.traceFlags || api_1.TraceFlags.NONE).toString(16)}`;\n        setter.set(carrier, exports.TRACE_PARENT_HEADER, traceParent);\n        if (spanContext.traceState) {\n            setter.set(carrier, exports.TRACE_STATE_HEADER, spanContext.traceState.serialize());\n        }\n    }\n    extract(context, carrier, getter) {\n        const traceParentHeader = getter.get(carrier, exports.TRACE_PARENT_HEADER);\n        if (!traceParentHeader)\n            return context;\n        const traceParent = Array.isArray(traceParentHeader)\n            ? traceParentHeader[0]\n            : traceParentHeader;\n        if (typeof traceParent !== 'string')\n            return context;\n        const spanContext = parseTraceParent(traceParent);\n        if (!spanContext)\n            return context;\n        spanContext.isRemote = true;\n        const traceStateHeader = getter.get(carrier, exports.TRACE_STATE_HEADER);\n        if (traceStateHeader) {\n            // If more than one `tracestate` header is found, we merge them into a\n            // single header.\n            const state = Array.isArray(traceStateHeader)\n                ? traceStateHeader.join(',')\n                : traceStateHeader;\n            spanContext.traceState = new TraceState_1.TraceState(typeof state === 'string' ? state : undefined);\n        }\n        return api_1.setExtractedSpanContext(context, spanContext);\n    }\n    fields() {\n        return [exports.TRACE_PARENT_HEADER, exports.TRACE_STATE_HEADER];\n    }\n}\nexports.HttpTraceContext = HttpTraceContext;\n//# sourceMappingURL=HttpTraceContext.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CompositePropagator = void 0;\nconst NoopLogger_1 = require(\"../../common/NoopLogger\");\n/** Combines multiple propagators into a single propagator. */\nclass CompositePropagator {\n    /**\n     * Construct a composite propagator from a list of propagators.\n     *\n     * @param [config] Configuration object for composite propagator\n     */\n    constructor(config = {}) {\n        var _a, _b;\n        this._propagators = (_a = config.propagators) !== null && _a !== void 0 ? _a : [];\n        this._logger = (_b = config.logger) !== null && _b !== void 0 ? _b : new NoopLogger_1.NoopLogger();\n        this._fields = Array.from(new Set(this._propagators\n            // older propagators may not have fields function, null check to be sure\n            .map(p => (typeof p.fields === 'function' ? p.fields() : []))\n            .reduce((x, y) => x.concat(y))));\n    }\n    /**\n     * Run each of the configured propagators with the given context and carrier.\n     * Propagators are run in the order they are configured, so if multiple\n     * propagators write the same carrier key, the propagator later in the list\n     * will \"win\".\n     *\n     * @param context Context to inject\n     * @param carrier Carrier into which context will be injected\n     */\n    inject(context, carrier, setter) {\n        for (const propagator of this._propagators) {\n            try {\n                propagator.inject(context, carrier, setter);\n            }\n            catch (err) {\n                this._logger.warn(`Failed to inject with ${propagator.constructor.name}. Err: ${err.message}`);\n            }\n        }\n    }\n    /**\n     * Run each of the configured propagators with the given context and carrier.\n     * Propagators are run in the order they are configured, so if multiple\n     * propagators write the same context key, the propagator later in the list\n     * will \"win\".\n     *\n     * @param context Context to add values to\n     * @param carrier Carrier from which to extract context\n     */\n    extract(context, carrier, getter) {\n        return this._propagators.reduce((ctx, propagator) => {\n            try {\n                return propagator.extract(ctx, carrier, getter);\n            }\n            catch (err) {\n                this._logger.warn(`Failed to inject with ${propagator.constructor.name}. Err: ${err.message}`);\n            }\n            return ctx;\n        }, context);\n    }\n    fields() {\n        // return a new array so our fields cannot be modified\n        return this._fields.slice();\n    }\n}\nexports.CompositePropagator = CompositePropagator;\n//# sourceMappingURL=composite.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=types.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./common/attributes\"), exports);\n__exportStar(require(\"./common/ConsoleLogger\"), exports);\n__exportStar(require(\"./common/global-error-handler\"), exports);\n__exportStar(require(\"./common/logging-error-handler\"), exports);\n__exportStar(require(\"./common/NoopLogger\"), exports);\n__exportStar(require(\"./common/time\"), exports);\n__exportStar(require(\"./common/types\"), exports);\n__exportStar(require(\"./ExportResult\"), exports);\n__exportStar(require(\"./version\"), exports);\n__exportStar(require(\"./context/propagation/composite\"), exports);\n__exportStar(require(\"./context/propagation/HttpTraceContext\"), exports);\n__exportStar(require(\"./context/propagation/types\"), exports);\n__exportStar(require(\"./baggage/propagation/HttpBaggage\"), exports);\n__exportStar(require(\"./platform\"), exports);\n__exportStar(require(\"./trace/NoRecordingSpan\"), exports);\n__exportStar(require(\"./trace/Plugin\"), exports);\n__exportStar(require(\"./trace/sampler/AlwaysOffSampler\"), exports);\n__exportStar(require(\"./trace/sampler/AlwaysOnSampler\"), exports);\n__exportStar(require(\"./trace/sampler/ParentBasedSampler\"), exports);\n__exportStar(require(\"./trace/sampler/TraceIdRatioBasedSampler\"), exports);\n__exportStar(require(\"./trace/TraceState\"), exports);\n__exportStar(require(\"./trace/IdGenerator\"), exports);\n__exportStar(require(\"./utils/deep-merge\"), exports);\n__exportStar(require(\"./utils/url\"), exports);\n__exportStar(require(\"./utils/wrap\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateValue = exports.validateKey = void 0;\nconst VALID_KEY_CHAR_RANGE = '[_0-9a-z-*/]';\nconst VALID_KEY = `[a-z]${VALID_KEY_CHAR_RANGE}{0,255}`;\nconst VALID_VENDOR_KEY = `[a-z0-9]${VALID_KEY_CHAR_RANGE}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE}{0,13}`;\nconst VALID_KEY_REGEX = new RegExp(`^(?:${VALID_KEY}|${VALID_VENDOR_KEY})$`);\nconst VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;\nconst INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;\n/**\n * Key is opaque string up to 256 characters printable. It MUST begin with a\n * lowercase letter, and can only contain lowercase letters a-z, digits 0-9,\n * underscores _, dashes -, asterisks *, and forward slashes /.\n * For multi-tenant vendor scenarios, an at sign (@) can be used to prefix the\n * vendor name. Vendors SHOULD set the tenant ID at the beginning of the key.\n * see https://www.w3.org/TR/trace-context/#key\n */\nfunction validateKey(key) {\n    return VALID_KEY_REGEX.test(key);\n}\nexports.validateKey = validateKey;\n/**\n * Value is opaque string up to 256 characters printable ASCII RFC0020\n * characters (i.e., the range 0x20 to 0x7E) except comma , and =.\n */\nfunction validateValue(value) {\n    return (VALID_VALUE_BASE_REGEX.test(value) &&\n        !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value));\n}\nexports.validateValue = validateValue;\n//# sourceMappingURL=validators.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BaseAbstractPlugin = void 0;\n/** This class represent the base to patch plugin. */\nclass BaseAbstractPlugin {\n    constructor(_tracerName, _tracerVersion) {\n        this._tracerName = _tracerName;\n        this._tracerVersion = _tracerVersion;\n    }\n    disable() {\n        this.unpatch();\n    }\n}\nexports.BaseAbstractPlugin = BaseAbstractPlugin;\n//# sourceMappingURL=BaseAbstractPlugin.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n__exportStar(require(\"./node\"), exports);\n//# sourceMappingURL=index.js.map","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = \"../../node_modules/@opentelemetry/core/build/src/platform/node sync recursive\";","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BasePlugin = void 0;\nconst semver = require(\"semver\");\nconst path = require(\"path\");\nconst BaseAbstractPlugin_1 = require(\"../BaseAbstractPlugin\");\n/** This class represent the base to patch plugin. */\nclass BasePlugin extends BaseAbstractPlugin_1.BaseAbstractPlugin {\n    enable(moduleExports, tracerProvider, logger, config) {\n        this._moduleExports = moduleExports;\n        this._tracer = tracerProvider.getTracer(this._tracerName, this._tracerVersion);\n        this._logger = logger;\n        this._internalFilesExports = this._loadInternalFilesExports();\n        if (config)\n            this._config = config;\n        return this.patch();\n    }\n    disable() {\n        this.unpatch();\n    }\n    /**\n     * @TODO: To avoid circular dependencies, internal file loading functionality currently\n     * lives in BasePlugin. It is not meant to work in the browser and so this logic\n     * should eventually be moved somewhere else where it makes more sense.\n     * https://github.com/open-telemetry/opentelemetry-js/issues/285\n     */\n    _loadInternalFilesExports() {\n        if (!this._internalFilesList)\n            return {};\n        if (!this.version || !this.moduleName || !this._basedir) {\n            // log here because internalFilesList was provided, so internal file loading\n            // was expected to be working\n            this._logger.debug('loadInternalFiles failed because one of the required fields was missing: moduleName=%s, version=%s, basedir=%s', this.moduleName, this.version, this._basedir);\n            return {};\n        }\n        const extraModules = {};\n        this._logger.debug('loadInternalFiles %o', this._internalFilesList);\n        Object.keys(this._internalFilesList).forEach(versionRange => {\n            this._loadInternalModule(versionRange, extraModules);\n        });\n        if (Object.keys(extraModules).length === 0) {\n            this._logger.debug('No internal files could be loaded for %s@%s', this.moduleName, this.version);\n        }\n        return extraModules;\n    }\n    _loadInternalModule(versionRange, outExtraModules) {\n        if (semver.satisfies(this.version, versionRange)) {\n            if (Object.keys(outExtraModules).length > 0) {\n                this._logger.warn('Plugin for %s@%s, has overlap version range (%s) for internal files: %o', this.moduleName, this.version, versionRange, this._internalFilesList);\n            }\n            this._requireInternalFiles(this._internalFilesList[versionRange], this._basedir, outExtraModules);\n        }\n    }\n    _requireInternalFiles(extraModulesList, basedir, outExtraModules) {\n        if (!extraModulesList)\n            return;\n        Object.keys(extraModulesList).forEach(moduleName => {\n            try {\n                this._logger.debug('loading File %s', extraModulesList[moduleName]);\n                outExtraModules[moduleName] = require(path.join(basedir, extraModulesList[moduleName]));\n            }\n            catch (e) {\n                this._logger.error('Could not load internal file %s of module %s. Error: %s', path.join(basedir, extraModulesList[moduleName]), this.moduleName, e.message);\n            }\n        });\n    }\n}\nexports.BasePlugin = BasePlugin;\n//# sourceMappingURL=BasePlugin.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RandomIdGenerator = void 0;\nconst SPAN_ID_BYTES = 8;\nconst TRACE_ID_BYTES = 16;\nclass RandomIdGenerator {\n    constructor() {\n        /**\n         * Returns a random 16-byte trace ID formatted/encoded as a 32 lowercase hex\n         * characters corresponding to 128 bits.\n         */\n        this.generateTraceId = getIdGenerator(TRACE_ID_BYTES);\n        /**\n         * Returns a random 8-byte span ID formatted/encoded as a 16 lowercase hex\n         * characters corresponding to 64 bits.\n         */\n        this.generateSpanId = getIdGenerator(SPAN_ID_BYTES);\n    }\n}\nexports.RandomIdGenerator = RandomIdGenerator;\nconst SHARED_BUFFER = Buffer.allocUnsafe(TRACE_ID_BYTES);\nfunction getIdGenerator(bytes) {\n    return function generateId() {\n        for (let i = 0; i < bytes / 4; i++) {\n            // unsigned right shift drops decimal part of the number\n            // it is required because if a number between 2**32 and 2**32 - 1 is generated, an out of range error is thrown by writeUInt32BE\n            SHARED_BUFFER.writeUInt32BE((Math.random() * 2 ** 32) >>> 0, i * 4);\n        }\n        // If buffer is all 0, set the last byte to 1 to guarantee a valid w3c id is generated\n        for (let i = 0; i < bytes; i++) {\n            if (SHARED_BUFFER[i] > 0) {\n                break;\n            }\n            else if (i === bytes - 1) {\n                SHARED_BUFFER[bytes - 1] = 1;\n            }\n        }\n        return SHARED_BUFFER.toString('hex', 0, bytes);\n    };\n}\n//# sourceMappingURL=RandomIdGenerator.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getEnv = void 0;\nconst environment_1 = require(\"../../utils/environment\");\n/**\n * Gets the environment variables\n */\nfunction getEnv() {\n    const processEnv = environment_1.parseEnvironment(process.env);\n    return Object.assign({}, environment_1.DEFAULT_ENVIRONMENT, processEnv);\n}\nexports.getEnv = getEnv;\n//# sourceMappingURL=environment.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hexToBase64 = void 0;\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction hexToBase64(hexStr) {\n    const hexStrLen = hexStr.length;\n    let hexAsciiCharsStr = '';\n    for (let i = 0; i < hexStrLen; i += 2) {\n        const hexPair = hexStr.substring(i, i + 2);\n        const hexVal = parseInt(hexPair, 16);\n        hexAsciiCharsStr += String.fromCharCode(hexVal);\n    }\n    return Buffer.from(hexAsciiCharsStr, 'ascii').toString('base64');\n}\nexports.hexToBase64 = hexToBase64;\n//# sourceMappingURL=hex-to-base64.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./BasePlugin\"), exports);\n__exportStar(require(\"./environment\"), exports);\n__exportStar(require(\"./hex-to-base64\"), exports);\n__exportStar(require(\"./RandomIdGenerator\"), exports);\n__exportStar(require(\"./performance\"), exports);\n__exportStar(require(\"./sdk-info\"), exports);\n__exportStar(require(\"./timer-util\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.otperformance = void 0;\nconst perf_hooks_1 = require(\"perf_hooks\");\nexports.otperformance = perf_hooks_1.performance;\n//# sourceMappingURL=performance.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SDK_INFO = void 0;\nconst version_1 = require(\"../../version\");\n/** Constants describing the SDK in use */\nexports.SDK_INFO = {\n    NAME: 'opentelemetry',\n    RUNTIME: 'node',\n    LANGUAGE: 'nodejs',\n    VERSION: version_1.VERSION,\n};\n//# sourceMappingURL=sdk-info.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.unrefTimer = void 0;\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction unrefTimer(timer) {\n    timer.unref();\n}\nexports.unrefTimer = unrefTimer;\n//# sourceMappingURL=timer-util.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=IdGenerator.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NoRecordingSpan = void 0;\nconst api_1 = require(\"@opentelemetry/api\");\n/**\n * The NoRecordingSpan extends the {@link NoopSpan}, making all operations no-op\n * except context propagation.\n */\nclass NoRecordingSpan extends api_1.NoopSpan {\n    constructor(spanContext) {\n        super(spanContext);\n        this._context = spanContext || api_1.INVALID_SPAN_CONTEXT;\n    }\n    // Returns a SpanContext.\n    context() {\n        return this._context;\n    }\n}\nexports.NoRecordingSpan = NoRecordingSpan;\n//# sourceMappingURL=NoRecordingSpan.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=Plugin.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TraceState = void 0;\nconst validators_1 = require(\"../internal/validators\");\nconst MAX_TRACE_STATE_ITEMS = 32;\nconst MAX_TRACE_STATE_LEN = 512;\nconst LIST_MEMBERS_SEPARATOR = ',';\nconst LIST_MEMBER_KEY_VALUE_SPLITTER = '=';\n/**\n * TraceState must be a class and not a simple object type because of the spec\n * requirement (https://www.w3.org/TR/trace-context/#tracestate-field).\n *\n * Here is the list of allowed mutations:\n * - New key-value pair should be added into the beginning of the list\n * - The value of any key can be updated. Modified keys MUST be moved to the\n * beginning of the list.\n */\nclass TraceState {\n    constructor(rawTraceState) {\n        this._internalState = new Map();\n        if (rawTraceState)\n            this._parse(rawTraceState);\n    }\n    set(key, value) {\n        // TODO: Benchmark the different approaches(map vs list) and\n        // use the faster one.\n        const traceState = this._clone();\n        if (traceState._internalState.has(key)) {\n            traceState._internalState.delete(key);\n        }\n        traceState._internalState.set(key, value);\n        return traceState;\n    }\n    unset(key) {\n        const traceState = this._clone();\n        traceState._internalState.delete(key);\n        return traceState;\n    }\n    get(key) {\n        return this._internalState.get(key);\n    }\n    serialize() {\n        return this._keys()\n            .reduce((agg, key) => {\n            agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + this.get(key));\n            return agg;\n        }, [])\n            .join(LIST_MEMBERS_SEPARATOR);\n    }\n    _parse(rawTraceState) {\n        if (rawTraceState.length > MAX_TRACE_STATE_LEN)\n            return;\n        this._internalState = rawTraceState\n            .split(LIST_MEMBERS_SEPARATOR)\n            .reverse() // Store in reverse so new keys (.set(...)) will be placed at the beginning\n            .reduce((agg, part) => {\n            const listMember = part.trim(); // Optional Whitespace (OWS) handling\n            const i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);\n            if (i !== -1) {\n                const key = listMember.slice(0, i);\n                const value = listMember.slice(i + 1, part.length);\n                if (validators_1.validateKey(key) && validators_1.validateValue(value)) {\n                    agg.set(key, value);\n                }\n                else {\n                    // TODO: Consider to add warning log\n                }\n            }\n            return agg;\n        }, new Map());\n        // Because of the reverse() requirement, trunc must be done after map is created\n        if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {\n            this._internalState = new Map(Array.from(this._internalState.entries())\n                .reverse() // Use reverse same as original tracestate parse chain\n                .slice(0, MAX_TRACE_STATE_ITEMS));\n        }\n    }\n    _keys() {\n        return Array.from(this._internalState.keys()).reverse();\n    }\n    _clone() {\n        const traceState = new TraceState();\n        traceState._internalState = new Map(this._internalState);\n        return traceState;\n    }\n}\nexports.TraceState = TraceState;\n//# sourceMappingURL=TraceState.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AlwaysOffSampler = void 0;\nconst api_1 = require(\"@opentelemetry/api\");\n/** Sampler that samples no traces. */\nclass AlwaysOffSampler {\n    shouldSample() {\n        return {\n            decision: api_1.SamplingDecision.NOT_RECORD,\n        };\n    }\n    toString() {\n        return 'AlwaysOffSampler';\n    }\n}\nexports.AlwaysOffSampler = AlwaysOffSampler;\n//# sourceMappingURL=AlwaysOffSampler.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AlwaysOnSampler = void 0;\nconst api_1 = require(\"@opentelemetry/api\");\n/** Sampler that samples all traces. */\nclass AlwaysOnSampler {\n    shouldSample() {\n        return {\n            decision: api_1.SamplingDecision.RECORD_AND_SAMPLED,\n        };\n    }\n    toString() {\n        return 'AlwaysOnSampler';\n    }\n}\nexports.AlwaysOnSampler = AlwaysOnSampler;\n//# sourceMappingURL=AlwaysOnSampler.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ParentBasedSampler = void 0;\nconst api_1 = require(\"@opentelemetry/api\");\nconst global_error_handler_1 = require(\"../../common/global-error-handler\");\nconst AlwaysOffSampler_1 = require(\"./AlwaysOffSampler\");\nconst AlwaysOnSampler_1 = require(\"./AlwaysOnSampler\");\n/**\n * A composite sampler that either respects the parent span's sampling decision\n * or delegates to `delegateSampler` for root spans.\n */\nclass ParentBasedSampler {\n    constructor(config) {\n        var _a, _b, _c, _d;\n        this._root = config.root;\n        if (!this._root) {\n            global_error_handler_1.globalErrorHandler(new Error('ParentBasedSampler must have a root sampler configured'));\n            this._root = new AlwaysOnSampler_1.AlwaysOnSampler();\n        }\n        this._remoteParentSampled = (_a = config.remoteParentSampled) !== null && _a !== void 0 ? _a : new AlwaysOnSampler_1.AlwaysOnSampler();\n        this._remoteParentNotSampled = (_b = config.remoteParentNotSampled) !== null && _b !== void 0 ? _b : new AlwaysOffSampler_1.AlwaysOffSampler();\n        this._localParentSampled = (_c = config.localParentSampled) !== null && _c !== void 0 ? _c : new AlwaysOnSampler_1.AlwaysOnSampler();\n        this._localParentNotSampled = (_d = config.localParentNotSampled) !== null && _d !== void 0 ? _d : new AlwaysOffSampler_1.AlwaysOffSampler();\n    }\n    shouldSample(context, traceId, spanName, spanKind, attributes, links) {\n        const parentContext = api_1.getParentSpanContext(context);\n        if (!parentContext) {\n            return this._root.shouldSample(context, traceId, spanName, spanKind, attributes, links);\n        }\n        if (parentContext.isRemote) {\n            if (parentContext.traceFlags & api_1.TraceFlags.SAMPLED) {\n                return this._remoteParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);\n            }\n            return this._remoteParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);\n        }\n        if (parentContext.traceFlags & api_1.TraceFlags.SAMPLED) {\n            return this._localParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);\n        }\n        return this._localParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);\n    }\n    toString() {\n        return `ParentBased{root=${this._root.toString()}, remoteParentSampled=${this._remoteParentSampled.toString()}, remoteParentNotSampled=${this._remoteParentNotSampled.toString()}, localParentSampled=${this._localParentSampled.toString()}, localParentNotSampled=${this._localParentNotSampled.toString()}}`;\n    }\n}\nexports.ParentBasedSampler = ParentBasedSampler;\n//# sourceMappingURL=ParentBasedSampler.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TraceIdRatioBasedSampler = void 0;\nconst api_1 = require(\"@opentelemetry/api\");\n/** Sampler that samples a given fraction of traces based of trace id deterministically. */\nclass TraceIdRatioBasedSampler {\n    constructor(_ratio = 0) {\n        this._ratio = _ratio;\n        this._ratio = this._normalize(_ratio);\n    }\n    shouldSample(context, traceId) {\n        let accumulation = 0;\n        for (let idx = 0; idx < traceId.length; idx++) {\n            accumulation += traceId.charCodeAt(idx);\n        }\n        const cmp = (accumulation % 100) / 100;\n        return {\n            decision: cmp < this._ratio\n                ? api_1.SamplingDecision.RECORD_AND_SAMPLED\n                : api_1.SamplingDecision.NOT_RECORD,\n        };\n    }\n    toString() {\n        return `TraceIdRatioBased{${this._ratio}}`;\n    }\n    _normalize(ratio) {\n        if (typeof ratio !== 'number' || isNaN(ratio))\n            return 0;\n        return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;\n    }\n}\nexports.TraceIdRatioBasedSampler = TraceIdRatioBasedSampler;\n//# sourceMappingURL=TraceIdRatioBasedSampler.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.deepMerge = void 0;\n/**\n * Deeply merges a source object onto a target object.\n * If a given property is an array in both source and target, the\n * source property replaces the target property entirely.\n * @param target\n * @param source\n * @param maxDepth avoids an infinite CPU loop. Defaults to 10.\n * @returns a deeply merged object\n */\nfunction deepMerge(target, source, maxDepth = 10) {\n    const merged = target;\n    if (maxDepth === 0) {\n        throw new Error('Max depth exceeded.');\n    }\n    for (const [prop, value] of Object.entries(source)) {\n        if (bothPropsAreObjects(target, source, prop)) {\n            if (bothPropsAreArrays(target, source, prop)) {\n                merged[prop] = value;\n            }\n            else {\n                merged[prop] = deepMerge(target[prop], value, maxDepth - 1);\n            }\n        }\n        else {\n            merged[prop] = value;\n        }\n    }\n    return merged;\n}\nexports.deepMerge = deepMerge;\nfunction bothPropsAreObjects(target, source, prop) {\n    return propIsObject(target, prop) && propIsObject(source, prop);\n}\nfunction propIsObject(object, prop) {\n    return typeof object[prop] === 'object' && object[prop] !== null;\n}\nfunction bothPropsAreArrays(target, source, prop) {\n    return Array.isArray(source[prop]) && Array.isArray(target[prop]);\n}\n//# sourceMappingURL=deep-merge.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseEnvironment = exports.DEFAULT_ENVIRONMENT = void 0;\nconst types_1 = require(\"../common/types\");\nconst ENVIRONMENT_NUMBERS = [\n    'OTEL_SAMPLING_PROBABILITY',\n    'OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT',\n    'OTEL_SPAN_EVENT_COUNT_LIMIT',\n    'OTEL_SPAN_LINK_COUNT_LIMIT',\n];\n/**\n * Default environment variables\n */\nexports.DEFAULT_ENVIRONMENT = {\n    OTEL_NO_PATCH_MODULES: '',\n    OTEL_LOG_LEVEL: types_1.LogLevel.INFO,\n    OTEL_SAMPLING_PROBABILITY: 1,\n    OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: 1000,\n    OTEL_SPAN_EVENT_COUNT_LIMIT: 1000,\n    OTEL_SPAN_LINK_COUNT_LIMIT: 1000,\n};\n/**\n * Parses a variable as number with number validation\n * @param name\n * @param environment\n * @param values\n * @param min\n * @param max\n */\nfunction parseNumber(name, environment, values, min = -Infinity, max = Infinity) {\n    if (typeof values[name] !== 'undefined') {\n        const value = Number(values[name]);\n        if (!isNaN(value)) {\n            if (value < min) {\n                environment[name] = min;\n            }\n            else if (value > max) {\n                environment[name] = max;\n            }\n            else {\n                environment[name] = value;\n            }\n        }\n    }\n}\n/**\n * Environmentally sets log level if valid log level string is provided\n * @param key\n * @param environment\n * @param values\n */\nfunction setLogLevelFromEnv(key, environment, values) {\n    const value = values[key];\n    switch (typeof value === 'string' ? value.toUpperCase() : value) {\n        case 'DEBUG':\n            environment[key] = types_1.LogLevel.DEBUG;\n            break;\n        case 'INFO':\n            environment[key] = types_1.LogLevel.INFO;\n            break;\n        case 'WARN':\n            environment[key] = types_1.LogLevel.WARN;\n            break;\n        case 'ERROR':\n            environment[key] = types_1.LogLevel.ERROR;\n            break;\n        default:\n            // do nothing\n            break;\n    }\n}\n/**\n * Parses environment values\n * @param values\n */\nfunction parseEnvironment(values) {\n    const environment = {};\n    for (const env in exports.DEFAULT_ENVIRONMENT) {\n        const key = env;\n        switch (key) {\n            case 'OTEL_SAMPLING_PROBABILITY':\n                parseNumber(key, environment, values, 0, 1);\n                break;\n            case 'OTEL_LOG_LEVEL':\n                setLogLevelFromEnv(key, environment, values);\n                break;\n            default:\n                if (ENVIRONMENT_NUMBERS.indexOf(key) >= 0) {\n                    parseNumber(key, environment, values);\n                }\n                else {\n                    if (typeof values[key] !== 'undefined') {\n                        environment[key] = values[key];\n                    }\n                }\n        }\n    }\n    return environment;\n}\nexports.parseEnvironment = parseEnvironment;\n//# sourceMappingURL=environment.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isUrlIgnored = exports.urlMatches = void 0;\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction urlMatches(url, urlToMatch) {\n    if (typeof urlToMatch === 'string') {\n        return url === urlToMatch;\n    }\n    else {\n        return !!url.match(urlToMatch);\n    }\n}\nexports.urlMatches = urlMatches;\n/**\n * Check if {@param url} should be ignored when comparing against {@param ignoredUrls}\n * @param url\n * @param ignoredUrls\n */\nfunction isUrlIgnored(url, ignoredUrls) {\n    if (!ignoredUrls) {\n        return false;\n    }\n    for (const ignoreUrl of ignoredUrls) {\n        if (urlMatches(url, ignoreUrl)) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.isUrlIgnored = isUrlIgnored;\n//# sourceMappingURL=url.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isWrapped = void 0;\n/**\n * Checks if certain function has been already wrapped\n * @param func\n */\nfunction isWrapped(func) {\n    return (typeof func === 'function' &&\n        typeof func.__original === 'function' &&\n        typeof func.__unwrap === 'function' &&\n        func.__wrapped === true);\n}\nexports.isWrapped = isWrapped;\n//# sourceMappingURL=wrap.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VERSION = void 0;\n// this is autogenerated file, see scripts/version-update.js\nexports.VERSION = '0.14.0';\n//# sourceMappingURL=version.js.map","const ANY = Symbol('SemVer ANY')\n// hoisted class for cyclic dependency\nclass Comparator {\n  static get ANY () {\n    return ANY\n  }\n  constructor (comp, options) {\n    options = parseOptions(options)\n\n    if (comp instanceof Comparator) {\n      if (comp.loose === !!options.loose) {\n        return comp\n      } else {\n        comp = comp.value\n      }\n    }\n\n    debug('comparator', comp, options)\n    this.options = options\n    this.loose = !!options.loose\n    this.parse(comp)\n\n    if (this.semver === ANY) {\n      this.value = ''\n    } else {\n      this.value = this.operator + this.semver.version\n    }\n\n    debug('comp', this)\n  }\n\n  parse (comp) {\n    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]\n    const m = comp.match(r)\n\n    if (!m) {\n      throw new TypeError(`Invalid comparator: ${comp}`)\n    }\n\n    this.operator = m[1] !== undefined ? m[1] : ''\n    if (this.operator === '=') {\n      this.operator = ''\n    }\n\n    // if it literally is just '>' or '' then allow anything.\n    if (!m[2]) {\n      this.semver = ANY\n    } else {\n      this.semver = new SemVer(m[2], this.options.loose)\n    }\n  }\n\n  toString () {\n    return this.value\n  }\n\n  test (version) {\n    debug('Comparator.test', version, this.options.loose)\n\n    if (this.semver === ANY || version === ANY) {\n      return true\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options)\n      } catch (er) {\n        return false\n      }\n    }\n\n    return cmp(version, this.operator, this.semver, this.options)\n  }\n\n  intersects (comp, options) {\n    if (!(comp instanceof Comparator)) {\n      throw new TypeError('a Comparator is required')\n    }\n\n    if (!options || typeof options !== 'object') {\n      options = {\n        loose: !!options,\n        includePrerelease: false\n      }\n    }\n\n    if (this.operator === '') {\n      if (this.value === '') {\n        return true\n      }\n      return new Range(comp.value, options).test(this.value)\n    } else if (comp.operator === '') {\n      if (comp.value === '') {\n        return true\n      }\n      return new Range(this.value, options).test(comp.semver)\n    }\n\n    const sameDirectionIncreasing =\n      (this.operator === '>=' || this.operator === '>') &&\n      (comp.operator === '>=' || comp.operator === '>')\n    const sameDirectionDecreasing =\n      (this.operator === '<=' || this.operator === '<') &&\n      (comp.operator === '<=' || comp.operator === '<')\n    const sameSemVer = this.semver.version === comp.semver.version\n    const differentDirectionsInclusive =\n      (this.operator === '>=' || this.operator === '<=') &&\n      (comp.operator === '>=' || comp.operator === '<=')\n    const oppositeDirectionsLessThan =\n      cmp(this.semver, '<', comp.semver, options) &&\n      (this.operator === '>=' || this.operator === '>') &&\n        (comp.operator === '<=' || comp.operator === '<')\n    const oppositeDirectionsGreaterThan =\n      cmp(this.semver, '>', comp.semver, options) &&\n      (this.operator === '<=' || this.operator === '<') &&\n        (comp.operator === '>=' || comp.operator === '>')\n\n    return (\n      sameDirectionIncreasing ||\n      sameDirectionDecreasing ||\n      (sameSemVer && differentDirectionsInclusive) ||\n      oppositeDirectionsLessThan ||\n      oppositeDirectionsGreaterThan\n    )\n  }\n}\n\nmodule.exports = Comparator\n\nconst parseOptions = require('../internal/parse-options')\nconst {re, t} = require('../internal/re')\nconst cmp = require('../functions/cmp')\nconst debug = require('../internal/debug')\nconst SemVer = require('./semver')\nconst Range = require('./range')\n","// hoisted class for cyclic dependency\nclass Range {\n  constructor (range, options) {\n    options = parseOptions(options)\n\n    if (range instanceof Range) {\n      if (\n        range.loose === !!options.loose &&\n        range.includePrerelease === !!options.includePrerelease\n      ) {\n        return range\n      } else {\n        return new Range(range.raw, options)\n      }\n    }\n\n    if (range instanceof Comparator) {\n      // just put it in the set and return\n      this.raw = range.value\n      this.set = [[range]]\n      this.format()\n      return this\n    }\n\n    this.options = options\n    this.loose = !!options.loose\n    this.includePrerelease = !!options.includePrerelease\n\n    // First, split based on boolean or ||\n    this.raw = range\n    this.set = range\n      .split(/\\s*\\|\\|\\s*/)\n      // map the range to a 2d array of comparators\n      .map(range => this.parseRange(range.trim()))\n      // throw out any comparator lists that are empty\n      // this generally means that it was not a valid range, which is allowed\n      // in loose mode, but will still throw if the WHOLE range is invalid.\n      .filter(c => c.length)\n\n    if (!this.set.length) {\n      throw new TypeError(`Invalid SemVer Range: ${range}`)\n    }\n\n    // if we have any that are not the null set, throw out null sets.\n    if (this.set.length > 1) {\n      // keep the first one, in case they're all null sets\n      const first = this.set[0]\n      this.set = this.set.filter(c => !isNullSet(c[0]))\n      if (this.set.length === 0)\n        this.set = [first]\n      else if (this.set.length > 1) {\n        // if we have any that are *, then the range is just *\n        for (const c of this.set) {\n          if (c.length === 1 && isAny(c[0])) {\n            this.set = [c]\n            break\n          }\n        }\n      }\n    }\n\n    this.format()\n  }\n\n  format () {\n    this.range = this.set\n      .map((comps) => {\n        return comps.join(' ').trim()\n      })\n      .join('||')\n      .trim()\n    return this.range\n  }\n\n  toString () {\n    return this.range\n  }\n\n  parseRange (range) {\n    range = range.trim()\n\n    // memoize range parsing for performance.\n    // this is a very hot path, and fully deterministic.\n    const memoOpts = Object.keys(this.options).join(',')\n    const memoKey = `parseRange:${memoOpts}:${range}`\n    const cached = cache.get(memoKey)\n    if (cached)\n      return cached\n\n    const loose = this.options.loose\n    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]\n    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))\n    debug('hyphen replace', range)\n    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)\n    debug('comparator trim', range, re[t.COMPARATORTRIM])\n\n    // `~ 1.2.3` => `~1.2.3`\n    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)\n\n    // `^ 1.2.3` => `^1.2.3`\n    range = range.replace(re[t.CARETTRIM], caretTrimReplace)\n\n    // normalize spaces\n    range = range.split(/\\s+/).join(' ')\n\n    // At this point, the range is completely trimmed and\n    // ready to be split into comparators.\n\n    const compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]\n    const rangeList = range\n      .split(' ')\n      .map(comp => parseComparator(comp, this.options))\n      .join(' ')\n      .split(/\\s+/)\n      // >=0.0.0 is equivalent to *\n      .map(comp => replaceGTE0(comp, this.options))\n      // in loose mode, throw out any that are not valid comparators\n      .filter(this.options.loose ? comp => !!comp.match(compRe) : () => true)\n      .map(comp => new Comparator(comp, this.options))\n\n    // if any comparators are the null set, then replace with JUST null set\n    // if more than one comparator, remove any * comparators\n    // also, don't include the same comparator more than once\n    const l = rangeList.length\n    const rangeMap = new Map()\n    for (const comp of rangeList) {\n      if (isNullSet(comp))\n        return [comp]\n      rangeMap.set(comp.value, comp)\n    }\n    if (rangeMap.size > 1 && rangeMap.has(''))\n      rangeMap.delete('')\n\n    const result = [...rangeMap.values()]\n    cache.set(memoKey, result)\n    return result\n  }\n\n  intersects (range, options) {\n    if (!(range instanceof Range)) {\n      throw new TypeError('a Range is required')\n    }\n\n    return this.set.some((thisComparators) => {\n      return (\n        isSatisfiable(thisComparators, options) &&\n        range.set.some((rangeComparators) => {\n          return (\n            isSatisfiable(rangeComparators, options) &&\n            thisComparators.every((thisComparator) => {\n              return rangeComparators.every((rangeComparator) => {\n                return thisComparator.intersects(rangeComparator, options)\n              })\n            })\n          )\n        })\n      )\n    })\n  }\n\n  // if ANY of the sets match ALL of its comparators, then pass\n  test (version) {\n    if (!version) {\n      return false\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options)\n      } catch (er) {\n        return false\n      }\n    }\n\n    for (let i = 0; i < this.set.length; i++) {\n      if (testSet(this.set[i], version, this.options)) {\n        return true\n      }\n    }\n    return false\n  }\n}\nmodule.exports = Range\n\nconst LRU = require('lru-cache')\nconst cache = new LRU({ max: 1000 })\n\nconst parseOptions = require('../internal/parse-options')\nconst Comparator = require('./comparator')\nconst debug = require('../internal/debug')\nconst SemVer = require('./semver')\nconst {\n  re,\n  t,\n  comparatorTrimReplace,\n  tildeTrimReplace,\n  caretTrimReplace\n} = require('../internal/re')\n\nconst isNullSet = c => c.value === '<0.0.0-0'\nconst isAny = c => c.value === ''\n\n// take a set of comparators and determine whether there\n// exists a version which can satisfy it\nconst isSatisfiable = (comparators, options) => {\n  let result = true\n  const remainingComparators = comparators.slice()\n  let testComparator = remainingComparators.pop()\n\n  while (result && remainingComparators.length) {\n    result = remainingComparators.every((otherComparator) => {\n      return testComparator.intersects(otherComparator, options)\n    })\n\n    testComparator = remainingComparators.pop()\n  }\n\n  return result\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nconst parseComparator = (comp, options) => {\n  debug('comp', comp, options)\n  comp = replaceCarets(comp, options)\n  debug('caret', comp)\n  comp = replaceTildes(comp, options)\n  debug('tildes', comp)\n  comp = replaceXRanges(comp, options)\n  debug('xrange', comp)\n  comp = replaceStars(comp, options)\n  debug('stars', comp)\n  return comp\n}\n\nconst isX = id => !id || id.toLowerCase() === 'x' || id === '*'\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0\nconst replaceTildes = (comp, options) =>\n  comp.trim().split(/\\s+/).map((comp) => {\n    return replaceTilde(comp, options)\n  }).join(' ')\n\nconst replaceTilde = (comp, options) => {\n  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('tilde', comp, _, M, m, p, pr)\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      // ~1.2 == >=1.2.0 <1.3.0-0\n      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`\n    } else if (pr) {\n      debug('replaceTilde pr', pr)\n      ret = `>=${M}.${m}.${p}-${pr\n      } <${M}.${+m + 1}.0-0`\n    } else {\n      // ~1.2.3 == >=1.2.3 <1.3.0-0\n      ret = `>=${M}.${m}.${p\n      } <${M}.${+m + 1}.0-0`\n    }\n\n    debug('tilde return', ret)\n    return ret\n  })\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0\n// ^1.2.3 --> >=1.2.3 <2.0.0-0\n// ^1.2.0 --> >=1.2.0 <2.0.0-0\nconst replaceCarets = (comp, options) =>\n  comp.trim().split(/\\s+/).map((comp) => {\n    return replaceCaret(comp, options)\n  }).join(' ')\n\nconst replaceCaret = (comp, options) => {\n  debug('caret', comp, options)\n  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]\n  const z = options.includePrerelease ? '-0' : ''\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('caret', comp, _, M, m, p, pr)\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      if (M === '0') {\n        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`\n      } else {\n        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`\n      }\n    } else if (pr) {\n      debug('replaceCaret pr', pr)\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p}-${pr\n        } <${+M + 1}.0.0-0`\n      }\n    } else {\n      debug('no pr')\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p\n        } <${+M + 1}.0.0-0`\n      }\n    }\n\n    debug('caret return', ret)\n    return ret\n  })\n}\n\nconst replaceXRanges = (comp, options) => {\n  debug('replaceXRanges', comp, options)\n  return comp.split(/\\s+/).map((comp) => {\n    return replaceXRange(comp, options)\n  }).join(' ')\n}\n\nconst replaceXRange = (comp, options) => {\n  comp = comp.trim()\n  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]\n  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr)\n    const xM = isX(M)\n    const xm = xM || isX(m)\n    const xp = xm || isX(p)\n    const anyX = xp\n\n    if (gtlt === '=' && anyX) {\n      gtlt = ''\n    }\n\n    // if we're including prereleases in the match, then we need\n    // to fix this to -0, the lowest possible prerelease value\n    pr = options.includePrerelease ? '-0' : ''\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0-0'\n      } else {\n        // nothing is forbidden\n        ret = '*'\n      }\n    } else if (gtlt && anyX) {\n      // we know patch is an x, because we have any x at all.\n      // replace X with 0\n      if (xm) {\n        m = 0\n      }\n      p = 0\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        gtlt = '>='\n        if (xm) {\n          M = +M + 1\n          m = 0\n          p = 0\n        } else {\n          m = +m + 1\n          p = 0\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<'\n        if (xm) {\n          M = +M + 1\n        } else {\n          m = +m + 1\n        }\n      }\n\n      if (gtlt === '<')\n        pr = '-0'\n\n      ret = `${gtlt + M}.${m}.${p}${pr}`\n    } else if (xm) {\n      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`\n    } else if (xp) {\n      ret = `>=${M}.${m}.0${pr\n      } <${M}.${+m + 1}.0-0`\n    }\n\n    debug('xRange return', ret)\n\n    return ret\n  })\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nconst replaceStars = (comp, options) => {\n  debug('replaceStars', comp, options)\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp.trim().replace(re[t.STAR], '')\n}\n\nconst replaceGTE0 = (comp, options) => {\n  debug('replaceGTE0', comp, options)\n  return comp.trim()\n    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')\n}\n\n// This function is passed to string.replace(re[t.HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0-0\nconst hyphenReplace = incPr => ($0,\n  from, fM, fm, fp, fpr, fb,\n  to, tM, tm, tp, tpr, tb) => {\n  if (isX(fM)) {\n    from = ''\n  } else if (isX(fm)) {\n    from = `>=${fM}.0.0${incPr ? '-0' : ''}`\n  } else if (isX(fp)) {\n    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`\n  } else if (fpr) {\n    from = `>=${from}`\n  } else {\n    from = `>=${from}${incPr ? '-0' : ''}`\n  }\n\n  if (isX(tM)) {\n    to = ''\n  } else if (isX(tm)) {\n    to = `<${+tM + 1}.0.0-0`\n  } else if (isX(tp)) {\n    to = `<${tM}.${+tm + 1}.0-0`\n  } else if (tpr) {\n    to = `<=${tM}.${tm}.${tp}-${tpr}`\n  } else if (incPr) {\n    to = `<${tM}.${tm}.${+tp + 1}-0`\n  } else {\n    to = `<=${to}`\n  }\n\n  return (`${from} ${to}`).trim()\n}\n\nconst testSet = (set, version, options) => {\n  for (let i = 0; i < set.length; i++) {\n    if (!set[i].test(version)) {\n      return false\n    }\n  }\n\n  if (version.prerelease.length && !options.includePrerelease) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (let i = 0; i < set.length; i++) {\n      debug(set[i].semver)\n      if (set[i].semver === Comparator.ANY) {\n        continue\n      }\n\n      if (set[i].semver.prerelease.length > 0) {\n        const allowed = set[i].semver\n        if (allowed.major === version.major &&\n            allowed.minor === version.minor &&\n            allowed.patch === version.patch) {\n          return true\n        }\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false\n  }\n\n  return true\n}\n","const debug = require('../internal/debug')\nconst { MAX_LENGTH, MAX_SAFE_INTEGER } = require('../internal/constants')\nconst { re, t } = require('../internal/re')\n\nconst parseOptions = require('../internal/parse-options')\nconst { compareIdentifiers } = require('../internal/identifiers')\nclass SemVer {\n  constructor (version, options) {\n    options = parseOptions(options)\n\n    if (version instanceof SemVer) {\n      if (version.loose === !!options.loose &&\n          version.includePrerelease === !!options.includePrerelease) {\n        return version\n      } else {\n        version = version.version\n      }\n    } else if (typeof version !== 'string') {\n      throw new TypeError(`Invalid Version: ${version}`)\n    }\n\n    if (version.length > MAX_LENGTH) {\n      throw new TypeError(\n        `version is longer than ${MAX_LENGTH} characters`\n      )\n    }\n\n    debug('SemVer', version, options)\n    this.options = options\n    this.loose = !!options.loose\n    // this isn't actually relevant for versions, but keep it so that we\n    // don't run into trouble passing this.options around.\n    this.includePrerelease = !!options.includePrerelease\n\n    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])\n\n    if (!m) {\n      throw new TypeError(`Invalid Version: ${version}`)\n    }\n\n    this.raw = version\n\n    // these are actually numbers\n    this.major = +m[1]\n    this.minor = +m[2]\n    this.patch = +m[3]\n\n    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n      throw new TypeError('Invalid major version')\n    }\n\n    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n      throw new TypeError('Invalid minor version')\n    }\n\n    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n      throw new TypeError('Invalid patch version')\n    }\n\n    // numberify any prerelease numeric ids\n    if (!m[4]) {\n      this.prerelease = []\n    } else {\n      this.prerelease = m[4].split('.').map((id) => {\n        if (/^[0-9]+$/.test(id)) {\n          const num = +id\n          if (num >= 0 && num < MAX_SAFE_INTEGER) {\n            return num\n          }\n        }\n        return id\n      })\n    }\n\n    this.build = m[5] ? m[5].split('.') : []\n    this.format()\n  }\n\n  format () {\n    this.version = `${this.major}.${this.minor}.${this.patch}`\n    if (this.prerelease.length) {\n      this.version += `-${this.prerelease.join('.')}`\n    }\n    return this.version\n  }\n\n  toString () {\n    return this.version\n  }\n\n  compare (other) {\n    debug('SemVer.compare', this.version, this.options, other)\n    if (!(other instanceof SemVer)) {\n      if (typeof other === 'string' && other === this.version) {\n        return 0\n      }\n      other = new SemVer(other, this.options)\n    }\n\n    if (other.version === this.version) {\n      return 0\n    }\n\n    return this.compareMain(other) || this.comparePre(other)\n  }\n\n  compareMain (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    return (\n      compareIdentifiers(this.major, other.major) ||\n      compareIdentifiers(this.minor, other.minor) ||\n      compareIdentifiers(this.patch, other.patch)\n    )\n  }\n\n  comparePre (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    // NOT having a prerelease is > having one\n    if (this.prerelease.length && !other.prerelease.length) {\n      return -1\n    } else if (!this.prerelease.length && other.prerelease.length) {\n      return 1\n    } else if (!this.prerelease.length && !other.prerelease.length) {\n      return 0\n    }\n\n    let i = 0\n    do {\n      const a = this.prerelease[i]\n      const b = other.prerelease[i]\n      debug('prerelease compare', i, a, b)\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n\n  compareBuild (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    let i = 0\n    do {\n      const a = this.build[i]\n      const b = other.build[i]\n      debug('prerelease compare', i, a, b)\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n\n  // preminor will bump the version up to the next minor release, and immediately\n  // down to pre-release. premajor and prepatch work the same way.\n  inc (release, identifier) {\n    switch (release) {\n      case 'premajor':\n        this.prerelease.length = 0\n        this.patch = 0\n        this.minor = 0\n        this.major++\n        this.inc('pre', identifier)\n        break\n      case 'preminor':\n        this.prerelease.length = 0\n        this.patch = 0\n        this.minor++\n        this.inc('pre', identifier)\n        break\n      case 'prepatch':\n        // If this is already a prerelease, it will bump to the next version\n        // drop any prereleases that might already exist, since they are not\n        // relevant at this point.\n        this.prerelease.length = 0\n        this.inc('patch', identifier)\n        this.inc('pre', identifier)\n        break\n      // If the input is a non-prerelease version, this acts the same as\n      // prepatch.\n      case 'prerelease':\n        if (this.prerelease.length === 0) {\n          this.inc('patch', identifier)\n        }\n        this.inc('pre', identifier)\n        break\n\n      case 'major':\n        // If this is a pre-major version, bump up to the same major version.\n        // Otherwise increment major.\n        // 1.0.0-5 bumps to 1.0.0\n        // 1.1.0 bumps to 2.0.0\n        if (\n          this.minor !== 0 ||\n          this.patch !== 0 ||\n          this.prerelease.length === 0\n        ) {\n          this.major++\n        }\n        this.minor = 0\n        this.patch = 0\n        this.prerelease = []\n        break\n      case 'minor':\n        // If this is a pre-minor version, bump up to the same minor version.\n        // Otherwise increment minor.\n        // 1.2.0-5 bumps to 1.2.0\n        // 1.2.1 bumps to 1.3.0\n        if (this.patch !== 0 || this.prerelease.length === 0) {\n          this.minor++\n        }\n        this.patch = 0\n        this.prerelease = []\n        break\n      case 'patch':\n        // If this is not a pre-release version, it will increment the patch.\n        // If it is a pre-release it will bump up to the same patch version.\n        // 1.2.0-5 patches to 1.2.0\n        // 1.2.0 patches to 1.2.1\n        if (this.prerelease.length === 0) {\n          this.patch++\n        }\n        this.prerelease = []\n        break\n      // This probably shouldn't be used publicly.\n      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.\n      case 'pre':\n        if (this.prerelease.length === 0) {\n          this.prerelease = [0]\n        } else {\n          let i = this.prerelease.length\n          while (--i >= 0) {\n            if (typeof this.prerelease[i] === 'number') {\n              this.prerelease[i]++\n              i = -2\n            }\n          }\n          if (i === -1) {\n            // didn't increment anything\n            this.prerelease.push(0)\n          }\n        }\n        if (identifier) {\n          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n          if (this.prerelease[0] === identifier) {\n            if (isNaN(this.prerelease[1])) {\n              this.prerelease = [identifier, 0]\n            }\n          } else {\n            this.prerelease = [identifier, 0]\n          }\n        }\n        break\n\n      default:\n        throw new Error(`invalid increment argument: ${release}`)\n    }\n    this.format()\n    this.raw = this.version\n    return this\n  }\n}\n\nmodule.exports = SemVer\n","const parse = require('./parse')\nconst clean = (version, options) => {\n  const s = parse(version.trim().replace(/^[=v]+/, ''), options)\n  return s ? s.version : null\n}\nmodule.exports = clean\n","const eq = require('./eq')\nconst neq = require('./neq')\nconst gt = require('./gt')\nconst gte = require('./gte')\nconst lt = require('./lt')\nconst lte = require('./lte')\n\nconst cmp = (a, op, b, loose) => {\n  switch (op) {\n    case '===':\n      if (typeof a === 'object')\n        a = a.version\n      if (typeof b === 'object')\n        b = b.version\n      return a === b\n\n    case '!==':\n      if (typeof a === 'object')\n        a = a.version\n      if (typeof b === 'object')\n        b = b.version\n      return a !== b\n\n    case '':\n    case '=':\n    case '==':\n      return eq(a, b, loose)\n\n    case '!=':\n      return neq(a, b, loose)\n\n    case '>':\n      return gt(a, b, loose)\n\n    case '>=':\n      return gte(a, b, loose)\n\n    case '<':\n      return lt(a, b, loose)\n\n    case '<=':\n      return lte(a, b, loose)\n\n    default:\n      throw new TypeError(`Invalid operator: ${op}`)\n  }\n}\nmodule.exports = cmp\n","const SemVer = require('../classes/semver')\nconst parse = require('./parse')\nconst {re, t} = require('../internal/re')\n\nconst coerce = (version, options) => {\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version === 'number') {\n    version = String(version)\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  options = options || {}\n\n  let match = null\n  if (!options.rtl) {\n    match = version.match(re[t.COERCE])\n  } else {\n    // Find the right-most coercible string that does not share\n    // a terminus with a more left-ward coercible string.\n    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'\n    //\n    // Walk through the string checking with a /g regexp\n    // Manually set the index so as to pick up overlapping matches.\n    // Stop when we get a match that ends at the string end, since no\n    // coercible string can be more right-ward without the same terminus.\n    let next\n    while ((next = re[t.COERCERTL].exec(version)) &&\n        (!match || match.index + match[0].length !== version.length)\n    ) {\n      if (!match ||\n            next.index + next[0].length !== match.index + match[0].length) {\n        match = next\n      }\n      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length\n    }\n    // leave it in a clean state\n    re[t.COERCERTL].lastIndex = -1\n  }\n\n  if (match === null)\n    return null\n\n  return parse(`${match[2]}.${match[3] || '0'}.${match[4] || '0'}`, options)\n}\nmodule.exports = coerce\n","const SemVer = require('../classes/semver')\nconst compareBuild = (a, b, loose) => {\n  const versionA = new SemVer(a, loose)\n  const versionB = new SemVer(b, loose)\n  return versionA.compare(versionB) || versionA.compareBuild(versionB)\n}\nmodule.exports = compareBuild\n","const compare = require('./compare')\nconst compareLoose = (a, b) => compare(a, b, true)\nmodule.exports = compareLoose\n","const SemVer = require('../classes/semver')\nconst compare = (a, b, loose) =>\n  new SemVer(a, loose).compare(new SemVer(b, loose))\n\nmodule.exports = compare\n","const parse = require('./parse')\nconst eq = require('./eq')\n\nconst diff = (version1, version2) => {\n  if (eq(version1, version2)) {\n    return null\n  } else {\n    const v1 = parse(version1)\n    const v2 = parse(version2)\n    const hasPre = v1.prerelease.length || v2.prerelease.length\n    const prefix = hasPre ? 'pre' : ''\n    const defaultResult = hasPre ? 'prerelease' : ''\n    for (const key in v1) {\n      if (key === 'major' || key === 'minor' || key === 'patch') {\n        if (v1[key] !== v2[key]) {\n          return prefix + key\n        }\n      }\n    }\n    return defaultResult // may be undefined\n  }\n}\nmodule.exports = diff\n","const compare = require('./compare')\nconst eq = (a, b, loose) => compare(a, b, loose) === 0\nmodule.exports = eq\n","const compare = require('./compare')\nconst gt = (a, b, loose) => compare(a, b, loose) > 0\nmodule.exports = gt\n","const compare = require('./compare')\nconst gte = (a, b, loose) => compare(a, b, loose) >= 0\nmodule.exports = gte\n","const SemVer = require('../classes/semver')\n\nconst inc = (version, release, options, identifier) => {\n  if (typeof (options) === 'string') {\n    identifier = options\n    options = undefined\n  }\n\n  try {\n    return new SemVer(version, options).inc(release, identifier).version\n  } catch (er) {\n    return null\n  }\n}\nmodule.exports = inc\n","const compare = require('./compare')\nconst lt = (a, b, loose) => compare(a, b, loose) < 0\nmodule.exports = lt\n","const compare = require('./compare')\nconst lte = (a, b, loose) => compare(a, b, loose) <= 0\nmodule.exports = lte\n","const SemVer = require('../classes/semver')\nconst major = (a, loose) => new SemVer(a, loose).major\nmodule.exports = major\n","const SemVer = require('../classes/semver')\nconst minor = (a, loose) => new SemVer(a, loose).minor\nmodule.exports = minor\n","const compare = require('./compare')\nconst neq = (a, b, loose) => compare(a, b, loose) !== 0\nmodule.exports = neq\n","const {MAX_LENGTH} = require('../internal/constants')\nconst { re, t } = require('../internal/re')\nconst SemVer = require('../classes/semver')\n\nconst parseOptions = require('../internal/parse-options')\nconst parse = (version, options) => {\n  options = parseOptions(options)\n\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  if (version.length > MAX_LENGTH) {\n    return null\n  }\n\n  const r = options.loose ? re[t.LOOSE] : re[t.FULL]\n  if (!r.test(version)) {\n    return null\n  }\n\n  try {\n    return new SemVer(version, options)\n  } catch (er) {\n    return null\n  }\n}\n\nmodule.exports = parse\n","const SemVer = require('../classes/semver')\nconst patch = (a, loose) => new SemVer(a, loose).patch\nmodule.exports = patch\n","const parse = require('./parse')\nconst prerelease = (version, options) => {\n  const parsed = parse(version, options)\n  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null\n}\nmodule.exports = prerelease\n","const compare = require('./compare')\nconst rcompare = (a, b, loose) => compare(b, a, loose)\nmodule.exports = rcompare\n","const compareBuild = require('./compare-build')\nconst rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))\nmodule.exports = rsort\n","const Range = require('../classes/range')\nconst satisfies = (version, range, options) => {\n  try {\n    range = new Range(range, options)\n  } catch (er) {\n    return false\n  }\n  return range.test(version)\n}\nmodule.exports = satisfies\n","const compareBuild = require('./compare-build')\nconst sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))\nmodule.exports = sort\n","const parse = require('./parse')\nconst valid = (version, options) => {\n  const v = parse(version, options)\n  return v ? v.version : null\n}\nmodule.exports = valid\n","// just pre-load all the stuff that index.js lazily exports\nconst internalRe = require('./internal/re')\nmodule.exports = {\n  re: internalRe.re,\n  src: internalRe.src,\n  tokens: internalRe.t,\n  SEMVER_SPEC_VERSION: require('./internal/constants').SEMVER_SPEC_VERSION,\n  SemVer: require('./classes/semver'),\n  compareIdentifiers: require('./internal/identifiers').compareIdentifiers,\n  rcompareIdentifiers: require('./internal/identifiers').rcompareIdentifiers,\n  parse: require('./functions/parse'),\n  valid: require('./functions/valid'),\n  clean: require('./functions/clean'),\n  inc: require('./functions/inc'),\n  diff: require('./functions/diff'),\n  major: require('./functions/major'),\n  minor: require('./functions/minor'),\n  patch: require('./functions/patch'),\n  prerelease: require('./functions/prerelease'),\n  compare: require('./functions/compare'),\n  rcompare: require('./functions/rcompare'),\n  compareLoose: require('./functions/compare-loose'),\n  compareBuild: require('./functions/compare-build'),\n  sort: require('./functions/sort'),\n  rsort: require('./functions/rsort'),\n  gt: require('./functions/gt'),\n  lt: require('./functions/lt'),\n  eq: require('./functions/eq'),\n  neq: require('./functions/neq'),\n  gte: require('./functions/gte'),\n  lte: require('./functions/lte'),\n  cmp: require('./functions/cmp'),\n  coerce: require('./functions/coerce'),\n  Comparator: require('./classes/comparator'),\n  Range: require('./classes/range'),\n  satisfies: require('./functions/satisfies'),\n  toComparators: require('./ranges/to-comparators'),\n  maxSatisfying: require('./ranges/max-satisfying'),\n  minSatisfying: require('./ranges/min-satisfying'),\n  minVersion: require('./ranges/min-version'),\n  validRange: require('./ranges/valid'),\n  outside: require('./ranges/outside'),\n  gtr: require('./ranges/gtr'),\n  ltr: require('./ranges/ltr'),\n  intersects: require('./ranges/intersects'),\n  simplifyRange: require('./ranges/simplify'),\n  subset: require('./ranges/subset'),\n}\n","// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nconst SEMVER_SPEC_VERSION = '2.0.0'\n\nconst MAX_LENGTH = 256\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||\n  /* istanbul ignore next */ 9007199254740991\n\n// Max safe segment length for coercion.\nconst MAX_SAFE_COMPONENT_LENGTH = 16\n\nmodule.exports = {\n  SEMVER_SPEC_VERSION,\n  MAX_LENGTH,\n  MAX_SAFE_INTEGER,\n  MAX_SAFE_COMPONENT_LENGTH\n}\n","const debug = (\n  typeof process === 'object' &&\n  process.env &&\n  process.env.NODE_DEBUG &&\n  /\\bsemver\\b/i.test(process.env.NODE_DEBUG)\n) ? (...args) => console.error('SEMVER', ...args)\n  : () => {}\n\nmodule.exports = debug\n","const numeric = /^[0-9]+$/\nconst compareIdentifiers = (a, b) => {\n  const anum = numeric.test(a)\n  const bnum = numeric.test(b)\n\n  if (anum && bnum) {\n    a = +a\n    b = +b\n  }\n\n  return a === b ? 0\n    : (anum && !bnum) ? -1\n    : (bnum && !anum) ? 1\n    : a < b ? -1\n    : 1\n}\n\nconst rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)\n\nmodule.exports = {\n  compareIdentifiers,\n  rcompareIdentifiers\n}\n","// parse out just the options we care about so we always get a consistent\n// obj with keys in a consistent order.\nconst opts = ['includePrerelease', 'loose', 'rtl']\nconst parseOptions = options =>\n  !options ? {}\n  : typeof options !== 'object' ? { loose: true }\n  : opts.filter(k => options[k]).reduce((options, k) => {\n    options[k] = true\n    return options\n  }, {})\nmodule.exports = parseOptions\n","const { MAX_SAFE_COMPONENT_LENGTH } = require('./constants')\nconst debug = require('./debug')\nexports = module.exports = {}\n\n// The actual regexps go on exports.re\nconst re = exports.re = []\nconst src = exports.src = []\nconst t = exports.t = {}\nlet R = 0\n\nconst createToken = (name, value, isGlobal) => {\n  const index = R++\n  debug(index, value)\n  t[name] = index\n  src[index] = value\n  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)\n}\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\ncreateToken('NUMERICIDENTIFIER', '0|[1-9]\\\\d*')\ncreateToken('NUMERICIDENTIFIERLOOSE', '[0-9]+')\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\ncreateToken('NONNUMERICIDENTIFIER', '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*')\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\ncreateToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n                   `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n                   `(${src[t.NUMERICIDENTIFIER]})`)\n\ncreateToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\ncreateToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]\n}|${src[t.NONNUMERICIDENTIFIER]})`)\n\ncreateToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]\n}|${src[t.NONNUMERICIDENTIFIER]})`)\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\ncreateToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIER]})*))`)\n\ncreateToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\ncreateToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+')\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\ncreateToken('BUILD', `(?:\\\\+(${src[t.BUILDIDENTIFIER]\n}(?:\\\\.${src[t.BUILDIDENTIFIER]})*))`)\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\ncreateToken('FULLPLAIN', `v?${src[t.MAINVERSION]\n}${src[t.PRERELEASE]}?${\n  src[t.BUILD]}?`)\n\ncreateToken('FULL', `^${src[t.FULLPLAIN]}$`)\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\ncreateToken('LOOSEPLAIN', `[v=\\\\s]*${src[t.MAINVERSIONLOOSE]\n}${src[t.PRERELEASELOOSE]}?${\n  src[t.BUILD]}?`)\n\ncreateToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)\n\ncreateToken('GTLT', '((?:<|>)?=?)')\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\ncreateToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\\\*`)\ncreateToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\\\*`)\n\ncreateToken('XRANGEPLAIN', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:${src[t.PRERELEASE]})?${\n                     src[t.BUILD]}?` +\n                   `)?)?`)\n\ncreateToken('XRANGEPLAINLOOSE', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:${src[t.PRERELEASELOOSE]})?${\n                          src[t.BUILD]}?` +\n                        `)?)?`)\n\ncreateToken('XRANGE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAIN]}$`)\ncreateToken('XRANGELOOSE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAINLOOSE]}$`)\n\n// Coercion.\n// Extract anything that could conceivably be a part of a valid semver\ncreateToken('COERCE', `${'(^|[^\\\\d])' +\n              '(\\\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +\n              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +\n              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +\n              `(?:$|[^\\\\d])`)\ncreateToken('COERCERTL', src[t.COERCE], true)\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\ncreateToken('LONETILDE', '(?:~>?)')\n\ncreateToken('TILDETRIM', `(\\\\s*)${src[t.LONETILDE]}\\\\s+`, true)\nexports.tildeTrimReplace = '$1~'\n\ncreateToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)\ncreateToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\ncreateToken('LONECARET', '(?:\\\\^)')\n\ncreateToken('CARETTRIM', `(\\\\s*)${src[t.LONECARET]}\\\\s+`, true)\nexports.caretTrimReplace = '$1^'\n\ncreateToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)\ncreateToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\ncreateToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\\\s*(${src[t.LOOSEPLAIN]})$|^$`)\ncreateToken('COMPARATOR', `^${src[t.GTLT]}\\\\s*(${src[t.FULLPLAIN]})$|^$`)\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\ncreateToken('COMPARATORTRIM', `(\\\\s*)${src[t.GTLT]\n}\\\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)\nexports.comparatorTrimReplace = '$1$2$3'\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\ncreateToken('HYPHENRANGE', `^\\\\s*(${src[t.XRANGEPLAIN]})` +\n                   `\\\\s+-\\\\s+` +\n                   `(${src[t.XRANGEPLAIN]})` +\n                   `\\\\s*$`)\n\ncreateToken('HYPHENRANGELOOSE', `^\\\\s*(${src[t.XRANGEPLAINLOOSE]})` +\n                        `\\\\s+-\\\\s+` +\n                        `(${src[t.XRANGEPLAINLOOSE]})` +\n                        `\\\\s*$`)\n\n// Star ranges basically just allow anything at all.\ncreateToken('STAR', '(<|>)?=?\\\\s*\\\\*')\n// >=0.0.0 is like a star\ncreateToken('GTE0', '^\\\\s*>=\\\\s*0\\.0\\.0\\\\s*$')\ncreateToken('GTE0PRE', '^\\\\s*>=\\\\s*0\\.0\\.0-0\\\\s*$')\n","// Determine if version is greater than all the versions possible in the range.\nconst outside = require('./outside')\nconst gtr = (version, range, options) => outside(version, range, '>', options)\nmodule.exports = gtr\n","const Range = require('../classes/range')\nconst intersects = (r1, r2, options) => {\n  r1 = new Range(r1, options)\n  r2 = new Range(r2, options)\n  return r1.intersects(r2)\n}\nmodule.exports = intersects\n","const outside = require('./outside')\n// Determine if version is less than all the versions possible in the range\nconst ltr = (version, range, options) => outside(version, range, '<', options)\nmodule.exports = ltr\n","const SemVer = require('../classes/semver')\nconst Range = require('../classes/range')\n\nconst maxSatisfying = (versions, range, options) => {\n  let max = null\n  let maxSV = null\n  let rangeObj = null\n  try {\n    rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!max || maxSV.compare(v) === -1) {\n        // compare(max, v, true)\n        max = v\n        maxSV = new SemVer(max, options)\n      }\n    }\n  })\n  return max\n}\nmodule.exports = maxSatisfying\n","const SemVer = require('../classes/semver')\nconst Range = require('../classes/range')\nconst minSatisfying = (versions, range, options) => {\n  let min = null\n  let minSV = null\n  let rangeObj = null\n  try {\n    rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!min || minSV.compare(v) === 1) {\n        // compare(min, v, true)\n        min = v\n        minSV = new SemVer(min, options)\n      }\n    }\n  })\n  return min\n}\nmodule.exports = minSatisfying\n","const SemVer = require('../classes/semver')\nconst Range = require('../classes/range')\nconst gt = require('../functions/gt')\n\nconst minVersion = (range, loose) => {\n  range = new Range(range, loose)\n\n  let minver = new SemVer('0.0.0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = new SemVer('0.0.0-0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = null\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i]\n\n    let setMin = null\n    comparators.forEach((comparator) => {\n      // Clone to avoid manipulating the comparator's semver object.\n      const compver = new SemVer(comparator.semver.version)\n      switch (comparator.operator) {\n        case '>':\n          if (compver.prerelease.length === 0) {\n            compver.patch++\n          } else {\n            compver.prerelease.push(0)\n          }\n          compver.raw = compver.format()\n          /* fallthrough */\n        case '':\n        case '>=':\n          if (!setMin || gt(compver, setMin)) {\n            setMin = compver\n          }\n          break\n        case '<':\n        case '<=':\n          /* Ignore maximum versions */\n          break\n        /* istanbul ignore next */\n        default:\n          throw new Error(`Unexpected operation: ${comparator.operator}`)\n      }\n    })\n    if (setMin && (!minver || gt(minver, setMin)))\n      minver = setMin\n  }\n\n  if (minver && range.test(minver)) {\n    return minver\n  }\n\n  return null\n}\nmodule.exports = minVersion\n","const SemVer = require('../classes/semver')\nconst Comparator = require('../classes/comparator')\nconst {ANY} = Comparator\nconst Range = require('../classes/range')\nconst satisfies = require('../functions/satisfies')\nconst gt = require('../functions/gt')\nconst lt = require('../functions/lt')\nconst lte = require('../functions/lte')\nconst gte = require('../functions/gte')\n\nconst outside = (version, range, hilo, options) => {\n  version = new SemVer(version, options)\n  range = new Range(range, options)\n\n  let gtfn, ltefn, ltfn, comp, ecomp\n  switch (hilo) {\n    case '>':\n      gtfn = gt\n      ltefn = lte\n      ltfn = lt\n      comp = '>'\n      ecomp = '>='\n      break\n    case '<':\n      gtfn = lt\n      ltefn = gte\n      ltfn = gt\n      comp = '<'\n      ecomp = '<='\n      break\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"')\n  }\n\n  // If it satisfies the range it is not outside\n  if (satisfies(version, range, options)) {\n    return false\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i]\n\n    let high = null\n    let low = null\n\n    comparators.forEach((comparator) => {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator('>=0.0.0')\n      }\n      high = high || comparator\n      low = low || comparator\n      if (gtfn(comparator.semver, high.semver, options)) {\n        high = comparator\n      } else if (ltfn(comparator.semver, low.semver, options)) {\n        low = comparator\n      }\n    })\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false\n    }\n  }\n  return true\n}\n\nmodule.exports = outside\n","// given a set of versions and a range, create a \"simplified\" range\n// that includes the same versions that the original range does\n// If the original range is shorter than the simplified one, return that.\nconst satisfies = require('../functions/satisfies.js')\nconst compare = require('../functions/compare.js')\nmodule.exports = (versions, range, options) => {\n  const set = []\n  let min = null\n  let prev = null\n  const v = versions.sort((a, b) => compare(a, b, options))\n  for (const version of v) {\n    const included = satisfies(version, range, options)\n    if (included) {\n      prev = version\n      if (!min)\n        min = version\n    } else {\n      if (prev) {\n        set.push([min, prev])\n      }\n      prev = null\n      min = null\n    }\n  }\n  if (min)\n    set.push([min, null])\n\n  const ranges = []\n  for (const [min, max] of set) {\n    if (min === max)\n      ranges.push(min)\n    else if (!max && min === v[0])\n      ranges.push('*')\n    else if (!max)\n      ranges.push(`>=${min}`)\n    else if (min === v[0])\n      ranges.push(`<=${max}`)\n    else\n      ranges.push(`${min} - ${max}`)\n  }\n  const simplified = ranges.join(' || ')\n  const original = typeof range.raw === 'string' ? range.raw : String(range)\n  return simplified.length < original.length ? simplified : range\n}\n","const Range = require('../classes/range.js')\nconst { ANY } = require('../classes/comparator.js')\nconst satisfies = require('../functions/satisfies.js')\nconst compare = require('../functions/compare.js')\n\n// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:\n// - Every simple range `r1, r2, ...` is a subset of some `R1, R2, ...`\n//\n// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:\n// - If c is only the ANY comparator\n//   - If C is only the ANY comparator, return true\n//   - Else return false\n// - Let EQ be the set of = comparators in c\n// - If EQ is more than one, return true (null set)\n// - Let GT be the highest > or >= comparator in c\n// - Let LT be the lowest < or <= comparator in c\n// - If GT and LT, and GT.semver > LT.semver, return true (null set)\n// - If EQ\n//   - If GT, and EQ does not satisfy GT, return true (null set)\n//   - If LT, and EQ does not satisfy LT, return true (null set)\n//   - If EQ satisfies every C, return true\n//   - Else return false\n// - If GT\n//   - If GT.semver is lower than any > or >= comp in C, return false\n//   - If GT is >=, and GT.semver does not satisfy every C, return false\n// - If LT\n//   - If LT.semver is greater than any < or <= comp in C, return false\n//   - If LT is <=, and LT.semver does not satisfy every C, return false\n// - If any C is a = range, and GT or LT are set, return false\n// - Else return true\n\nconst subset = (sub, dom, options) => {\n  if (sub === dom)\n    return true\n\n  sub = new Range(sub, options)\n  dom = new Range(dom, options)\n  let sawNonNull = false\n\n  OUTER: for (const simpleSub of sub.set) {\n    for (const simpleDom of dom.set) {\n      const isSub = simpleSubset(simpleSub, simpleDom, options)\n      sawNonNull = sawNonNull || isSub !== null\n      if (isSub)\n        continue OUTER\n    }\n    // the null set is a subset of everything, but null simple ranges in\n    // a complex range should be ignored.  so if we saw a non-null range,\n    // then we know this isn't a subset, but if EVERY simple range was null,\n    // then it is a subset.\n    if (sawNonNull)\n      return false\n  }\n  return true\n}\n\nconst simpleSubset = (sub, dom, options) => {\n  if (sub === dom)\n    return true\n\n  if (sub.length === 1 && sub[0].semver === ANY)\n    return dom.length === 1 && dom[0].semver === ANY\n\n  const eqSet = new Set()\n  let gt, lt\n  for (const c of sub) {\n    if (c.operator === '>' || c.operator === '>=')\n      gt = higherGT(gt, c, options)\n    else if (c.operator === '<' || c.operator === '<=')\n      lt = lowerLT(lt, c, options)\n    else\n      eqSet.add(c.semver)\n  }\n\n  if (eqSet.size > 1)\n    return null\n\n  let gtltComp\n  if (gt && lt) {\n    gtltComp = compare(gt.semver, lt.semver, options)\n    if (gtltComp > 0)\n      return null\n    else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<='))\n      return null\n  }\n\n  // will iterate one or zero times\n  for (const eq of eqSet) {\n    if (gt && !satisfies(eq, String(gt), options))\n      return null\n\n    if (lt && !satisfies(eq, String(lt), options))\n      return null\n\n    for (const c of dom) {\n      if (!satisfies(eq, String(c), options))\n        return false\n    }\n\n    return true\n  }\n\n  let higher, lower\n  let hasDomLT, hasDomGT\n  for (const c of dom) {\n    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='\n    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='\n    if (gt) {\n      if (c.operator === '>' || c.operator === '>=') {\n        higher = higherGT(gt, c, options)\n        if (higher === c && higher !== gt)\n          return false\n      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options))\n        return false\n    }\n    if (lt) {\n      if (c.operator === '<' || c.operator === '<=') {\n        lower = lowerLT(lt, c, options)\n        if (lower === c && lower !== lt)\n          return false\n      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options))\n        return false\n    }\n    if (!c.operator && (lt || gt) && gtltComp !== 0)\n      return false\n  }\n\n  // if there was a < or >, and nothing in the dom, then must be false\n  // UNLESS it was limited by another range in the other direction.\n  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0\n  if (gt && hasDomLT && !lt && gtltComp !== 0)\n    return false\n\n  if (lt && hasDomGT && !gt && gtltComp !== 0)\n    return false\n\n  return true\n}\n\n// >=1.2.3 is lower than >1.2.3\nconst higherGT = (a, b, options) => {\n  if (!a)\n    return b\n  const comp = compare(a.semver, b.semver, options)\n  return comp > 0 ? a\n    : comp < 0 ? b\n    : b.operator === '>' && a.operator === '>=' ? b\n    : a\n}\n\n// <=1.2.3 is higher than <1.2.3\nconst lowerLT = (a, b, options) => {\n  if (!a)\n    return b\n  const comp = compare(a.semver, b.semver, options)\n  return comp < 0 ? a\n    : comp > 0 ? b\n    : b.operator === '<' && a.operator === '<=' ? b\n    : a\n}\n\nmodule.exports = subset\n","const Range = require('../classes/range')\n\n// Mostly just for testing and legacy API reasons\nconst toComparators = (range, options) =>\n  new Range(range, options).set\n    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '))\n\nmodule.exports = toComparators\n","const Range = require('../classes/range')\nconst validRange = (range, options) => {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, options).range || '*'\n  } catch (er) {\n    return null\n  }\n}\nmodule.exports = validRange\n","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Resource = void 0;\nconst core_1 = require(\"@opentelemetry/core\");\nconst constants_1 = require(\"./constants\");\n/**\n * A Resource describes the entity for which a signals (metrics or trace) are\n * collected.\n */\nclass Resource {\n    constructor(\n    /**\n     * A dictionary of attributes with string keys and values that provide\n     * information about the entity as numbers, strings or booleans\n     * TODO: Consider to add check/validation on attributes.\n     */\n    attributes) {\n        this.attributes = attributes;\n    }\n    /**\n     * Returns an empty Resource\n     */\n    static empty() {\n        return Resource.EMPTY;\n    }\n    /**\n     * Returns a Resource that indentifies the SDK in use.\n     */\n    static createTelemetrySDKResource() {\n        return new Resource({\n            [constants_1.TELEMETRY_SDK_RESOURCE.LANGUAGE]: core_1.SDK_INFO.LANGUAGE,\n            [constants_1.TELEMETRY_SDK_RESOURCE.NAME]: core_1.SDK_INFO.NAME,\n            [constants_1.TELEMETRY_SDK_RESOURCE.VERSION]: core_1.SDK_INFO.VERSION,\n        });\n    }\n    /**\n     * Returns a new, merged {@link Resource} by merging the current Resource\n     * with the other Resource. In case of a collision, current Resource takes\n     * precedence.\n     *\n     * @param other the Resource that will be merged with this.\n     * @returns the newly merged Resource.\n     */\n    merge(other) {\n        if (!other || !Object.keys(other.attributes).length)\n            return this;\n        // Attributes from resource overwrite attributes from other resource.\n        const mergedAttributes = Object.assign({}, other.attributes, this.attributes);\n        return new Resource(mergedAttributes);\n    }\n}\nexports.Resource = Resource;\nResource.EMPTY = new Resource({});\n//# sourceMappingURL=Resource.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=config.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PROCESS_RESOURCE = exports.SERVICE_RESOURCE = exports.TELEMETRY_SDK_RESOURCE = exports.K8S_RESOURCE = exports.HOST_RESOURCE = exports.CONTAINER_RESOURCE = exports.CLOUD_RESOURCE = void 0;\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexports.CLOUD_RESOURCE = {\n    /** Name of the cloud provider. Example values are aws, azure, gcp. */\n    PROVIDER: 'cloud.provider',\n    /** The cloud account id used to identify different entities. */\n    ACCOUNT_ID: 'cloud.account.id',\n    /** A specific geographical location where different entities can run. */\n    REGION: 'cloud.region',\n    /** Zones are a sub set of the region connected through low-latency links. */\n    ZONE: 'cloud.zone',\n};\n/**\n * Attributes defining a compute unit (e.g. Container, Process, Lambda\n * Function).\n * */\nexports.CONTAINER_RESOURCE = {\n    /** The container name. */\n    NAME: 'container.name',\n    /** The container id. */\n    ID: 'container.id',\n    /** The name of the image the container was built on. */\n    IMAGE_NAME: 'container.image.name',\n    /** The container image tag. */\n    IMAGE_TAG: 'container.image.tag',\n};\n/** Attributes defining a computing instance (e.g. host). */\nexports.HOST_RESOURCE = {\n    /**\n     * Unique host id. For Cloud this must be the instance_id assigned by the\n     * cloud provider\n     */\n    ID: 'host.id',\n    /**\n     * Name of the host. It may contain what hostname returns on Unix systems,\n     * the fully qualified, or a name specified by the user.\n     */\n    NAME: 'host.name',\n    /** Type of host. For Cloud this must be the machine type.*/\n    TYPE: 'host.type',\n    /** Name of the VM image or OS install the host was instantiated from. */\n    IMAGE_NAME: 'host.image.name',\n    /** VM image id. For Cloud, this value is from the provider. */\n    IMAGE_ID: 'host.image.id',\n    /** The version string of the VM image */\n    IMAGE_VERSION: 'host.image.version',\n};\n/** Attributes defining a deployment service (e.g. Kubernetes). */\nexports.K8S_RESOURCE = {\n    /** The name of the cluster that the pod is running in. */\n    CLUSTER_NAME: 'k8s.cluster.name',\n    /** The name of the namespace that the pod is running in. */\n    NAMESPACE_NAME: 'k8s.namespace.name',\n    /** The name of the pod. */\n    POD_NAME: 'k8s.pod.name',\n    /** The name of the deployment. */\n    DEPLOYMENT_NAME: 'k8s.deployment.name',\n};\n/** Attributes describing the telemetry library. */\nexports.TELEMETRY_SDK_RESOURCE = {\n    /** The name of the telemetry library. */\n    NAME: 'telemetry.sdk.name',\n    /** The language of telemetry library and of the code instrumented with it. */\n    LANGUAGE: 'telemetry.sdk.language',\n    /** The version string of the telemetry library */\n    VERSION: 'telemetry.sdk.version',\n};\n/** Attributes describing a service instance. */\nexports.SERVICE_RESOURCE = {\n    /** Logical name of the service.  */\n    NAME: 'service.name',\n    /** A namespace for `service.name`. */\n    NAMESPACE: 'service.namespace',\n    /** The string ID of the service instance. */\n    INSTANCE_ID: 'service.instance.id',\n    /** The version string of the service API or implementation. */\n    VERSION: 'service.version',\n};\n/** Attributes describing a Process. */\nexports.PROCESS_RESOURCE = {\n    /** A command which launced this proces.  */\n    COMMAND: 'process.command',\n    /** The full command with arguments as string.  */\n    COMMAND_LINE: 'process.command_line',\n    /** A name given to currently running porcess defaults to executable (process.title) .  */\n    NAME: 'process.executable.name',\n    /** An owner of currently running process.  */\n    OWNER: 'process.owner',\n    /** The full path to the process executable.  */\n    PATH: 'process.executable.path',\n    /** Process identifier of currently running process.  */\n    PID: 'process.id',\n};\n//# sourceMappingURL=constants.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./Resource\"), exports);\n__exportStar(require(\"./platform\"), exports);\n__exportStar(require(\"./constants\"), exports);\n__exportStar(require(\"./types\"), exports);\n__exportStar(require(\"./config\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./node\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.detectResources = void 0;\nconst Resource_1 = require(\"../../Resource\");\nconst util = require(\"util\");\nconst core_1 = require(\"@opentelemetry/core\");\n/**\n * Runs all resource detectors and returns the results merged into a single\n * Resource.\n *\n * @param config Configuration for resource detection\n */\nexports.detectResources = async (config = {}) => {\n    const internalConfig = Object.assign({\n        logger: new core_1.NoopLogger(),\n    }, config);\n    const resources = await Promise.all((internalConfig.detectors || []).map(async (d) => {\n        var _a, _b;\n        try {\n            const resource = await d.detect(internalConfig);\n            (_a = config.logger) === null || _a === void 0 ? void 0 : _a.debug(`${d.constructor.name} found resource.`, resource);\n            return resource;\n        }\n        catch (e) {\n            (_b = config.logger) === null || _b === void 0 ? void 0 : _b.debug(`${d.constructor.name} failed: ${e.message}`);\n            return Resource_1.Resource.empty();\n        }\n    }));\n    // Log Resources only if there is a user-provided logger\n    if (config.logger) {\n        logResources(config.logger, resources);\n    }\n    return resources.reduce((acc, resource) => acc.merge(resource), Resource_1.Resource.createTelemetrySDKResource());\n};\n/**\n * Writes debug information about the detected resources to the logger defined in the resource detection config, if one is provided.\n *\n * @param logger The {@link Logger} to write the debug information to.\n * @param resources The array of {@link Resource} that should be logged. Empty entried will be ignored.\n */\nconst logResources = (logger, resources) => {\n    resources.forEach(resource => {\n        // Print only populated resources\n        if (Object.keys(resource.attributes).length > 0) {\n            const resourceDebugString = util.inspect(resource.attributes, {\n                depth: 2,\n                breakLength: Infinity,\n                sorted: true,\n                compact: false,\n            });\n            logger.debug(resourceDebugString);\n        }\n    });\n};\n//# sourceMappingURL=detect-resources.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.envDetector = void 0;\nconst __1 = require(\"../../../\");\n/**\n * EnvDetector can be used to detect the presence of and create a Resource\n * from the OTEL_RESOURCE_ATTRIBUTES environment variable.\n */\nclass EnvDetector {\n    constructor() {\n        // Type, attribute keys, and attribute values should not exceed 256 characters.\n        this._MAX_LENGTH = 255;\n        // OTEL_RESOURCE_ATTRIBUTES is a comma-separated list of attributes.\n        this._COMMA_SEPARATOR = ',';\n        // OTEL_RESOURCE_ATTRIBUTES contains key value pair separated by '='.\n        this._LABEL_KEY_VALUE_SPLITTER = '=';\n        this._ERROR_MESSAGE_INVALID_CHARS = 'should be a ASCII string with a length greater than 0 and not exceed ' +\n            this._MAX_LENGTH +\n            ' characters.';\n        this._ERROR_MESSAGE_INVALID_VALUE = 'should be a ASCII string with a length not exceed ' +\n            this._MAX_LENGTH +\n            ' characters.';\n    }\n    /**\n     * Returns a {@link Resource} populated with attributes from the\n     * OTEL_RESOURCE_ATTRIBUTES environment variable. Note this is an async\n     * function to conform to the Detector interface.\n     *\n     * @param config The resource detection config with a required logger\n     */\n    async detect(config) {\n        try {\n            const rawAttributes = process.env.OTEL_RESOURCE_ATTRIBUTES;\n            if (!rawAttributes) {\n                config.logger.debug('EnvDetector failed: Environment variable \"OTEL_RESOURCE_ATTRIBUTES\" is missing.');\n                return __1.Resource.empty();\n            }\n            const attributes = this._parseResourceAttributes(rawAttributes);\n            return new __1.Resource(attributes);\n        }\n        catch (e) {\n            config.logger.debug(`EnvDetector failed: ${e.message}`);\n            return __1.Resource.empty();\n        }\n    }\n    /**\n     * Creates an attribute map from the OTEL_RESOURCE_ATTRIBUTES environment\n     * variable.\n     *\n     * OTEL_RESOURCE_ATTRIBUTES: A comma-separated list of attributes describing\n     * the source in more detail, e.g. key1=val1,key2=val2. Domain names and\n     * paths are accepted as attribute keys. Values may be quoted or unquoted in\n     * general. If a value contains whitespaces, =, or \" characters, it must\n     * always be quoted.\n     *\n     * @param rawEnvAttributes The resource attributes as a comma-seperated list\n     * of key/value pairs.\n     * @returns The sanitized resource attributes.\n     */\n    _parseResourceAttributes(rawEnvAttributes) {\n        if (!rawEnvAttributes)\n            return {};\n        const attributes = {};\n        const rawAttributes = rawEnvAttributes.split(this._COMMA_SEPARATOR, -1);\n        for (const rawAttribute of rawAttributes) {\n            const keyValuePair = rawAttribute.split(this._LABEL_KEY_VALUE_SPLITTER, -1);\n            if (keyValuePair.length !== 2) {\n                continue;\n            }\n            let [key, value] = keyValuePair;\n            // Leading and trailing whitespaces are trimmed.\n            key = key.trim();\n            value = value.trim().split('^\"|\"$').join('');\n            if (!this._isValidAndNotEmpty(key)) {\n                throw new Error(`Attribute key ${this._ERROR_MESSAGE_INVALID_CHARS}`);\n            }\n            if (!this._isValid(value)) {\n                throw new Error(`Attribute value ${this._ERROR_MESSAGE_INVALID_VALUE}`);\n            }\n            attributes[key] = value;\n        }\n        return attributes;\n    }\n    /**\n     * Determines whether the given String is a valid printable ASCII string with\n     * a length not exceed _MAX_LENGTH characters.\n     *\n     * @param str The String to be validated.\n     * @returns Whether the String is valid.\n     */\n    _isValid(name) {\n        return name.length <= this._MAX_LENGTH && this._isPrintableString(name);\n    }\n    _isPrintableString(str) {\n        for (let i = 0; i < str.length; i++) {\n            const ch = str.charAt(i);\n            if (ch <= ' ' || ch >= '~') {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Determines whether the given String is a valid printable ASCII string with\n     * a length greater than 0 and not exceed _MAX_LENGTH characters.\n     *\n     * @param str The String to be validated.\n     * @returns Whether the String is valid and not empty.\n     */\n    _isValidAndNotEmpty(str) {\n        return str.length > 0 && this._isValid(str);\n    }\n}\nexports.envDetector = new EnvDetector();\n//# sourceMappingURL=EnvDetector.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.processDetector = void 0;\nconst __1 = require(\"../../../\");\n/**\n * ProcessDetector will be used to detect the resoureces related current process running\n * and being instumented from the NodeJS Process module.\n */\nclass ProcessDetector {\n    async detect(config) {\n        const processResource = {\n            [__1.PROCESS_RESOURCE.PID]: process.pid,\n            [__1.PROCESS_RESOURCE.NAME]: process.title || '',\n            [__1.PROCESS_RESOURCE.COMMAND]: process.argv[1] || '',\n            [__1.PROCESS_RESOURCE.COMMAND_LINE]: process.argv.join(' ') || '',\n        };\n        return this._getResourceAttributes(processResource, config);\n    }\n    /**\n     * Validates process resource attribute map from process varaibls\n     *\n     * @param processResource The unsantized resource attributes from process as key/value pairs.\n     * @param config: Config\n     * @returns The sanitized resource attributes.\n     */\n    _getResourceAttributes(processResource, config) {\n        if (processResource[__1.PROCESS_RESOURCE.NAME] === '' ||\n            processResource[__1.PROCESS_RESOURCE.PATH] === '' ||\n            processResource[__1.PROCESS_RESOURCE.COMMAND] === '' ||\n            processResource[__1.PROCESS_RESOURCE.COMMAND_LINE] === '') {\n            config.logger.debug('ProcessDetector failed: Unable to find required process resources. ');\n            return __1.Resource.empty();\n        }\n        else {\n            return new __1.Resource(Object.assign({}, processResource));\n        }\n    }\n}\nexports.processDetector = new ProcessDetector();\n//# sourceMappingURL=ProcessDetector.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./EnvDetector\"), exports);\n__exportStar(require(\"./ProcessDetector\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./detect-resources\"), exports);\n__exportStar(require(\"./detectors\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=types.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./trace\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DatabaseAttribute = void 0;\n/**\n * Database attribute names defined by the Opetelemetry Semantic Conventions specification\n * https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/database.md\n */\nexports.DatabaseAttribute = {\n    // Connection-level attributes\n    /**\n     * An identifier for the database management system (DBMS) product being used.\n     *\n     * @remarks\n     * Required.\n     */\n    DB_SYSTEM: 'db.system',\n    /**\n     * The connection string used to connect to the database.\n     * It is recommended to remove embedded credentials.\n     *\n     * @remarks\n     * Optional.\n     */\n    DB_CONNECTION_STRING: 'db.connection_string',\n    /**\n     * Username for accessing the database, e.g., \"readonly_user\" or \"reporting_user\".\n     *\n     * @remarks\n     * Optional.\n     */\n    DB_USER: 'db.user',\n    // Please see ./general.ts for NET_PEER_NAME, NET_PEER_IP, NET_PEER_PORT, NET_TRANSPORT\n    // Call-level attributes\n    /**\n     * If no [tech-specific attribute](https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/database.md#call-level-attributes-for-specific-technologies)\n     * is defined in the list below,\n     * this attribute is used to report the name of the database being accessed.\n     * For commands that switch the database,this should be set to the\n     * target database (even if the command fails).\n     *\n     * @remarks\n     * Required if applicable and no more specific attribute is defined.\n     */\n    DB_NAME: 'db.name',\n    /**\n     * The database statement being executed.\n     * Note that the value may be sanitized to exclude sensitive information.\n     * E.g., for db.system=\"other_sql\", \"SELECT * FROM wuser_table\";\n     * for db.system=\"redis\", \"SET mykey 'WuValue'\".\n     *\n     * @remarks\n     * Required if applicable.\n     */\n    DB_STATEMENT: 'db.statement',\n    /**\n     * The name of the operation being executed,\n     * e.g. the MongoDB command name such as findAndModify.\n     * While it would semantically make sense to set this,\n     * e.g., to an SQL keyword like SELECT or INSERT,\n     * it is not recommended to attempt any client-side parsing of\n     * db.statement just to get this property (the back end can do that if required).\n     *\n     * @remarks\n     * Required if db.statement is not applicable.\n     */\n    DB_OPERATION: 'db.operation',\n    // Connection-level attributes for specific technologies\n    /**\n     * The instance name connecting to.\n     * This name is used to determine the port of a named instance.\n     *\n     * @remarks\n     * If setting a `db.mssql.instance_name`,\n     * `net.peer.port` is no longer required (but still recommended if non-standard)\n     */\n    DB_MSSSQL_INSTANCE_NAME: 'db.mssql.instance_name',\n    /**\n     * The fully-qualified class name of the Java Database Connectivity (JDBC) driver used to connect,\n     * e.g., \"org.postgresql.Driver\" or \"com.microsoft.sqlserver.jdbc.SQLServerDriver\".\n     *\n     * @remarks\n     * Optional.\n     */\n    DB_JDBC_DRIVER_CLASSNAME: 'db.jdbc.driver_classname',\n    // Call-level attributes for specific technologies\n    /**\n     * The name of the keyspace being accessed. To be used instead of the generic db.name attribute.\n     *\n     * @remarks\n     * Required.\n     */\n    DB_CASSANDRA_KEYSPACE: 'db.cassandra.keyspace',\n    /**\n     * The [HBase namespace](https://hbase.apache.org/book.html#_namespace) being accessed.\n     * To be used instead of the generic db.name attribute.\n     *\n     * @remarks\n     * Required.\n     */\n    DB_HBASE_NAMESPACE: 'db.hbase.namespace',\n    /**\n     * The index of the database being accessed as used in the [SELECT command](https://redis.io/commands/select),\n     * provided as an integer. To be used instead of the generic db.name attribute.\n     *\n     * @remarks\n     * Required if other than the default database (0).\n     */\n    DB_REDIS_DATABASE_INDEX: 'db.redis.database_index',\n    /**\n     * The collection being accessed within the database stated in db.name.\n     *\n     * @remarks\n     * Required.\n     */\n    DB_MONGODB_COLLECTION: 'db.mongodb.collection',\n    // Not in spec.\n    /** Deprecated. Not in spec. */\n    DB_TYPE: 'db.type',\n    /** Deprecated. Not in spec. */\n    DB_INSTANCE: 'db.instance',\n    /** Deprecated. Not in spec. */\n    DB_URL: 'db.url',\n};\n//# sourceMappingURL=database.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ExceptionEventName = exports.ExceptionAttribute = void 0;\nexports.ExceptionAttribute = {\n    MESSAGE: 'exception.message',\n    STACKTRACE: 'exception.stacktrace',\n    TYPE: 'exception.type',\n};\nexports.ExceptionEventName = 'exception';\n//# sourceMappingURL=exception.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FaasAttribute = void 0;\n/**\n * FaaS (Function as a Service) attribute names defined by the Opetelemetry Semantic Conventions specification\n * https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/faas.md\n */\nexports.FaasAttribute = {\n    // General attributes\n    /**\n     * The name of the function being executed.\n     *\n     * @remarks\n     * Required.\n     */\n    FAAS_NAME: 'faas.name',\n    /**\n     * The unique ID of the function being executed.\n     * For example, in AWS Lambda this field corresponds to the ARN value, in GCP to the URI of the resource, and in Azure to the FunctionDirectory field.\n     *\n     * @remarks\n     * Required.\n     */\n    FAAS_ID: 'faas.id',\n    /**\n     * The version string of the function being executed.\n     *\n     * @remarks\n     * Optional.\n     */\n    FAAS_VERSION: 'faas.version',\n    /**\n     * The execution environment ID as a string.\n     *\n     * @remarks\n     * Optional.\n     */\n    FAAS_INSTANCE: 'faas.instance',\n    /**\n     * Type of the trigger on which the function is executed.\n     * Possible values: datasource, http, pubsub, timer, other\n     *\n     * @remarks\n     * Required if applicable.\n     */\n    FAAS_TRIGGER: 'faas.trigger',\n    /**\n     * The execution ID of the current function execution.\n     *\n     * @remarks\n     * Optional.\n     */\n    FAAS_EXECUTION: 'faas.execution',\n    // Incoming Invocations\n    /**\n     * A boolean that is true if the serverless function is executed for the first time (aka cold-start).\n     *\n     * @remarks\n     * Optional.\n     */\n    FAAS_COLD_START: 'faas.coldstart',\n    // Outgoing Invocations\n    // This section describes outgoing FaaS invocations as they are reported by a client calling a FaaS instance.\n    /**\n     * The name of the invoked function.\n     * SHOULD be equal to the faas.name resource attribute of the invoked function.\n     *\n     * @remarks\n     * Optional.\n     */\n    FAAS_INVOKED_NAME: 'faas.invoked_name',\n    /**\n     * The cloud provider of the invoked function.\n     * SHOULD be equal to the cloud.provider resource attribute of the invoked function.\n     *\n     * @remarks\n     * Optional.\n     */\n    FAAS_INVOKED_PROVIDER: 'faas.invoked_provider',\n    /**\n     * The cloud region of the invoked function.\n     *  SHOULD be equal to the cloud.region resource attribute of the invoked function.\n     *\n     * @remarks\n     * Optional.\n     */\n    FAAS_INVOKED_REGION: 'faas.invoked_region',\n    // Datesource Trigger\n    /**\n     * The name of the source on which the triggering operation was performed.\n     * For example, in Cloud Storage or S3 corresponds to the bucket name, and in Cosmos DB to the database name.\n     *\n     * @remarks\n     * Required if applicable.\n     */\n    FAAS_DOC_COLLECTION: 'faas.document.collection',\n    /**\n     * Describes the type of the operation that was performed on the data.\n     * MUST be one of the following or, if none of the listed values apply, a custom value: insert, edit, delete\n     *\n     * @remarks\n     * Required if applicable.\n     */\n    FAAS_DOC_OPERATION: 'faas.document.operation',\n    /**\n     * A string containing the time when the data was accessed in the ISO 8601 format expressed in UTC.\n     *\n     * @remarks\n     * Required if applicable.\n     */\n    FAAS_DOC_TIME: 'faas.document.time',\n    /**\n     * The document name/table subjected to the operation.\n     * For example, in Cloud Storage or S3 is the name of the file, and in Cosmos DB the table name.\n     *\n     * @remarks\n     * Optional.\n     */\n    FAAS_DOC_NAME: 'faas.document.name',\n    // Timer Trigger\n    /**\n     * A string containing the function invocation time in the ISO 8601 format expressed in UTC.\n     * Example: \"2020-01-23T13:47:06Z\"\n     *\n     * @remarks\n     * Required if applicable.\n     */\n    FAAS_TIME: 'faas.time',\n    /**\n     * A string containing the schedule period as Cron Expression.\n     * Example: \"0/5 * * * ? *\"\n     *\n     * @remarks\n     * Optional.\n     */\n    FAAS_CRON: 'faas.cron',\n};\n//# sourceMappingURL=faas.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GeneralAttribute = void 0;\n/**\n * General purpose networking attributes defined by the OpenTelemetry Semantic Conventions Specification\n * https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/span-general.md\n */\nexports.GeneralAttribute = {\n    NET_PEER_IP: 'net.peer.ip',\n    NET_PEER_ADDRESS: 'net.peer.address',\n    NET_PEER_HOSTNAME: 'net.peer.host',\n    NET_PEER_PORT: 'net.peer.port',\n    NET_PEER_NAME: 'net.peer.name',\n    NET_PEER_IPV4: 'net.peer.ipv4',\n    NET_PEER_IPV6: 'net.peer.ipv6',\n    NET_PEER_SERVICE: 'net.peer.service',\n    NET_HOST_IP: 'net.host.ip',\n    NET_HOST_PORT: 'net.host.port',\n    NET_HOST_NAME: 'net.host.name',\n    NET_TRANSPORT: 'net.transport',\n    // These are used as potential values to NET_TRANSPORT\n    IP_TCP: 'IP.TCP',\n    IP_UDP: 'IP.UDP',\n    INPROC: 'inproc',\n};\n//# sourceMappingURL=general.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HttpAttribute = void 0;\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexports.HttpAttribute = {\n    HTTP_HOST: 'http.host',\n    HTTP_METHOD: 'http.method',\n    HTTP_TARGET: 'http.target',\n    HTTP_ROUTE: 'http.route',\n    HTTP_URL: 'http.url',\n    HTTP_STATUS_CODE: 'http.status_code',\n    HTTP_STATUS_TEXT: 'http.status_text',\n    HTTP_FLAVOR: 'http.flavor',\n    HTTP_SERVER_NAME: 'http.server_name',\n    HTTP_CLIENT_IP: 'http.client_ip',\n    HTTP_SCHEME: 'http.scheme',\n    HTTP_RESPONSE_CONTENT_LENGTH: 'http.response_content_length',\n    HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED: 'http.response_content_length_uncompressed',\n    HTTP_REQUEST_CONTENT_LENGTH: 'http.request_content_length',\n    HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED: 'http.request_content_length_uncompressed',\n    // NOT ON OFFICIAL SPEC\n    HTTP_ERROR_NAME: 'http.error_name',\n    HTTP_ERROR_MESSAGE: 'http.error_message',\n    HTTP_USER_AGENT: 'http.user_agent',\n};\n//# sourceMappingURL=http.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./database\"), exports);\n__exportStar(require(\"./exception\"), exports);\n__exportStar(require(\"./general\"), exports);\n__exportStar(require(\"./http\"), exports);\n__exportStar(require(\"./os\"), exports);\n__exportStar(require(\"./rpc\"), exports);\n__exportStar(require(\"./faas\"), exports);\n__exportStar(require(\"./messaging\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MessagingOperationName = exports.MessagingAttribute = void 0;\n/**\n * messaging attribute names defined by the Opetelemetry Semantic Conventions specification\n * https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/messaging.md\n */\nexports.MessagingAttribute = {\n    /**\n     * A string identifying the messaging system.\n     * example: kafka, rabbitmq, sqs, sns\n     *\n     * @remarks\n     * Required.\n     */\n    MESSAGING_SYSTEM: 'messaging.system',\n    /**\n     * The message destination name. This might be equal to the span name but is required nevertheless.\n     * example: MyQueue, MyTopic\n     *\n     * @remarks\n     * Required.\n     */\n    MESSAGING_DESTINATION: 'messaging.destination',\n    /**\n     * The kind of message destination\n     * allowed values: queue, topic,\n     *\n     * @remarks\n     * Required only if the message destination is either a queue or topic.\n     */\n    MESSAGING_DESTINATION_KIND: 'messaging.destination_kind',\n    /**\n     * A boolean that is true if the message destination is temporary\n     *\n     * @remarks\n     * Conditional If missing, it is assumed to be false.\n     */\n    MESSAGING_TEMP_DESTINATION: 'messaging.temp_destination',\n    /**\n     * The kind of message destination\n     * allowed values: queue, topic,\n     *\n     * @remarks\n     * Required only if the message destination is either a queue or topic.\n     */\n    MESSAGING_PROTOCOL: 'messaging.protocol',\n    /**\n     * The version of the transport protocol.\n     *\n     * @remarks\n     * Optional.\n     */\n    MESSAGING_PROTOCOL_VERSION: 'messaging.protocol_version',\n    /**\n     * Connection string.\n     * example: https://queue.amazonaws.com/80398EXAMPLE/MyQueue\n     *\n     * @remarks\n     * Optional.\n     */\n    MESSAGING_URL: 'messaging.url',\n    /**\n     * A value used by the messaging system as an identifier for the message, represented as a string.\n     *\n     * @remarks\n     * Optional.\n     */\n    MESSAGING_MESSAGE_ID: 'messaging.message_id',\n    /**\n     * The conversation ID identifying the conversation to which the message belongs, represented as a string. Sometimes called \"Correlation ID\".\n     *\n     * @remarks\n     * Optional.\n     */\n    MESSAGING_CONVERSATION_ID: 'messaging.conversation_id',\n    /**\n     * The (uncompressed) size of the message payload in bytes. Also use this attribute if it is unknown whether the compressed or uncompressed payload size is reported.\n     * Should be number.\n     *\n     * @remarks\n     * Optional.\n     */\n    MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES: 'messaging.message_payload_size_bytes',\n    /**\n     * The compressed size of the message payload in bytes.\n     * Should be number.\n     *\n     * @remarks\n     * Optional.\n     */\n    MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES: 'messaging.message_payload_compressed_size_bytes',\n    /**\n     * For message consumers only.\n     * allowed values: receive, process,\n     *\n     * @remarks\n     * Optional.\n     */\n    MESSAGING_OPERATION: 'messaging.operation',\n    // System specific attributes\n    MESSAGING_RABBITMQ_ROUTING_KEY: 'messaging.rabbitmq.routing_key',\n    MESSAGING_KAFKA_MESSAGE_KEY: 'messaging.kafka.message_key',\n    MESSAGING_KAFKA_CONSUMER_GROUP: 'messaging.kafka.consumer_group',\n    MESSAGING_KAFKA_CLIENT_ID: 'messaging.kafka.client_id',\n    MESSAGING_KAFKA_PARTITION: 'messaging.kafka.partition',\n    MESSAGING_KAFKA_TOMBSTONE: 'messaging.kafka.tombstone',\n};\nexports.MessagingOperationName = {\n    /**\n     *  A message is sent to a destination by a message producer/client.\n     */\n    SEND: 'send',\n    /**\n     *  A message is received from a destination by a message consumer/server.\n     */\n    RECEIVE: 'receive',\n    /**\n     *  A message that was previously received from a destination is processed by a message consumer/server.\n     */\n    PROCESS: 'process',\n};\n//# sourceMappingURL=messaging.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OperatingSystemValues = exports.OperatingSystem = void 0;\n/**\n * The operating system (OS) on which the process represented by this resource is running.\n *\n * In case of virtualized environments, this is the operating system as it\n * is observed by the process, i.e., the virtualized guest rather than the\n * underlying host.\n * https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/resource/semantic_conventions/os.md\n */\nexports.OperatingSystem = {\n    /**\n     * The operating system type.\n     * This should be set to one of {@link OperatingSystemValues}\n     * E.g., \"WINDOWS\"\n     *\n     * @remarks\n     * Required.\n     */\n    TYPE: 'os.type',\n    /**\n     * Human readable (not intended to be parsed) OS version information.\n     * E.g., \"Microsoft Windows [Version 10.0.18363.778]\"\n     *\n     * @remarks\n     * Required if applicable.\n     */\n    DESCRIPTION: 'os.description',\n};\n/**\n * {@link OperatingSystem.TYPE} SHOULD be set to one of the values\n * listed below.\n * If none of the listed values apply, a custom value best describing\n * the family the operating system belongs to CAN be used.\n */\nexports.OperatingSystemValues = {\n    WINDOWS: 'WINDOWS',\n    LINUX: 'LINUX',\n    DARWIN: 'DARWIN',\n    FREEBSD: 'FREEBSD',\n    NETBSD: 'NETBSD',\n    OPENBSD: 'OPENBSD',\n    DRAGONFLYBSD: 'DRAGONFLYBSD',\n    HPUX: 'HPUX',\n    AIX: 'AIX',\n    SOLARIS: 'SOLARIS',\n    ZOS: 'ZOS',\n};\n//# sourceMappingURL=os.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RpcAttribute = void 0;\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexports.RpcAttribute = {\n    RPC_SERVICE: 'rpc.service',\n    // GRPC (no spec)\n    GRPC_KIND: 'grpc.kind',\n    GRPC_METHOD: 'grpc.method',\n    GRPC_STATUS_CODE: 'grpc.status_code',\n    GRPC_ERROR_NAME: 'grpc.error_name',\n    GRPC_ERROR_MESSAGE: 'grpc.error_message',\n};\n//# sourceMappingURL=rpc.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BasicTracerProvider = void 0;\nconst api = require(\"@opentelemetry/api\");\nconst core_1 = require(\"@opentelemetry/core\");\nconst _1 = require(\".\");\nconst config_1 = require(\"./config\");\nconst MultiSpanProcessor_1 = require(\"./MultiSpanProcessor\");\nconst NoopSpanProcessor_1 = require(\"./NoopSpanProcessor\");\nconst resources_1 = require(\"@opentelemetry/resources\");\n/**\n * This class represents a basic tracer provider which platform libraries can extend\n */\nclass BasicTracerProvider {\n    constructor(config = config_1.DEFAULT_CONFIG) {\n        var _a, _b;\n        this._registeredSpanProcessors = [];\n        this._tracers = new Map();\n        this.activeSpanProcessor = new NoopSpanProcessor_1.NoopSpanProcessor();\n        this.logger = (_a = config.logger) !== null && _a !== void 0 ? _a : new core_1.ConsoleLogger(config.logLevel);\n        this.resource = (_b = config.resource) !== null && _b !== void 0 ? _b : resources_1.Resource.createTelemetrySDKResource();\n        this._config = Object.assign({}, config, {\n            logger: this.logger,\n            resource: this.resource,\n        });\n    }\n    getTracer(name, version = '*', config) {\n        const key = `${name}@${version}`;\n        if (!this._tracers.has(key)) {\n            this._tracers.set(key, new _1.Tracer({ name, version }, config || this._config, this));\n        }\n        return this._tracers.get(key);\n    }\n    /**\n     * Adds a new {@link SpanProcessor} to this tracer.\n     * @param spanProcessor the new SpanProcessor to be added.\n     */\n    addSpanProcessor(spanProcessor) {\n        this._registeredSpanProcessors.push(spanProcessor);\n        this.activeSpanProcessor = new MultiSpanProcessor_1.MultiSpanProcessor(this._registeredSpanProcessors);\n    }\n    getActiveSpanProcessor() {\n        return this.activeSpanProcessor;\n    }\n    /**\n     * Register this TracerProvider for use with the OpenTelemetry API.\n     * Undefined values may be replaced with defaults, and\n     * null values will be skipped.\n     *\n     * @param config Configuration object for SDK registration\n     */\n    register(config = {}) {\n        api.trace.setGlobalTracerProvider(this);\n        if (config.propagator === undefined) {\n            config.propagator = new core_1.CompositePropagator({\n                propagators: [new core_1.HttpBaggage(), new core_1.HttpTraceContext()],\n            });\n        }\n        if (config.contextManager) {\n            api.context.setGlobalContextManager(config.contextManager);\n        }\n        if (config.propagator) {\n            api.propagation.setGlobalPropagator(config.propagator);\n        }\n    }\n    shutdown() {\n        return this.activeSpanProcessor.shutdown();\n    }\n}\nexports.BasicTracerProvider = BasicTracerProvider;\n//# sourceMappingURL=BasicTracerProvider.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MultiSpanProcessor = void 0;\nconst core_1 = require(\"@opentelemetry/core\");\n/**\n * Implementation of the {@link SpanProcessor} that simply forwards all\n * received events to a list of {@link SpanProcessor}s.\n */\nclass MultiSpanProcessor {\n    constructor(_spanProcessors) {\n        this._spanProcessors = _spanProcessors;\n    }\n    forceFlush() {\n        const promises = [];\n        for (const spanProcessor of this._spanProcessors) {\n            promises.push(spanProcessor.forceFlush());\n        }\n        return new Promise(resolve => {\n            Promise.all(promises)\n                .then(() => {\n                resolve();\n            })\n                .catch(error => {\n                core_1.globalErrorHandler(error || new Error('MultiSpanProcessor: forceFlush failed'));\n                resolve();\n            });\n        });\n    }\n    onStart(span, context) {\n        for (const spanProcessor of this._spanProcessors) {\n            spanProcessor.onStart(span, context);\n        }\n    }\n    onEnd(span) {\n        for (const spanProcessor of this._spanProcessors) {\n            spanProcessor.onEnd(span);\n        }\n    }\n    shutdown() {\n        const promises = [];\n        for (const spanProcessor of this._spanProcessors) {\n            promises.push(spanProcessor.shutdown());\n        }\n        return new Promise((resolve, reject) => {\n            Promise.all(promises).then(() => {\n                resolve();\n            }, reject);\n        });\n    }\n}\nexports.MultiSpanProcessor = MultiSpanProcessor;\n//# sourceMappingURL=MultiSpanProcessor.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NoopSpanProcessor = void 0;\n/** No-op implementation of SpanProcessor */\nclass NoopSpanProcessor {\n    onStart(_span, _context) { }\n    onEnd(_span) { }\n    shutdown() {\n        return Promise.resolve();\n    }\n    forceFlush() {\n        return Promise.resolve();\n    }\n}\nexports.NoopSpanProcessor = NoopSpanProcessor;\n//# sourceMappingURL=NoopSpanProcessor.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Span = void 0;\nconst api = require(\"@opentelemetry/api\");\nconst core_1 = require(\"@opentelemetry/core\");\nconst semantic_conventions_1 = require(\"@opentelemetry/semantic-conventions\");\n/**\n * This class represents a span.\n */\nclass Span {\n    /** Constructs a new Span instance. */\n    constructor(parentTracer, context, spanName, spanContext, kind, parentSpanId, links = [], startTime = core_1.hrTime()) {\n        this.attributes = {};\n        this.links = [];\n        this.events = [];\n        this.status = {\n            code: api.StatusCode.UNSET,\n        };\n        this.endTime = [0, 0];\n        this._ended = false;\n        this._duration = [-1, -1];\n        this.name = spanName;\n        this.spanContext = spanContext;\n        this.parentSpanId = parentSpanId;\n        this.kind = kind;\n        this.links = links;\n        this.startTime = core_1.timeInputToHrTime(startTime);\n        this.resource = parentTracer.resource;\n        this.instrumentationLibrary = parentTracer.instrumentationLibrary;\n        this._logger = parentTracer.logger;\n        this._traceParams = parentTracer.getActiveTraceParams();\n        this._spanProcessor = parentTracer.getActiveSpanProcessor();\n        this._spanProcessor.onStart(this, context);\n    }\n    context() {\n        return this.spanContext;\n    }\n    setAttribute(key, value) {\n        if (value == null || this._isSpanEnded())\n            return this;\n        if (key.length === 0) {\n            this._logger.warn(`Invalid attribute key: ${key}`);\n            return this;\n        }\n        if (!core_1.isAttributeValue(value)) {\n            this._logger.warn(`Invalid attribute value set for key: ${key}`);\n            return this;\n        }\n        if (Object.keys(this.attributes).length >=\n            this._traceParams.numberOfAttributesPerSpan &&\n            !Object.prototype.hasOwnProperty.call(this.attributes, key)) {\n            return this;\n        }\n        this.attributes[key] = value;\n        return this;\n    }\n    setAttributes(attributes) {\n        for (const [k, v] of Object.entries(attributes)) {\n            this.setAttribute(k, v);\n        }\n        return this;\n    }\n    /**\n     *\n     * @param name Span Name\n     * @param [attributesOrStartTime] Span attributes or start time\n     *     if type is {@type TimeInput} and 3rd param is undefined\n     * @param [startTime] Specified start time for the event\n     */\n    addEvent(name, attributesOrStartTime, startTime) {\n        if (this._isSpanEnded())\n            return this;\n        if (this.events.length >= this._traceParams.numberOfEventsPerSpan) {\n            this._logger.warn('Dropping extra events.');\n            this.events.shift();\n        }\n        if (core_1.isTimeInput(attributesOrStartTime)) {\n            if (typeof startTime === 'undefined') {\n                startTime = attributesOrStartTime;\n            }\n            attributesOrStartTime = undefined;\n        }\n        if (typeof startTime === 'undefined') {\n            startTime = core_1.hrTime();\n        }\n        this.events.push({\n            name,\n            attributes: attributesOrStartTime,\n            time: core_1.timeInputToHrTime(startTime),\n        });\n        return this;\n    }\n    setStatus(status) {\n        if (this._isSpanEnded())\n            return this;\n        this.status = status;\n        return this;\n    }\n    updateName(name) {\n        if (this._isSpanEnded())\n            return this;\n        this.name = name;\n        return this;\n    }\n    end(endTime = core_1.hrTime()) {\n        if (this._isSpanEnded()) {\n            this._logger.error('You can only call end() on a span once.');\n            return;\n        }\n        this._ended = true;\n        this.endTime = core_1.timeInputToHrTime(endTime);\n        this._duration = core_1.hrTimeDuration(this.startTime, this.endTime);\n        if (this._duration[0] < 0) {\n            this._logger.warn('Inconsistent start and end time, startTime > endTime', this.startTime, this.endTime);\n        }\n        this._spanProcessor.onEnd(this);\n    }\n    isRecording() {\n        return this._ended === false;\n    }\n    recordException(exception, time = core_1.hrTime()) {\n        const attributes = {};\n        if (typeof exception === 'string') {\n            attributes[semantic_conventions_1.ExceptionAttribute.MESSAGE] = exception;\n        }\n        else if (exception) {\n            if (exception.code) {\n                attributes[semantic_conventions_1.ExceptionAttribute.TYPE] = exception.code;\n            }\n            else if (exception.name) {\n                attributes[semantic_conventions_1.ExceptionAttribute.TYPE] = exception.name;\n            }\n            if (exception.message) {\n                attributes[semantic_conventions_1.ExceptionAttribute.MESSAGE] = exception.message;\n            }\n            if (exception.stack) {\n                attributes[semantic_conventions_1.ExceptionAttribute.STACKTRACE] = exception.stack;\n            }\n        }\n        // these are minimum requirements from spec\n        if (attributes[semantic_conventions_1.ExceptionAttribute.TYPE] ||\n            attributes[semantic_conventions_1.ExceptionAttribute.MESSAGE]) {\n            this.addEvent(semantic_conventions_1.ExceptionEventName, attributes, time);\n        }\n        else {\n            this._logger.warn(`Failed to record an exception ${exception}`);\n        }\n    }\n    get duration() {\n        return this._duration;\n    }\n    get ended() {\n        return this._ended;\n    }\n    _isSpanEnded() {\n        if (this._ended) {\n            this._logger.warn('Can not execute the operation on ended Span {traceId: %s, spanId: %s}', this.spanContext.traceId, this.spanContext.spanId);\n        }\n        return this._ended;\n    }\n}\nexports.Span = Span;\n//# sourceMappingURL=Span.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=SpanProcessor.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Tracer = void 0;\nconst api = require(\"@opentelemetry/api\");\nconst core_1 = require(\"@opentelemetry/core\");\nconst Span_1 = require(\"./Span\");\nconst utility_1 = require(\"./utility\");\n/**\n * This class represents a basic tracer.\n */\nclass Tracer {\n    /**\n     * Constructs a new Tracer instance.\n     */\n    constructor(instrumentationLibrary, config, _tracerProvider) {\n        this._tracerProvider = _tracerProvider;\n        const localConfig = utility_1.mergeConfig(config);\n        this._sampler = localConfig.sampler;\n        this._traceParams = localConfig.traceParams;\n        this._idGenerator = config.idGenerator || new core_1.RandomIdGenerator();\n        this.resource = _tracerProvider.resource;\n        this.instrumentationLibrary = instrumentationLibrary;\n        this.logger = config.logger || new core_1.ConsoleLogger(config.logLevel);\n    }\n    /**\n     * Starts a new Span or returns the default NoopSpan based on the sampling\n     * decision.\n     */\n    startSpan(name, options = {}, context = api.context.active()) {\n        var _a, _b;\n        if (api.isInstrumentationSuppressed(context)) {\n            this.logger.debug('Instrumentation suppressed, returning Noop Span');\n            return api.NOOP_SPAN;\n        }\n        const parentContext = getParent(options, context);\n        const spanId = this._idGenerator.generateSpanId();\n        let traceId;\n        let traceState;\n        if (!parentContext || !api.trace.isSpanContextValid(parentContext)) {\n            // New root span.\n            traceId = this._idGenerator.generateTraceId();\n        }\n        else {\n            // New child span.\n            traceId = parentContext.traceId;\n            traceState = parentContext.traceState;\n        }\n        const spanKind = (_a = options.kind) !== null && _a !== void 0 ? _a : api.SpanKind.INTERNAL;\n        const links = (_b = options.links) !== null && _b !== void 0 ? _b : [];\n        const attributes = core_1.sanitizeAttributes(options.attributes);\n        // make sampling decision\n        const samplingResult = this._sampler.shouldSample(context, traceId, name, spanKind, attributes, links);\n        const traceFlags = samplingResult.decision === api.SamplingDecision.RECORD_AND_SAMPLED\n            ? api.TraceFlags.SAMPLED\n            : api.TraceFlags.NONE;\n        const spanContext = { traceId, spanId, traceFlags, traceState };\n        if (samplingResult.decision === api.SamplingDecision.NOT_RECORD) {\n            this.logger.debug('Recording is off, starting no recording span');\n            return new core_1.NoRecordingSpan(spanContext);\n        }\n        const span = new Span_1.Span(this, context, name, spanContext, spanKind, parentContext ? parentContext.spanId : undefined, links, options.startTime);\n        // Set default attributes\n        span.setAttributes(Object.assign(attributes, samplingResult.attributes));\n        return span;\n    }\n    /**\n     * Returns the current Span from the current context.\n     *\n     * If there is no Span associated with the current context, undefined is returned.\n     */\n    getCurrentSpan() {\n        const ctx = api.context.active();\n        // Get the current Span from the context or null if none found.\n        return api.getActiveSpan(ctx);\n    }\n    /**\n     * Enters the context of code where the given Span is in the current context.\n     */\n    withSpan(span, fn) {\n        // Set given span to context.\n        return api.context.with(api.setActiveSpan(api.context.active(), span), fn);\n    }\n    /**\n     * Bind a span (or the current one) to the target's context\n     */\n    bind(target, span) {\n        return api.context.bind(target, span\n            ? api.setActiveSpan(api.context.active(), span)\n            : api.context.active());\n    }\n    /** Returns the active {@link TraceParams}. */\n    getActiveTraceParams() {\n        return this._traceParams;\n    }\n    getActiveSpanProcessor() {\n        return this._tracerProvider.getActiveSpanProcessor();\n    }\n}\nexports.Tracer = Tracer;\n/**\n * Get the parent to assign to a started span. If options.parent is null,\n * do not assign a parent.\n *\n * @param options span options\n * @param context context to check for parent\n */\nfunction getParent(options, context) {\n    if (options.root)\n        return undefined;\n    return api.getParentSpanContext(context);\n}\n//# sourceMappingURL=Tracer.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DEFAULT_CONFIG = void 0;\nconst core_1 = require(\"@opentelemetry/core\");\n/**\n * Default configuration. For fields with primitive values, any user-provided\n * value will override the corresponding default value. For fields with\n * non-primitive values (like `traceParams`), the user-provided value will be\n * used to extend the default value.\n */\nexports.DEFAULT_CONFIG = {\n    logLevel: core_1.getEnv().OTEL_LOG_LEVEL,\n    sampler: new core_1.AlwaysOnSampler(),\n    traceParams: {\n        numberOfAttributesPerSpan: core_1.getEnv().OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT,\n        numberOfLinksPerSpan: core_1.getEnv().OTEL_SPAN_LINK_COUNT_LIMIT,\n        numberOfEventsPerSpan: core_1.getEnv().OTEL_SPAN_EVENT_COUNT_LIMIT,\n    },\n};\n//# sourceMappingURL=config.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BatchSpanProcessor = void 0;\nconst api_1 = require(\"@opentelemetry/api\");\nconst core_1 = require(\"@opentelemetry/core\");\nconst DEFAULT_BUFFER_SIZE = 100;\nconst DEFAULT_BUFFER_TIMEOUT_MS = 20000;\n/**\n * Implementation of the {@link SpanProcessor} that batches spans exported by\n * the SDK then pushes them to the exporter pipeline.\n */\nclass BatchSpanProcessor {\n    constructor(_exporter, config) {\n        this._exporter = _exporter;\n        this._finishedSpans = [];\n        this._isShutdown = false;\n        this._shuttingDownPromise = Promise.resolve();\n        this._bufferSize =\n            config && config.bufferSize ? config.bufferSize : DEFAULT_BUFFER_SIZE;\n        this._bufferTimeout =\n            config && typeof config.bufferTimeout === 'number'\n                ? config.bufferTimeout\n                : DEFAULT_BUFFER_TIMEOUT_MS;\n    }\n    forceFlush() {\n        if (this._isShutdown) {\n            return this._shuttingDownPromise;\n        }\n        return this._flush();\n    }\n    // does nothing.\n    onStart(_span) { }\n    onEnd(span) {\n        if (this._isShutdown) {\n            return;\n        }\n        this._addToBuffer(span);\n    }\n    shutdown() {\n        if (this._isShutdown) {\n            return this._shuttingDownPromise;\n        }\n        this._isShutdown = true;\n        this._shuttingDownPromise = new Promise((resolve, reject) => {\n            Promise.resolve()\n                .then(() => {\n                return this._flush();\n            })\n                .then(() => {\n                return this._exporter.shutdown();\n            })\n                .then(resolve)\n                .catch(e => {\n                reject(e);\n            });\n        });\n        return this._shuttingDownPromise;\n    }\n    /** Add a span in the buffer. */\n    _addToBuffer(span) {\n        this._finishedSpans.push(span);\n        this._maybeStartTimer();\n        if (this._finishedSpans.length > this._bufferSize) {\n            this._flush().catch(e => {\n                core_1.globalErrorHandler(e);\n            });\n        }\n    }\n    /** Send the span data list to exporter */\n    _flush() {\n        this._clearTimer();\n        if (this._finishedSpans.length === 0) {\n            return Promise.resolve();\n        }\n        return new Promise((resolve, reject) => {\n            // prevent downstream exporter calls from generating spans\n            api_1.context.with(api_1.suppressInstrumentation(api_1.context.active()), () => {\n                // Reset the finished spans buffer here because the next invocations of the _flush method\n                // could pass the same finished spans to the exporter if the buffer is cleared\n                // outside of the execution of this callback.\n                this._exporter.export(this._finishedSpans.splice(0), result => {\n                    var _a;\n                    if (result.code === core_1.ExportResultCode.SUCCESS) {\n                        resolve();\n                    }\n                    else {\n                        reject((_a = result.error) !== null && _a !== void 0 ? _a : new Error('BatchSpanProcessor: span export failed'));\n                    }\n                });\n            });\n        });\n    }\n    _maybeStartTimer() {\n        if (this._timer !== undefined)\n            return;\n        this._timer = setTimeout(() => {\n            this._flush().catch(e => {\n                core_1.globalErrorHandler(e);\n            });\n        }, this._bufferTimeout);\n        core_1.unrefTimer(this._timer);\n    }\n    _clearTimer() {\n        if (this._timer !== undefined) {\n            clearTimeout(this._timer);\n            this._timer = undefined;\n        }\n    }\n}\nexports.BatchSpanProcessor = BatchSpanProcessor;\n//# sourceMappingURL=BatchSpanProcessor.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConsoleSpanExporter = void 0;\nconst core_1 = require(\"@opentelemetry/core\");\n/**\n * This is implementation of {@link SpanExporter} that prints spans to the\n * console. This class can be used for diagnostic purposes.\n */\nclass ConsoleSpanExporter {\n    /**\n     * Export spans.\n     * @param spans\n     * @param resultCallback\n     */\n    export(spans, resultCallback) {\n        return this._sendSpans(spans, resultCallback);\n    }\n    /**\n     * Shutdown the exporter.\n     */\n    shutdown() {\n        this._sendSpans([]);\n        return Promise.resolve();\n    }\n    /**\n     * converts span info into more readable format\n     * @param span\n     */\n    _exportInfo(span) {\n        return {\n            traceId: span.spanContext.traceId,\n            parentId: span.parentSpanId,\n            name: span.name,\n            id: span.spanContext.spanId,\n            kind: span.kind,\n            timestamp: core_1.hrTimeToMicroseconds(span.startTime),\n            duration: core_1.hrTimeToMicroseconds(span.duration),\n            attributes: span.attributes,\n            status: span.status,\n            events: span.events,\n        };\n    }\n    /**\n     * Showing spans in console\n     * @param spans\n     * @param done\n     */\n    _sendSpans(spans, done) {\n        for (const span of spans) {\n            console.log(this._exportInfo(span));\n        }\n        if (done) {\n            return done({ code: core_1.ExportResultCode.SUCCESS });\n        }\n    }\n}\nexports.ConsoleSpanExporter = ConsoleSpanExporter;\n//# sourceMappingURL=ConsoleSpanExporter.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InMemorySpanExporter = void 0;\nconst core_1 = require(\"@opentelemetry/core\");\n/**\n * This class can be used for testing purposes. It stores the exported spans\n * in a list in memory that can be retrieved using the `getFinishedSpans()`\n * method.\n */\nclass InMemorySpanExporter {\n    constructor() {\n        this._finishedSpans = [];\n        /**\n         * Indicates if the exporter has been \"shutdown.\"\n         * When false, exported spans will not be stored in-memory.\n         */\n        this._stopped = false;\n    }\n    export(spans, resultCallback) {\n        if (this._stopped)\n            return resultCallback({\n                code: core_1.ExportResultCode.FAILED,\n                error: new Error('Exporter has been stopped'),\n            });\n        this._finishedSpans.push(...spans);\n        setTimeout(() => resultCallback({ code: core_1.ExportResultCode.SUCCESS }), 0);\n    }\n    shutdown() {\n        this._stopped = true;\n        this._finishedSpans = [];\n        return Promise.resolve();\n    }\n    reset() {\n        this._finishedSpans = [];\n    }\n    getFinishedSpans() {\n        return this._finishedSpans;\n    }\n}\nexports.InMemorySpanExporter = InMemorySpanExporter;\n//# sourceMappingURL=InMemorySpanExporter.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=ReadableSpan.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SimpleSpanProcessor = void 0;\nconst api_1 = require(\"@opentelemetry/api\");\nconst core_1 = require(\"@opentelemetry/core\");\n/**\n * An implementation of the {@link SpanProcessor} that converts the {@link Span}\n * to {@link ReadableSpan} and passes it to the configured exporter.\n *\n * Only spans that are sampled are converted.\n */\nclass SimpleSpanProcessor {\n    constructor(_exporter) {\n        this._exporter = _exporter;\n        this._isShutdown = false;\n        this._shuttingDownPromise = Promise.resolve();\n    }\n    forceFlush() {\n        // do nothing as all spans are being exported without waiting\n        return Promise.resolve();\n    }\n    // does nothing.\n    onStart(_span) { }\n    onEnd(span) {\n        if (this._isShutdown) {\n            return;\n        }\n        // prevent downstream exporter calls from generating spans\n        api_1.context.with(api_1.suppressInstrumentation(api_1.context.active()), () => {\n            this._exporter.export([span], result => {\n                var _a;\n                if (result.code !== core_1.ExportResultCode.SUCCESS) {\n                    core_1.globalErrorHandler((_a = result.error) !== null && _a !== void 0 ? _a : new Error(`SimpleSpanProcessor: span export failed (status ${result})`));\n                }\n            });\n        });\n    }\n    shutdown() {\n        if (this._isShutdown) {\n            return this._shuttingDownPromise;\n        }\n        this._isShutdown = true;\n        this._shuttingDownPromise = new Promise((resolve, reject) => {\n            Promise.resolve()\n                .then(() => {\n                return this._exporter.shutdown();\n            })\n                .then(resolve)\n                .catch(e => {\n                reject(e);\n            });\n        });\n        return this._shuttingDownPromise;\n    }\n}\nexports.SimpleSpanProcessor = SimpleSpanProcessor;\n//# sourceMappingURL=SimpleSpanProcessor.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=SpanExporter.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./Tracer\"), exports);\n__exportStar(require(\"./BasicTracerProvider\"), exports);\n__exportStar(require(\"./export/ConsoleSpanExporter\"), exports);\n__exportStar(require(\"./export/BatchSpanProcessor\"), exports);\n__exportStar(require(\"./export/InMemorySpanExporter\"), exports);\n__exportStar(require(\"./export/ReadableSpan\"), exports);\n__exportStar(require(\"./export/SimpleSpanProcessor\"), exports);\n__exportStar(require(\"./export/SpanExporter\"), exports);\n__exportStar(require(\"./Span\"), exports);\n__exportStar(require(\"./SpanProcessor\"), exports);\n__exportStar(require(\"./types\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=types.js.map","\"use strict\";\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mergeConfig = void 0;\nconst config_1 = require(\"./config\");\nconst core_1 = require(\"@opentelemetry/core\");\n/**\n * Function to merge Default configuration (as specified in './config') with\n * user provided configurations.\n */\nfunction mergeConfig(userConfig) {\n    const otelSamplingProbability = core_1.getEnv().OTEL_SAMPLING_PROBABILITY;\n    const target = Object.assign({}, config_1.DEFAULT_CONFIG, \n    // use default AlwaysOnSampler if otelSamplingProbability is 1\n    otelSamplingProbability !== undefined && otelSamplingProbability < 1\n        ? {\n            sampler: new core_1.ParentBasedSampler({\n                root: new core_1.TraceIdRatioBasedSampler(otelSamplingProbability),\n            }),\n        }\n        : {}, userConfig);\n    target.traceParams = Object.assign({}, config_1.DEFAULT_CONFIG.traceParams, userConfig.traceParams || {});\n    return target;\n}\nexports.mergeConfig = mergeConfig;\n//# sourceMappingURL=utility.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.curves = void 0;\r\n/**\r\n * List of EC curves supported by the SSH ECDSA algorithm.\r\n */\r\nexports.curves = [\r\n    {\r\n        shortName: 'P-256',\r\n        name: 'nistp256',\r\n        oid: '1.2.840.10045.3.1.7',\r\n        keySize: 256,\r\n    },\r\n    {\r\n        shortName: 'P-384',\r\n        name: 'nistp384',\r\n        oid: '1.3.132.0.34',\r\n        keySize: 384,\r\n    },\r\n    {\r\n        shortName: 'P-521',\r\n        name: 'nistp521',\r\n        oid: '1.3.132.0.35',\r\n        keySize: 521,\r\n    },\r\n];\r\n//# sourceMappingURL=ecdsaCurves.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.EncryptionAlgorithm = void 0;\r\nclass EncryptionAlgorithm {\r\n    constructor(name) {\r\n        this.name = name;\r\n    }\r\n}\r\nexports.EncryptionAlgorithm = EncryptionAlgorithm;\r\n//# sourceMappingURL=encryptionAlgorithm.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.HmacAlgorithm = void 0;\r\nclass HmacAlgorithm {\r\n    constructor(name, algorithmName, keyLength, digestLength) {\r\n        this.name = name;\r\n        this.algorithmName = algorithmName;\r\n        this.keyLength = keyLength;\r\n        this.digestLength = digestLength;\r\n    }\r\n}\r\nexports.HmacAlgorithm = HmacAlgorithm;\r\n//# sourceMappingURL=hmacAlgorithm.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.KeyExchangeAlgorithm = void 0;\r\nclass KeyExchangeAlgorithm {\r\n    constructor(name, keySizeInBits, hashAlgorithmName, hashDigestLength) {\r\n        this.name = name;\r\n        this.keySizeInBits = keySizeInBits;\r\n        this.hashAlgorithmName = hashAlgorithmName;\r\n        this.hashDigestLength = hashDigestLength;\r\n    }\r\n}\r\nexports.KeyExchangeAlgorithm = KeyExchangeAlgorithm;\r\n//# sourceMappingURL=keyExchangeAlgorithm.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Sec1KeyFormatter = exports.Pkcs1KeyFormatter = exports.parsePem = exports.formatPem = void 0;\r\nconst bigInt_1 = require(\"../../io/bigInt\");\r\nconst derData_1 = require(\"../../io/derData\");\r\nconst ecdsaCurves_1 = require(\"../ecdsaCurves\");\r\nfunction formatPem(keyBytes, name) {\r\n    const key = `-----BEGIN ${name}-----\\n` +\r\n        keyBytes\r\n            .toString('base64')\r\n            .match(/.{1,64}/g)\r\n            .join('\\n') +\r\n        '\\n' +\r\n        `-----END ${name}-----\\n`;\r\n    return key;\r\n}\r\nexports.formatPem = formatPem;\r\nfunction parsePem(key) {\r\n    const keyBase64 = key.replace(/-+[^-\\n]+KEY-+/g, '').replace(/\\s/g, '');\r\n    const keyBytes = Buffer.from(keyBase64, 'base64');\r\n    return keyBytes;\r\n}\r\nexports.parsePem = parsePem;\r\n/**\r\n * Provides *minimal* PKCS#1 import/export support for Node.js keys.\r\n *\r\n * This code is redundant with some of the PKCS#1 import/export code in the separate\r\n * `ssh-keys` library; that is intentional, and necessary to support a consistent\r\n * interface for importing/exporting key parameters in the core `ssh` library.\r\n */\r\nclass Pkcs1KeyFormatter {\r\n    static formatRsaPublic(rsa) {\r\n        const writer = new derData_1.DerWriter(Buffer.alloc(1024));\r\n        writer.writeInteger(rsa.modulus);\r\n        writer.writeInteger(rsa.exponent);\r\n        return writer.toBuffer();\r\n    }\r\n    static formatRsaPrivate(rsa) {\r\n        if (!(rsa.d && rsa.p && rsa.q && rsa.dp && rsa.dq && rsa.qi)) {\r\n            throw new Error('Missing private key parameters.');\r\n        }\r\n        const writer = new derData_1.DerWriter(Buffer.alloc(2048));\r\n        writer.writeInteger(bigInt_1.BigInt.fromInt32(0));\r\n        writer.writeInteger(rsa.modulus);\r\n        writer.writeInteger(rsa.exponent);\r\n        writer.writeInteger(rsa.d);\r\n        writer.writeInteger(rsa.p);\r\n        writer.writeInteger(rsa.q);\r\n        writer.writeInteger(rsa.dp);\r\n        writer.writeInteger(rsa.dq);\r\n        writer.writeInteger(rsa.qi);\r\n        return writer.toBuffer();\r\n    }\r\n    static parseRsaPublic(keyBytes) {\r\n        const reader = new derData_1.DerReader(keyBytes);\r\n        const modulus = reader.readInteger();\r\n        const exponent = reader.readInteger();\r\n        return { modulus, exponent };\r\n    }\r\n    static parseRsaPrivate(keyBytes) {\r\n        const reader = new derData_1.DerReader(keyBytes);\r\n        const version = reader.readInteger();\r\n        const modulus = reader.readInteger();\r\n        const exponent = reader.readInteger();\r\n        const d = reader.readInteger();\r\n        const p = reader.readInteger();\r\n        const q = reader.readInteger();\r\n        const dp = reader.readInteger();\r\n        const dq = reader.readInteger();\r\n        const qi = reader.readInteger();\r\n        return { modulus, exponent, d, p, q, dp, dq, qi };\r\n    }\r\n}\r\nexports.Pkcs1KeyFormatter = Pkcs1KeyFormatter;\r\n/**\r\n * Provides *minimal* SEC1 import/export support for Node.js keys.\r\n *\r\n * This code is redundant with some of the SEC1 import/export code in the separate\r\n * `ssh-keys` library; that is intentional, and necessary to support a consistent\r\n * interface for importing/exporting key parameters in the core `ssh` library.\r\n */\r\nclass Sec1KeyFormatter {\r\n    static formatECPublic(ec) {\r\n        const curve = ecdsaCurves_1.curves.find((c) => c.oid === ec.curve.oid);\r\n        const keySizeInBytes = Math.ceil(curve.keySize / 8);\r\n        const writer = new derData_1.DerWriter(Buffer.alloc(512));\r\n        const oidsWriter = new derData_1.DerWriter(Buffer.alloc(100));\r\n        oidsWriter.writeObjectIdentifier(Sec1KeyFormatter.ecPublicKeyOid);\r\n        oidsWriter.writeObjectIdentifier(ec.curve.oid);\r\n        writer.writeSequence(oidsWriter);\r\n        const x = ec.x.toBytes({ unsigned: true, length: keySizeInBytes });\r\n        const y = ec.y.toBytes({ unsigned: true, length: keySizeInBytes });\r\n        const publicKeyData = Buffer.alloc(1 + x.length + y.length);\r\n        publicKeyData[0] = 4; // Indicates uncompressed curve format\r\n        x.copy(publicKeyData, 1);\r\n        y.copy(publicKeyData, 1 + x.length);\r\n        writer.writeBitString(publicKeyData);\r\n        return writer.toBuffer();\r\n    }\r\n    static formatECPrivate(ec) {\r\n        const curve = ecdsaCurves_1.curves.find((c) => c.oid === ec.curve.oid);\r\n        const keySizeInBytes = Math.ceil(curve.keySize / 8);\r\n        const writer = new derData_1.DerWriter(Buffer.alloc(512));\r\n        writer.writeInteger(bigInt_1.BigInt.fromInt32(1)); // version\r\n        writer.writeOctetString(ec.d.toBytes({ unsigned: true, length: keySizeInBytes }));\r\n        const curveWriter = new derData_1.DerWriter(Buffer.alloc(100));\r\n        curveWriter.writeObjectIdentifier(ec.curve.oid);\r\n        writer.writeTagged(0, curveWriter);\r\n        const x = ec.x.toBytes({ unsigned: true, length: keySizeInBytes });\r\n        const y = ec.y.toBytes({ unsigned: true, length: keySizeInBytes });\r\n        const publicKeyData = Buffer.alloc(1 + x.length + y.length);\r\n        publicKeyData[0] = 4; // Indicates uncompressed curve format\r\n        x.copy(publicKeyData, 1);\r\n        y.copy(publicKeyData, 1 + x.length);\r\n        const keyWriter = new derData_1.DerWriter(Buffer.alloc(512));\r\n        keyWriter.writeBitString(publicKeyData);\r\n        writer.writeTagged(1, keyWriter);\r\n        return writer.toBuffer();\r\n    }\r\n    static parseECPublic(keyBytes) {\r\n        var _a;\r\n        const reader = new derData_1.DerReader(keyBytes);\r\n        const oidsReader = reader.readSequence();\r\n        const keyTypeOid = oidsReader.readObjectIdentifier();\r\n        if (keyTypeOid !== Sec1KeyFormatter.ecPublicKeyOid) {\r\n            throw new Error(`Unexpected key type OID: ${keyTypeOid}`);\r\n        }\r\n        const curveOid = oidsReader.readObjectIdentifier();\r\n        const curveName = (_a = ecdsaCurves_1.curves.find((c) => c.oid === curveOid)) === null || _a === void 0 ? void 0 : _a.name;\r\n        const xy = reader.readBitString();\r\n        if (xy.length % 2 !== 1) {\r\n            throw new Error(`Unexpected key data length: ${xy.length}`);\r\n        }\r\n        const x = bigInt_1.BigInt.fromBytes(xy.slice(1, 1 + (xy.length - 1) / 2), { unsigned: true });\r\n        const y = bigInt_1.BigInt.fromBytes(xy.slice(1 + (xy.length - 1) / 2), { unsigned: true });\r\n        const ec = {\r\n            curve: { name: curveName, oid: curveOid },\r\n            x,\r\n            y,\r\n        };\r\n        return ec;\r\n    }\r\n    static parseECPrivate(keyBytes) {\r\n        var _a;\r\n        const reader = new derData_1.DerReader(keyBytes);\r\n        const version = reader.readInteger().toInt32();\r\n        if (version !== 1) {\r\n            throw new Error(`Unsupported SEC1 format version: ${version}`);\r\n        }\r\n        const d = bigInt_1.BigInt.fromBytes(reader.readOctetString(), { unsigned: true });\r\n        const curveReader = reader.tryReadTagged(0);\r\n        if (!curveReader) {\r\n            throw new Error('SEC1 curve info not found.');\r\n        }\r\n        const curveOid = curveReader.readObjectIdentifier();\r\n        const curveName = (_a = ecdsaCurves_1.curves.find((c) => c.oid === curveOid)) === null || _a === void 0 ? void 0 : _a.name;\r\n        const publicKeyReader = reader.tryReadTagged(1);\r\n        if (!publicKeyReader) {\r\n            throw new Error('SEC1 public key data not found.');\r\n        }\r\n        const xy = publicKeyReader.readBitString();\r\n        if (xy.length % 2 !== 1) {\r\n            throw new Error(`Unexpected key data length: ${xy.length}`);\r\n        }\r\n        const x = bigInt_1.BigInt.fromBytes(xy.slice(1, 1 + (xy.length - 1) / 2), { unsigned: true });\r\n        const y = bigInt_1.BigInt.fromBytes(xy.slice(1 + (xy.length - 1) / 2), { unsigned: true });\r\n        const ec = {\r\n            curve: { name: curveName, oid: curveOid },\r\n            x,\r\n            y,\r\n            d,\r\n        };\r\n        return ec;\r\n    }\r\n}\r\nexports.Sec1KeyFormatter = Sec1KeyFormatter;\r\nSec1KeyFormatter.ecPublicKeyOid = '1.2.840.10045.2.1';\r\n//# sourceMappingURL=keyFormatters.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.NodeECDsa = void 0;\r\nconst crypto = require(\"crypto\");\r\nconst buffer_1 = require(\"buffer\");\r\nconst publicKeyAlgorithm_1 = require(\"../publicKeyAlgorithm\");\r\nconst ecdsaCurves_1 = require(\"../ecdsaCurves\");\r\nconst bigInt_1 = require(\"../../io/bigInt\");\r\nconst derData_1 = require(\"../../io/derData\");\r\nconst sshData_1 = require(\"../../io/sshData\");\r\nconst keyFormatters_1 = require(\"./keyFormatters\");\r\nconst nodeVersionParts = process.versions.node.split('.').map((v) => parseInt(v, 10));\r\nconst nodeGenerateKeyPairSupport = nodeVersionParts[0] > 10 || (nodeVersionParts[0] === 10 && nodeVersionParts[1] >= 12);\r\nconst nodeKeyObjectSupport = nodeVersionParts[0] > 11 || (nodeVersionParts[0] === 11 && nodeVersionParts[1] >= 6);\r\nclass NodeECDsaKeyPair {\r\n    /**\r\n     * Constructs a new ECDSA key pair object.\r\n     *\r\n     * @param algorithmName Key pair algorithm name. If unspecified, the key pair object must be\r\n     * initialized before use via `importParameters()`.\r\n     */\r\n    constructor(algorithmName) {\r\n        this.comment = null;\r\n        if (algorithmName) {\r\n            this.algorithmName = algorithmName;\r\n        }\r\n    }\r\n    get hasPublicKey() {\r\n        return !!this.publicKey;\r\n    }\r\n    get hasPrivateKey() {\r\n        return !!this.privateKey;\r\n    }\r\n    get keyAlgorithmName() {\r\n        return this.algorithmName;\r\n    }\r\n    get algorithmName() {\r\n        return this.algorithm;\r\n    }\r\n    set algorithmName(value) {\r\n        const curveName = value.split('-')[2];\r\n        this.curve = ecdsaCurves_1.curves.find((c) => c.name === curveName);\r\n        if (!this.curve) {\r\n            throw new Error('Invalid or unsupported ECDSA algorithm: ' + value);\r\n        }\r\n        this.algorithm = value;\r\n    }\r\n    generate() {\r\n        if (nodeGenerateKeyPairSupport && nodeKeyObjectSupport) {\r\n            return this.generateNodeKeyPairObjects();\r\n        }\r\n        else if (nodeGenerateKeyPairSupport) {\r\n            return this.generateNodeKeyPairBuffers();\r\n        }\r\n        else {\r\n            return this.generateExternalKeyPair();\r\n        }\r\n    }\r\n    async generateNodeKeyPairObjects() {\r\n        [this.publicKey, this.privateKey] = await new Promise((resolve, reject) => {\r\n            const keyGenParams = {\r\n                namedCurve: this.curve.shortName,\r\n            };\r\n            try {\r\n                crypto.generateKeyPair('ec', keyGenParams, (err, publicKey, privateKey) => {\r\n                    if (err) {\r\n                        reject(err);\r\n                    }\r\n                    else {\r\n                        resolve([publicKey, privateKey]);\r\n                    }\r\n                });\r\n            }\r\n            catch (err) {\r\n                reject(err);\r\n            }\r\n        });\r\n    }\r\n    async generateNodeKeyPairBuffers() {\r\n        [this.publicKey, this.privateKey] = await new Promise((resolve, reject) => {\r\n            const keyGenParams = {\r\n                namedCurve: this.curve.shortName,\r\n                publicKeyEncoding: { type: 'spki', format: 'pem' },\r\n                privateKeyEncoding: {\r\n                    type: 'sec1',\r\n                    format: 'pem',\r\n                    cipher: undefined,\r\n                    passphrase: undefined,\r\n                },\r\n            };\r\n            try {\r\n                crypto.generateKeyPair('ec', keyGenParams, (err, publicKey, privateKey) => {\r\n                    if (err) {\r\n                        reject(err);\r\n                    }\r\n                    else {\r\n                        resolve([publicKey, privateKey]);\r\n                    }\r\n                });\r\n            }\r\n            catch (err) {\r\n                reject(err);\r\n            }\r\n        });\r\n    }\r\n    async generateExternalKeyPair() {\r\n        throw new Error('This version of node does not support generating key pairs. Use node >= 10.12.');\r\n    }\r\n    async setPublicKeyBytes(keyBytes, algorithmName) {\r\n        if (!keyBytes) {\r\n            throw new TypeError('Buffer is required.');\r\n        }\r\n        // Read public key in SSH format.\r\n        const reader = new sshData_1.SshDataReader(keyBytes);\r\n        const readAlgorithmName = reader.readString('ascii');\r\n        this.algorithmName = algorithmName || readAlgorithmName;\r\n        const curveName = reader.readString('ascii');\r\n        this.algorithmName = `ecdsa-sha2-${curveName}`;\r\n        const xy = reader.readBinary();\r\n        const x = bigInt_1.BigInt.fromBytes(xy.slice(1, 1 + (xy.length - 1) / 2), { unsigned: true });\r\n        const y = bigInt_1.BigInt.fromBytes(xy.slice(1 + (xy.length - 1) / 2), { unsigned: true });\r\n        const derKeyBytes = keyFormatters_1.Sec1KeyFormatter.formatECPublic({\r\n            curve: { name: this.curve.name, oid: this.curve.oid },\r\n            x,\r\n            y,\r\n        });\r\n        if (nodeKeyObjectSupport) {\r\n            this.publicKey = crypto.createPublicKey({\r\n                key: derKeyBytes,\r\n                type: 'spki',\r\n                format: 'der',\r\n            });\r\n        }\r\n        else {\r\n            this.publicKey = (0, keyFormatters_1.formatPem)(derKeyBytes, 'PUBLIC KEY');\r\n        }\r\n    }\r\n    async getPublicKeyBytes(algorithmName) {\r\n        if (!this.publicKey) {\r\n            return null;\r\n        }\r\n        let derKeyBytes;\r\n        if (typeof this.publicKey === 'string') {\r\n            derKeyBytes = (0, keyFormatters_1.parsePem)(this.publicKey);\r\n        }\r\n        else {\r\n            derKeyBytes = this.publicKey.export({\r\n                type: 'spki',\r\n                format: 'der',\r\n            });\r\n        }\r\n        const ec = keyFormatters_1.Sec1KeyFormatter.parseECPublic(derKeyBytes);\r\n        // Write public key in SSH format.\r\n        algorithmName = algorithmName || this.algorithmName || this.keyAlgorithmName;\r\n        const keyWriter = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(512));\r\n        keyWriter.writeString(algorithmName, 'ascii');\r\n        keyWriter.writeString(this.curve.name, 'ascii');\r\n        const keySizeInBytes = Math.ceil(this.curve.keySize / 8);\r\n        const xBytes = ec.x.toBytes({ unsigned: true, length: keySizeInBytes });\r\n        const yBytes = ec.y.toBytes({ unsigned: true, length: keySizeInBytes });\r\n        keyWriter.writeUInt32(1 + xBytes.length + yBytes.length);\r\n        keyWriter.writeByte(4); // Indicates uncompressed curve format\r\n        keyWriter.write(xBytes);\r\n        keyWriter.write(yBytes);\r\n        const keyBytes = keyWriter.toBuffer();\r\n        return keyBytes;\r\n    }\r\n    async importParameters(parameters) {\r\n        if (!parameters.curve)\r\n            throw new TypeError('A curve is required.');\r\n        let curve;\r\n        if (parameters.curve.oid) {\r\n            curve = ecdsaCurves_1.curves.find((c) => c.oid === parameters.curve.oid);\r\n            if (!curve) {\r\n                throw new Error(`Unsupported curve OID: ${parameters.curve.oid}`);\r\n            }\r\n        }\r\n        else if (parameters.curve.name) {\r\n            curve = ecdsaCurves_1.curves.find((c) => c.name === parameters.curve.name);\r\n            if (!curve) {\r\n                throw new Error(`Unsupported curve: ${parameters.curve.name}`);\r\n            }\r\n        }\r\n        else {\r\n            throw new TypeError('A curve OID or name is required.');\r\n        }\r\n        this.algorithmName = 'ecdsa-sha2-' + curve.name;\r\n        const publicKeyBytes = keyFormatters_1.Sec1KeyFormatter.formatECPublic(parameters);\r\n        if (nodeKeyObjectSupport) {\r\n            this.publicKey = crypto.createPublicKey({\r\n                key: publicKeyBytes,\r\n                type: 'spki',\r\n                format: 'der',\r\n            });\r\n        }\r\n        else {\r\n            this.publicKey = (0, keyFormatters_1.formatPem)(publicKeyBytes, 'EC PUBLIC KEY');\r\n        }\r\n        if (parameters.d) {\r\n            const privateKeyBytes = keyFormatters_1.Sec1KeyFormatter.formatECPrivate(parameters);\r\n            if (nodeKeyObjectSupport) {\r\n                this.privateKey = crypto.createPrivateKey({\r\n                    key: privateKeyBytes,\r\n                    type: 'sec1',\r\n                    format: 'der',\r\n                });\r\n            }\r\n            else {\r\n                this.privateKey = (0, keyFormatters_1.formatPem)(privateKeyBytes, 'EC PRIVATE KEY');\r\n            }\r\n        }\r\n        else {\r\n            this.privateKey = undefined;\r\n        }\r\n    }\r\n    async exportParameters() {\r\n        var _a, _b;\r\n        if (!this.publicKey) {\r\n            throw new Error('Key is not present.');\r\n        }\r\n        let derKeyBytes;\r\n        if (typeof this.publicKey === 'string') {\r\n            derKeyBytes = (0, keyFormatters_1.parsePem)((_a = this.privateKey) !== null && _a !== void 0 ? _a : this.publicKey);\r\n        }\r\n        else {\r\n            derKeyBytes = ((_b = this.privateKey) !== null && _b !== void 0 ? _b : this.publicKey).export({\r\n                type: this.privateKey ? 'sec1' : 'spki',\r\n                format: 'der',\r\n            });\r\n        }\r\n        return this.privateKey\r\n            ? keyFormatters_1.Sec1KeyFormatter.parseECPrivate(derKeyBytes)\r\n            : keyFormatters_1.Sec1KeyFormatter.parseECPublic(derKeyBytes);\r\n    }\r\n    dispose() { }\r\n}\r\nclass NodeECDsa extends publicKeyAlgorithm_1.PublicKeyAlgorithm {\r\n    constructor(name, hashAlgorithmName) {\r\n        super(name, name, // The key algorithm name is the same (unlike RSA).\r\n        hashAlgorithmName);\r\n    }\r\n    createKeyPair() {\r\n        return new NodeECDsaKeyPair(this.name);\r\n    }\r\n    async generateKeyPair() {\r\n        const ecdsaKey = new NodeECDsaKeyPair(this.name);\r\n        await ecdsaKey.generate();\r\n        return ecdsaKey;\r\n    }\r\n    createSigner(keyPair) {\r\n        if (!(keyPair instanceof NodeECDsaKeyPair)) {\r\n            throw new TypeError('ECDSA key pair object expected.');\r\n        }\r\n        return new NodeECDsaSignerVerifier(keyPair, NodeECDsa.convertHashAlgorithmName(this.hashAlgorithmName));\r\n    }\r\n    createVerifier(keyPair) {\r\n        if (!(keyPair instanceof NodeECDsaKeyPair)) {\r\n            throw new TypeError('ECDSA key pair object expected.');\r\n        }\r\n        return new NodeECDsaSignerVerifier(keyPair, NodeECDsa.convertHashAlgorithmName(this.hashAlgorithmName));\r\n    }\r\n    static convertHashAlgorithmName(hashAlgorithmName) {\r\n        return hashAlgorithmName.replace('SHA2-', 'SHA');\r\n    }\r\n    /* @internal */\r\n    static getSignatureLength(keySizeInBits) {\r\n        // The signature is double the key size, but formatted as 2 bigints.\r\n        // To each bigint add 4 for the length and 1 for a leading zero.\r\n        const keySizeInBytes = Math.ceil(keySizeInBits / 8);\r\n        return (4 + 1 + keySizeInBytes) * 2;\r\n    }\r\n}\r\nexports.NodeECDsa = NodeECDsa;\r\nNodeECDsa.ecdsaSha2Nistp256 = 'ecdsa-sha2-nistp256';\r\nNodeECDsa.ecdsaSha2Nistp384 = 'ecdsa-sha2-nistp384';\r\nNodeECDsa.ecdsaSha2Nistp521 = 'ecdsa-sha2-nistp521';\r\nNodeECDsa.curves = ecdsaCurves_1.curves;\r\n// eslint-disable-next-line @typescript-eslint/tslint/config\r\nNodeECDsa.KeyPair = NodeECDsaKeyPair;\r\nclass NodeECDsaSignerVerifier {\r\n    constructor(keyPair, hashAlgorithmName) {\r\n        this.keyPair = keyPair;\r\n        this.hashAlgorithmName = hashAlgorithmName;\r\n    }\r\n    get digestLength() {\r\n        const curve = this.keyPair.curve;\r\n        if (!curve) {\r\n            return 0;\r\n        }\r\n        else {\r\n            return NodeECDsa.getSignatureLength(curve.keySize);\r\n        }\r\n    }\r\n    async sign(data) {\r\n        if (!this.keyPair.privateKey) {\r\n            throw new Error('Private key not set.');\r\n        }\r\n        const signer = crypto.createSign(this.hashAlgorithmName);\r\n        signer.update(data);\r\n        let signature = signer.sign(this.keyPair.privateKey);\r\n        // Reformat the signature integer bytes as required by SSH.\r\n        const signatureReader = new derData_1.DerReader(signature);\r\n        const x = signatureReader.readInteger();\r\n        const y = signatureReader.readInteger();\r\n        const keySizeInBytes = Math.ceil(this.keyPair.curve.keySize / 8);\r\n        const signatureWriter = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(this.digestLength));\r\n        signatureWriter.writeBinary(x.toBytes({ unsigned: true, length: keySizeInBytes + 1 }));\r\n        signatureWriter.writeBinary(y.toBytes({ unsigned: true, length: keySizeInBytes + 1 }));\r\n        signature = signatureWriter.toBuffer();\r\n        return signature;\r\n    }\r\n    async verify(data, signature) {\r\n        if (!this.keyPair.publicKey) {\r\n            throw new Error('Public key not set.');\r\n        }\r\n        // Reformat the signature integer bytes as required by node.\r\n        const signatureReader = new sshData_1.SshDataReader(signature);\r\n        const x = signatureReader.readBigInt();\r\n        const y = signatureReader.readBigInt();\r\n        const signatureWriter = new derData_1.DerWriter(buffer_1.Buffer.alloc(signature.length));\r\n        signatureWriter.writeInteger(x);\r\n        signatureWriter.writeInteger(y);\r\n        signature = signatureWriter.toBuffer();\r\n        const verifier = crypto.createVerify(this.hashAlgorithmName);\r\n        verifier.update(data);\r\n        const result = verifier.verify(this.keyPair.publicKey, signature);\r\n        return result;\r\n    }\r\n    dispose() { }\r\n}\r\n//# sourceMappingURL=nodeECDsa.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.NodeEncryption = void 0;\r\nconst crypto = require(\"crypto\");\r\nconst buffer_1 = require(\"buffer\");\r\nconst encryptionAlgorithm_1 = require(\"../encryptionAlgorithm\");\r\nconst trace_1 = require(\"../../trace\");\r\nclass NodeEncryption extends encryptionAlgorithm_1.EncryptionAlgorithm {\r\n    constructor(name, algorithmName, cipherMode, keySizeInBits) {\r\n        super(name);\r\n        this.algorithmName = algorithmName;\r\n        this.cipherMode = cipherMode;\r\n        this.keySizeInBits = keySizeInBits;\r\n        if (algorithmName !== 'AES') {\r\n            throw new Error(`Unsupported encryption algorithm: ${algorithmName}`);\r\n        }\r\n        this.blockSizeInBits = NodeEncryption.getBlockSize(algorithmName);\r\n    }\r\n    get keyLength() {\r\n        return this.keySizeInBits / 8;\r\n    }\r\n    get blockLength() {\r\n        return this.blockSizeInBits / 8;\r\n    }\r\n    async createCipher(isEncryption, key, iv) {\r\n        let cipher;\r\n        if (this.cipherMode === 'CTR' || this.cipherMode === 'CBC') {\r\n            cipher = new NodeAesCipher(isEncryption, this.keySizeInBits, this.blockSizeInBits, key, iv, this.cipherMode);\r\n        }\r\n        else if (this.cipherMode === 'GCM') {\r\n            cipher = new NodeAesGcmCipher(isEncryption, this.keySizeInBits, this.blockSizeInBits, key, iv);\r\n        }\r\n        else {\r\n            throw new Error(`Unsupported cipher mode: ${this.cipherMode}`);\r\n        }\r\n        return cipher;\r\n    }\r\n    static getBlockSize(algorithmName) {\r\n        if (algorithmName === 'AES') {\r\n            return 128;\r\n        }\r\n        else {\r\n            throw new Error(`Unsupported encryption algorithm: ${algorithmName}`);\r\n        }\r\n    }\r\n}\r\nexports.NodeEncryption = NodeEncryption;\r\nclass NodeAesCipher {\r\n    constructor(isEncryption, keySizeInBits, blockSizeInBits, key, iv, cipherMode) {\r\n        this.isEncryption = isEncryption;\r\n        this.keySizeInBits = keySizeInBits;\r\n        this.blockSizeInBits = blockSizeInBits;\r\n        const nodeAlgorithm = `AES-${this.keySizeInBits}-${cipherMode}`;\r\n        this.cipher = this.isEncryption\r\n            ? crypto.createCipheriv(nodeAlgorithm, key, iv)\r\n            : crypto.createDecipheriv(nodeAlgorithm, key, iv);\r\n        this.cipher.setAutoPadding(false);\r\n    }\r\n    get blockLength() {\r\n        return this.blockSizeInBits / 8;\r\n    }\r\n    transform(data) {\r\n        const result = this.cipher.update(data);\r\n        if (result.length !== data.length) {\r\n            const message = 'Result from encrypt/decrypt has invalid length ' +\r\n                `${result.length}, expected ${data.length}.`;\r\n            (0, trace_1.trace)('Error: ' + message);\r\n            throw new Error(message);\r\n        }\r\n        return Promise.resolve(result);\r\n    }\r\n    dispose() { }\r\n}\r\nclass NodeAesGcmCipher {\r\n    constructor(isEncryption, keySizeInBits, blockSizeInBits, key, iv) {\r\n        this.isEncryption = isEncryption;\r\n        this.keySizeInBits = keySizeInBits;\r\n        this.blockSizeInBits = blockSizeInBits;\r\n        this.tag = null;\r\n        this.algorithmName = `aes-${this.keySizeInBits}-gcm`;\r\n        this.key = buffer_1.Buffer.alloc(key.length);\r\n        key.copy(this.key);\r\n        // Ininitialize the nonce to the first 12 bytes of the IV. It will be incremented by each op.\r\n        this.nonce = buffer_1.Buffer.alloc(12);\r\n        iv.copy(this.nonce, 0, 0, 12);\r\n        this.associatedData = buffer_1.Buffer.alloc(4);\r\n    }\r\n    get blockLength() {\r\n        return this.blockSizeInBits / 8;\r\n    }\r\n    get digestLength() {\r\n        return 16;\r\n    }\r\n    get authenticatedEncryption() {\r\n        return true;\r\n    }\r\n    transform(data) {\r\n        if (data.length % this.blockLength !== 0) {\r\n            const message = 'Encrypt/decrypt input has invalid length ' +\r\n                `${data.length}, not a multiple of block size ${this.blockLength}.`;\r\n            (0, trace_1.trace)('Error: ' + message);\r\n            throw new Error(message);\r\n        }\r\n        const cipher = this.isEncryption\r\n            ? crypto.createCipheriv(this.algorithmName, this.key, this.nonce)\r\n            : crypto.createDecipheriv(this.algorithmName, this.key, this.nonce);\r\n        // Associated data is the 32-bit packet length.\r\n        const packetLength = data.length;\r\n        this.associatedData[0] = packetLength >>> 24;\r\n        this.associatedData[1] = packetLength >>> 16;\r\n        this.associatedData[2] = packetLength >>> 8;\r\n        this.associatedData[3] = packetLength;\r\n        cipher.setAAD(this.associatedData);\r\n        if (!this.isEncryption) {\r\n            if (!this.tag) {\r\n                throw new Error('AES-GCM tag was not set before decrypting.');\r\n            }\r\n            cipher.setAuthTag(this.tag);\r\n        }\r\n        const result = cipher.update(data);\r\n        if (result.length !== data.length) {\r\n            const message = 'Result from encrypt/decrypt has invalid length ' +\r\n                `${result.length}, expected ${data.length}.`;\r\n            (0, trace_1.trace)('Error: ' + message);\r\n            throw new Error(message);\r\n        }\r\n        cipher.final();\r\n        if (this.isEncryption) {\r\n            this.tag = cipher.getAuthTag();\r\n        }\r\n        else {\r\n            this.tag = null;\r\n        }\r\n        // Increment the counter (last 8 bytes of the nonce) as a big-endian integer.\r\n        // First increment the last byte, and if it reaches 0 then increment the\r\n        // next-to-last byte, and so on.\r\n        let k = 12;\r\n        while (--k >= 4) {\r\n            this.nonce[k]++;\r\n            if (this.nonce[k] !== 0) {\r\n                break;\r\n            }\r\n        }\r\n        return Promise.resolve(result);\r\n    }\r\n    async sign(data) {\r\n        if (!this.tag) {\r\n            throw new Error('AES-GCM tag was not obtained by encrypting.');\r\n        }\r\n        return this.tag;\r\n    }\r\n    async verify(data, signature) {\r\n        if (signature.length !== this.digestLength) {\r\n            throw new Error('Incorrect AES-GCM tag length.');\r\n        }\r\n        this.tag = signature;\r\n        return true;\r\n    }\r\n    dispose() { }\r\n}\r\n//# sourceMappingURL=nodeEncryption.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.NodeHmac = void 0;\r\nconst crypto = require(\"crypto\");\r\nconst buffer_1 = require(\"buffer\");\r\nconst hmacAlgorithm_1 = require(\"../hmacAlgorithm\");\r\nclass NodeHmac extends hmacAlgorithm_1.HmacAlgorithm {\r\n    constructor(name, algorithmName, encryptThenMac = false) {\r\n        super(name, algorithmName, NodeHmac.getHashKeyLength(algorithmName), NodeHmac.getHashDigestLength(algorithmName));\r\n        this.encryptThenMac = encryptThenMac;\r\n    }\r\n    async createSigner(key) {\r\n        const hmac = new NodeSignerVerifier(NodeHmac.getNodeHashAlgorithmName(this.algorithmName), this.digestLength, this.encryptThenMac, key);\r\n        return hmac;\r\n    }\r\n    async createVerifier(key) {\r\n        const hmac = new NodeSignerVerifier(NodeHmac.getNodeHashAlgorithmName(this.algorithmName), this.digestLength, this.encryptThenMac, key);\r\n        return hmac;\r\n    }\r\n    static getHashKeyLength(hashAlgorithmName) {\r\n        if (hashAlgorithmName === 'SHA2-512')\r\n            return 512 / 8;\r\n        if (hashAlgorithmName === 'SHA2-384')\r\n            return 384 / 8;\r\n        if (hashAlgorithmName === 'SHA2-256')\r\n            return 256 / 8;\r\n        throw new Error(`Unsupported hash algorithm: ${hashAlgorithmName}`);\r\n    }\r\n    static getHashDigestLength(hashAlgorithmName) {\r\n        return this.getHashKeyLength(hashAlgorithmName);\r\n    }\r\n    static getNodeHashAlgorithmName(hashAlgorithmName) {\r\n        if (hashAlgorithmName === 'SHA2-512')\r\n            return 'sha512';\r\n        if (hashAlgorithmName === 'SHA2-384')\r\n            return 'sha384';\r\n        if (hashAlgorithmName === 'SHA2-256')\r\n            return 'sha256';\r\n        throw new Error(`Unsupported hash algorithm: ${hashAlgorithmName}`);\r\n    }\r\n}\r\nexports.NodeHmac = NodeHmac;\r\nclass NodeSignerVerifier {\r\n    constructor(algorithmName, digestLength, encryptThenMac, key) {\r\n        this.algorithmName = algorithmName;\r\n        this.digestLength = digestLength;\r\n        this.encryptThenMac = encryptThenMac;\r\n        // crypto.createSecretKey is only available on node >= 11.6.\r\n        this.key = crypto.createSecretKey ? crypto.createSecretKey(key) : buffer_1.Buffer.from(key);\r\n    }\r\n    async sign(data) {\r\n        const signer = crypto.createHmac(this.algorithmName, this.key);\r\n        signer.update(data);\r\n        const hmac = signer.digest();\r\n        return hmac;\r\n    }\r\n    async verify(data, signature) {\r\n        const verifier = crypto.createHmac(this.algorithmName, this.key);\r\n        verifier.update(data);\r\n        const hmac = verifier.digest();\r\n        const result = hmac.equals(signature);\r\n        return result;\r\n    }\r\n    dispose() { }\r\n}\r\n//# sourceMappingURL=nodeHmac.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.NodeECDiffieHellman = exports.NodeDiffieHellman = void 0;\r\nconst crypto = require(\"crypto\");\r\nconst buffer_1 = require(\"buffer\");\r\nconst keyExchangeAlgorithm_1 = require(\"../keyExchangeAlgorithm\");\r\nconst nodeHmac_1 = require(\"./nodeHmac\");\r\nconst bigInt_1 = require(\"../../io/bigInt\");\r\nclass NodeDiffieHellman extends keyExchangeAlgorithm_1.KeyExchangeAlgorithm {\r\n    constructor(name, keySizeInBits, hashAlgorithmName) {\r\n        super(name, keySizeInBits, hashAlgorithmName, nodeHmac_1.NodeHmac.getHashDigestLength(hashAlgorithmName));\r\n    }\r\n    createKeyExchange() {\r\n        return new NodeDiffieHellmanKex(this.keySizeInBits, nodeHmac_1.NodeHmac.getNodeHashAlgorithmName(this.hashAlgorithmName), this.hashDigestLength);\r\n    }\r\n}\r\nexports.NodeDiffieHellman = NodeDiffieHellman;\r\nclass NodeDiffieHellmanKex {\r\n    constructor(bitLength, hashAlgorithmName, digestLength) {\r\n        this.hashAlgorithmName = hashAlgorithmName;\r\n        this.digestLength = digestLength;\r\n        switch (bitLength) {\r\n            case 1024:\r\n                this.dh = crypto.getDiffieHellman('modp2');\r\n                break;\r\n            case 2048:\r\n                this.dh = crypto.getDiffieHellman('modp14');\r\n                break;\r\n            case 4096:\r\n                this.dh = crypto.getDiffieHellman('modp16');\r\n                break;\r\n            default:\r\n                throw new Error('Invalid DH bit length.');\r\n        }\r\n    }\r\n    startKeyExchange() {\r\n        const exchangeValueKeys = this.dh.generateKeys();\r\n        const exchangeValue = bigInt_1.BigInt.fromBytes(exchangeValueKeys, { unsigned: true }).toBytes();\r\n        return Promise.resolve(exchangeValue);\r\n    }\r\n    decryptKeyExchange(exchangeValue) {\r\n        const key = this.dh.computeSecret(exchangeValue);\r\n        const sharedSecret = bigInt_1.BigInt.fromBytes(key, { unsigned: true }).toBytes();\r\n        return Promise.resolve(sharedSecret);\r\n    }\r\n    async sign(data) {\r\n        const hash = crypto.createHash(this.hashAlgorithmName);\r\n        hash.update(data);\r\n        return buffer_1.Buffer.from(hash.digest());\r\n    }\r\n    dispose() { }\r\n}\r\nclass NodeECDiffieHellman extends keyExchangeAlgorithm_1.KeyExchangeAlgorithm {\r\n    constructor(name, keySizeInBits, hashAlgorithmName) {\r\n        super(name, keySizeInBits, hashAlgorithmName, nodeHmac_1.NodeHmac.getHashDigestLength(hashAlgorithmName));\r\n    }\r\n    createKeyExchange() {\r\n        return new NodeECDiffieHellmanKex(this.keySizeInBits, nodeHmac_1.NodeHmac.getNodeHashAlgorithmName(this.hashAlgorithmName), this.hashDigestLength);\r\n    }\r\n}\r\nexports.NodeECDiffieHellman = NodeECDiffieHellman;\r\nclass NodeECDiffieHellmanKex {\r\n    constructor(bitLength, hashAlgorithmName, digestLength) {\r\n        this.hashAlgorithmName = hashAlgorithmName;\r\n        this.digestLength = digestLength;\r\n        switch (bitLength) {\r\n            case 256:\r\n                this.ecdh = crypto.createECDH('prime256v1');\r\n                break;\r\n            case 384:\r\n                this.ecdh = crypto.createECDH('secp384r1');\r\n                break;\r\n            case 521:\r\n                this.ecdh = crypto.createECDH('secp521r1');\r\n                break;\r\n            default:\r\n                throw new Error('Invalid ECDH bit length.');\r\n        }\r\n    }\r\n    startKeyExchange() {\r\n        const exchangeValue = this.ecdh.generateKeys();\r\n        return Promise.resolve(exchangeValue);\r\n    }\r\n    decryptKeyExchange(exchangeValue) {\r\n        const sharedSecretBytes = this.ecdh.computeSecret(exchangeValue);\r\n        const sharedSecret = bigInt_1.BigInt.fromBytes(sharedSecretBytes, { unsigned: true }).toBytes();\r\n        return Promise.resolve(sharedSecret);\r\n    }\r\n    async sign(data) {\r\n        const hash = crypto.createHash(this.hashAlgorithmName);\r\n        hash.update(data);\r\n        return buffer_1.Buffer.from(hash.digest());\r\n    }\r\n    dispose() { }\r\n}\r\n//# sourceMappingURL=nodeKeyExchange.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.NodeRandom = void 0;\r\nconst crypto = require(\"crypto\");\r\nclass NodeRandom {\r\n    getBytes(buffer) {\r\n        const randomBytes = crypto.randomBytes(buffer.length);\r\n        randomBytes.copy(buffer);\r\n    }\r\n}\r\nexports.NodeRandom = NodeRandom;\r\n//# sourceMappingURL=nodeRandom.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.NodeRsa = void 0;\r\nconst crypto = require(\"crypto\");\r\nconst buffer_1 = require(\"buffer\");\r\nconst publicKeyAlgorithm_1 = require(\"../publicKeyAlgorithm\");\r\nconst sshData_1 = require(\"../../io/sshData\");\r\nconst nodeHmac_1 = require(\"./nodeHmac\");\r\nconst keyFormatters_1 = require(\"./keyFormatters\");\r\nconst nodeVersionParts = process.versions.node.split('.').map((v) => parseInt(v, 10));\r\nconst nodeGenerateKeyPairSupport = nodeVersionParts[0] > 10 || (nodeVersionParts[0] === 10 && nodeVersionParts[1] >= 12);\r\nconst nodeKeyObjectSupport = nodeVersionParts[0] > 11 || (nodeVersionParts[0] === 11 && nodeVersionParts[1] >= 6);\r\n// Note this is exposed as an inner-class property below: `NodeRsa.KeyPair`.\r\n// TypeScript requires that the class definition comes first.\r\nclass NodeRsaKeyPair {\r\n    /* @internal */\r\n    constructor() {\r\n        this.comment = null;\r\n    }\r\n    get hasPublicKey() {\r\n        return !!this.publicKey;\r\n    }\r\n    get hasPrivateKey() {\r\n        return !!this.privateKey;\r\n    }\r\n    get keyAlgorithmName() {\r\n        return NodeRsa.keyAlgorithmName;\r\n    }\r\n    generate(keySizeInBits) {\r\n        keySizeInBits = keySizeInBits !== null && keySizeInBits !== void 0 ? keySizeInBits : NodeRsaKeyPair.defaultKeySize;\r\n        if (nodeGenerateKeyPairSupport && nodeKeyObjectSupport) {\r\n            return this.generateNodeKeyPairObjects(keySizeInBits);\r\n        }\r\n        else if (nodeGenerateKeyPairSupport) {\r\n            return this.generateNodeKeyPairBuffers(keySizeInBits);\r\n        }\r\n        else {\r\n            return this.generateExternalKeyPair(keySizeInBits);\r\n        }\r\n    }\r\n    async generateNodeKeyPairObjects(keySizeInBits) {\r\n        [this.publicKey, this.privateKey] = await new Promise((resolve, reject) => {\r\n            const keyGenParams = {\r\n                modulusLength: keySizeInBits,\r\n            };\r\n            try {\r\n                crypto.generateKeyPair('rsa', keyGenParams, (err, publicKey, privateKey) => {\r\n                    if (err) {\r\n                        reject(err);\r\n                    }\r\n                    else {\r\n                        resolve([publicKey, privateKey]);\r\n                    }\r\n                });\r\n            }\r\n            catch (err) {\r\n                reject(err);\r\n            }\r\n        });\r\n    }\r\n    async generateNodeKeyPairBuffers(keySizeInBits) {\r\n        [this.publicKey, this.privateKey] = await new Promise((resolve, reject) => {\r\n            const keyGenParams = {\r\n                modulusLength: keySizeInBits,\r\n                publicKeyEncoding: { type: 'pkcs1', format: 'pem' },\r\n                privateKeyEncoding: {\r\n                    type: 'pkcs1',\r\n                    format: 'pem',\r\n                    cipher: undefined,\r\n                    passphrase: undefined,\r\n                },\r\n            };\r\n            try {\r\n                crypto.generateKeyPair('rsa', keyGenParams, (err, publicKey, privateKey) => {\r\n                    if (err) {\r\n                        reject(err);\r\n                    }\r\n                    else {\r\n                        resolve([publicKey, privateKey]);\r\n                    }\r\n                });\r\n            }\r\n            catch (err) {\r\n                reject(err);\r\n            }\r\n        });\r\n    }\r\n    async generateExternalKeyPair(keySizeInBits) {\r\n        // When running in a version of node that doesn't have a built-in API\r\n        // for RSA key-gen, use an external library. Note this implementation\r\n        // is SLOW because it's pure JS. It may take 1-5 seconds to generate\r\n        // a 2048 bit key.\r\n        const externRsa = await Promise.resolve().then(() => require('node-rsa'));\r\n        const keyPair = new externRsa({ b: keySizeInBits });\r\n        this.publicKey = keyPair.exportKey('pkcs1-public-pem');\r\n        this.privateKey = keyPair.exportKey('pkcs1-private-pem');\r\n        // Ensure the PEM format ends in a newline, just for consistency.\r\n        if (!this.publicKey.endsWith('\\n'))\r\n            this.publicKey += '\\n';\r\n        if (!this.privateKey.endsWith('\\n'))\r\n            this.privateKey += '\\n';\r\n    }\r\n    async setPublicKeyBytes(keyBytes) {\r\n        if (!keyBytes) {\r\n            throw new TypeError('Buffer is required.');\r\n        }\r\n        // Read public key in SSH format.\r\n        const reader = new sshData_1.SshDataReader(keyBytes);\r\n        const algorithmName = reader.readString('ascii');\r\n        if (algorithmName !== this.keyAlgorithmName &&\r\n            algorithmName !== NodeRsa.rsaWithSha256 &&\r\n            algorithmName !== NodeRsa.rsaWithSha512) {\r\n            throw new Error(`Invalid RSA key algorithm: ${algorithmName}`);\r\n        }\r\n        const exponent = reader.readBigInt();\r\n        const modulus = reader.readBigInt();\r\n        // Write public key in PKCS#1 format.\r\n        keyBytes = keyFormatters_1.Pkcs1KeyFormatter.formatRsaPublic({ modulus, exponent });\r\n        if (nodeKeyObjectSupport) {\r\n            this.publicKey = crypto.createPublicKey({\r\n                key: keyBytes,\r\n                type: 'pkcs1',\r\n                format: 'der',\r\n            });\r\n        }\r\n        else {\r\n            this.publicKey = (0, keyFormatters_1.formatPem)(keyBytes, 'RSA PUBLIC KEY');\r\n        }\r\n    }\r\n    async getPublicKeyBytes(algorithmName) {\r\n        if (!this.publicKey) {\r\n            return null;\r\n        }\r\n        if (!algorithmName) {\r\n            algorithmName = this.keyAlgorithmName;\r\n        }\r\n        let keyBytes;\r\n        if (typeof this.publicKey === 'string') {\r\n            keyBytes = (0, keyFormatters_1.parsePem)(this.publicKey);\r\n        }\r\n        else {\r\n            keyBytes = this.publicKey.export({\r\n                type: 'pkcs1',\r\n                format: 'der',\r\n            });\r\n        }\r\n        const parameters = keyFormatters_1.Pkcs1KeyFormatter.parseRsaPublic(keyBytes);\r\n        // Write public key in SSH format.\r\n        const keyBuffer = buffer_1.Buffer.alloc(512);\r\n        const keyWriter = new sshData_1.SshDataWriter(keyBuffer);\r\n        keyWriter.writeString(algorithmName, 'ascii');\r\n        keyWriter.writeBigInt(parameters.exponent);\r\n        keyWriter.writeBigInt(parameters.modulus);\r\n        keyBytes = keyWriter.toBuffer();\r\n        return keyBytes;\r\n    }\r\n    async importParameters(parameters) {\r\n        if (nodeKeyObjectSupport) {\r\n            this.publicKey = crypto.createPublicKey({\r\n                key: keyFormatters_1.Pkcs1KeyFormatter.formatRsaPublic(parameters),\r\n                format: 'der',\r\n                type: 'pkcs1',\r\n            });\r\n            if (parameters.d) {\r\n                this.privateKey = crypto.createPrivateKey({\r\n                    key: keyFormatters_1.Pkcs1KeyFormatter.formatRsaPrivate(parameters),\r\n                    format: 'der',\r\n                    type: 'pkcs1',\r\n                });\r\n            }\r\n            else {\r\n                this.privateKey = undefined;\r\n            }\r\n        }\r\n        else {\r\n            const publicKeyBytes = keyFormatters_1.Pkcs1KeyFormatter.formatRsaPublic(parameters);\r\n            this.publicKey = (0, keyFormatters_1.formatPem)(publicKeyBytes, 'RSA PUBLIC KEY');\r\n            if (parameters.d) {\r\n                const privateKeyBytes = keyFormatters_1.Pkcs1KeyFormatter.formatRsaPrivate(parameters);\r\n                this.privateKey = (0, keyFormatters_1.formatPem)(privateKeyBytes, 'RSA PRIVATE KEY');\r\n            }\r\n        }\r\n    }\r\n    async exportParameters() {\r\n        var _a, _b;\r\n        if (!this.publicKey)\r\n            throw new Error('Public key not set.');\r\n        let keyBytes;\r\n        if (nodeKeyObjectSupport) {\r\n            keyBytes = ((_a = this.privateKey) !== null && _a !== void 0 ? _a : this.publicKey).export({\r\n                format: 'der',\r\n                type: 'pkcs1',\r\n            });\r\n        }\r\n        else {\r\n            keyBytes = (0, keyFormatters_1.parsePem)((_b = this.privateKey) !== null && _b !== void 0 ? _b : this.publicKey);\r\n        }\r\n        return this.privateKey\r\n            ? keyFormatters_1.Pkcs1KeyFormatter.parseRsaPrivate(keyBytes)\r\n            : keyFormatters_1.Pkcs1KeyFormatter.parseRsaPublic(keyBytes);\r\n    }\r\n    dispose() {\r\n        this.publicKey = undefined;\r\n        this.privateKey = undefined;\r\n    }\r\n}\r\nNodeRsaKeyPair.defaultKeySize = 2048;\r\nclass NodeRsa extends publicKeyAlgorithm_1.PublicKeyAlgorithm {\r\n    constructor(name, hashAlgorithmName) {\r\n        super(name, NodeRsa.keyAlgorithmName, hashAlgorithmName);\r\n    }\r\n    createKeyPair() {\r\n        return new NodeRsaKeyPair();\r\n    }\r\n    async generateKeyPair(keySizeInBits) {\r\n        const rsaKey = new NodeRsaKeyPair();\r\n        await rsaKey.generate(keySizeInBits);\r\n        return rsaKey;\r\n    }\r\n    createSigner(keyPair) {\r\n        if (!(keyPair instanceof NodeRsaKeyPair)) {\r\n            throw new TypeError('RSA key pair object expected.');\r\n        }\r\n        return new NodeRsaSignerVerifier(keyPair, NodeRsa.convertHashAlgorithmName(this.hashAlgorithmName), nodeHmac_1.NodeHmac.getHashDigestLength(this.hashAlgorithmName));\r\n    }\r\n    createVerifier(keyPair) {\r\n        if (!(keyPair instanceof NodeRsaKeyPair)) {\r\n            throw new TypeError('RSA key pair object expected.');\r\n        }\r\n        return new NodeRsaSignerVerifier(keyPair, NodeRsa.convertHashAlgorithmName(this.hashAlgorithmName), nodeHmac_1.NodeHmac.getHashDigestLength(this.hashAlgorithmName));\r\n    }\r\n    static convertHashAlgorithmName(hashAlgorithmName) {\r\n        return hashAlgorithmName.replace('SHA2-', 'SHA');\r\n    }\r\n}\r\nexports.NodeRsa = NodeRsa;\r\nNodeRsa.keyAlgorithmName = 'ssh-rsa';\r\nNodeRsa.rsaWithSha256 = 'rsa-sha2-256';\r\nNodeRsa.rsaWithSha512 = 'rsa-sha2-512';\r\n// eslint-disable-next-line @typescript-eslint/tslint/config\r\nNodeRsa.KeyPair = NodeRsaKeyPair;\r\nclass NodeRsaSignerVerifier {\r\n    constructor(keyPair, hashAlgorithmName, digestLength) {\r\n        this.keyPair = keyPair;\r\n        this.hashAlgorithmName = hashAlgorithmName;\r\n        this.digestLength = digestLength;\r\n    }\r\n    async sign(data) {\r\n        if (!this.keyPair.privateKey) {\r\n            throw new Error('Private key not set.');\r\n        }\r\n        const signer = crypto.createSign(this.hashAlgorithmName);\r\n        signer.update(data);\r\n        const signature = signer.sign(this.keyPair.privateKey);\r\n        return signature;\r\n    }\r\n    async verify(data, signature) {\r\n        if (!this.keyPair.publicKey) {\r\n            throw new Error('Public key not set.');\r\n        }\r\n        const verifier = crypto.createVerify(this.hashAlgorithmName);\r\n        verifier.update(data);\r\n        const result = verifier.verify(this.keyPair.publicKey, signature);\r\n        return result;\r\n    }\r\n    dispose() { }\r\n}\r\n//# sourceMappingURL=nodeRsa.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.PublicKeyAlgorithm = void 0;\r\nconst buffer_1 = require(\"buffer\");\r\nconst sshData_1 = require(\"../io/sshData\");\r\nclass PublicKeyAlgorithm {\r\n    constructor(name, keyAlgorithmName, hashAlgorithmName) {\r\n        this.name = name;\r\n        this.keyAlgorithmName = keyAlgorithmName;\r\n        this.hashAlgorithmName = hashAlgorithmName;\r\n    }\r\n    readSignatureData(signatureData) {\r\n        const reader = new sshData_1.SshDataReader(signatureData);\r\n        const algorithmName = reader.readString('ascii');\r\n        if (algorithmName !== this.name) {\r\n            throw new Error('Mismatched public key algorithm: ' +\r\n                `got '${algorithmName}', expected '${this.name}'.`);\r\n        }\r\n        const signature = reader.readBinary();\r\n        return signature;\r\n    }\r\n    createSignatureData(signature) {\r\n        const writer = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(this.name.length + signature.length + 20));\r\n        writer.writeString(this.name, 'ascii');\r\n        writer.writeBinary(signature);\r\n        return writer.toBuffer();\r\n    }\r\n}\r\nexports.PublicKeyAlgorithm = PublicKeyAlgorithm;\r\n//# sourceMappingURL=publicKeyAlgorithm.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.algorithmNames = exports.SshAlgorithms = exports.Encryption = exports.ECDsa = exports.Rsa = exports.HmacAlgorithm = exports.EncryptionAlgorithm = exports.PublicKeyAlgorithm = exports.KeyExchangeAlgorithm = void 0;\r\nconst keyExchangeAlgorithm_1 = require(\"./keyExchangeAlgorithm\");\r\nObject.defineProperty(exports, \"KeyExchangeAlgorithm\", { enumerable: true, get: function () { return keyExchangeAlgorithm_1.KeyExchangeAlgorithm; } });\r\nconst publicKeyAlgorithm_1 = require(\"./publicKeyAlgorithm\");\r\nObject.defineProperty(exports, \"PublicKeyAlgorithm\", { enumerable: true, get: function () { return publicKeyAlgorithm_1.PublicKeyAlgorithm; } });\r\nconst encryptionAlgorithm_1 = require(\"./encryptionAlgorithm\");\r\nObject.defineProperty(exports, \"EncryptionAlgorithm\", { enumerable: true, get: function () { return encryptionAlgorithm_1.EncryptionAlgorithm; } });\r\nconst hmacAlgorithm_1 = require(\"./hmacAlgorithm\");\r\nObject.defineProperty(exports, \"HmacAlgorithm\", { enumerable: true, get: function () { return hmacAlgorithm_1.HmacAlgorithm; } });\r\n// Swap imports to node crypto implementations when web crypto is not available.\r\nconst useWebCrypto = !!(typeof crypto === 'object' && crypto.subtle);\r\nconst webKeyExchange_1 = require(\"./web/webKeyExchange\");\r\nconst webRsa_1 = require(\"./web/webRsa\");\r\nconst webECDsa_1 = require(\"./web/webECDsa\");\r\nconst webEncryption_1 = require(\"./web/webEncryption\");\r\nconst webHmac_1 = require(\"./web/webHmac\");\r\nconst webRandom_1 = require(\"./web/webRandom\");\r\n// tslint:disable:variable-name\r\nconst DiffieHellman = useWebCrypto\r\n    ? webKeyExchange_1.WebDiffieHellman\r\n    : require('./node/nodeKeyExchange').NodeDiffieHellman;\r\nconst ECDiffieHellman = useWebCrypto\r\n    ? webKeyExchange_1.WebECDiffieHellman\r\n    : require('./node/nodeKeyExchange').NodeECDiffieHellman;\r\nconst Rsa = useWebCrypto ? webRsa_1.WebRsa : require('./node/nodeRsa').NodeRsa;\r\nexports.Rsa = Rsa;\r\nconst ECDsa = useWebCrypto ? webECDsa_1.WebECDsa : require('./node/nodeECDsa').NodeECDsa;\r\nexports.ECDsa = ECDsa;\r\nconst Encryption = useWebCrypto\r\n    ? webEncryption_1.WebEncryption\r\n    : require('./node/nodeEncryption').NodeEncryption;\r\nexports.Encryption = Encryption;\r\nconst Hmac = useWebCrypto ? webHmac_1.WebHmac : require('./node/nodeHmac').NodeHmac;\r\nconst Random = useWebCrypto ? webRandom_1.WebRandom : require('./node/nodeRandom').NodeRandom;\r\nclass SshAlgorithms {\r\n}\r\nexports.SshAlgorithms = SshAlgorithms;\r\nSshAlgorithms.keyExchange = {\r\n    none: null,\r\n    dhGroup14Sha256: new DiffieHellman('diffie-hellman-group14-sha256', 2048, 'SHA2-256'),\r\n    dhGroup16Sha512: new DiffieHellman('diffie-hellman-group16-sha512', 4096, 'SHA2-512'),\r\n    ecdhNistp256Sha256: new ECDiffieHellman('ecdh-sha2-nistp256', 256, 'SHA2-256'),\r\n    ecdhNistp384Sha384: new ECDiffieHellman('ecdh-sha2-nistp384', 384, 'SHA2-384'),\r\n    ecdhNistp521Sha512: new ECDiffieHellman('ecdh-sha2-nistp521', 521, 'SHA2-512'),\r\n};\r\nSshAlgorithms.publicKey = {\r\n    none: null,\r\n    rsaWithSha256: new Rsa('rsa-sha2-256', 'SHA2-256'),\r\n    rsaWithSha512: new Rsa('rsa-sha2-512', 'SHA2-512'),\r\n    ecdsaSha2Nistp256: new ECDsa('ecdsa-sha2-nistp256', 'SHA2-256'),\r\n    ecdsaSha2Nistp384: new ECDsa('ecdsa-sha2-nistp384', 'SHA2-384'),\r\n    ecdsaSha2Nistp521: new ECDsa('ecdsa-sha2-nistp521', 'SHA2-512'),\r\n};\r\nSshAlgorithms.encryption = {\r\n    none: null,\r\n    ////aes256Cbc: new Encryption('aes256-cbc', 'AES', 'CBC', 256) },\r\n    aes256Ctr: new Encryption('aes256-ctr', 'AES', 'CTR', 256),\r\n    aes256Gcm: new Encryption('aes256-gcm@openssh.com', 'AES', 'GCM', 256),\r\n};\r\nSshAlgorithms.hmac = {\r\n    none: null,\r\n    hmacSha256: new Hmac('hmac-sha2-256', 'SHA2-256'),\r\n    hmacSha512: new Hmac('hmac-sha2-512', 'SHA2-512'),\r\n    hmacSha256Etm: new Hmac('hmac-sha2-256-etm@openssh.com', 'SHA2-256', true),\r\n    hmacSha512Etm: new Hmac('hmac-sha2-512-etm@openssh.com', 'SHA2-512', true),\r\n};\r\nSshAlgorithms.compression = {\r\n    none: null,\r\n};\r\nSshAlgorithms.random = new Random();\r\nfunction algorithmNames(list) {\r\n    return list.map((a) => (a ? a.name : 'none'));\r\n}\r\nexports.algorithmNames = algorithmNames;\r\n//# sourceMappingURL=sshAlgorithms.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.JsonWebKeyFormatter = void 0;\r\nconst bigInt_1 = require(\"../../io/bigInt\");\r\nconst ecdsaCurves_1 = require(\"../ecdsaCurves\");\r\n/**\r\n * Provides *minimal* JWK import/export support for web keys.\r\n *\r\n * This code is redundant with some of the JWK import/export code in the separate\r\n * `ssh-keys` library; that is intentional, and necessary to support a consistent\r\n * interface for importing/exporting key parameters in the core `ssh` library.\r\n */\r\nclass JsonWebKeyFormatter {\r\n    static formatRsa(rsa, includePrivate) {\r\n        const formatBigInt = JsonWebKeyFormatter.formatBigInt;\r\n        let jwk;\r\n        if (includePrivate !== false && rsa.d && rsa.p && rsa.q && rsa.dp && rsa.dq && rsa.qi) {\r\n            jwk = {\r\n                kty: 'RSA',\r\n                n: formatBigInt(rsa.modulus),\r\n                e: formatBigInt(rsa.exponent),\r\n                d: formatBigInt(rsa.d),\r\n                p: formatBigInt(rsa.p),\r\n                q: formatBigInt(rsa.q),\r\n                dp: formatBigInt(rsa.dp),\r\n                dq: formatBigInt(rsa.dq),\r\n                qi: formatBigInt(rsa.qi),\r\n            };\r\n        }\r\n        else if (!includePrivate) {\r\n            jwk = {\r\n                kty: 'RSA',\r\n                n: formatBigInt(rsa.modulus),\r\n                e: formatBigInt(rsa.exponent),\r\n            };\r\n        }\r\n        else {\r\n            throw new Error('Missing private key parameters.');\r\n        }\r\n        return jwk;\r\n    }\r\n    static parseRsa(jwk, includePrivate) {\r\n        if ((jwk === null || jwk === void 0 ? void 0 : jwk.kty) !== 'RSA' || !(jwk.n && jwk.e))\r\n            throw new Error('Invalid RSA JWK.');\r\n        const parseBigInt = JsonWebKeyFormatter.parseBigInt;\r\n        let rsa;\r\n        if (includePrivate !== false && jwk.d && jwk.p && jwk.q && jwk.dp && jwk.dq && jwk.qi) {\r\n            rsa = {\r\n                modulus: parseBigInt(jwk.n),\r\n                exponent: parseBigInt(jwk.e),\r\n                d: parseBigInt(jwk.d),\r\n                p: parseBigInt(jwk.p),\r\n                q: parseBigInt(jwk.q),\r\n                dp: parseBigInt(jwk.dp),\r\n                dq: parseBigInt(jwk.dq),\r\n                qi: parseBigInt(jwk.qi),\r\n            };\r\n        }\r\n        else {\r\n            rsa = {\r\n                modulus: parseBigInt(jwk.n),\r\n                exponent: parseBigInt(jwk.e),\r\n            };\r\n        }\r\n        return rsa;\r\n    }\r\n    static formatEC(ec, includePrivate) {\r\n        const formatBigInt = JsonWebKeyFormatter.formatBigInt;\r\n        const curve = ecdsaCurves_1.curves.find((c) => c.oid === ec.curve.oid || c.name === ec.curve.name || c.shortName === ec.curve.name);\r\n        const keySizeInBytes = Math.ceil(curve.keySize / 8);\r\n        const jwk = {\r\n            kty: 'EC',\r\n            crv: ec.curve.name,\r\n            x: formatBigInt(ec.x, keySizeInBytes),\r\n            y: formatBigInt(ec.y, keySizeInBytes),\r\n        };\r\n        if (includePrivate !== false && ec.d) {\r\n            jwk.d = formatBigInt(ec.d, keySizeInBytes);\r\n        }\r\n        else if (includePrivate) {\r\n            throw new Error('Missing private key parameters.');\r\n        }\r\n        return jwk;\r\n    }\r\n    static parseEC(jwk, includePrivate) {\r\n        if ((jwk === null || jwk === void 0 ? void 0 : jwk.kty) !== 'EC' || !(jwk.crv && jwk.x && jwk.y))\r\n            throw new Error('Invalid EC JWK.');\r\n        const parseBigInt = JsonWebKeyFormatter.parseBigInt;\r\n        const ec = {\r\n            curve: { name: jwk.crv },\r\n            x: parseBigInt(jwk.x),\r\n            y: parseBigInt(jwk.y),\r\n        };\r\n        if (includePrivate !== false && jwk.d) {\r\n            ec.d = parseBigInt(jwk.d);\r\n        }\r\n        return ec;\r\n    }\r\n    static formatBigInt(value, length) {\r\n        return JsonWebKeyFormatter.base64UrlEncode(value.toBytes({ unsigned: true, length }));\r\n    }\r\n    static parseBigInt(value) {\r\n        return bigInt_1.BigInt.fromBytes(Buffer.from(value, 'base64'), { unsigned: true });\r\n    }\r\n    static base64UrlEncode(data) {\r\n        // JWK format uses base64-url-encoding, which is base64 but with 2 substituted characters.\r\n        // (Note Buffer's base64 DECODING implicitly supports this format.)\r\n        return data\r\n            .toString('base64')\r\n            .replace(/=+$/g, '')\r\n            .replace(/\\+/g, '-')\r\n            .replace(/\\//g, '_');\r\n    }\r\n}\r\nexports.JsonWebKeyFormatter = JsonWebKeyFormatter;\r\n//# sourceMappingURL=jsonWebKeyFormatter.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.WebECDsa = void 0;\r\nconst buffer_1 = require(\"buffer\");\r\nconst publicKeyAlgorithm_1 = require(\"../publicKeyAlgorithm\");\r\nconst sshData_1 = require(\"../../io/sshData\");\r\nconst ecdsaCurves_1 = require(\"../ecdsaCurves\");\r\nconst bigInt_1 = require(\"../../io/bigInt\");\r\nconst jsonWebKeyFormatter_1 = require(\"./jsonWebKeyFormatter\");\r\nclass WebECDsaKeyPair {\r\n    /**\r\n     * Constructs a new ECDSA key pair object.\r\n     *\r\n     * @param algorithmName Key pair algorithm name. If unspecified, the key pair object must be\r\n     * initialized before use via `importParameters()`.\r\n     */\r\n    constructor(algorithmName) {\r\n        this.comment = null;\r\n        if (algorithmName) {\r\n            this.algorithmName = algorithmName;\r\n        }\r\n    }\r\n    get hasPublicKey() {\r\n        return !!this.publicKey;\r\n    }\r\n    get hasPrivateKey() {\r\n        return !!this.privateKey;\r\n    }\r\n    get keyAlgorithmName() {\r\n        return this.algorithmName;\r\n    }\r\n    get algorithmName() {\r\n        return this.algorithm;\r\n    }\r\n    set algorithmName(value) {\r\n        const curveName = value.split('-')[2];\r\n        this.curve = ecdsaCurves_1.curves.find((c) => c.name === curveName);\r\n        if (!this.curve) {\r\n            throw new Error('Invalid or unsupported ECDSA algorithm: ' + value);\r\n        }\r\n        this.algorithm = value;\r\n    }\r\n    async generate() {\r\n        try {\r\n            const keyGenParams = {\r\n                name: 'ECDSA',\r\n                namedCurve: this.curve.shortName,\r\n            };\r\n            const keyPair = (await crypto.subtle.generateKey(keyGenParams, true, ['sign', 'verify']));\r\n            this.publicKey = keyPair.publicKey;\r\n            this.privateKey = keyPair.privateKey;\r\n        }\r\n        catch (e) {\r\n            throw new Error('Failed to generate RSA key pair: ' + e);\r\n        }\r\n    }\r\n    async setPublicKeyBytes(keyBytes, algorithmName) {\r\n        if (!keyBytes) {\r\n            throw new TypeError('Buffer is required.');\r\n        }\r\n        // Read public key in SSH format.\r\n        const reader = new sshData_1.SshDataReader(keyBytes);\r\n        const readAlgorithmName = reader.readString('ascii');\r\n        this.algorithmName = algorithmName || readAlgorithmName;\r\n        const curveName = reader.readString('ascii');\r\n        if (curveName !== this.curve.name) {\r\n            throw new Error('EC curve name does not match.');\r\n        }\r\n        // X and Y parameters are equal length, after a one-byte header.\r\n        const key = reader.readBinary();\r\n        const n = Math.ceil(this.curve.keySize / 8);\r\n        const x = bigInt_1.BigInt.fromBytes(key.slice(1, 1 + n), { unsigned: true });\r\n        const y = bigInt_1.BigInt.fromBytes(key.slice(1 + n, key.length), { unsigned: true });\r\n        const jwk = jsonWebKeyFormatter_1.JsonWebKeyFormatter.formatEC({\r\n            curve: { name: this.curve.shortName, oid: this.curve.oid },\r\n            x,\r\n            y,\r\n        });\r\n        try {\r\n            const importParams = {\r\n                name: 'ECDSA',\r\n                namedCurve: this.curve.shortName,\r\n            };\r\n            this.publicKey = await crypto.subtle.importKey('jwk', jwk, importParams, true, ['verify']);\r\n        }\r\n        catch (e) {\r\n            throw new Error('Failed to import EC public key: ' + e);\r\n        }\r\n    }\r\n    async getPublicKeyBytes(algorithmName) {\r\n        if (!this.publicKey) {\r\n            return null;\r\n        }\r\n        // Export public key in JWK format.\r\n        let jwk;\r\n        try {\r\n            jwk = await crypto.subtle.exportKey('jwk', this.publicKey);\r\n        }\r\n        catch (e) {\r\n            throw new Error('Failed to export ECDSA public key: ' + e);\r\n        }\r\n        const x = buffer_1.Buffer.from(jwk.x, 'base64');\r\n        const y = buffer_1.Buffer.from(jwk.y, 'base64');\r\n        const n = Math.ceil(this.curve.keySize / 8);\r\n        if (x.length !== n || y.length !== n) {\r\n            throw new Error('Unexpected key length.');\r\n        }\r\n        // Write public key in SSH format.\r\n        algorithmName = algorithmName || this.algorithmName || this.keyAlgorithmName;\r\n        const keyBuffer = buffer_1.Buffer.alloc(algorithmName.length + x.length + y.length + 10);\r\n        const keyWriter = new sshData_1.SshDataWriter(keyBuffer);\r\n        keyWriter.writeString(algorithmName, 'ascii');\r\n        keyWriter.writeString(this.curve.name, 'ascii');\r\n        keyWriter.writeUInt32(1 + x.length + y.length);\r\n        keyWriter.writeByte(4); // Indicates uncompressed curve format\r\n        keyWriter.write(x);\r\n        keyWriter.write(y);\r\n        const keyBytes = keyWriter.toBuffer();\r\n        return keyBytes;\r\n    }\r\n    async importParameters(parameters) {\r\n        if (!parameters.curve)\r\n            throw new TypeError('A curve is required.');\r\n        let curve;\r\n        if (parameters.curve.oid) {\r\n            curve = ecdsaCurves_1.curves.find((c) => c.oid === parameters.curve.oid);\r\n            if (!curve) {\r\n                throw new Error(`Unsupported curve OID: ${parameters.curve.oid}`);\r\n            }\r\n        }\r\n        else if (parameters.curve.name) {\r\n            curve = ecdsaCurves_1.curves.find((c) => c.name === parameters.curve.name);\r\n            if (!curve) {\r\n                throw new Error(`Unsupported curve: ${parameters.curve.name}`);\r\n            }\r\n        }\r\n        else {\r\n            throw new TypeError('A curve OID or name is required.');\r\n        }\r\n        this.algorithmName = 'ecdsa-sha2-' + curve.name;\r\n        const importParams = {\r\n            name: 'ECDSA',\r\n            namedCurve: this.curve.shortName,\r\n        };\r\n        const jwk = jsonWebKeyFormatter_1.JsonWebKeyFormatter.formatEC(parameters);\r\n        jwk.crv = this.curve.shortName;\r\n        try {\r\n            if (jwk.d) {\r\n                this.privateKey = await crypto.subtle.importKey('jwk', jwk, importParams, true, [\r\n                    'sign',\r\n                ]);\r\n                jwk.d = undefined;\r\n            }\r\n            else {\r\n                this.privateKey = undefined;\r\n            }\r\n            this.publicKey = await crypto.subtle.importKey('jwk', jwk, importParams, true, ['verify']);\r\n        }\r\n        catch (e) {\r\n            throw new Error('Failed to import ECDSA key pair: ' + e);\r\n        }\r\n    }\r\n    async exportParameters() {\r\n        var _a;\r\n        const exportKey = (_a = this.privateKey) !== null && _a !== void 0 ? _a : this.publicKey;\r\n        if (!exportKey) {\r\n            throw new Error('Key not present.');\r\n        }\r\n        let jwk;\r\n        try {\r\n            jwk = await crypto.subtle.exportKey('jwk', exportKey);\r\n        }\r\n        catch (e) {\r\n            throw new Error('Failed to export ECDSA key pair: ' + e);\r\n        }\r\n        const parameters = jsonWebKeyFormatter_1.JsonWebKeyFormatter.parseEC(jwk);\r\n        parameters.curve = { name: this.curve.name, oid: this.curve.oid };\r\n        return parameters;\r\n    }\r\n    dispose() { }\r\n}\r\nclass WebECDsa extends publicKeyAlgorithm_1.PublicKeyAlgorithm {\r\n    constructor(name, hashAlgorithmName) {\r\n        super(name, name, hashAlgorithmName);\r\n    }\r\n    createKeyPair() {\r\n        return new WebECDsaKeyPair(this.name);\r\n    }\r\n    async generateKeyPair() {\r\n        const ecdsaKey = new WebECDsaKeyPair(this.name);\r\n        await ecdsaKey.generate();\r\n        return ecdsaKey;\r\n    }\r\n    createSigner(keyPair) {\r\n        if (!(keyPair instanceof WebECDsaKeyPair)) {\r\n            throw new TypeError('ECDSA key pair object expected.');\r\n        }\r\n        const hashAlgorithm = WebECDsa.convertHashAlgorithmName(this.hashAlgorithmName);\r\n        return new WebECDsaSignerVerifier(keyPair, hashAlgorithm);\r\n    }\r\n    createVerifier(keyPair) {\r\n        if (!(keyPair instanceof WebECDsaKeyPair)) {\r\n            throw new TypeError('ECDSA key pair object expected.');\r\n        }\r\n        const hashAlgorithm = WebECDsa.convertHashAlgorithmName(this.hashAlgorithmName);\r\n        return new WebECDsaSignerVerifier(keyPair, hashAlgorithm);\r\n    }\r\n    static convertHashAlgorithmName(hashAlgorithmName) {\r\n        return hashAlgorithmName.replace('SHA2-', 'SHA-');\r\n    }\r\n    /* @internal */\r\n    static getSignatureLength(keySizeInBits) {\r\n        // The signature is double the key size, but formatted as 2 bigints.\r\n        // To each bigint add 4 for the length and 1 for a leading zero.\r\n        const keySizeInBytes = Math.ceil(keySizeInBits / 8);\r\n        return (4 + 1 + keySizeInBytes) * 2;\r\n    }\r\n}\r\nexports.WebECDsa = WebECDsa;\r\nWebECDsa.ecdsaSha2Nistp256 = 'ecdsa-sha2-nistp256';\r\nWebECDsa.ecdsaSha2Nistp384 = 'ecdsa-sha2-nistp384';\r\nWebECDsa.ecdsaSha2Nistp521 = 'ecdsa-sha2-nistp521';\r\nWebECDsa.curves = ecdsaCurves_1.curves;\r\n// eslint-disable-next-line @typescript-eslint/tslint/config\r\nWebECDsa.KeyPair = WebECDsaKeyPair;\r\nclass WebECDsaSignerVerifier {\r\n    constructor(keyPair, hashAlgorithm) {\r\n        this.keyPair = keyPair;\r\n        this.hashAlgorithm = hashAlgorithm;\r\n    }\r\n    get digestLength() {\r\n        const curve = this.keyPair.curve;\r\n        if (!curve) {\r\n            return 0;\r\n        }\r\n        else {\r\n            return WebECDsa.getSignatureLength(curve.keySize);\r\n        }\r\n    }\r\n    async sign(data) {\r\n        if (!this.keyPair.privateKey) {\r\n            throw new Error('Private key not set.');\r\n        }\r\n        let signature = buffer_1.Buffer.from(await crypto.subtle.sign({ name: 'ECDSA', hash: { name: this.hashAlgorithm } }, this.keyPair.privateKey, data));\r\n        const keySizeInBytes = Math.ceil(this.keyPair.curve.keySize / 8);\r\n        if (signature.length !== 2 * keySizeInBytes) {\r\n            throw new Error(`Unexpected signature length: ${signature.length}`);\r\n        }\r\n        // Reformat the signature integer bytes as required by SSH.\r\n        const x = bigInt_1.BigInt.fromBytes(signature.slice(0, keySizeInBytes), { unsigned: true });\r\n        const y = bigInt_1.BigInt.fromBytes(signature.slice(keySizeInBytes, signature.length), {\r\n            unsigned: true,\r\n        });\r\n        const signatureWriter = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(this.digestLength));\r\n        signatureWriter.writeBinary(x.toBytes({ unsigned: true, length: keySizeInBytes + 1 }));\r\n        signatureWriter.writeBinary(y.toBytes({ unsigned: true, length: keySizeInBytes + 1 }));\r\n        signature = signatureWriter.toBuffer();\r\n        return signature;\r\n    }\r\n    async verify(data, signature) {\r\n        if (!this.keyPair.publicKey) {\r\n            throw new Error('Public key not set.');\r\n        }\r\n        // Reformat the signature integer bytes as required by the web crypto API.\r\n        const signatureReader = new sshData_1.SshDataReader(signature);\r\n        const x = signatureReader.readBigInt();\r\n        const y = signatureReader.readBigInt();\r\n        const keySizeInBytes = Math.ceil(this.keyPair.curve.keySize / 8);\r\n        signature = buffer_1.Buffer.alloc(2 * keySizeInBytes);\r\n        x.toBytes({ unsigned: true, length: keySizeInBytes }).copy(signature, 0);\r\n        y.toBytes({ unsigned: true, length: keySizeInBytes }).copy(signature, keySizeInBytes);\r\n        const result = await crypto.subtle.verify({ name: 'ECDSA', hash: { name: this.hashAlgorithm } }, this.keyPair.publicKey, signature, data);\r\n        return result;\r\n    }\r\n    dispose() { }\r\n}\r\n//# sourceMappingURL=webECDsa.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.WebEncryption = void 0;\r\nconst trace_1 = require(\"../../trace\");\r\nconst buffer_1 = require(\"buffer\");\r\nconst encryptionAlgorithm_1 = require(\"../encryptionAlgorithm\");\r\nclass WebEncryption extends encryptionAlgorithm_1.EncryptionAlgorithm {\r\n    constructor(name, algorithmName, cipherMode, keySizeInBits) {\r\n        super(name);\r\n        this.algorithmName = algorithmName;\r\n        this.cipherMode = cipherMode;\r\n        this.keySizeInBits = keySizeInBits;\r\n        this.blockSizeInBits = WebEncryption.getBlockSize(algorithmName);\r\n    }\r\n    get keyLength() {\r\n        return this.keySizeInBits / 8;\r\n    }\r\n    get blockLength() {\r\n        return this.blockSizeInBits / 8;\r\n    }\r\n    async createCipher(isEncryption, key, iv) {\r\n        const cipher = new WebCipher(isEncryption, this.algorithmName, this.cipherMode, this.keySizeInBits, this.blockSizeInBits);\r\n        await cipher.init(key, iv);\r\n        return cipher;\r\n    }\r\n    static getBlockSize(algorithmName) {\r\n        if (algorithmName === 'AES') {\r\n            return 128;\r\n        }\r\n        else {\r\n            throw new Error(`Unsupported encryption algorithm: ${algorithmName}`);\r\n        }\r\n    }\r\n}\r\nexports.WebEncryption = WebEncryption;\r\nclass WebCipher {\r\n    constructor(isEncryption, algorithmName, cipherMode, keySizeInBits, blockSizeInBits) {\r\n        this.isEncryption = isEncryption;\r\n        this.algorithmName = algorithmName;\r\n        this.cipherMode = cipherMode;\r\n        this.keySizeInBits = keySizeInBits;\r\n        this.blockSizeInBits = blockSizeInBits;\r\n        this.tag = null;\r\n        if (this.algorithmName === 'AES' && this.cipherMode === 'CTR') {\r\n            this.transform = this.aesCtr.bind(this, isEncryption);\r\n        }\r\n        else if (this.algorithmName === 'AES' && this.cipherMode === 'CBC') {\r\n            this.transform = this.aesCbc.bind(this, isEncryption);\r\n        }\r\n        else if (this.algorithmName === 'AES' && this.cipherMode === 'GCM') {\r\n            this.transform = this.aesGcm.bind(this, isEncryption);\r\n            this.associatedData = buffer_1.Buffer.alloc(4);\r\n            this.decryptBuffer = buffer_1.Buffer.alloc(this.blockLength * 4);\r\n        }\r\n        else {\r\n            throw new Error(`Unsupported encryption algorithm: ${this.algorithmName}-${this.cipherMode}`);\r\n        }\r\n    }\r\n    get blockLength() {\r\n        return this.blockSizeInBits / 8;\r\n    }\r\n    async init(key, iv) {\r\n        try {\r\n            const name = `${this.algorithmName}-${this.cipherMode}`;\r\n            this.key = await crypto.subtle.importKey('raw', key, { name, length: this.keySizeInBits }, false, this.isEncryption ? ['encrypt'] : ['decrypt']);\r\n        }\r\n        catch (e) {\r\n            throw new Error('Failed to initialize AES: ' + e);\r\n        }\r\n        if (this.cipherMode === 'GCM') {\r\n            this.iv = buffer_1.Buffer.from(iv.slice(0, 12));\r\n        }\r\n        else {\r\n            this.iv = buffer_1.Buffer.from(iv);\r\n        }\r\n    }\r\n    async aesCtr(isEncryption, data) {\r\n        if (data.length % this.blockLength !== 0) {\r\n            const message = 'Encrypt/decrypt input has invalid length ' +\r\n                `${data.length}, not a multiple of block size ${this.blockLength}.`;\r\n            (0, trace_1.trace)('Error: ' + message);\r\n            throw new Error(message);\r\n        }\r\n        let result;\r\n        if (isEncryption) {\r\n            result = buffer_1.Buffer.from(await crypto.subtle.encrypt({ name: 'AES-CTR', counter: this.iv, length: this.blockSizeInBits }, this.key, data));\r\n        }\r\n        else {\r\n            result = buffer_1.Buffer.from(await crypto.subtle.decrypt({ name: 'AES-CTR', counter: this.iv, length: this.blockSizeInBits }, this.key, data));\r\n        }\r\n        if (result.length !== data.length) {\r\n            const message = 'Result from encrypt/decrypt has invalid length ' +\r\n                `${result.length}, expected ${data.length}.`;\r\n            (0, trace_1.trace)('Error: ' + message);\r\n            throw new Error(message);\r\n        }\r\n        // A single call to encrypt() or decrypt() internally increments the counter.\r\n        // This code ensures those increments get preserved across multiple calls.\r\n        const incrementCount = data.length / this.blockLength;\r\n        for (let i = 0; i < incrementCount; i++) {\r\n            // Increment the counter that is combined with the IV as a big-endian integer.\r\n            // First increment the last byte, and if it reaches 0 then increment the\r\n            // next-to-last byte, and so on.\r\n            for (let k = this.iv.length - 1; k >= 0; k--) {\r\n                this.iv[k] = this.iv[k] + 1;\r\n                if (this.iv[k])\r\n                    break;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    async aesCbc(isEncryption, data) {\r\n        // TODO: Fix padding. Web crypto's AES-CBC uses padding by default,\r\n        // which isn't compatible with SSH.\r\n        if (isEncryption) {\r\n            let result = buffer_1.Buffer.from(await crypto.subtle.encrypt({ name: 'AES-CBC', iv: this.iv }, this.key, data));\r\n            result = result.slice(0, data.length);\r\n            return result;\r\n        }\r\n        else {\r\n            return buffer_1.Buffer.from(await crypto.subtle.decrypt({ name: 'AES-CBC', iv: this.iv }, this.key, data));\r\n        }\r\n    }\r\n    async aesGcm(isEncryption, data) {\r\n        if (data.length % this.blockLength !== 0) {\r\n            const message = 'Encrypt/decrypt input has invalid length ' +\r\n                `${data.length}, not a multiple of block size ${this.blockLength}.`;\r\n            (0, trace_1.trace)('Error: ' + message);\r\n            throw new Error(message);\r\n        }\r\n        // Associated data is the 32-bit packet length.\r\n        const packetLength = data.length;\r\n        this.associatedData[0] = packetLength >>> 24;\r\n        this.associatedData[1] = packetLength >>> 16;\r\n        this.associatedData[2] = packetLength >>> 8;\r\n        this.associatedData[3] = packetLength;\r\n        let result;\r\n        if (isEncryption) {\r\n            result = buffer_1.Buffer.from(await crypto.subtle.encrypt({\r\n                name: 'AES-GCM',\r\n                iv: this.iv,\r\n                additionalData: this.associatedData,\r\n                tagLength: this.digestLength * 8, // tagLength is in bits, not bytes\r\n            }, this.key, data));\r\n            this.tag = result.slice(result.length - this.digestLength);\r\n            result = result.slice(0, result.length - this.digestLength);\r\n        }\r\n        else {\r\n            if (!this.tag) {\r\n                throw new Error('AES-GCM tag was not set before decrypting.');\r\n            }\r\n            // The AES-GCM decrypt API expects the ciphertext and tag to be in a contiguous buffer.\r\n            // Re-use a temporary buffer for that purpose, expanding it as needed.\r\n            const inputLength = data.length + this.digestLength;\r\n            if (this.decryptBuffer.length < inputLength) {\r\n                let newLength = this.decryptBuffer.length * 2;\r\n                while (newLength < inputLength)\r\n                    newLength *= 2;\r\n                this.decryptBuffer = buffer_1.Buffer.alloc(newLength);\r\n            }\r\n            const input = this.decryptBuffer.slice(0, inputLength);\r\n            data.copy(input, 0);\r\n            this.tag.copy(input, data.length);\r\n            result = buffer_1.Buffer.from(await crypto.subtle.decrypt({\r\n                name: 'AES-GCM',\r\n                iv: this.iv,\r\n                additionalData: this.associatedData,\r\n                tagLength: this.digestLength * 8, // tagLength is in bits, not bytes\r\n            }, this.key, input));\r\n        }\r\n        if (result.length !== data.length) {\r\n            const message = 'Result from encrypt/decrypt has invalid length ' +\r\n                `${result.length}, expected ${data.length}.`;\r\n            (0, trace_1.trace)('Error: ' + message);\r\n            throw new Error(message);\r\n        }\r\n        // Increment the counter (last 8 bytes of the iv/nonce) as a big-endian integer.\r\n        // First increment the last byte, and if it reaches 0 then increment the\r\n        // next-to-last byte, and so on.\r\n        let k = 12;\r\n        while (--k >= 4) {\r\n            this.iv[k]++;\r\n            if (this.iv[k] !== 0) {\r\n                break;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    get digestLength() {\r\n        return 16;\r\n    }\r\n    get authenticatedEncryption() {\r\n        return this.cipherMode === 'GCM';\r\n    }\r\n    async sign(data) {\r\n        if (!this.tag) {\r\n            throw new Error('AES-GCM tag was not obtained by encrypting.');\r\n        }\r\n        return this.tag;\r\n    }\r\n    async verify(data, signature) {\r\n        if (signature.length !== this.digestLength) {\r\n            throw new Error('Incorrect AES-GCM tag length.');\r\n        }\r\n        this.tag = signature;\r\n        return true;\r\n    }\r\n    dispose() { }\r\n}\r\n//# sourceMappingURL=webEncryption.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.WebHmac = void 0;\r\nconst buffer_1 = require(\"buffer\");\r\nconst hmacAlgorithm_1 = require(\"../hmacAlgorithm\");\r\nclass WebHmac extends hmacAlgorithm_1.HmacAlgorithm {\r\n    constructor(name, algorithmName, encryptThenMac = false) {\r\n        super(name, algorithmName, WebHmac.getHashKeyLength(algorithmName), WebHmac.getHashDigestLength(algorithmName));\r\n        this.encryptThenMac = encryptThenMac;\r\n    }\r\n    async createSigner(key) {\r\n        const hmac = new WebSignerVerifier(this.algorithmName, true, this.digestLength, this.encryptThenMac);\r\n        await hmac.init(key);\r\n        return hmac;\r\n    }\r\n    async createVerifier(key) {\r\n        const hmac = new WebSignerVerifier(this.algorithmName, false, this.digestLength, this.encryptThenMac);\r\n        await hmac.init(key);\r\n        return hmac;\r\n    }\r\n    static getHashKeyLength(hashAlgorithmName) {\r\n        if (hashAlgorithmName === 'SHA2-512')\r\n            return 512 / 8;\r\n        if (hashAlgorithmName === 'SHA2-384')\r\n            return 384 / 8;\r\n        if (hashAlgorithmName === 'SHA2-256')\r\n            return 256 / 8;\r\n        throw new Error(`Unsupported hash algorithm: ${hashAlgorithmName}`);\r\n    }\r\n    static getHashDigestLength(hashAlgorithmName) {\r\n        return this.getHashKeyLength(hashAlgorithmName);\r\n    }\r\n    static getWebHashAlgorithmName(hashAlgorithmName) {\r\n        if (hashAlgorithmName === 'SHA2-512')\r\n            return 'SHA-512';\r\n        if (hashAlgorithmName === 'SHA2-384')\r\n            return 'SHA-384';\r\n        if (hashAlgorithmName === 'SHA2-256')\r\n            return 'SHA-256';\r\n        throw new Error(`Unsupported hash algorithm: ${hashAlgorithmName}`);\r\n    }\r\n}\r\nexports.WebHmac = WebHmac;\r\nclass WebSignerVerifier {\r\n    constructor(algorithmName, isSigning, digestLength, encryptThenMac) {\r\n        this.algorithmName = algorithmName;\r\n        this.isSigning = isSigning;\r\n        this.digestLength = digestLength;\r\n        this.encryptThenMac = encryptThenMac;\r\n    }\r\n    async init(key) {\r\n        try {\r\n            const name = this.algorithmName.replace('SHA2-', 'SHA-');\r\n            this.key = await crypto.subtle.importKey('raw', key, { name: 'HMAC', hash: { name } }, false, this.isSigning ? ['sign'] : ['verify']);\r\n        }\r\n        catch (e) {\r\n            throw new Error('Failed to initialize HMAC: ' + e);\r\n        }\r\n    }\r\n    async sign(data) {\r\n        return buffer_1.Buffer.from(await crypto.subtle.sign({ name: 'HMAC', hash: { name: this.algorithmName } }, this.key, data));\r\n    }\r\n    async verify(data, signature) {\r\n        return await crypto.subtle.verify({ name: 'HMAC', hash: { name: this.algorithmName } }, this.key, signature, data);\r\n    }\r\n    dispose() { }\r\n}\r\n//# sourceMappingURL=webHmac.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.WebECDiffieHellman = exports.WebDiffieHellman = void 0;\r\nconst buffer_1 = require(\"buffer\");\r\nconst diffie_hellman_1 = require(\"diffie-hellman\");\r\nconst keyExchangeAlgorithm_1 = require(\"../keyExchangeAlgorithm\");\r\nconst webHmac_1 = require(\"./webHmac\");\r\nconst bigInt_1 = require(\"../../io/bigInt\");\r\nconst jsonWebKeyFormatter_1 = require(\"./jsonWebKeyFormatter\");\r\nclass WebDiffieHellman extends keyExchangeAlgorithm_1.KeyExchangeAlgorithm {\r\n    constructor(name, keySizeInBits, hashAlgorithmName) {\r\n        super(name, keySizeInBits, hashAlgorithmName, webHmac_1.WebHmac.getHashDigestLength(hashAlgorithmName));\r\n    }\r\n    createKeyExchange() {\r\n        return new WebDiffieHellmanKex(this.keySizeInBits, webHmac_1.WebHmac.getWebHashAlgorithmName(this.hashAlgorithmName), this.hashDigestLength);\r\n    }\r\n}\r\nexports.WebDiffieHellman = WebDiffieHellman;\r\nclass WebDiffieHellmanKex {\r\n    constructor(bitLength, hashAlgorithmName, digestLength) {\r\n        this.hashAlgorithmName = hashAlgorithmName;\r\n        this.digestLength = digestLength;\r\n        switch (bitLength) {\r\n            case 1024:\r\n                this.dh = (0, diffie_hellman_1.getDiffieHellman)('modp2');\r\n                break;\r\n            case 2048:\r\n                this.dh = (0, diffie_hellman_1.getDiffieHellman)('modp14');\r\n                break;\r\n            case 4096:\r\n                this.dh = (0, diffie_hellman_1.getDiffieHellman)('modp16');\r\n                break;\r\n            default:\r\n                throw new Error('Invalid DH bit length.');\r\n        }\r\n    }\r\n    startKeyExchange() {\r\n        const exchangeValueKeys = this.dh.generateKeys();\r\n        const exchangeValue = bigInt_1.BigInt.fromBytes(exchangeValueKeys, { unsigned: true }).toBytes();\r\n        return Promise.resolve(exchangeValue);\r\n    }\r\n    decryptKeyExchange(exchangeValue) {\r\n        const key = this.dh.computeSecret(exchangeValue);\r\n        const sharedSecret = bigInt_1.BigInt.fromBytes(key, { unsigned: true }).toBytes();\r\n        return Promise.resolve(sharedSecret);\r\n    }\r\n    async sign(data) {\r\n        const hashBuffer = await crypto.subtle.digest(this.hashAlgorithmName, data);\r\n        return buffer_1.Buffer.from(hashBuffer);\r\n    }\r\n    dispose() { }\r\n}\r\nclass WebECDiffieHellman extends keyExchangeAlgorithm_1.KeyExchangeAlgorithm {\r\n    constructor(name, keySizeInBits, hashAlgorithmName) {\r\n        super(name, keySizeInBits, hashAlgorithmName, webHmac_1.WebHmac.getHashDigestLength(hashAlgorithmName));\r\n    }\r\n    createKeyExchange() {\r\n        return new WebECDiffieHellmanKex(this.keySizeInBits, webHmac_1.WebHmac.getWebHashAlgorithmName(this.hashAlgorithmName), this.hashDigestLength);\r\n    }\r\n}\r\nexports.WebECDiffieHellman = WebECDiffieHellman;\r\nclass WebECDiffieHellmanKex {\r\n    constructor(bitLength, hashAlgorithmName, digestLength) {\r\n        this.bitLength = bitLength;\r\n        this.hashAlgorithmName = hashAlgorithmName;\r\n        this.digestLength = digestLength;\r\n        this.algorithm = {\r\n            name: 'ECDH',\r\n            namedCurve: 'P-' + bitLength,\r\n        };\r\n    }\r\n    async startKeyExchange() {\r\n        if (!this.keyPair) {\r\n            this.keyPair = await crypto.subtle.generateKey(this.algorithm, true, // exportable\r\n            ['deriveBits']);\r\n        }\r\n        const jwk = await crypto.subtle.exportKey('jwk', this.keyPair.publicKey);\r\n        const ec = jsonWebKeyFormatter_1.JsonWebKeyFormatter.parseEC(jwk);\r\n        const length = Math.ceil(this.bitLength / 8);\r\n        const publicKeyBytes = buffer_1.Buffer.alloc(1 + length * 2);\r\n        publicKeyBytes[0] = 4;\r\n        ec.x.toBytes({ unsigned: true, length }).copy(publicKeyBytes, 1);\r\n        ec.y.toBytes({ unsigned: true, length }).copy(publicKeyBytes, 1 + length);\r\n        return buffer_1.Buffer.from(publicKeyBytes);\r\n    }\r\n    async decryptKeyExchange(exchangeValue) {\r\n        if (!this.keyPair) {\r\n            throw new Error('Key exchange not started.');\r\n        }\r\n        const xy = exchangeValue;\r\n        const jwk = jsonWebKeyFormatter_1.JsonWebKeyFormatter.formatEC({\r\n            curve: { name: this.algorithm.namedCurve },\r\n            x: bigInt_1.BigInt.fromBytes(xy.slice(1, 1 + (xy.length - 1) / 2), { unsigned: true }),\r\n            y: bigInt_1.BigInt.fromBytes(xy.slice(1 + (xy.length - 1) / 2), { unsigned: true }),\r\n        });\r\n        const otherPublicKey = await crypto.subtle.importKey('jwk', jwk, this.algorithm, false, []);\r\n        const sharedSecretBytes = buffer_1.Buffer.from(await crypto.subtle.deriveBits(Object.assign(Object.assign({}, this.algorithm), { public: otherPublicKey }), this.keyPair.privateKey, Math.ceil(this.bitLength / 8) * 8));\r\n        const sharedSecret = bigInt_1.BigInt.fromBytes(sharedSecretBytes, { unsigned: true }).toBytes();\r\n        return sharedSecret;\r\n    }\r\n    async sign(data) {\r\n        const hashBuffer = await crypto.subtle.digest(this.hashAlgorithmName, data);\r\n        return buffer_1.Buffer.from(hashBuffer);\r\n    }\r\n    dispose() { }\r\n}\r\n//# sourceMappingURL=webKeyExchange.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.WebRandom = void 0;\r\nclass WebRandom {\r\n    getBytes(buffer) {\r\n        crypto.getRandomValues(buffer);\r\n    }\r\n}\r\nexports.WebRandom = WebRandom;\r\n//# sourceMappingURL=webRandom.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.WebRsa = void 0;\r\nconst buffer_1 = require(\"buffer\");\r\nconst publicKeyAlgorithm_1 = require(\"../publicKeyAlgorithm\");\r\nconst webHmac_1 = require(\"./webHmac\");\r\nconst sshData_1 = require(\"../../io/sshData\");\r\nconst jsonWebKeyFormatter_1 = require(\"./jsonWebKeyFormatter\");\r\n// Note this is exposed as an inner-class property below: `WebRsa.KeyPair`.\r\n// TypeScript requires that the class definition comes first.\r\nclass WebRsaKeyPair {\r\n    /* @internal */\r\n    constructor(hashAlgorithm) {\r\n        this.hashAlgorithm = hashAlgorithm;\r\n        this.comment = null;\r\n    }\r\n    get hasPublicKey() {\r\n        return !!this.publicKey;\r\n    }\r\n    get hasPrivateKey() {\r\n        return !!this.privateKey;\r\n    }\r\n    get keyAlgorithmName() {\r\n        return WebRsa.keyAlgorithmName;\r\n    }\r\n    async generate(keySizeInBits) {\r\n        keySizeInBits = keySizeInBits !== null && keySizeInBits !== void 0 ? keySizeInBits : WebRsaKeyPair.defaultKeySize;\r\n        try {\r\n            const keyGenParams = {\r\n                name: 'RSASSA-PKCS1-v1_5',\r\n                modulusLength: keySizeInBits,\r\n                publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\r\n                hash: { name: this.hashAlgorithm },\r\n            };\r\n            const keyPair = (await crypto.subtle.generateKey(keyGenParams, true, ['sign', 'verify']));\r\n            this.publicKey = keyPair.publicKey;\r\n            this.privateKey = keyPair.privateKey;\r\n        }\r\n        catch (e) {\r\n            throw new Error('Failed to generate RSA key pair: ' + e);\r\n        }\r\n    }\r\n    async setPublicKeyBytes(keyBytes) {\r\n        if (!keyBytes) {\r\n            throw new TypeError('Buffer is required.');\r\n        }\r\n        // Read public key in SSH format.\r\n        const reader = new sshData_1.SshDataReader(keyBytes);\r\n        const algorithmName = reader.readString('ascii');\r\n        if (algorithmName !== this.keyAlgorithmName &&\r\n            algorithmName !== WebRsa.rsaWithSha256 &&\r\n            algorithmName !== WebRsa.rsaWithSha512) {\r\n            throw new Error(`Invalid RSA key algorithm: ${algorithmName}`);\r\n        }\r\n        const exponent = reader.readBigInt();\r\n        const modulus = reader.readBigInt();\r\n        // Import public key in JWK format.\r\n        const jwk = jsonWebKeyFormatter_1.JsonWebKeyFormatter.formatRsa({ modulus, exponent }, false);\r\n        jwk.alg = 'RS' + this.hashAlgorithm.replace('SHA-', '');\r\n        jwk.key_ops = ['verify'];\r\n        try {\r\n            const importParams = {\r\n                name: 'RSASSA-PKCS1-v1_5',\r\n                hash: { name: this.hashAlgorithm },\r\n            };\r\n            this.publicKey = await crypto.subtle.importKey('jwk', jwk, importParams, true, ['verify']);\r\n        }\r\n        catch (e) {\r\n            throw new Error('Failed to import RSA public key: ' + e);\r\n        }\r\n    }\r\n    async getPublicKeyBytes(algorithmName) {\r\n        if (!this.publicKey) {\r\n            return null;\r\n        }\r\n        if (!algorithmName) {\r\n            algorithmName = this.keyAlgorithmName;\r\n        }\r\n        // Export public key in JWK format.\r\n        let jwk;\r\n        try {\r\n            jwk = await crypto.subtle.exportKey('jwk', this.publicKey);\r\n        }\r\n        catch (e) {\r\n            throw new Error('Failed to export RSA public key: ' + e);\r\n        }\r\n        const { modulus, exponent } = jsonWebKeyFormatter_1.JsonWebKeyFormatter.parseRsa(jwk, false);\r\n        // Write public key in SSH format.\r\n        const keyBuffer = buffer_1.Buffer.alloc(512);\r\n        const keyWriter = new sshData_1.SshDataWriter(keyBuffer);\r\n        keyWriter.writeString(algorithmName, 'ascii');\r\n        keyWriter.writeBigInt(exponent);\r\n        keyWriter.writeBigInt(modulus);\r\n        const keyBytes = keyWriter.toBuffer();\r\n        return keyBytes;\r\n    }\r\n    async importParameters(parameters) {\r\n        const privateJwk = parameters.d ? jsonWebKeyFormatter_1.JsonWebKeyFormatter.formatRsa(parameters, true) : null;\r\n        const publicJwk = jsonWebKeyFormatter_1.JsonWebKeyFormatter.formatRsa(parameters, false);\r\n        const importParams = {\r\n            name: 'RSASSA-PKCS1-v1_5',\r\n            hash: { name: this.hashAlgorithm },\r\n        };\r\n        try {\r\n            this.publicKey = await crypto.subtle.importKey('jwk', publicJwk, importParams, true, [\r\n                'verify',\r\n            ]);\r\n            if (privateJwk) {\r\n                this.privateKey = await crypto.subtle.importKey('jwk', privateJwk, importParams, true, [\r\n                    'sign',\r\n                ]);\r\n            }\r\n            else {\r\n                this.privateKey = undefined;\r\n            }\r\n        }\r\n        catch (e) {\r\n            if (!(e instanceof Error))\r\n                throw e;\r\n            throw new Error('Failed to import RSA key pair: ' + e.message);\r\n        }\r\n    }\r\n    async exportParameters() {\r\n        var _a;\r\n        if (!this.publicKey)\r\n            throw new Error('Public key not set.');\r\n        let jwk;\r\n        try {\r\n            jwk = await crypto.subtle.exportKey('jwk', (_a = this.privateKey) !== null && _a !== void 0 ? _a : this.publicKey);\r\n        }\r\n        catch (e) {\r\n            if (!(e instanceof Error))\r\n                throw e;\r\n            throw new Error('Failed to export RSA public key: ' + e.message);\r\n        }\r\n        return jsonWebKeyFormatter_1.JsonWebKeyFormatter.parseRsa(jwk, !!this.privateKey);\r\n    }\r\n    dispose() { }\r\n}\r\nWebRsaKeyPair.defaultKeySize = 2048;\r\nclass WebRsa extends publicKeyAlgorithm_1.PublicKeyAlgorithm {\r\n    constructor(name, hashAlgorithmName) {\r\n        super(name, WebRsa.keyAlgorithmName, hashAlgorithmName);\r\n    }\r\n    createKeyPair() {\r\n        const hashAlgorithm = WebRsa.convertHashAlgorithmName(this.hashAlgorithmName);\r\n        return new WebRsaKeyPair(hashAlgorithm);\r\n    }\r\n    async generateKeyPair(keySizeInBits) {\r\n        const hashAlgorithm = WebRsa.convertHashAlgorithmName(this.hashAlgorithmName);\r\n        const rsaKey = new WebRsaKeyPair(hashAlgorithm);\r\n        await rsaKey.generate(keySizeInBits);\r\n        return rsaKey;\r\n    }\r\n    createSigner(keyPair) {\r\n        if (!(keyPair instanceof WebRsaKeyPair)) {\r\n            throw new TypeError('RSA key pair object expected.');\r\n        }\r\n        const hashAlgorithm = WebRsa.convertHashAlgorithmName(this.hashAlgorithmName);\r\n        return new WebRsaSignerVerifier(keyPair, hashAlgorithm, webHmac_1.WebHmac.getHashDigestLength(this.hashAlgorithmName));\r\n    }\r\n    createVerifier(keyPair) {\r\n        if (!(keyPair instanceof WebRsaKeyPair)) {\r\n            throw new TypeError('RSA key pair object expected.');\r\n        }\r\n        const hashAlgorithm = WebRsa.convertHashAlgorithmName(this.hashAlgorithmName);\r\n        return new WebRsaSignerVerifier(keyPair, hashAlgorithm, webHmac_1.WebHmac.getHashDigestLength(this.hashAlgorithmName));\r\n    }\r\n    static convertHashAlgorithmName(hashAlgorithmName) {\r\n        return hashAlgorithmName.replace('SHA2-', 'SHA-');\r\n    }\r\n}\r\nexports.WebRsa = WebRsa;\r\nWebRsa.keyAlgorithmName = 'ssh-rsa';\r\nWebRsa.rsaWithSha256 = 'rsa-sha2-256';\r\nWebRsa.rsaWithSha512 = 'rsa-sha2-512';\r\n// eslint-disable-next-line @typescript-eslint/tslint/config\r\nWebRsa.KeyPair = WebRsaKeyPair;\r\nclass WebRsaSignerVerifier {\r\n    constructor(keyPair, hashAlgorithm, digestLength) {\r\n        this.keyPair = keyPair;\r\n        this.hashAlgorithm = hashAlgorithm;\r\n        this.digestLength = digestLength;\r\n    }\r\n    async sign(data) {\r\n        if (!this.keyPair.privateKey) {\r\n            throw new Error('Private key not set.');\r\n        }\r\n        await this.convertKeyHashAlgorithm();\r\n        const signature = buffer_1.Buffer.from(await crypto.subtle.sign('RSASSA-PKCS1-v1_5', this.keyPair.privateKey, data));\r\n        return signature;\r\n    }\r\n    async verify(data, signature) {\r\n        if (!this.keyPair.publicKey) {\r\n            throw new Error('Public key not set.');\r\n        }\r\n        await this.convertKeyHashAlgorithm();\r\n        const result = await crypto.subtle.verify('RSASSA-PKCS1-v1_5', this.keyPair.publicKey, signature, data);\r\n        return result;\r\n    }\r\n    async convertKeyHashAlgorithm() {\r\n        if (this.keyPair.hashAlgorithm !== this.hashAlgorithm) {\r\n            const parameters = await this.keyPair.exportParameters();\r\n            this.keyPair = new WebRsaKeyPair(this.hashAlgorithm);\r\n            await this.keyPair.importParameters(parameters);\r\n        }\r\n    }\r\n    dispose() { }\r\n}\r\n//# sourceMappingURL=webRsa.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ObjectDisposedError = exports.SshChannelError = exports.SshReconnectError = exports.SshConnectionError = void 0;\r\nclass SshConnectionError extends Error {\r\n    constructor(message, reason) {\r\n        super(message);\r\n        this.reason = reason;\r\n    }\r\n}\r\nexports.SshConnectionError = SshConnectionError;\r\nclass SshReconnectError extends Error {\r\n    constructor(message, reason) {\r\n        super(message);\r\n        this.reason = reason;\r\n    }\r\n}\r\nexports.SshReconnectError = SshReconnectError;\r\nclass SshChannelError extends Error {\r\n    constructor(message, reason) {\r\n        super(message);\r\n        this.reason = reason;\r\n    }\r\n}\r\nexports.SshChannelError = SshChannelError;\r\nclass ObjectDisposedError extends Error {\r\n    constructor(objectOrMessage) {\r\n        var _a, _b;\r\n        let message;\r\n        if (typeof objectOrMessage === 'string') {\r\n            // Custom message.\r\n            message = objectOrMessage;\r\n        }\r\n        else if (typeof objectOrMessage === 'function') {\r\n            // Constructor function (class name).\r\n            message = objectOrMessage.name + ' disposed.';\r\n        }\r\n        else {\r\n            // Disposable object - get its class name.\r\n            message = ((_b = (_a = objectOrMessage === null || objectOrMessage === void 0 ? void 0 : objectOrMessage.constructor) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : 'Object ') + ' disposed.';\r\n        }\r\n        super(message);\r\n    }\r\n}\r\nexports.ObjectDisposedError = ObjectDisposedError;\r\n//# sourceMappingURL=errors.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SshAuthenticatingEventArgs = exports.SshAuthenticationType = void 0;\r\nconst vscode_jsonrpc_1 = require(\"vscode-jsonrpc\");\r\n/**\r\n * Indicates the type of authentication being requested by an SSH client or server when an\r\n * `SshSession.authenticating` event is raised.\r\n */\r\nvar SshAuthenticationType;\r\n(function (SshAuthenticationType) {\r\n    /**\r\n     * The client is attempting to authenticate without any credentials, or with only a\r\n     * username, or is merely checking what authentication methods are supported by the server.\r\n     *\r\n     * This event is raised by an `SshServerSession` when the client requests authentication\r\n     * using the \"none\" method. With this method, all of the credential properties in the\r\n     * `SshAuthenticatingEventArgs` are null.\r\n     *\r\n     * If the server app wishes to allow the client to authenticate with only a username, it may\r\n     * return a principal for the user. Othwerwise, the \"none\" authentication method fails, and\r\n     * the client may make a follow-up attempt to authenticate _with_ credentials.\r\n     */\r\n    SshAuthenticationType[SshAuthenticationType[\"clientNone\"] = 0] = \"clientNone\";\r\n    /**\r\n     * The client is attempting to authenticate with a client host public key.\r\n     *\r\n     * This event is raised by an `SshServerSession` when the client requests authentication\r\n     * using the \"hostbased\" method. The authentication handler must verify that the public key\r\n     * actually belongs to the client host name, _and_ that the network address the client\r\n     * connected from matches that host name, before returning a user principal to indicate\r\n     * successful authentication.\r\n     */\r\n    SshAuthenticationType[SshAuthenticationType[\"clientHostBased\"] = 1] = \"clientHostBased\";\r\n    /**\r\n     * The client is attempting to authenticate with a username and password credential.\r\n     *\r\n     * This event is raised by an `SshServerSession` when the client requests authentication\r\n     * using the \"password\" method. The authentication handler must verify that the username\r\n     * and password match known credentials on the server, before returning a user principal\r\n     * to indicate successful authentication.\r\n     */\r\n    SshAuthenticationType[SshAuthenticationType[\"clientPassword\"] = 2] = \"clientPassword\";\r\n    /**\r\n     * The client is querying whether authentication may be possible for a specified username and\r\n     * public key without yet proving they have the private key.\r\n     *\r\n     * This event is raised by an `SshServerSession` when the client requests authentication\r\n     * using the \"publickey\" method _without_ providing a signature. The authentication handler\r\n     * must verify that the username and public key match known credentials on the server. If\r\n     * they match, an _unauthenticated_ principal should be returned. That indicates to the\r\n     * client that they may proceed to actually authenticate using that username and public key.\r\n     */\r\n    SshAuthenticationType[SshAuthenticationType[\"clientPublicKeyQuery\"] = 3] = \"clientPublicKeyQuery\";\r\n    /**\r\n     * The client is attempting to authenticate with a username and public key credential.\r\n     *\r\n     * This event is raised by an `SshServerSession` when the client requests authentication\r\n     * using the \"publickey\" method, including a signature that proves they have the private\r\n     * key. The authentication handler must verify that the username and public key match known\r\n     * credentials on the server, before returning a user principal to indicate successful\r\n     * authentication.\r\n     */\r\n    SshAuthenticationType[SshAuthenticationType[\"clientPublicKey\"] = 4] = \"clientPublicKey\";\r\n    /**\r\n     * The server is attempting to authenticate with a public key credential.\r\n     *\r\n     * This event is raised by an `SshClientSession` when the server requests\r\n     * authentication by providing a signature that proves it has the private key. The client\r\n     * authentication handler must verify that the public key matches known public key(s) for\r\n     * that server. Or if not known (often the case for the first time connecting to that server)\r\n     * it may prompt the user to consent, and then save the public key for later reference. To\r\n     * indicate successful authentication, the client authentication handler returns a principal\r\n     * that represents the server.\r\n     */\r\n    SshAuthenticationType[SshAuthenticationType[\"serverPublicKey\"] = 10] = \"serverPublicKey\";\r\n})(SshAuthenticationType = exports.SshAuthenticationType || (exports.SshAuthenticationType = {}));\r\n/**\r\n * Arguments for the `SshSession.Authenticating` event that is raised when a client\r\n * or server is requesting authentication.\r\n *\r\n * See `SshAuthenticationType` for a description of the different authentication methods and\r\n * how they map to properties in this event-args object.\r\n *\r\n * After validating the credentials, the event handler must set the `authenticationPromise`\r\n * property to a task that resolves to a principal object to indicate successful authentication.\r\n * That principal will then be associated with the sesssion as the `SshSession.principal` property.\r\n */\r\nclass SshAuthenticatingEventArgs {\r\n    constructor(authenticationType, { username, password, publicKey, clientHostname, clientUsername, }, cancellation) {\r\n        this.authenticationType = authenticationType;\r\n        const validate = ({ usernameRequired, passwordRequired, publicKeyRequired, clientHostnameRequired, clientUsernameRequired, }) => {\r\n            // This is intentionally not checking for empty strings. The authentication handler\r\n            // should determine whether any non-null string values are valid.\r\n            if ((typeof username === 'string') !== !!usernameRequired)\r\n                return false;\r\n            if ((typeof password === 'string') !== !!passwordRequired)\r\n                return false;\r\n            if (!!publicKey !== !!publicKeyRequired)\r\n                return false;\r\n            if ((typeof clientHostname === 'string') !== !!clientHostnameRequired)\r\n                return false;\r\n            if ((typeof clientUsername === 'string') !== !!clientUsernameRequired)\r\n                return false;\r\n            return true;\r\n        };\r\n        let valid;\r\n        switch (authenticationType) {\r\n            case SshAuthenticationType.clientNone:\r\n                valid = validate({ usernameRequired: true });\r\n                break;\r\n            case SshAuthenticationType.clientHostBased:\r\n                valid = validate({\r\n                    usernameRequired: true,\r\n                    publicKeyRequired: true,\r\n                    clientHostnameRequired: true,\r\n                    clientUsernameRequired: true,\r\n                });\r\n                break;\r\n            case SshAuthenticationType.clientPassword:\r\n                valid = validate({ usernameRequired: true, passwordRequired: true });\r\n                break;\r\n            case SshAuthenticationType.clientPublicKeyQuery:\r\n            case SshAuthenticationType.clientPublicKey:\r\n                valid = validate({ usernameRequired: true, publicKeyRequired: true });\r\n                break;\r\n            case SshAuthenticationType.serverPublicKey:\r\n                valid = validate({ publicKeyRequired: true });\r\n                break;\r\n            default:\r\n                throw new Error(`Invalid authentication type: ${authenticationType}`);\r\n        }\r\n        if (!valid) {\r\n            throw new Error(`Invalid arguments for authentication type: ${authenticationType}`);\r\n        }\r\n        this.username = username !== null && username !== void 0 ? username : null;\r\n        this.password = password !== null && password !== void 0 ? password : null;\r\n        this.publicKey = publicKey !== null && publicKey !== void 0 ? publicKey : null;\r\n        this.clientHostname = clientHostname !== null && clientHostname !== void 0 ? clientHostname : null;\r\n        this.clientUsername = clientUsername !== null && clientUsername !== void 0 ? clientUsername : null;\r\n        this.cancellationValue = cancellation !== null && cancellation !== void 0 ? cancellation : vscode_jsonrpc_1.CancellationToken.None;\r\n    }\r\n    /**\r\n     * Gets a token that is cancelled if the session ends before the authentication handler\r\n     * completes.\r\n     */\r\n    get cancellation() {\r\n        return this.cancellationValue;\r\n    }\r\n    /* @internal */\r\n    set cancellation(value) {\r\n        this.cancellationValue = value;\r\n    }\r\n    toString() {\r\n        if (this.password) {\r\n            return `${this.username ? '\"' + this.username + '\" ' : ''}[password]`;\r\n        }\r\n        else if (this.publicKey) {\r\n            return `${this.username ? '\"' + this.username + '\" ' : ''}[${this.publicKey.keyAlgorithmName}]`;\r\n        }\r\n        else {\r\n            return `\"${this.username}\"`;\r\n        }\r\n    }\r\n}\r\nexports.SshAuthenticatingEventArgs = SshAuthenticatingEventArgs;\r\n//# sourceMappingURL=sshAuthenticatingEventArgs.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SshChannelClosedEventArgs = void 0;\r\nclass SshChannelClosedEventArgs {\r\n    constructor(exitStatusOrSignalOrError, errorMessage) {\r\n        if (typeof exitStatusOrSignalOrError === 'number') {\r\n            this.exitStatus = exitStatusOrSignalOrError;\r\n        }\r\n        else if (typeof exitStatusOrSignalOrError === 'string') {\r\n            this.exitSignal = exitStatusOrSignalOrError;\r\n            this.errorMessage = errorMessage;\r\n        }\r\n        else if (exitStatusOrSignalOrError instanceof Error) {\r\n            this.error = exitStatusOrSignalOrError;\r\n        }\r\n    }\r\n}\r\nexports.SshChannelClosedEventArgs = SshChannelClosedEventArgs;\r\n//# sourceMappingURL=sshChannelClosedEventArgs.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SshChannelOpeningEventArgs = void 0;\r\nconst connectionMessages_1 = require(\"../messages/connectionMessages\");\r\nclass SshChannelOpeningEventArgs {\r\n    constructor(request, channel, isRemoteRequest) {\r\n        this.request = request;\r\n        this.channel = channel;\r\n        this.isRemoteRequest = isRemoteRequest;\r\n        this.failureReason = connectionMessages_1.SshChannelOpenFailureReason.none;\r\n        this.failureDescription = null;\r\n        if (!request)\r\n            throw new TypeError('A channel open message is required.');\r\n        if (!channel)\r\n            throw new TypeError('A channel is required.');\r\n    }\r\n    toString() {\r\n        return `${this.channel.toString()}${this.failureReason ? ' ' + connectionMessages_1.SshChannelOpenFailureReason[this.failureReason] : ''}`;\r\n    }\r\n}\r\nexports.SshChannelOpeningEventArgs = SshChannelOpeningEventArgs;\r\n//# sourceMappingURL=sshChannelOpeningEventArgs.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SshRequestEventArgs = void 0;\r\nclass SshRequestEventArgs {\r\n    constructor(requestType, request, principal) {\r\n        this.requestType = requestType;\r\n        this.request = request;\r\n        this.principal = principal;\r\n    }\r\n    toString() {\r\n        return `RequestType: ${this.requestType}` + this.request ? ` Request: ${this.request}` : '';\r\n    }\r\n}\r\nexports.SshRequestEventArgs = SshRequestEventArgs;\r\n//# sourceMappingURL=sshRequestEventArgs.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SshSessionClosedEventArgs = void 0;\r\nconst transportMessages_1 = require(\"../messages/transportMessages\");\r\nclass SshSessionClosedEventArgs {\r\n    constructor(reason, message, error) {\r\n        this.reason = reason;\r\n        this.message = message;\r\n        this.error = error;\r\n        if (!message)\r\n            throw new TypeError('A disconnect message is required.');\r\n    }\r\n    toString() {\r\n        return `${transportMessages_1.SshDisconnectReason[this.reason]}: ${this.message}`;\r\n    }\r\n}\r\nexports.SshSessionClosedEventArgs = SshSessionClosedEventArgs;\r\n//# sourceMappingURL=sshSessionClosedEventArgs.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ObjectDisposedError = exports.SshReconnectError = exports.SshConnectionError = exports.SshChannelError = exports.BigInt = exports.DerWriter = exports.DerReader = exports.formatBuffer = exports.SshDataWriter = exports.SshDataReader = exports.ECDsa = exports.Rsa = exports.Encryption = exports.HmacAlgorithm = exports.EncryptionAlgorithm = exports.PublicKeyAlgorithm = exports.KeyExchangeAlgorithm = exports.SshAlgorithms = exports.CommandRequestMessage = exports.ChannelRequestType = exports.ChannelRequestMessage = exports.ChannelOpenMessage = exports.SshChannelOpenFailureReason = exports.SshReconnectFailureReason = exports.SshDisconnectReason = exports.SessionRequestFailureMessage = exports.SessionRequestSuccessMessage = exports.DebugMessage = exports.SessionRequestMessage = exports.SshMessage = exports.SshChannelClosedEventArgs = exports.SshSessionClosedEventArgs = exports.SshChannelOpeningEventArgs = exports.SshRequestEventArgs = exports.SshAuthenticatingEventArgs = exports.SshAuthenticationType = exports.serviceActivation = exports.SshService = exports.SshRpcMessageStream = exports.WebSocketStream = exports.NodeStream = exports.BaseStream = exports.SshStream = exports.SshChannel = exports.SshServerSession = exports.SshClientSession = exports.SshSession = exports.SshVersionInfo = exports.SshProtocolExtensionNames = exports.SshSessionConfiguration = void 0;\r\nexports.MultiChannelStream = exports.SessionContour = exports.ChannelMetrics = exports.SessionMetrics = exports.Queue = exports.Semaphore = exports.PromiseCompletionSource = exports.CancellationError = exports.CancellationTokenSource = exports.CancellationToken = void 0;\r\nvar sshSessionConfiguration_1 = require(\"./sshSessionConfiguration\");\r\nObject.defineProperty(exports, \"SshSessionConfiguration\", { enumerable: true, get: function () { return sshSessionConfiguration_1.SshSessionConfiguration; } });\r\nObject.defineProperty(exports, \"SshProtocolExtensionNames\", { enumerable: true, get: function () { return sshSessionConfiguration_1.SshProtocolExtensionNames; } });\r\nvar sshVersionInfo_1 = require(\"./sshVersionInfo\");\r\nObject.defineProperty(exports, \"SshVersionInfo\", { enumerable: true, get: function () { return sshVersionInfo_1.SshVersionInfo; } });\r\nvar sshSession_1 = require(\"./sshSession\");\r\nObject.defineProperty(exports, \"SshSession\", { enumerable: true, get: function () { return sshSession_1.SshSession; } });\r\nvar sshClientSession_1 = require(\"./sshClientSession\");\r\nObject.defineProperty(exports, \"SshClientSession\", { enumerable: true, get: function () { return sshClientSession_1.SshClientSession; } });\r\nvar sshServerSession_1 = require(\"./sshServerSession\");\r\nObject.defineProperty(exports, \"SshServerSession\", { enumerable: true, get: function () { return sshServerSession_1.SshServerSession; } });\r\nvar sshChannel_1 = require(\"./sshChannel\");\r\nObject.defineProperty(exports, \"SshChannel\", { enumerable: true, get: function () { return sshChannel_1.SshChannel; } });\r\nvar sshStream_1 = require(\"./sshStream\");\r\nObject.defineProperty(exports, \"SshStream\", { enumerable: true, get: function () { return sshStream_1.SshStream; } });\r\nvar streams_1 = require(\"./streams\");\r\nObject.defineProperty(exports, \"BaseStream\", { enumerable: true, get: function () { return streams_1.BaseStream; } });\r\nObject.defineProperty(exports, \"NodeStream\", { enumerable: true, get: function () { return streams_1.NodeStream; } });\r\nObject.defineProperty(exports, \"WebSocketStream\", { enumerable: true, get: function () { return streams_1.WebSocketStream; } });\r\nvar sshRpcMessageStream_1 = require(\"./sshRpcMessageStream\");\r\nObject.defineProperty(exports, \"SshRpcMessageStream\", { enumerable: true, get: function () { return sshRpcMessageStream_1.SshRpcMessageStream; } });\r\nvar sshService_1 = require(\"./services/sshService\");\r\nObject.defineProperty(exports, \"SshService\", { enumerable: true, get: function () { return sshService_1.SshService; } });\r\nvar serviceActivation_1 = require(\"./services/serviceActivation\");\r\nObject.defineProperty(exports, \"serviceActivation\", { enumerable: true, get: function () { return serviceActivation_1.serviceActivation; } });\r\nvar sshAuthenticatingEventArgs_1 = require(\"./events/sshAuthenticatingEventArgs\");\r\nObject.defineProperty(exports, \"SshAuthenticationType\", { enumerable: true, get: function () { return sshAuthenticatingEventArgs_1.SshAuthenticationType; } });\r\nObject.defineProperty(exports, \"SshAuthenticatingEventArgs\", { enumerable: true, get: function () { return sshAuthenticatingEventArgs_1.SshAuthenticatingEventArgs; } });\r\nvar sshRequestEventArgs_1 = require(\"./events/sshRequestEventArgs\");\r\nObject.defineProperty(exports, \"SshRequestEventArgs\", { enumerable: true, get: function () { return sshRequestEventArgs_1.SshRequestEventArgs; } });\r\nvar sshChannelOpeningEventArgs_1 = require(\"./events/sshChannelOpeningEventArgs\");\r\nObject.defineProperty(exports, \"SshChannelOpeningEventArgs\", { enumerable: true, get: function () { return sshChannelOpeningEventArgs_1.SshChannelOpeningEventArgs; } });\r\nvar sshSessionClosedEventArgs_1 = require(\"./events/sshSessionClosedEventArgs\");\r\nObject.defineProperty(exports, \"SshSessionClosedEventArgs\", { enumerable: true, get: function () { return sshSessionClosedEventArgs_1.SshSessionClosedEventArgs; } });\r\nvar sshChannelClosedEventArgs_1 = require(\"./events/sshChannelClosedEventArgs\");\r\nObject.defineProperty(exports, \"SshChannelClosedEventArgs\", { enumerable: true, get: function () { return sshChannelClosedEventArgs_1.SshChannelClosedEventArgs; } });\r\nvar sshMessage_1 = require(\"./messages/sshMessage\");\r\nObject.defineProperty(exports, \"SshMessage\", { enumerable: true, get: function () { return sshMessage_1.SshMessage; } });\r\nvar transportMessages_1 = require(\"./messages/transportMessages\");\r\nObject.defineProperty(exports, \"SessionRequestMessage\", { enumerable: true, get: function () { return transportMessages_1.SessionRequestMessage; } });\r\nObject.defineProperty(exports, \"DebugMessage\", { enumerable: true, get: function () { return transportMessages_1.DebugMessage; } });\r\nObject.defineProperty(exports, \"SessionRequestSuccessMessage\", { enumerable: true, get: function () { return transportMessages_1.SessionRequestSuccessMessage; } });\r\nObject.defineProperty(exports, \"SessionRequestFailureMessage\", { enumerable: true, get: function () { return transportMessages_1.SessionRequestFailureMessage; } });\r\nObject.defineProperty(exports, \"SshDisconnectReason\", { enumerable: true, get: function () { return transportMessages_1.SshDisconnectReason; } });\r\nObject.defineProperty(exports, \"SshReconnectFailureReason\", { enumerable: true, get: function () { return transportMessages_1.SshReconnectFailureReason; } });\r\nvar connectionMessages_1 = require(\"./messages/connectionMessages\");\r\nObject.defineProperty(exports, \"SshChannelOpenFailureReason\", { enumerable: true, get: function () { return connectionMessages_1.SshChannelOpenFailureReason; } });\r\nObject.defineProperty(exports, \"ChannelOpenMessage\", { enumerable: true, get: function () { return connectionMessages_1.ChannelOpenMessage; } });\r\nObject.defineProperty(exports, \"ChannelRequestMessage\", { enumerable: true, get: function () { return connectionMessages_1.ChannelRequestMessage; } });\r\nObject.defineProperty(exports, \"ChannelRequestType\", { enumerable: true, get: function () { return connectionMessages_1.ChannelRequestType; } });\r\nObject.defineProperty(exports, \"CommandRequestMessage\", { enumerable: true, get: function () { return connectionMessages_1.CommandRequestMessage; } });\r\nvar sshAlgorithms_1 = require(\"./algorithms/sshAlgorithms\");\r\nObject.defineProperty(exports, \"SshAlgorithms\", { enumerable: true, get: function () { return sshAlgorithms_1.SshAlgorithms; } });\r\nObject.defineProperty(exports, \"KeyExchangeAlgorithm\", { enumerable: true, get: function () { return sshAlgorithms_1.KeyExchangeAlgorithm; } });\r\nObject.defineProperty(exports, \"PublicKeyAlgorithm\", { enumerable: true, get: function () { return sshAlgorithms_1.PublicKeyAlgorithm; } });\r\nObject.defineProperty(exports, \"EncryptionAlgorithm\", { enumerable: true, get: function () { return sshAlgorithms_1.EncryptionAlgorithm; } });\r\nObject.defineProperty(exports, \"HmacAlgorithm\", { enumerable: true, get: function () { return sshAlgorithms_1.HmacAlgorithm; } });\r\nObject.defineProperty(exports, \"Encryption\", { enumerable: true, get: function () { return sshAlgorithms_1.Encryption; } });\r\nObject.defineProperty(exports, \"Rsa\", { enumerable: true, get: function () { return sshAlgorithms_1.Rsa; } });\r\nObject.defineProperty(exports, \"ECDsa\", { enumerable: true, get: function () { return sshAlgorithms_1.ECDsa; } });\r\nvar sshData_1 = require(\"./io/sshData\");\r\nObject.defineProperty(exports, \"SshDataReader\", { enumerable: true, get: function () { return sshData_1.SshDataReader; } });\r\nObject.defineProperty(exports, \"SshDataWriter\", { enumerable: true, get: function () { return sshData_1.SshDataWriter; } });\r\nObject.defineProperty(exports, \"formatBuffer\", { enumerable: true, get: function () { return sshData_1.formatBuffer; } });\r\nvar derData_1 = require(\"./io/derData\");\r\nObject.defineProperty(exports, \"DerReader\", { enumerable: true, get: function () { return derData_1.DerReader; } });\r\nObject.defineProperty(exports, \"DerWriter\", { enumerable: true, get: function () { return derData_1.DerWriter; } });\r\nvar bigInt_1 = require(\"./io/bigInt\");\r\nObject.defineProperty(exports, \"BigInt\", { enumerable: true, get: function () { return bigInt_1.BigInt; } });\r\nvar errors_1 = require(\"./errors\");\r\nObject.defineProperty(exports, \"SshChannelError\", { enumerable: true, get: function () { return errors_1.SshChannelError; } });\r\nObject.defineProperty(exports, \"SshConnectionError\", { enumerable: true, get: function () { return errors_1.SshConnectionError; } });\r\nObject.defineProperty(exports, \"SshReconnectError\", { enumerable: true, get: function () { return errors_1.SshReconnectError; } });\r\nObject.defineProperty(exports, \"ObjectDisposedError\", { enumerable: true, get: function () { return errors_1.ObjectDisposedError; } });\r\nvar cancellation_1 = require(\"./util/cancellation\");\r\nObject.defineProperty(exports, \"CancellationToken\", { enumerable: true, get: function () { return cancellation_1.CancellationToken; } });\r\nObject.defineProperty(exports, \"CancellationTokenSource\", { enumerable: true, get: function () { return cancellation_1.CancellationTokenSource; } });\r\nObject.defineProperty(exports, \"CancellationError\", { enumerable: true, get: function () { return cancellation_1.CancellationError; } });\r\nvar promiseCompletionSource_1 = require(\"./util/promiseCompletionSource\");\r\nObject.defineProperty(exports, \"PromiseCompletionSource\", { enumerable: true, get: function () { return promiseCompletionSource_1.PromiseCompletionSource; } });\r\nvar semaphore_1 = require(\"./util/semaphore\");\r\nObject.defineProperty(exports, \"Semaphore\", { enumerable: true, get: function () { return semaphore_1.Semaphore; } });\r\nvar queue_1 = require(\"./util/queue\");\r\nObject.defineProperty(exports, \"Queue\", { enumerable: true, get: function () { return queue_1.Queue; } });\r\nvar sessionMetrics_1 = require(\"./metrics/sessionMetrics\");\r\nObject.defineProperty(exports, \"SessionMetrics\", { enumerable: true, get: function () { return sessionMetrics_1.SessionMetrics; } });\r\nvar channelMetrics_1 = require(\"./metrics/channelMetrics\");\r\nObject.defineProperty(exports, \"ChannelMetrics\", { enumerable: true, get: function () { return channelMetrics_1.ChannelMetrics; } });\r\nvar sessionContour_1 = require(\"./metrics/sessionContour\");\r\nObject.defineProperty(exports, \"SessionContour\", { enumerable: true, get: function () { return sessionContour_1.SessionContour; } });\r\nvar multiChannelStream_1 = require(\"./multiChannelStream\");\r\nObject.defineProperty(exports, \"MultiChannelStream\", { enumerable: true, get: function () { return multiChannelStream_1.MultiChannelStream; } });\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.BigInt = void 0;\r\nconst buffer_1 = require(\"buffer\");\r\nconst sshData_1 = require(\"./sshData\");\r\n/**\r\n * Represents a large signed integer as a byte byffer.\r\n */\r\nclass BigInt {\r\n    /**\r\n     * Creates a new BigInt instance from a buffer of signed bytes.\r\n     *\r\n     * The first (high) bit of the first (high) byte is the sign bit. Therefore if the\r\n     * highest byte of an unsigned integer is greater than 127, the bytes must include\r\n     * a leading zero byte to prevent interpretation as a negative value.\r\n     */\r\n    constructor(buffer) {\r\n        this.buffer = buffer;\r\n        if (buffer.length === 0) {\r\n            throw new Error('BigInt buffer length must be greater than zero.');\r\n        }\r\n    }\r\n    /**\r\n     * Gets a value that indicates the sign of the big integer:\r\n     * 1 for positive, 0 for zero, -1 for negative.\r\n     */\r\n    get sign() {\r\n        const highByte = this.buffer[0];\r\n        if (highByte === 0) {\r\n            return this.buffer.length > 1 ? 1 : 0;\r\n        }\r\n        else {\r\n            return (highByte & 0x80) === 0 ? 1 : -1;\r\n        }\r\n    }\r\n    static fromInt32(value) {\r\n        if (value === 0) {\r\n            return BigInt.zero;\r\n        }\r\n        let isNegative = false;\r\n        if (value < 0) {\r\n            isNegative = true;\r\n            value = -value;\r\n        }\r\n        const bytes = [];\r\n        for (let bit = 24; bit >= 0; bit -= 8) {\r\n            if (value >= 1 << bit || bytes.length > 0) {\r\n                bytes.push(value >> bit);\r\n                value = value & ~((1 << bit) - 1);\r\n            }\r\n        }\r\n        if (isNegative) {\r\n            if ((bytes[0] & 0x80) === 0) {\r\n                bytes[0] |= 0x80;\r\n            }\r\n            else {\r\n                bytes.splice(0, 0, 0x80);\r\n            }\r\n        }\r\n        return new BigInt(buffer_1.Buffer.from(new Uint8Array(bytes)));\r\n    }\r\n    toInt32() {\r\n        if (this.buffer.length > 4) {\r\n            throw new TypeError(`BigInt value cannot be converted to a 32-bit signed integer.`);\r\n        }\r\n        let value = this.buffer[0];\r\n        if (this.sign < 0) {\r\n            value &= 0x7f;\r\n        }\r\n        for (let i = 1; i < this.buffer.length; i++) {\r\n            value = (value << 8) + this.buffer[i];\r\n        }\r\n        if (this.sign < 0) {\r\n            value = -value;\r\n        }\r\n        return value;\r\n    }\r\n    /**\r\n     * Creates a new BigInt instance from a byte buffer.\r\n     * @param bytes Source byte buffer.\r\n     * @param options.unsigned True if the bytes should be interpreted as unsigned. If false,\r\n     * the high bit of the high byte is the sign bit. The default is false.\r\n     */\r\n    static fromBytes(bytes, options) {\r\n        if (!buffer_1.Buffer.isBuffer(bytes)) {\r\n            throw new TypeError('Buffer expected.');\r\n        }\r\n        else if (bytes.length === 0) {\r\n            throw new Error('BigInt buffer length must be greater than zero.');\r\n        }\r\n        options = options !== null && options !== void 0 ? options : {};\r\n        const highBit = (bytes[0] & 0x80) !== 0;\r\n        const prependZeroCount = options.unsigned && highBit ? 1 : 0;\r\n        let skipZeroCount = 0;\r\n        // Skip non-significant zeroes at the big end.\r\n        for (let i = 0; i < bytes.length - 1 && bytes[i] === 0; i++) {\r\n            if ((bytes[i + 1] & 0x80) === 0) {\r\n                skipZeroCount++;\r\n            }\r\n        }\r\n        const newBytes = buffer_1.Buffer.alloc(bytes.length + prependZeroCount - skipZeroCount);\r\n        bytes.copy(newBytes, prependZeroCount, skipZeroCount, bytes.length);\r\n        return new BigInt(newBytes);\r\n    }\r\n    /**\r\n     * Converts a BigInt instance to a byte buffer.\r\n     *\r\n     * @param options.unsigned True if the returned bytes will be interprted as unsigned.\r\n     * If false, a positive integer may have a leading zero to prevent it from being\r\n     * interpreted as negative.\r\n     * @param options.length Desired length of the resulting buffer. The value will be zero-\r\n     * padded to fill the length. Only applies when `options.unsigned` is true.\r\n     */\r\n    toBytes(options) {\r\n        options = options !== null && options !== void 0 ? options : {};\r\n        let bytes = this.buffer;\r\n        if (options.unsigned) {\r\n            if (this.sign < 0) {\r\n                throw new TypeError('Cannot format a negative BigInt as unsigned.');\r\n            }\r\n            else if (bytes[0] === 0 && bytes.length > 1) {\r\n                bytes = bytes.slice(1, bytes.length);\r\n            }\r\n            if (options.length !== undefined) {\r\n                if (bytes.length > options.length) {\r\n                    throw new Error(`BigInt (${bytes.length} bytes) is too large for length ${options.length}.`);\r\n                }\r\n                else if (bytes.length < options.length) {\r\n                    const padded = buffer_1.Buffer.alloc(options.length);\r\n                    bytes.copy(padded, options.length - bytes.length);\r\n                    return padded;\r\n                }\r\n            }\r\n        }\r\n        const newBytes = buffer_1.Buffer.alloc(bytes.length);\r\n        bytes.copy(newBytes, 0, 0, bytes.length);\r\n        return newBytes;\r\n    }\r\n    copyTo(buffer, offset = 0) {\r\n        this.buffer.copy(buffer, offset, 0, this.buffer.length);\r\n    }\r\n    equals(other) {\r\n        return other instanceof BigInt && this.buffer.equals(other.buffer);\r\n    }\r\n    toString(name) {\r\n        return (0, sshData_1.formatBuffer)(this.buffer, name !== null && name !== void 0 ? name : 'BigInt');\r\n    }\r\n}\r\nexports.BigInt = BigInt;\r\nBigInt.zero = new BigInt(buffer_1.Buffer.alloc(1));\r\n//# sourceMappingURL=bigInt.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.DerWriter = exports.DerReader = void 0;\r\nconst buffer_1 = require(\"buffer\");\r\nconst bigInt_1 = require(\"./bigInt\");\r\n/**\r\n * Reads data in DER (Distinguished Encoding Rules) format.\r\n *\r\n * Enables importing and exporting key files, which are commonly DER-encoded.\r\n */\r\nclass DerReader {\r\n    constructor(buffer, dataType = 32 /* Constructed */ | 16 /* Sequence */) {\r\n        this.buffer = buffer;\r\n        this.position = 0;\r\n        this.readType(dataType);\r\n        const length = this.readLength();\r\n        if (length > this.buffer.length - this.position) {\r\n            throw new Error('Read out of bounds.');\r\n        }\r\n        this.buffer = this.buffer.slice(0, this.position + length);\r\n    }\r\n    get available() {\r\n        return this.buffer.length - this.position;\r\n    }\r\n    readNull() {\r\n        this.readType(5 /* Null */);\r\n        if (this.readByte() !== 0) {\r\n            throw new Error('Expected a 0 after Null type.');\r\n        }\r\n    }\r\n    readInteger() {\r\n        this.readType(2 /* Integer */);\r\n        const length = this.readLength();\r\n        const bytes = this.readBytes(length);\r\n        const result = new bigInt_1.BigInt(bytes);\r\n        return result;\r\n    }\r\n    readOctetString() {\r\n        this.readType(4 /* OctetString */);\r\n        const length = this.readLength();\r\n        const result = this.readBytes(length);\r\n        return result;\r\n    }\r\n    readBitString() {\r\n        this.readType(3 /* BitString */);\r\n        const length = this.readLength();\r\n        const padding = this.readByte();\r\n        if (padding !== 0) {\r\n            throw new Error('Padded bit strings are not supported.');\r\n        }\r\n        const result = this.readBytes(length - 1);\r\n        return result;\r\n    }\r\n    readObjectIdentifier(expected) {\r\n        this.readType(6 /* ObjectIdentifier */);\r\n        const length = this.readLength();\r\n        const end = this.position + length;\r\n        const values = [];\r\n        const first = this.readByte();\r\n        values.push(Math.trunc(first / 40));\r\n        values.push(first % 40);\r\n        let next = 0;\r\n        while (this.position < end) {\r\n            const b = this.readByte();\r\n            if ((b & 0x80) !== 0) {\r\n                next = next * 128 + (b & 0x7f);\r\n            }\r\n            else {\r\n                next = next * 128 + b;\r\n                values.push(next);\r\n                next = 0;\r\n            }\r\n        }\r\n        if (next !== 0) {\r\n            throw new Error('Invalid OID format.');\r\n        }\r\n        const result = values.join('.');\r\n        if (expected && result !== expected) {\r\n            throw new Error(`Expected OID ${expected}, found: ${result}`);\r\n        }\r\n        return result;\r\n    }\r\n    readSequence() {\r\n        const start = this.position;\r\n        this.readType(32 /* Constructed */ | 16 /* Sequence */);\r\n        const length = this.readLength();\r\n        this.position += length;\r\n        return new DerReader(this.buffer.slice(start, this.position));\r\n    }\r\n    tryReadTagged(tagId) {\r\n        if (this.position >= this.buffer.length) {\r\n            return null;\r\n        }\r\n        const type = this.buffer[this.position];\r\n        if ((type & 160 /* Tagged */) === 0 || (type & ~160 /* Tagged */) !== tagId) {\r\n            return null;\r\n        }\r\n        const start = this.position;\r\n        this.position++;\r\n        const length = this.readLength();\r\n        this.position += length;\r\n        const taggedData = new DerReader(this.buffer.slice(start, this.position), type);\r\n        return taggedData;\r\n    }\r\n    /** Reads the type of the next value in the sequence WITHOUT advancing the reader position. */\r\n    peek() {\r\n        if (this.position >= this.buffer.length) {\r\n            throw new Error('Read out of bounds.');\r\n        }\r\n        return this.buffer[this.position];\r\n    }\r\n    readLength() {\r\n        let length = this.readByte();\r\n        if (length === 0x80) {\r\n            throw new Error('Indefinite-length encoding is not supported.');\r\n        }\r\n        if (length > 127) {\r\n            const size = length & 0x7f;\r\n            if (size > 4) {\r\n                throw new Error(`DER length size is ${size} and cannot be more than 4 bytes.`);\r\n            }\r\n            length = 0;\r\n            for (let i = 0; i < size; i++) {\r\n                const next = this.readByte();\r\n                length = (length << 8) + next;\r\n            }\r\n            if (length < 0) {\r\n                throw new Error('Corrupted data - negative length found');\r\n            }\r\n        }\r\n        return length;\r\n    }\r\n    readByte() {\r\n        if (this.position >= this.buffer.length) {\r\n            throw new Error('Read out of bounds.');\r\n        }\r\n        return this.buffer[this.position++];\r\n    }\r\n    readBytes(length) {\r\n        if (this.position + length > this.buffer.length) {\r\n            throw new Error('Read out of bounds.');\r\n        }\r\n        const result = this.buffer.slice(this.position, this.position + length);\r\n        this.position += length;\r\n        return result;\r\n    }\r\n    readType(expectedType) {\r\n        const type = this.readByte();\r\n        if (type !== expectedType) {\r\n            throw new Error(`Expected ${expectedType} data type, found : ${type}`);\r\n        }\r\n    }\r\n}\r\nexports.DerReader = DerReader;\r\n/**\r\n * Writes data in DER (Distinguished Encoding Rules) format.\r\n *\r\n * Enables importing and exporting key files, which are commonly DER-encoded.\r\n */\r\nclass DerWriter {\r\n    constructor(buffer, dataType = 32 /* Constructed */ | 16 /* Sequence */) {\r\n        this.buffer = buffer;\r\n        this.dataType = dataType;\r\n        this.position = 0;\r\n        this.buffer = buffer;\r\n    }\r\n    toBuffer() {\r\n        // Move the data over to make space for the type + length prefix.\r\n        const length = this.position;\r\n        const lengthBytes = DerWriter.getLength(length);\r\n        this.ensureCapacity(1 + lengthBytes.length + length);\r\n        const result = this.buffer.slice(0, 1 + lengthBytes.length + length);\r\n        this.buffer.copy(result, 1 + lengthBytes.length);\r\n        // Write the type + length prefix.\r\n        result[0] = this.dataType;\r\n        lengthBytes.copy(result, 1, 0);\r\n        // Restore the writer buffer to its previous state (without the type + length prefix).\r\n        this.buffer = this.buffer.slice(1 + lengthBytes.length, result.length);\r\n        this.position = length;\r\n        return result;\r\n    }\r\n    writeSequence(data) {\r\n        this.writeBytes(data.toBuffer());\r\n    }\r\n    writeTagged(tagId, data) {\r\n        if (tagId > 0xf)\r\n            throw new Error('Invalid DER tag.');\r\n        this.writeByte(160 /* Tagged */ | tagId);\r\n        const lengthBytes = DerWriter.getLength(data.position);\r\n        this.writeBytes(lengthBytes);\r\n        this.writeBytes(data.buffer.slice(0, data.position));\r\n    }\r\n    writeNull() {\r\n        this.writeByte(5 /* Null */);\r\n        this.writeByte(0);\r\n    }\r\n    writeInteger(value) {\r\n        this.writeByte(2 /* Integer */);\r\n        const integerBytes = value.toBytes();\r\n        const lengthBytes = DerWriter.getLength(integerBytes.length);\r\n        this.writeBytes(lengthBytes);\r\n        this.writeBytes(integerBytes);\r\n    }\r\n    writeOctetString(data) {\r\n        this.writeByte(4 /* OctetString */);\r\n        const lengthBytes = DerWriter.getLength(data.length);\r\n        this.writeBytes(lengthBytes);\r\n        this.writeBytes(data);\r\n    }\r\n    writeBitString(data) {\r\n        this.writeByte(3 /* BitString */);\r\n        const lengthBytes = DerWriter.getLength(1 + data.length);\r\n        this.writeBytes(lengthBytes);\r\n        this.writeByte(0);\r\n        this.writeBytes(data);\r\n    }\r\n    writeObjectIdentifier(oid) {\r\n        if (!oid)\r\n            throw new TypeError('OID value is null or empty.');\r\n        const values = oid.split('.').map(Number);\r\n        if (values.length < 2 || values[0] > 3 || values[1] >= 40) {\r\n            throw new Error(`Invalid OID: ${oid}`);\r\n        }\r\n        this.writeByte(6 /* ObjectIdentifier */);\r\n        let length = values.length - 1;\r\n        for (let i = 2; i < values.length; i++) {\r\n            let value = values[i];\r\n            while (value > 128) {\r\n                length++;\r\n                value /= 128;\r\n            }\r\n        }\r\n        const lengthBytes = DerWriter.getLength(length);\r\n        this.writeBytes(lengthBytes);\r\n        this.writeByte(values[0] * 40 + values[1]);\r\n        for (let i = 2; i < values.length; i++) {\r\n            let value = values[i];\r\n            if (value >= 128) {\r\n                let bytes = [];\r\n                bytes.push(value & 0x7f);\r\n                while (value >= 128) {\r\n                    value /= 128;\r\n                    bytes.push(0x80 | (value & 0x7f));\r\n                }\r\n                while (bytes.length > 0) {\r\n                    this.writeByte(bytes.pop());\r\n                }\r\n            }\r\n            else {\r\n                this.writeByte(value);\r\n            }\r\n        }\r\n    }\r\n    static getLength(length) {\r\n        if (length > 127) {\r\n            let size = 1;\r\n            for (let val = length >> 8; val !== 0; val >>= 8) {\r\n                size++;\r\n            }\r\n            const lengthBytes = DerWriter.lengthBuffer.slice(0, size + 1);\r\n            lengthBytes[0] = size | 0x80;\r\n            for (let i = (size - 1) * 8, j = 1; i >= 0; i -= 8, j++) {\r\n                lengthBytes[j] = length >> i;\r\n            }\r\n            return lengthBytes;\r\n        }\r\n        else {\r\n            const lengthBytes = DerWriter.lengthBuffer.slice(0, 1);\r\n            lengthBytes[0] = length;\r\n            return lengthBytes;\r\n        }\r\n    }\r\n    writeByte(value) {\r\n        this.ensureCapacity(this.position + 1);\r\n        this.buffer[this.position++] = value;\r\n    }\r\n    writeBytes(value) {\r\n        this.ensureCapacity(this.position + value.length);\r\n        value.copy(this.buffer, this.position);\r\n        this.position += value.length;\r\n    }\r\n    ensureCapacity(capacity) {\r\n        if (this.buffer.length < capacity) {\r\n            let newLength = Math.max(512, this.buffer.length * 2);\r\n            while (newLength < capacity)\r\n                newLength *= 2;\r\n            const newBuffer = buffer_1.Buffer.alloc(newLength);\r\n            this.buffer.copy(newBuffer, 0, 0, this.position);\r\n            this.buffer = newBuffer;\r\n        }\r\n    }\r\n}\r\nexports.DerWriter = DerWriter;\r\nDerWriter.lengthBuffer = buffer_1.Buffer.alloc(10);\r\n//# sourceMappingURL=derData.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.formatBuffer = exports.SshDataWriter = exports.SshDataReader = void 0;\r\nconst buffer_1 = require(\"buffer\");\r\nconst sshAlgorithms_1 = require(\"../algorithms/sshAlgorithms\");\r\nconst bigInt_1 = require(\"./bigInt\");\r\nclass SshDataReader {\r\n    constructor(buffer) {\r\n        this.buffer = buffer;\r\n        this.position = 0;\r\n    }\r\n    get available() {\r\n        return this.buffer.length - this.position;\r\n    }\r\n    read(length) {\r\n        if (this.available < length) {\r\n            throw new Error('Attempted to read past end of buffer.');\r\n        }\r\n        const data = this.buffer.slice(this.position, this.position + length);\r\n        this.position += length;\r\n        return data;\r\n    }\r\n    readByte() {\r\n        if (this.available === 0) {\r\n            throw new Error('Attempted to read past end of buffer.');\r\n        }\r\n        const value = this.buffer[this.position];\r\n        this.position++;\r\n        return value;\r\n    }\r\n    readBinary() {\r\n        const length = this.readUInt32();\r\n        if (this.available < length) {\r\n            throw new Error('Attempted to read past end of buffer.');\r\n        }\r\n        const data = this.buffer.slice(this.position, this.position + length);\r\n        this.position += length;\r\n        return data;\r\n    }\r\n    readString(encoding) {\r\n        const bytes = this.readBinary();\r\n        return bytes.toString();\r\n    }\r\n    readList(encoding) {\r\n        const stringList = this.readString(encoding);\r\n        return stringList.length === 0 ? [] : stringList.split(',');\r\n    }\r\n    readBoolean() {\r\n        return this.readByte() !== 0;\r\n    }\r\n    readUInt32() {\r\n        if (this.available < 4) {\r\n            throw new Error('Attempted to read past end of buffer.');\r\n        }\r\n        // Big-endian encoding\r\n        const value0 = this.buffer[this.position + 0];\r\n        const value1 = this.buffer[this.position + 1];\r\n        const value2 = this.buffer[this.position + 2];\r\n        const value3 = this.buffer[this.position + 3];\r\n        this.position += 4;\r\n        const value = ((value0 << 24) | (value1 << 16) | (value2 << 8) | value3) >>> 0;\r\n        return value;\r\n    }\r\n    readUInt64() {\r\n        if (this.available < 8) {\r\n            throw new Error('Attempted to read past end of buffer.');\r\n        }\r\n        // Big-endian encoding\r\n        const value0 = this.buffer[this.position + 0];\r\n        const value1 = this.buffer[this.position + 1];\r\n        const value2 = this.buffer[this.position + 2];\r\n        const value3 = this.buffer[this.position + 3];\r\n        const value4 = this.buffer[this.position + 4];\r\n        const value5 = this.buffer[this.position + 5];\r\n        const value6 = this.buffer[this.position + 6];\r\n        const value7 = this.buffer[this.position + 7];\r\n        this.position += 8;\r\n        const high = ((value0 << 24) | (value1 << 16) | (value2 << 8) | value3) >>> 0;\r\n        const low = ((value4 << 24) | (value5 << 16) | (value6 << 8) | value7) >>> 0;\r\n        return high * 0x100000000 + low;\r\n    }\r\n    readBigInt() {\r\n        const data = this.readBinary();\r\n        if (data.length === 0) {\r\n            return bigInt_1.BigInt.zero;\r\n        }\r\n        return bigInt_1.BigInt.fromBytes(data);\r\n    }\r\n}\r\nexports.SshDataReader = SshDataReader;\r\nSshDataReader.mpintZero = buffer_1.Buffer.alloc(1);\r\nclass SshDataWriter {\r\n    constructor(buffer) {\r\n        this.buffer = buffer;\r\n        this.position = 0;\r\n    }\r\n    write(data) {\r\n        this.ensureCapacity(this.position + data.length);\r\n        data.copy(this.buffer, this.position);\r\n        this.position += data.length;\r\n    }\r\n    writeByte(value) {\r\n        this.ensureCapacity(this.position + 1);\r\n        this.buffer[this.position] = value;\r\n        this.position++;\r\n    }\r\n    writeBinary(data) {\r\n        this.ensureCapacity(this.position + 4 + data.length);\r\n        this.writeUInt32(data.length);\r\n        data.copy(this.buffer, this.position);\r\n        this.position += data.length;\r\n    }\r\n    writeString(value, encoding) {\r\n        this.writeBinary(buffer_1.Buffer.from(value));\r\n    }\r\n    writeList(value, encoding) {\r\n        this.writeString(value ? value.join(',') : '', encoding);\r\n    }\r\n    writeBoolean(value) {\r\n        this.writeByte(value ? 1 : 0);\r\n    }\r\n    writeUInt32(value) {\r\n        this.ensureCapacity(this.position + 4);\r\n        // Big-endian encoding\r\n        this.buffer[this.position + 0] = value >>> 24;\r\n        this.buffer[this.position + 1] = value >>> 16;\r\n        this.buffer[this.position + 2] = value >>> 8;\r\n        this.buffer[this.position + 3] = value >>> 0;\r\n        this.position += 4;\r\n    }\r\n    writeUInt64(value) {\r\n        this.ensureCapacity(this.position + 8);\r\n        const low = value & 0xffffffff;\r\n        const high = (value - low) / 0x100000000;\r\n        // Big-endian encoding\r\n        this.buffer[this.position + 0] = high >>> 24;\r\n        this.buffer[this.position + 1] = high >>> 16;\r\n        this.buffer[this.position + 2] = high >>> 8;\r\n        this.buffer[this.position + 3] = high >>> 0;\r\n        this.buffer[this.position + 4] = low >>> 24;\r\n        this.buffer[this.position + 5] = low >>> 16;\r\n        this.buffer[this.position + 6] = low >>> 8;\r\n        this.buffer[this.position + 7] = low >>> 0;\r\n        this.position += 8;\r\n    }\r\n    writeBigInt(value) {\r\n        const data = value.toBytes();\r\n        if (data.length === 1 && data[0] === 0) {\r\n            this.writeUInt32(0);\r\n        }\r\n        else {\r\n            this.writeBinary(data);\r\n        }\r\n    }\r\n    writeRandom(length) {\r\n        this.ensureCapacity(this.position + length);\r\n        const randomBuffer = this.buffer.slice(this.position, this.position + length);\r\n        sshAlgorithms_1.SshAlgorithms.random.getBytes(randomBuffer);\r\n        this.position += length;\r\n    }\r\n    skip(length) {\r\n        this.ensureCapacity(this.position + length);\r\n        this.position += length;\r\n    }\r\n    ensureCapacity(capacity) {\r\n        if (this.buffer.length < capacity) {\r\n            let newLength = Math.max(512, this.buffer.length * 2);\r\n            while (newLength < capacity)\r\n                newLength *= 2;\r\n            const newBuffer = buffer_1.Buffer.alloc(newLength);\r\n            this.buffer.copy(newBuffer, 0, 0, this.position);\r\n            this.buffer = newBuffer;\r\n        }\r\n    }\r\n    toBuffer() {\r\n        return this.buffer.slice(0, this.position);\r\n    }\r\n}\r\nexports.SshDataWriter = SshDataWriter;\r\nfunction makeCrcTable() {\r\n    let c;\r\n    const table = [];\r\n    for (let n = 0; n < 256; n++) {\r\n        c = n;\r\n        for (let k = 0; k < 8; k++) {\r\n            c = c & 1 ? 0xedb88320 ^ (c >>> 1) : c >>> 1;\r\n        }\r\n        table[n] = c;\r\n    }\r\n    return table;\r\n}\r\nlet crcTable;\r\nfunction crc32(data) {\r\n    if (!crcTable) {\r\n        crcTable = makeCrcTable();\r\n    }\r\n    let crc = 0 ^ -1;\r\n    for (let i = 0; i < data.length; i++) {\r\n        crc = (crc >>> 8) ^ crcTable[(crc ^ data[i]) & 0xff];\r\n    }\r\n    const result = (crc ^ -1) >>> 0;\r\n    return (result + 0x100000000)\r\n        .toString(16)\r\n        .substr(-8)\r\n        .toUpperCase();\r\n}\r\n/**\r\n * Formats a byte buffer using the same format as OpenSSH,\r\n * useful for debugging and comparison in logs.\r\n */\r\nfunction formatBuffer(data, name, formatData) {\r\n    let s = `${name === undefined ? 'Buffer' : name}[${data.length}] (${crc32(data)})\\n`;\r\n    if (formatData === false) {\r\n        return s;\r\n    }\r\n    const max = Math.min(2048, data.length);\r\n    for (let lineOffset = 0; lineOffset < max; lineOffset += 16) {\r\n        if (lineOffset < 1000)\r\n            s += '0';\r\n        if (lineOffset < 100)\r\n            s += '0';\r\n        if (lineOffset < 10)\r\n            s += '0';\r\n        s += lineOffset + ':';\r\n        for (let i = lineOffset; i < lineOffset + 16; i++) {\r\n            if (i < max) {\r\n                s += ' ' + data.slice(i, i + 1).toString('hex');\r\n            }\r\n            else {\r\n                s += '   ';\r\n            }\r\n        }\r\n        s += '  ';\r\n        for (let i = lineOffset; i < lineOffset + 16; i++) {\r\n            if (i < max) {\r\n                const c = data[i];\r\n                s += c > 32 && c <= 127 ? data.slice(i, i + 1).toString() : '.';\r\n            }\r\n            else {\r\n                s += ' ';\r\n            }\r\n        }\r\n        s += '\\n';\r\n    }\r\n    if (max < data.length) {\r\n        s += '...\\n';\r\n    }\r\n    return s;\r\n}\r\nexports.formatBuffer = formatBuffer;\r\n//# sourceMappingURL=sshData.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SshProtocol = void 0;\r\nconst trace_1 = require(\"../trace\");\r\nconst buffer_1 = require(\"buffer\");\r\nconst queue_1 = require(\"../util/queue\");\r\nconst semaphore_1 = require(\"../util/semaphore\");\r\nconst sshMessage_1 = require(\"../messages/sshMessage\");\r\nconst sshData_1 = require(\"../io/sshData\");\r\nconst transportMessages_1 = require(\"../messages/transportMessages\");\r\nconst kexMessages_1 = require(\"../messages/kexMessages\");\r\nconst connectionMessages_1 = require(\"../messages/connectionMessages\");\r\nconst errors_1 = require(\"../errors\");\r\nclass SequencedMessage {\r\n    constructor(sequence, message) {\r\n        this.sequence = sequence;\r\n        this.message = message;\r\n    }\r\n}\r\n/**\r\n * Implements the base SSH protocol (sending and receiving messages) over a Stream.\r\n */\r\nclass SshProtocol {\r\n    constructor(stream, config, metrics) {\r\n        this.config = config;\r\n        this.metrics = metrics;\r\n        this.sessionSemaphore = new semaphore_1.Semaphore(1);\r\n        this.inboundPacketSequence = 0;\r\n        this.outboundPacketSequence = 0;\r\n        this.inboundFlow = 0;\r\n        this.outboundFlow = 0;\r\n        // Sent messages are kept for a short time, until the other side acknowledges\r\n        // that they have been received. This enables re-sending lost messages on reconnect.\r\n        this.recentSentMessages = new queue_1.Queue();\r\n        // Initialize buffers that are re-used for each sent/received message.\r\n        // The buffers will be automatically expanded as necessary.\r\n        this.sendWriter = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(1024));\r\n        this.receiveWriter = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(1024));\r\n        this.extensions = null;\r\n        this.kexService = null;\r\n        this.algorithms = null;\r\n        this.outgoingMessagesHaveLatencyInfo = false;\r\n        this.incomingMessagesHaveLatencyInfo = false;\r\n        this.outgoingMessagesHaveReconnectInfo = false;\r\n        this.incomingMessagesHaveReconnectInfo = false;\r\n        this.stream = stream;\r\n    }\r\n    get lastIncomingSequence() {\r\n        return this.inboundPacketSequence - 1;\r\n    }\r\n    getSentMessages(startingSequenceNumber) {\r\n        if (startingSequenceNumber === this.outboundPacketSequence + 1) {\r\n            // The recipient is already up-to-date.\r\n            return [];\r\n        }\r\n        if (this.recentSentMessages.size > 0 &&\r\n            startingSequenceNumber < this.recentSentMessages.peek().sequence) {\r\n            // The cached recent messages do not go back as far as the requested sequence number.\r\n            // This should never happen because messages are not dropped from this list until\r\n            // the other side acknowledges they have been received, so they should not be\r\n            // requested again after reconnecting.\r\n            return null;\r\n        }\r\n        // Return all messages starting with the requested sequence number.\r\n        // Exclude key exchange messages because they cannot be retransmitted; a reconnected\r\n        // session will do key exchange separately. Also exclude any disconnect messages that\r\n        // may have been attempted when the connection was lost.\r\n        const messagesToRetransmit = new Array();\r\n        for (let sequencedMessage of this.recentSentMessages) {\r\n            if (sequencedMessage.sequence >= startingSequenceNumber) {\r\n                const message = sequencedMessage.message;\r\n                if (!(message instanceof kexMessages_1.KeyExchangeMessage || message instanceof transportMessages_1.DisconnectMessage)) {\r\n                    messagesToRetransmit.push(message);\r\n                }\r\n            }\r\n        }\r\n        return messagesToRetransmit;\r\n    }\r\n    async writeProtocolVersion(version, cancellation) {\r\n        const stream = this.stream;\r\n        if (!stream)\r\n            throw new Error('SSH session disconnected.');\r\n        const data = buffer_1.Buffer.from(version + '\\r\\n');\r\n        await stream.write(data, cancellation);\r\n        this.metrics.addMessageSent(data.length);\r\n        return Promise.resolve();\r\n    }\r\n    async readProtocolVersion(cancellation) {\r\n        const stream = this.stream;\r\n        if (!stream)\r\n            throw new Error('SSH session disconnected.');\r\n        // http://tools.ietf.org/html/rfc4253#section-4.2\r\n        const buffer = buffer_1.Buffer.alloc(255);\r\n        let lineCount = 0;\r\n        for (let i = 0; i < buffer.length; i++) {\r\n            const byteBuffer = await stream.read(1, cancellation);\r\n            if (!byteBuffer) {\r\n                break;\r\n            }\r\n            buffer[i] = byteBuffer[0];\r\n            const carriageReturn = 0x0d;\r\n            const lineFeed = 0x0a;\r\n            if (i > 0 && buffer[i - 1] === carriageReturn && buffer[i] === lineFeed) {\r\n                const line = buffer.toString('utf8', 0, i - 1);\r\n                if (line.startsWith('SSH-')) {\r\n                    this.metrics.addMessageReceived(i + 1);\r\n                    return line;\r\n                }\r\n                else if (lineCount > 20) {\r\n                    // Give up if a version string was not found after 20 lines.\r\n                    break;\r\n                }\r\n                else {\r\n                    // Ignore initial lines before the version line.\r\n                    lineCount++;\r\n                    i = -1;\r\n                }\r\n            }\r\n        }\r\n        throw new errors_1.SshConnectionError('Failed to read the protocol version', transportMessages_1.SshDisconnectReason.protocolError);\r\n    }\r\n    async handleNewKeys(cancellation) {\r\n        try {\r\n            await this.sessionSemaphore.wait(cancellation);\r\n            this.inboundFlow = 0;\r\n            this.outboundFlow = 0;\r\n            this.algorithms = this.kexService.finishKeyExchange();\r\n        }\r\n        finally {\r\n            this.sessionSemaphore.release();\r\n        }\r\n    }\r\n    /**\r\n     * Attempts to read from the stream until the buffer is full.\r\n     * @returns True if the read succeeded, false if the stream was disposed.\r\n     */\r\n    async read(buffer, cancellation) {\r\n        const stream = this.stream;\r\n        if (!stream)\r\n            return false;\r\n        let bytesRead = 0;\r\n        do {\r\n            let data;\r\n            try {\r\n                data = await stream.read(buffer.length - bytesRead, cancellation);\r\n            }\r\n            catch (e) {\r\n                if (!(e instanceof Error))\r\n                    throw e;\r\n                if (stream.isDisposed)\r\n                    return false;\r\n                stream.dispose();\r\n                this.stream = null;\r\n                (0, trace_1.trace)('Error reading from stream: ' + e.message);\r\n                throw new errors_1.SshConnectionError('Error reading from stream: ' + e.message, transportMessages_1.SshDisconnectReason.connectionLost);\r\n            }\r\n            if (!data)\r\n                return false;\r\n            data.copy(buffer, bytesRead);\r\n            bytesRead += data.length;\r\n        } while (bytesRead < buffer.length);\r\n        return true;\r\n    }\r\n    /**\r\n     * Attempts to write data to the stream.\r\n     * @returns True if the write succeeded, false if the stream was disposed.\r\n     */\r\n    async write(data, cancellation) {\r\n        const stream = this.stream;\r\n        if (!stream)\r\n            return false;\r\n        try {\r\n            await stream.write(data, cancellation);\r\n        }\r\n        catch (e) {\r\n            if (!(e instanceof Error))\r\n                throw e;\r\n            if (stream.isDisposed)\r\n                return false;\r\n            stream.dispose();\r\n            this.stream = null;\r\n            (0, trace_1.trace)('Error writing to stream: ' + e.message);\r\n            throw new errors_1.SshConnectionError('Error writing to stream: ' + e.message, transportMessages_1.SshDisconnectReason.connectionLost);\r\n        }\r\n        return true;\r\n    }\r\n    async considerReExchange(initial, cancellation) {\r\n        const kexService = this.kexService;\r\n        if (!kexService)\r\n            return;\r\n        let kexMessage = null;\r\n        let kexGuessMessage = null;\r\n        if (!kexService.exchanging &&\r\n            (initial || this.inboundFlow + this.outboundFlow > this.config.keyRotationThreshold)) {\r\n            [kexMessage, kexGuessMessage] = await kexService.startKeyExchange(initial);\r\n        }\r\n        if (kexMessage) {\r\n            await this.sendMessage(kexMessage, cancellation);\r\n            if (kexGuessMessage) {\r\n                await this.sendMessage(kexGuessMessage, cancellation);\r\n            }\r\n        }\r\n    }\r\n    async computeHmac(signer, payload, seq) {\r\n        const writer = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(4 + payload.length));\r\n        writer.writeUInt32(seq);\r\n        writer.write(payload);\r\n        const result = await signer.sign(writer.toBuffer());\r\n        return result;\r\n    }\r\n    async verifyHmac(verifier, payload, seq, mac) {\r\n        const writer = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(4 + payload.length));\r\n        writer.writeUInt32(seq);\r\n        writer.write(payload);\r\n        const result = await verifier.verify(writer.toBuffer(), mac);\r\n        return result;\r\n    }\r\n    async readAndVerifyHmac(verifier, data, macBuffer, cancellation) {\r\n        if (!(await this.read(macBuffer, cancellation))) {\r\n            return false;\r\n        }\r\n        const verified = await this.verifyHmac(verifier, data, this.inboundPacketSequence, macBuffer);\r\n        if (!verified) {\r\n            throw new errors_1.SshConnectionError('Invalid MAC', transportMessages_1.SshDisconnectReason.macError);\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Attemps to write one message to the stream.\r\n     * @returns `true` if writing succeeded, `false` if the stream was disposed.\r\n     * @throws SshConnectionException if writing to the stream failed for any other reason.\r\n     */\r\n    async sendMessage(message, cancellation) {\r\n        var _a;\r\n        const algorithms = this.algorithms;\r\n        const compression = algorithms === null || algorithms === void 0 ? void 0 : algorithms.compressor;\r\n        const encryption = algorithms === null || algorithms === void 0 ? void 0 : algorithms.cipher;\r\n        const hmac = algorithms === null || algorithms === void 0 ? void 0 : algorithms.messageSigner;\r\n        let result;\r\n        await this.sessionSemaphore.wait(cancellation);\r\n        try {\r\n            const blockSize = encryption ? Math.max(8, encryption.blockLength) : 8;\r\n            // Start by writing the uncompressed payload to the buffer at the correct offset.\r\n            const payloadOffset = SshProtocol.packetLengthSize + SshProtocol.paddingLengthSize;\r\n            this.sendWriter.position = payloadOffset;\r\n            message.write(this.sendWriter);\r\n            if (this.outgoingMessagesHaveReconnectInfo) {\r\n                // Write the sequence number of the last inbound packet processed.\r\n                this.sendWriter.writeUInt64(this.lastIncomingSequence);\r\n                if (this.outgoingMessagesHaveLatencyInfo) {\r\n                    // Write the time (in microseconds, not ms) since last packet was received.\r\n                    const timeSinceLastReceivedMessage = Math.min(4294967295, // max uint32\r\n                    Math.round((this.metrics.time - this.lastIncomingTimestamp) * 1000));\r\n                    this.sendWriter.writeUInt32(timeSinceLastReceivedMessage);\r\n                }\r\n            }\r\n            let payload = this.sendWriter.toBuffer().slice(payloadOffset);\r\n            if (compression != null) {\r\n                payload = compression.compress(payload);\r\n            }\r\n            // The packet length is not encrypted when in EtM or AEAD mode.\r\n            const isLengthEncrypted = !((hmac === null || hmac === void 0 ? void 0 : hmac.encryptThenMac) || (hmac === null || hmac === void 0 ? void 0 : hmac.authenticatedEncryption));\r\n            // http://tools.ietf.org/html/rfc4253\r\n            // 6.  Binary Packet Protocol\r\n            // the total length of (packet_length || padding_length || payload || padding)\r\n            // is a multiple of the cipher block size or 8,\r\n            // padding length must between 4 and 255 bytes.\r\n            let paddingLength = blockSize -\r\n                (((isLengthEncrypted ? SshProtocol.packetLengthSize : 0) +\r\n                    SshProtocol.paddingLengthSize +\r\n                    payload.length) %\r\n                    blockSize);\r\n            if (paddingLength < 4) {\r\n                paddingLength += blockSize;\r\n            }\r\n            const packetLength = SshProtocol.paddingLengthSize + payload.length + paddingLength;\r\n            this.sendWriter.position = 0;\r\n            this.sendWriter.writeUInt32(packetLength);\r\n            this.sendWriter.writeByte(paddingLength);\r\n            // The uncompressed payload was already written at the correct offset.\r\n            // When compression is enabled, rewrite the compressed payload.\r\n            if (compression != null) {\r\n                this.sendWriter.write(payload);\r\n            }\r\n            else {\r\n                this.sendWriter.position += payload.length;\r\n            }\r\n            this.sendWriter.writeRandom(paddingLength);\r\n            payload = this.sendWriter.toBuffer();\r\n            let mac = null;\r\n            if ((hmac === null || hmac === void 0 ? void 0 : hmac.encryptThenMac) && encryption) {\r\n                // In EtM mode, compute the MAC after encrypting. And don't encrypt the length.\r\n                const packetWithoutLength = payload.slice(SshProtocol.packetLengthSize, payload.length);\r\n                const encryptedPacket = await encryption.transform(packetWithoutLength);\r\n                encryptedPacket.copy(packetWithoutLength);\r\n                mac = await this.computeHmac(hmac, payload, this.outboundPacketSequence);\r\n            }\r\n            else if (hmac === null || hmac === void 0 ? void 0 : hmac.authenticatedEncryption) {\r\n                // With a GCM cipher, the packet length is not included in the plaintext.\r\n                let packetWithoutLength = payload.slice(SshProtocol.packetLengthSize, payload.length);\r\n                const encryptedPacket = await encryption.transform(packetWithoutLength);\r\n                encryptedPacket.copy(packetWithoutLength);\r\n                // The GCM tag was already generated during the transform call above;\r\n                // this just retrieves it.\r\n                mac = await hmac.sign(packetWithoutLength);\r\n            }\r\n            else {\r\n                if (hmac) {\r\n                    mac = await this.computeHmac(hmac, payload, this.outboundPacketSequence);\r\n                }\r\n                if (encryption) {\r\n                    payload = await encryption.transform(payload);\r\n                }\r\n            }\r\n            if (!(message instanceof connectionMessages_1.ChannelDataMessage)) {\r\n                (0, trace_1.trace)(`Sending #${this.outboundPacketSequence} ${message}`);\r\n            }\r\n            else if (trace_1.traceData.enabled) {\r\n                (0, trace_1.traceData)(`Sending #${this.outboundPacketSequence} ${message}`);\r\n            }\r\n            if (this.incomingMessagesHaveReconnectInfo) {\r\n                // Save sent messages in case they need to be re-sent after reconnect.\r\n                // They'll be discarded soon, after the other side acknowledges them.\r\n                const sequencedMessage = new SequencedMessage(this.outboundPacketSequence, message);\r\n                sequencedMessage.sentTime = this.metrics.time;\r\n                this.recentSentMessages.enqueue(sequencedMessage);\r\n            }\r\n            this.outboundPacketSequence++;\r\n            this.outboundFlow += packetLength;\r\n            if (mac) {\r\n                const packet = buffer_1.Buffer.concat([payload, mac], payload.length + mac.length);\r\n                result = await this.write(packet, cancellation);\r\n            }\r\n            else {\r\n                result = await this.write(payload, cancellation);\r\n            }\r\n            this.metrics.addMessageSent(SshProtocol.packetLengthSize + packetLength + ((_a = hmac === null || hmac === void 0 ? void 0 : hmac.digestLength) !== null && _a !== void 0 ? _a : 0));\r\n        }\r\n        finally {\r\n            this.sessionSemaphore.release();\r\n        }\r\n        await this.considerReExchange(false, cancellation);\r\n        return result;\r\n    }\r\n    /**\r\n     * Attemps to read one message from the stream.\r\n     * @returns The message, or `null` if the stream was disposed.\r\n     * @throws SshConnectionError if reading from the stream failed for any other reason.\r\n     */\r\n    async receiveMessage(cancellation) {\r\n        var _a;\r\n        const algorithms = this.algorithms;\r\n        const encryption = algorithms === null || algorithms === void 0 ? void 0 : algorithms.decipher;\r\n        const hmac = algorithms === null || algorithms === void 0 ? void 0 : algorithms.messageVerifier;\r\n        const compression = algorithms === null || algorithms === void 0 ? void 0 : algorithms.decompressor;\r\n        // The packet length is not encrypted when in EtM or AEAD mode.\r\n        // So read only the length bytes first, separate from the remaining payload.\r\n        const isLengthEncrypted = !((hmac === null || hmac === void 0 ? void 0 : hmac.encryptThenMac) || (hmac === null || hmac === void 0 ? void 0 : hmac.authenticatedEncryption));\r\n        const firstBlockSize = !isLengthEncrypted\r\n            ? SshProtocol.packetLengthSize\r\n            : encryption\r\n                ? Math.max(8, encryption.blockLength)\r\n                : 8;\r\n        this.receiveWriter.position = firstBlockSize;\r\n        let firstBlock = this.receiveWriter.toBuffer();\r\n        if (!(await this.read(firstBlock, cancellation))) {\r\n            return null;\r\n        }\r\n        this.lastIncomingTimestamp = this.metrics.time;\r\n        // Decrypt the first block to get the packet length.\r\n        if (encryption && isLengthEncrypted) {\r\n            firstBlock = await encryption.transform(firstBlock);\r\n            this.receiveWriter.position = 0;\r\n            this.receiveWriter.write(firstBlock);\r\n        }\r\n        const receiveReader = new sshData_1.SshDataReader(firstBlock);\r\n        const packetLength = receiveReader.readUInt32();\r\n        if (packetLength > SshProtocol.maxPacketLength) {\r\n            (0, trace_1.trace)('Invalid packet length.');\r\n            throw new errors_1.SshConnectionError('Invalid packet length.', transportMessages_1.SshDisconnectReason.protocolError);\r\n        }\r\n        const packetBufferSize = SshProtocol.packetLengthSize + packetLength;\r\n        if (packetBufferSize > firstBlockSize) {\r\n            this.receiveWriter.skip(packetBufferSize - firstBlockSize);\r\n        }\r\n        if (hmac) {\r\n            // Ensure the receive buffer is large enough to also hold the mac without expanding.\r\n            this.receiveWriter.skip(hmac.digestLength);\r\n        }\r\n        const receiveBuffer = this.receiveWriter.toBuffer();\r\n        const packetBuffer = receiveBuffer.slice(0, packetBufferSize);\r\n        const macBuffer = receiveBuffer.slice(packetBufferSize);\r\n        let followingBlocks = packetBuffer.slice(firstBlockSize, packetBufferSize);\r\n        if (followingBlocks.length > 0) {\r\n            if (!(await this.read(followingBlocks, cancellation))) {\r\n                return null;\r\n            }\r\n            if (hmac === null || hmac === void 0 ? void 0 : hmac.encryptThenMac) {\r\n                // In EtM mode, read and verify the MAC before decrypting.\r\n                ///const packetWithoutLength = packet.slice(SshProtocol.packetLengthSize);\r\n                if (!(await this.readAndVerifyHmac(hmac, packetBuffer, macBuffer, cancellation))) {\r\n                    return null;\r\n                }\r\n            }\r\n            if (encryption) {\r\n                if (hmac === null || hmac === void 0 ? void 0 : hmac.authenticatedEncryption) {\r\n                    // With a GCM cipher, the MAC is required for decryption.\r\n                    if (!(await this.read(macBuffer, cancellation))) {\r\n                        return null;\r\n                    }\r\n                    // This doesn't actually verify anything yet (hence the return value is not checked);\r\n                    // it sets the tag to be used for verification in the following transform call.\r\n                    await hmac.verify(followingBlocks, macBuffer);\r\n                }\r\n                try {\r\n                    followingBlocks = await encryption.transform(followingBlocks);\r\n                }\r\n                catch (e) {\r\n                    if (hmac === null || hmac === void 0 ? void 0 : hmac.authenticatedEncryption) {\r\n                        // GCM decryption failed to verify data + tag.\r\n                        throw new errors_1.SshConnectionError('Invalid MAC', transportMessages_1.SshDisconnectReason.macError);\r\n                    }\r\n                    else {\r\n                        throw e;\r\n                    }\r\n                }\r\n                this.receiveWriter.position = firstBlockSize;\r\n                this.receiveWriter.write(followingBlocks);\r\n            }\r\n        }\r\n        if (hmac && !hmac.encryptThenMac && !hmac.authenticatedEncryption) {\r\n            if (!(await this.readAndVerifyHmac(hmac, packetBuffer, macBuffer, cancellation))) {\r\n                return null;\r\n            }\r\n        }\r\n        const paddingLength = packetBuffer[SshProtocol.packetLengthSize];\r\n        let payload = packetBuffer.slice(SshProtocol.packetLengthSize + SshProtocol.paddingLengthSize, SshProtocol.packetLengthSize + (packetLength - paddingLength));\r\n        if (compression) {\r\n            payload = compression.decompress(payload);\r\n        }\r\n        if (this.incomingMessagesHaveReconnectInfo) {\r\n            // Read the extension info from the end of the payload.\r\n            let lastSequenceSeenByRemote;\r\n            let remoteTimeSinceLastReceived;\r\n            if (this.incomingMessagesHaveLatencyInfo) {\r\n                const reader = new sshData_1.SshDataReader(payload.slice(payload.length - 12, payload.length));\r\n                lastSequenceSeenByRemote = reader.readUInt64();\r\n                remoteTimeSinceLastReceived = reader.readUInt32() / 1000; // microseconds to ms\r\n                payload = payload.slice(0, payload.length - 12);\r\n            }\r\n            else {\r\n                const reader = new sshData_1.SshDataReader(payload.slice(payload.length - 8, payload.length));\r\n                lastSequenceSeenByRemote = reader.readUInt64();\r\n                remoteTimeSinceLastReceived = 0;\r\n                payload = payload.slice(0, payload.length - 8);\r\n            }\r\n            // Discard any recently sent messages that were acknowledged.\r\n            while (this.recentSentMessages.size > 0) {\r\n                const oldestSequenceMessage = this.recentSentMessages.peek();\r\n                if (oldestSequenceMessage.sequence > lastSequenceSeenByRemote) {\r\n                    break;\r\n                }\r\n                if (this.stream &&\r\n                    this.incomingMessagesHaveLatencyInfo &&\r\n                    oldestSequenceMessage.sequence === lastSequenceSeenByRemote) {\r\n                    // Compute the time since the message with the last-seen sequence was sent.\r\n                    // Subtract the time between when the remote side received the message with the\r\n                    // last-seen sequence and sent the current message.\r\n                    const timeSinceSent = this.lastIncomingTimestamp - oldestSequenceMessage.sentTime;\r\n                    const roundTripLatency = timeSinceSent - remoteTimeSinceLastReceived;\r\n                    this.metrics.updateLatency(roundTripLatency);\r\n                }\r\n                this.recentSentMessages.dequeue();\r\n            }\r\n        }\r\n        const messageType = payload[0];\r\n        let message = sshMessage_1.SshMessage.create(messageType, payload);\r\n        if (!message) {\r\n            const unimplementedMessage = new transportMessages_1.UnimplementedMessage();\r\n            unimplementedMessage.sequenceNumber = this.inboundPacketSequence;\r\n            unimplementedMessage.unimplementedMessageType = messageType;\r\n            message = unimplementedMessage;\r\n        }\r\n        if (!(message instanceof connectionMessages_1.ChannelDataMessage)) {\r\n            (0, trace_1.trace)(`Receiving #${this.inboundPacketSequence} ${message}`);\r\n        }\r\n        else if (trace_1.traceData.enabled) {\r\n            (0, trace_1.traceData)(`Receiving #${this.inboundPacketSequence} ${message}`);\r\n        }\r\n        await this.sessionSemaphore.wait(cancellation);\r\n        this.inboundPacketSequence++;\r\n        this.inboundFlow += packetLength;\r\n        this.sessionSemaphore.release();\r\n        this.metrics.addMessageReceived(SshProtocol.packetLengthSize + packetLength + ((_a = hmac === null || hmac === void 0 ? void 0 : hmac.digestLength) !== null && _a !== void 0 ? _a : 0));\r\n        await this.considerReExchange(false, cancellation);\r\n        return message;\r\n    }\r\n    dispose() {\r\n        try {\r\n            if (this.stream)\r\n                this.stream.close().catch((e) => {\r\n                    (0, trace_1.trace)('Error closing stream: ' + e.message);\r\n                });\r\n        }\r\n        catch (e) {\r\n            if (!(e instanceof Error))\r\n                throw e;\r\n            (0, trace_1.trace)('Error closing stream: ' + e.message);\r\n        }\r\n        this.stream = null;\r\n        this.metrics.updateLatency(0);\r\n        if (this.algorithms)\r\n            this.algorithms.dispose();\r\n    }\r\n}\r\nexports.SshProtocol = SshProtocol;\r\nSshProtocol.maxPacketLength = 1024 * 1024; // 1 MB\r\nSshProtocol.packetLengthSize = 4;\r\nSshProtocol.paddingLengthSize = 1;\r\n//# sourceMappingURL=sshProtocol.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.AuthenticationSuccessMessage = exports.AuthenticationFailureMessage = exports.PasswordRequestMessage = exports.PublicKeyOKMessage = exports.PublicKeyRequestMessage = exports.AuthenticationRequestMessage = exports.AuthenticationMessage = void 0;\r\nconst sshMessage_1 = require(\"./sshMessage\");\r\nclass AuthenticationMessage extends sshMessage_1.SshMessage {\r\n}\r\nexports.AuthenticationMessage = AuthenticationMessage;\r\nclass AuthenticationRequestMessage extends AuthenticationMessage {\r\n    get messageType() {\r\n        return 50;\r\n    }\r\n    onRead(reader) {\r\n        this.username = reader.readString('utf8');\r\n        this.serviceName = reader.readString('ascii');\r\n        this.methodName = reader.readString('ascii');\r\n    }\r\n    onWrite(writer) {\r\n        writer.writeString(this.username || '', 'utf8');\r\n        writer.writeString(this.serviceName || '', 'ascii');\r\n        writer.writeString(this.validateField(this.methodName, 'method name'), 'ascii');\r\n    }\r\n}\r\nexports.AuthenticationRequestMessage = AuthenticationRequestMessage;\r\nclass PublicKeyRequestMessage extends AuthenticationRequestMessage {\r\n    constructor() {\r\n        super();\r\n        this.methodName = \"publickey\" /* publicKey */;\r\n    }\r\n    get hasSignature() {\r\n        return this.signature && this.signature.length > 0 ? true : false;\r\n    }\r\n    onRead(reader) {\r\n        super.onRead(reader);\r\n        const hasSignature = reader.readBoolean();\r\n        this.keyAlgorithmName = reader.readString('ascii');\r\n        this.publicKey = reader.readBinary();\r\n        if (hasSignature) {\r\n            this.signature = reader.readBinary();\r\n            this.payloadWithoutSignature = this.rawBytes.slice(0, this.rawBytes.length - this.signature.length - 4);\r\n        }\r\n        else {\r\n            this.signature = undefined;\r\n        }\r\n    }\r\n    onWrite(writer) {\r\n        var _a, _b;\r\n        super.onWrite(writer);\r\n        if (!this.keyAlgorithmName)\r\n            throw new Error('Key algorithm name not set.');\r\n        if (this.methodName === \"hostbased\" /* hostBased */) {\r\n            writer.writeString(this.keyAlgorithmName, 'ascii');\r\n            writer.writeBinary(this.publicKey || Buffer.alloc(0));\r\n            writer.writeString((_a = this.clientHostname) !== null && _a !== void 0 ? _a : '', 'ascii');\r\n            writer.writeString((_b = this.clientUsername) !== null && _b !== void 0 ? _b : '', 'ascii');\r\n            if (!this.hasSignature) {\r\n                throw new Error('A signature is required for a host-based authentcation request.');\r\n            }\r\n            writer.writeBinary(this.signature);\r\n        }\r\n        else {\r\n            writer.writeBoolean(this.hasSignature);\r\n            writer.writeString(this.keyAlgorithmName, 'ascii');\r\n            writer.writeBinary(this.publicKey || Buffer.alloc(0));\r\n            if (this.hasSignature) {\r\n                writer.writeBinary(this.signature);\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.PublicKeyRequestMessage = PublicKeyRequestMessage;\r\nclass PublicKeyOKMessage extends AuthenticationMessage {\r\n    get messageType() {\r\n        return 60;\r\n    }\r\n    onRead(reader) {\r\n        this.keyAlgorithmName = reader.readString('ascii');\r\n        this.publicKey = reader.readBinary();\r\n    }\r\n    onWrite(writer) {\r\n        if (!this.keyAlgorithmName)\r\n            throw new Error('Key algorithm name not set.');\r\n        if (!this.publicKey)\r\n            throw new Error('Public key not set.');\r\n        writer.writeString(this.keyAlgorithmName, 'ascii');\r\n        writer.writeBinary(this.publicKey);\r\n    }\r\n}\r\nexports.PublicKeyOKMessage = PublicKeyOKMessage;\r\nclass PasswordRequestMessage extends AuthenticationRequestMessage {\r\n    constructor() {\r\n        super();\r\n        this.methodName = \"password\" /* password */;\r\n    }\r\n    onRead(reader) {\r\n        super.onRead(reader);\r\n        reader.readBoolean();\r\n        this.password = reader.readString('utf8');\r\n    }\r\n    onWrite(writer) {\r\n        super.onWrite(writer);\r\n        writer.writeBoolean(false);\r\n        writer.writeString(this.password || '', 'utf8');\r\n    }\r\n}\r\nexports.PasswordRequestMessage = PasswordRequestMessage;\r\nclass AuthenticationFailureMessage extends AuthenticationMessage {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.partialSuccess = false;\r\n    }\r\n    get messageType() {\r\n        return 51;\r\n    }\r\n    onRead(reader) {\r\n        this.methodNames = reader.readList('ascii');\r\n        this.partialSuccess = reader.readBoolean();\r\n    }\r\n    onWrite(writer) {\r\n        writer.writeList(this.methodNames || [], 'ascii');\r\n        writer.writeBoolean(this.partialSuccess);\r\n    }\r\n}\r\nexports.AuthenticationFailureMessage = AuthenticationFailureMessage;\r\nclass AuthenticationSuccessMessage extends AuthenticationMessage {\r\n    get messageType() {\r\n        return 52;\r\n    }\r\n    onRead(reader) { }\r\n    onWrite(writer) { }\r\n}\r\nexports.AuthenticationSuccessMessage = AuthenticationSuccessMessage;\r\nsshMessage_1.SshMessage.index.set(50, AuthenticationRequestMessage);\r\nsshMessage_1.SshMessage.index.set(51, AuthenticationFailureMessage);\r\nsshMessage_1.SshMessage.index.set(52, AuthenticationSuccessMessage);\r\n//# sourceMappingURL=authenticationMessages.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ChannelFailureMessage = exports.ChannelSuccessMessage = exports.ChannelSignalMessage = exports.CommandRequestMessage = exports.ChannelRequestMessage = exports.ChannelRequestType = exports.ChannelCloseMessage = exports.ChannelEofMessage = exports.ChannelDataMessage = exports.ChannelWindowAdjustMessage = exports.ChannelOpenFailureMessage = exports.SshChannelOpenFailureReason = exports.ChannelOpenConfirmationMessage = exports.ChannelOpenMessage = exports.ConnectionMessage = void 0;\r\nconst sshMessage_1 = require(\"./sshMessage\");\r\nconst sshData_1 = require(\"../io/sshData\");\r\nclass ConnectionMessage extends sshMessage_1.SshMessage {\r\n}\r\nexports.ConnectionMessage = ConnectionMessage;\r\nclass ChannelOpenMessage extends ConnectionMessage {\r\n    get messageType() {\r\n        return 90;\r\n    }\r\n    onRead(reader) {\r\n        this.channelType = reader.readString('ascii');\r\n        this.senderChannel = reader.readUInt32();\r\n        this.initialWindowSize = reader.readUInt32();\r\n        this.maximumPacketSize = reader.readUInt32();\r\n    }\r\n    onWrite(writer) {\r\n        writer.writeString(this.validateField(this.channelType, 'channel type'), 'ascii');\r\n        writer.writeUInt32(this.validateField(this.senderChannel, 'sender channel'));\r\n        writer.writeUInt32(this.initialWindowSize || ChannelOpenMessage.defaultInitialWindowSize);\r\n        writer.writeUInt32(this.maximumPacketSize || ChannelOpenMessage.defaultMaximumPacketSize);\r\n    }\r\n}\r\nexports.ChannelOpenMessage = ChannelOpenMessage;\r\nChannelOpenMessage.defaultInitialWindowSize = 1024 * 1024;\r\nChannelOpenMessage.defaultMaximumPacketSize = 16 * 1024;\r\nclass ChannelOpenConfirmationMessage extends ConnectionMessage {\r\n    get messageType() {\r\n        return 91;\r\n    }\r\n    onRead(reader) {\r\n        this.recipientChannel = reader.readUInt32();\r\n        this.senderChannel = reader.readUInt32();\r\n        this.initialWindowSize = reader.readUInt32();\r\n        this.maximumPacketSize = reader.readUInt32();\r\n    }\r\n    onWrite(writer) {\r\n        writer.writeUInt32(this.validateField(this.recipientChannel, 'recipient channel'));\r\n        writer.writeUInt32(this.validateField(this.senderChannel, 'sender channel'));\r\n        writer.writeUInt32(this.validateField(this.initialWindowSize, 'initial window size'));\r\n        writer.writeUInt32(this.validateField(this.maximumPacketSize, 'max packet size'));\r\n    }\r\n    toString() {\r\n        return `${super.toString()} (recipientChannel=${this.recipientChannel} senderChannel=${this.senderChannel})`;\r\n    }\r\n}\r\nexports.ChannelOpenConfirmationMessage = ChannelOpenConfirmationMessage;\r\nvar SshChannelOpenFailureReason;\r\n(function (SshChannelOpenFailureReason) {\r\n    SshChannelOpenFailureReason[SshChannelOpenFailureReason[\"none\"] = 0] = \"none\";\r\n    SshChannelOpenFailureReason[SshChannelOpenFailureReason[\"administrativelyProhibited\"] = 1] = \"administrativelyProhibited\";\r\n    SshChannelOpenFailureReason[SshChannelOpenFailureReason[\"connectFailed\"] = 2] = \"connectFailed\";\r\n    SshChannelOpenFailureReason[SshChannelOpenFailureReason[\"unknownChannelType\"] = 3] = \"unknownChannelType\";\r\n    SshChannelOpenFailureReason[SshChannelOpenFailureReason[\"resourceShortage\"] = 4] = \"resourceShortage\";\r\n})(SshChannelOpenFailureReason = exports.SshChannelOpenFailureReason || (exports.SshChannelOpenFailureReason = {}));\r\nclass ChannelOpenFailureMessage extends ConnectionMessage {\r\n    get messageType() {\r\n        return 92;\r\n    }\r\n    onRead(reader) {\r\n        this.recipientChannel = reader.readUInt32();\r\n        this.reasonCode = reader.readUInt32();\r\n        this.description = reader.readString('utf8');\r\n        this.language = reader.readString('ascii');\r\n    }\r\n    onWrite(writer) {\r\n        writer.writeUInt32(this.validateField(this.recipientChannel, 'recipient channel'));\r\n        writer.writeUInt32(this.validateField(this.reasonCode, 'reason code'));\r\n        writer.writeString(this.description || '', 'utf8');\r\n        writer.writeString(this.language || 'en', 'ascii');\r\n    }\r\n    toString() {\r\n        return `${super.toString} (${SshChannelOpenFailureReason[this.reasonCode || 0]}: ${this.description})`;\r\n    }\r\n}\r\nexports.ChannelOpenFailureMessage = ChannelOpenFailureMessage;\r\nclass ChannelWindowAdjustMessage extends ConnectionMessage {\r\n    get messageType() {\r\n        return 93;\r\n    }\r\n    onRead(reader) {\r\n        this.recipientChannel = reader.readUInt32();\r\n        this.bytesToAdd = reader.readUInt32();\r\n    }\r\n    onWrite(writer) {\r\n        writer.writeUInt32(this.validateField(this.recipientChannel, 'recipient channel'));\r\n        writer.writeUInt32(this.validateField(this.bytesToAdd, 'bytes to add'));\r\n    }\r\n}\r\nexports.ChannelWindowAdjustMessage = ChannelWindowAdjustMessage;\r\nclass ChannelDataMessage extends ConnectionMessage {\r\n    get messageType() {\r\n        return 94;\r\n    }\r\n    onRead(reader) {\r\n        this.recipientChannel = reader.readUInt32();\r\n        this.data = reader.readBinary();\r\n    }\r\n    onWrite(writer) {\r\n        writer.writeUInt32(this.validateField(this.recipientChannel, 'recipient channel'));\r\n        writer.writeBinary(this.validateField(this.data, 'data'));\r\n    }\r\n    toString() {\r\n        return this.data ? (0, sshData_1.formatBuffer)(this.data, '') : `[0]`;\r\n    }\r\n}\r\nexports.ChannelDataMessage = ChannelDataMessage;\r\nclass ChannelEofMessage extends ConnectionMessage {\r\n    get messageType() {\r\n        return 96;\r\n    }\r\n    onRead(reader) {\r\n        this.recipientChannel = reader.readUInt32();\r\n    }\r\n    onWrite(writer) {\r\n        writer.writeUInt32(this.validateField(this.recipientChannel, 'recipient channel'));\r\n    }\r\n}\r\nexports.ChannelEofMessage = ChannelEofMessage;\r\nclass ChannelCloseMessage extends ConnectionMessage {\r\n    get messageType() {\r\n        return 97;\r\n    }\r\n    onRead(reader) {\r\n        this.recipientChannel = reader.readUInt32();\r\n    }\r\n    onWrite(writer) {\r\n        writer.writeUInt32(this.validateField(this.recipientChannel, 'recipient channel'));\r\n    }\r\n}\r\nexports.ChannelCloseMessage = ChannelCloseMessage;\r\nvar ChannelRequestType;\r\n(function (ChannelRequestType) {\r\n    ChannelRequestType[\"command\"] = \"exec\";\r\n    ChannelRequestType[\"shell\"] = \"shell\";\r\n    ChannelRequestType[\"terminal\"] = \"pty-req\";\r\n    ChannelRequestType[\"signal\"] = \"signal\";\r\n    ChannelRequestType[\"exitSignal\"] = \"exit-signal\";\r\n    ChannelRequestType[\"exitStatus\"] = \"exit-status\";\r\n})(ChannelRequestType = exports.ChannelRequestType || (exports.ChannelRequestType = {}));\r\nclass ChannelRequestMessage extends ConnectionMessage {\r\n    constructor(requestType, wantReply) {\r\n        super();\r\n        this.requestType = requestType;\r\n        this.wantReply = wantReply !== null && wantReply !== void 0 ? wantReply : false;\r\n    }\r\n    get messageType() {\r\n        return 98;\r\n    }\r\n    onRead(reader) {\r\n        this.recipientChannel = reader.readUInt32();\r\n        this.requestType = reader.readString('ascii');\r\n        this.wantReply = reader.readBoolean();\r\n    }\r\n    onWrite(writer) {\r\n        writer.writeUInt32(this.recipientChannel || 0);\r\n        writer.writeString(this.validateField(this.requestType, 'request type'), 'ascii');\r\n        writer.writeBoolean(this.wantReply);\r\n    }\r\n}\r\nexports.ChannelRequestMessage = ChannelRequestMessage;\r\nclass CommandRequestMessage extends ChannelRequestMessage {\r\n    constructor() {\r\n        super();\r\n        this.requestType = ChannelRequestType.command;\r\n    }\r\n    onRead(reader) {\r\n        super.onRead(reader);\r\n        this.command = reader.readString('utf8');\r\n    }\r\n    onWrite(writer) {\r\n        super.onWrite(writer);\r\n        writer.writeString(this.validateField(this.command, 'command'), 'utf8');\r\n    }\r\n    toString() {\r\n        return `${super.toString()} (requestType=${this.requestType})`;\r\n    }\r\n}\r\nexports.CommandRequestMessage = CommandRequestMessage;\r\nclass ChannelSignalMessage extends ChannelRequestMessage {\r\n    constructor() {\r\n        super();\r\n    }\r\n    get signal() {\r\n        return this.signalValue;\r\n    }\r\n    set signal(value) {\r\n        this.requestType = ChannelRequestType.signal;\r\n        this.signalValue = value;\r\n    }\r\n    get exitSignal() {\r\n        return this.signalValue;\r\n    }\r\n    set exitSignal(value) {\r\n        this.requestType = ChannelRequestType.exitSignal;\r\n        this.signalValue = value;\r\n    }\r\n    get errorMessage() {\r\n        return this.errorMessageValue;\r\n    }\r\n    set errorMessage(value) {\r\n        if (this.requestType !== ChannelRequestType.exitSignal) {\r\n            throw new Error(`Error message property is only valid for ${ChannelRequestType.exitSignal} messages.`);\r\n        }\r\n        this.errorMessageValue = value;\r\n    }\r\n    get exitStatus() {\r\n        return this.statusValue;\r\n    }\r\n    set exitStatus(value) {\r\n        this.requestType = ChannelRequestType.exitStatus;\r\n        this.statusValue = value;\r\n    }\r\n    onRead(reader) {\r\n        super.onRead(reader);\r\n        switch (this.requestType) {\r\n            case ChannelRequestType.exitStatus:\r\n                this.exitStatus = reader.readUInt32();\r\n                break;\r\n            case ChannelRequestType.signal:\r\n                this.signal = reader.readString('ascii');\r\n                break;\r\n            case ChannelRequestType.exitSignal:\r\n                this.exitSignal = reader.readString('ascii');\r\n                reader.readBoolean(); // Core dumped\r\n                this.errorMessage = reader.readString('utf8');\r\n                reader.readString('ascii'); // Language tag\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n    onWrite(writer) {\r\n        if (!this.requestType) {\r\n            throw new Error('Signal message request type not set.');\r\n        }\r\n        this.wantReply = false;\r\n        super.onWrite(writer);\r\n        switch (this.requestType) {\r\n            case ChannelRequestType.exitStatus:\r\n                writer.writeUInt32(this.validateField(this.exitStatus, 'exit status'));\r\n                break;\r\n            case ChannelRequestType.signal:\r\n                writer.writeString(this.validateField(this.signal, 'signal'), 'ascii');\r\n                break;\r\n            case ChannelRequestType.exitSignal:\r\n                writer.writeString(this.validateField(this.exitSignal, 'exit signal'), 'ascii');\r\n                writer.writeBoolean(false); // Core dumped\r\n                writer.writeString(this.errorMessage || '', 'utf8');\r\n                writer.writeString('', 'ascii'); // Language tag\r\n                break;\r\n            default:\r\n                throw new Error(`Unknown signal message request type: ${this.requestType}`);\r\n        }\r\n    }\r\n}\r\nexports.ChannelSignalMessage = ChannelSignalMessage;\r\nclass ChannelSuccessMessage extends ConnectionMessage {\r\n    get messageType() {\r\n        return 99;\r\n    }\r\n    onRead(reader) {\r\n        this.recipientChannel = reader.readUInt32();\r\n    }\r\n    onWrite(writer) {\r\n        writer.writeUInt32(this.validateField(this.recipientChannel, 'recipient channel'));\r\n    }\r\n}\r\nexports.ChannelSuccessMessage = ChannelSuccessMessage;\r\nclass ChannelFailureMessage extends ConnectionMessage {\r\n    get messageType() {\r\n        return 100;\r\n    }\r\n    onRead(reader) {\r\n        this.recipientChannel = reader.readUInt32();\r\n    }\r\n    onWrite(writer) {\r\n        writer.writeUInt32(this.validateField(this.recipientChannel, 'recipient channel'));\r\n    }\r\n}\r\nexports.ChannelFailureMessage = ChannelFailureMessage;\r\nsshMessage_1.SshMessage.index.set(90, ChannelOpenMessage);\r\nsshMessage_1.SshMessage.index.set(91, ChannelOpenConfirmationMessage);\r\nsshMessage_1.SshMessage.index.set(92, ChannelOpenFailureMessage);\r\nsshMessage_1.SshMessage.index.set(93, ChannelWindowAdjustMessage);\r\nsshMessage_1.SshMessage.index.set(94, ChannelDataMessage);\r\nsshMessage_1.SshMessage.index.set(96, ChannelEofMessage);\r\nsshMessage_1.SshMessage.index.set(97, ChannelCloseMessage);\r\nsshMessage_1.SshMessage.index.set(98, ChannelRequestMessage);\r\nsshMessage_1.SshMessage.index.set(99, ChannelSuccessMessage);\r\nsshMessage_1.SshMessage.index.set(100, ChannelFailureMessage);\r\n//# sourceMappingURL=connectionMessages.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.NewKeysMessage = exports.KeyExchangeDhReplyMessage = exports.KeyExchangeDhInitMessage = exports.KeyExchangeInitMessage = exports.KeyExchangeMessage = void 0;\r\nconst buffer_1 = require(\"buffer\");\r\nconst sshMessage_1 = require(\"./sshMessage\");\r\nconst sshAlgorithms_1 = require(\"../algorithms/sshAlgorithms\");\r\nclass KeyExchangeMessage extends sshMessage_1.SshMessage {\r\n}\r\nexports.KeyExchangeMessage = KeyExchangeMessage;\r\nclass KeyExchangeInitMessage extends KeyExchangeMessage {\r\n    get messageType() {\r\n        return 20;\r\n    }\r\n    onRead(reader) {\r\n        this.cookie = reader.read(16);\r\n        this.keyExchangeAlgorithms = reader.readList('ascii');\r\n        this.serverHostKeyAlgorithms = reader.readList('ascii');\r\n        this.encryptionAlgorithmsClientToServer = reader.readList('ascii');\r\n        this.encryptionAlgorithmsServerToClient = reader.readList('ascii');\r\n        this.macAlgorithmsClientToServer = reader.readList('ascii');\r\n        this.macAlgorithmsServerToClient = reader.readList('ascii');\r\n        this.compressionAlgorithmsClientToServer = reader.readList('ascii');\r\n        this.compressionAlgorithmsServerToClient = reader.readList('ascii');\r\n        this.languagesClientToServer = reader.readList('ascii');\r\n        this.languagesServerToClient = reader.readList('ascii');\r\n        this.firstKexPacketFollows = reader.readBoolean();\r\n        this.reserved = reader.readUInt32();\r\n    }\r\n    onWrite(writer) {\r\n        if (!this.cookie) {\r\n            this.cookie = buffer_1.Buffer.alloc(16);\r\n            sshAlgorithms_1.SshAlgorithms.random.getBytes(this.cookie);\r\n        }\r\n        writer.write(this.cookie);\r\n        writer.writeList(this.keyExchangeAlgorithms || [], 'ascii');\r\n        writer.writeList(this.serverHostKeyAlgorithms || [], 'ascii');\r\n        writer.writeList(this.encryptionAlgorithmsClientToServer || [], 'ascii');\r\n        writer.writeList(this.encryptionAlgorithmsServerToClient || [], 'ascii');\r\n        writer.writeList(this.macAlgorithmsClientToServer || [], 'ascii');\r\n        writer.writeList(this.macAlgorithmsServerToClient || [], 'ascii');\r\n        writer.writeList(this.compressionAlgorithmsClientToServer || [], 'ascii');\r\n        writer.writeList(this.compressionAlgorithmsServerToClient || [], 'ascii');\r\n        writer.writeList(this.languagesClientToServer || [], 'ascii');\r\n        writer.writeList(this.languagesServerToClient || [], 'ascii');\r\n        writer.writeBoolean(this.validateField(this.firstKexPacketFollows, 'first KEX package follows'));\r\n        writer.writeUInt32(this.reserved || 0);\r\n    }\r\n}\r\nexports.KeyExchangeInitMessage = KeyExchangeInitMessage;\r\nclass KeyExchangeDhInitMessage extends KeyExchangeMessage {\r\n    get messageType() {\r\n        return 30;\r\n    }\r\n    onRead(reader) {\r\n        this.e = reader.readBinary();\r\n    }\r\n    onWrite(writer) {\r\n        writer.writeBinary(this.validateField(this.e, 'E'));\r\n    }\r\n}\r\nexports.KeyExchangeDhInitMessage = KeyExchangeDhInitMessage;\r\nclass KeyExchangeDhReplyMessage extends KeyExchangeMessage {\r\n    get messageType() {\r\n        return 31;\r\n    }\r\n    onRead(reader) {\r\n        this.hostKey = reader.readBinary();\r\n        this.f = reader.readBinary();\r\n        this.signature = reader.readBinary();\r\n    }\r\n    onWrite(writer) {\r\n        writer.writeBinary(this.validateField(this.hostKey, 'host key'));\r\n        writer.writeBinary(this.validateField(this.f, 'F'));\r\n        writer.writeBinary(this.validateField(this.signature, 'signature'));\r\n    }\r\n}\r\nexports.KeyExchangeDhReplyMessage = KeyExchangeDhReplyMessage;\r\nclass NewKeysMessage extends KeyExchangeMessage {\r\n    get messageType() {\r\n        return 21;\r\n    }\r\n    onRead(reader) { }\r\n    onWrite(writer) { }\r\n}\r\nexports.NewKeysMessage = NewKeysMessage;\r\nsshMessage_1.SshMessage.index.set(20, KeyExchangeInitMessage);\r\nsshMessage_1.SshMessage.index.set(30, KeyExchangeDhInitMessage);\r\nsshMessage_1.SshMessage.index.set(31, KeyExchangeDhReplyMessage);\r\nsshMessage_1.SshMessage.index.set(21, NewKeysMessage);\r\n//# sourceMappingURL=kexMessages.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SshMessage = void 0;\r\nconst buffer_1 = require(\"buffer\");\r\nconst sshData_1 = require(\"../io/sshData\");\r\nclass SshMessage {\r\n    get messageType() {\r\n        return 0;\r\n    }\r\n    toBuffer() {\r\n        const writer = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(16));\r\n        this.write(writer);\r\n        return writer.toBuffer();\r\n    }\r\n    read(reader) {\r\n        this.rawBytes = reader.buffer;\r\n        const number = reader.readByte();\r\n        if (number !== this.messageType) {\r\n            throw new Error(`Message type ${number} is not valid.`);\r\n        }\r\n        this.onRead(reader);\r\n    }\r\n    write(writer) {\r\n        writer.writeByte(this.messageType);\r\n        this.onWrite(writer);\r\n    }\r\n    onRead(reader) {\r\n        throw new Error('Not supported.');\r\n    }\r\n    onWrite(writer) {\r\n        throw new Error('Not supported.');\r\n    }\r\n    validateField(value, name) {\r\n        if (typeof value === 'undefined') {\r\n            throw new Error(`${this.constructor.name} ${name} is required.`);\r\n        }\r\n        return value;\r\n    }\r\n    toString() {\r\n        return this.constructor.name;\r\n    }\r\n    static create(messageType, data) {\r\n        const messageClass = SshMessage.index.get(messageType);\r\n        if (messageClass) {\r\n            const message = new messageClass();\r\n            message.read(new sshData_1.SshDataReader(data));\r\n            return message;\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    convertTo(otherMessage, copy = false) {\r\n        const reader = new sshData_1.SshDataReader(copy ? buffer_1.Buffer.from(this.rawBytes) : this.rawBytes);\r\n        otherMessage.read(reader);\r\n        return otherMessage;\r\n    }\r\n}\r\nexports.SshMessage = SshMessage;\r\nSshMessage.index = new Map();\r\n//# sourceMappingURL=sshMessage.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SessionReconnectFailureMessage = exports.SshReconnectFailureReason = exports.SessionReconnectResponseMessage = exports.SessionReconnectRequestMessage = exports.SessionChannelRequestMessage = exports.ExtensionInfoMessage = exports.SessionRequestFailureMessage = exports.SessionRequestSuccessMessage = exports.SessionRequestMessage = exports.ServiceAcceptMessage = exports.ServiceRequestMessage = exports.DebugMessage = exports.UnimplementedMessage = exports.IgnoreMessage = exports.DisconnectMessage = exports.SshDisconnectReason = void 0;\r\nconst sshMessage_1 = require(\"./sshMessage\");\r\nconst connectionMessages_1 = require(\"./connectionMessages\");\r\nvar SshDisconnectReason;\r\n(function (SshDisconnectReason) {\r\n    SshDisconnectReason[SshDisconnectReason[\"none\"] = 0] = \"none\";\r\n    SshDisconnectReason[SshDisconnectReason[\"hostNotAllowedToConnect\"] = 1] = \"hostNotAllowedToConnect\";\r\n    SshDisconnectReason[SshDisconnectReason[\"protocolError\"] = 2] = \"protocolError\";\r\n    SshDisconnectReason[SshDisconnectReason[\"keyExchangeFailed\"] = 3] = \"keyExchangeFailed\";\r\n    SshDisconnectReason[SshDisconnectReason[\"reserved\"] = 4] = \"reserved\";\r\n    SshDisconnectReason[SshDisconnectReason[\"macError\"] = 5] = \"macError\";\r\n    SshDisconnectReason[SshDisconnectReason[\"compressionError\"] = 6] = \"compressionError\";\r\n    SshDisconnectReason[SshDisconnectReason[\"serviceNotAvailable\"] = 7] = \"serviceNotAvailable\";\r\n    SshDisconnectReason[SshDisconnectReason[\"protocolVersionNotSupported\"] = 8] = \"protocolVersionNotSupported\";\r\n    SshDisconnectReason[SshDisconnectReason[\"hostKeyNotVerifiable\"] = 9] = \"hostKeyNotVerifiable\";\r\n    SshDisconnectReason[SshDisconnectReason[\"connectionLost\"] = 10] = \"connectionLost\";\r\n    SshDisconnectReason[SshDisconnectReason[\"byApplication\"] = 11] = \"byApplication\";\r\n    SshDisconnectReason[SshDisconnectReason[\"tooManyConnections\"] = 12] = \"tooManyConnections\";\r\n    SshDisconnectReason[SshDisconnectReason[\"authCancelledByUser\"] = 13] = \"authCancelledByUser\";\r\n    SshDisconnectReason[SshDisconnectReason[\"noMoreAuthMethodsAvailable\"] = 14] = \"noMoreAuthMethodsAvailable\";\r\n    SshDisconnectReason[SshDisconnectReason[\"illegalUserName\"] = 15] = \"illegalUserName\";\r\n})(SshDisconnectReason = exports.SshDisconnectReason || (exports.SshDisconnectReason = {}));\r\nclass DisconnectMessage extends sshMessage_1.SshMessage {\r\n    get messageType() {\r\n        return 1;\r\n    }\r\n    onRead(reader) {\r\n        this.reasonCode = reader.readUInt32();\r\n        this.description = reader.readString('utf8');\r\n        if (reader.available >= 4) {\r\n            this.language = reader.readString('ascii');\r\n        }\r\n        else {\r\n            this.language = null;\r\n        }\r\n    }\r\n    onWrite(writer) {\r\n        writer.writeUInt32(this.validateField(this.reasonCode, 'reason code'));\r\n        writer.writeString(this.description || '', 'utf8');\r\n        if (this.language) {\r\n            writer.writeString(this.language, 'ascii');\r\n        }\r\n    }\r\n}\r\nexports.DisconnectMessage = DisconnectMessage;\r\nclass IgnoreMessage extends sshMessage_1.SshMessage {\r\n    get messageType() {\r\n        return 2;\r\n    }\r\n    onRead(reader) { }\r\n    onWrite(writer) { }\r\n}\r\nexports.IgnoreMessage = IgnoreMessage;\r\nclass UnimplementedMessage extends sshMessage_1.SshMessage {\r\n    get messageType() {\r\n        return 3;\r\n    }\r\n    onRead(reader) {\r\n        this.sequenceNumber = reader.readUInt32();\r\n    }\r\n    onWrite(writer) {\r\n        writer.writeUInt32(this.validateField(this.sequenceNumber, 'sequence number'));\r\n    }\r\n    toString() {\r\n        return !!this.unimplementedMessageType\r\n            ? `${super.toString()} (messageType=${this.unimplementedMessageType})`\r\n            : `${super.toString()} (sequenceNumber=${this.sequenceNumber})`;\r\n    }\r\n}\r\nexports.UnimplementedMessage = UnimplementedMessage;\r\nclass DebugMessage extends sshMessage_1.SshMessage {\r\n    constructor(message) {\r\n        super();\r\n        this.alwaysDisplay = false;\r\n        this.message = message;\r\n    }\r\n    get messageType() {\r\n        return 4;\r\n    }\r\n    onRead(reader) {\r\n        this.alwaysDisplay = reader.readBoolean();\r\n        this.message = reader.readString('utf8');\r\n        this.language = reader.readString('ascii');\r\n    }\r\n    onWrite(writer) {\r\n        var _a, _b;\r\n        writer.writeBoolean(this.alwaysDisplay);\r\n        writer.writeString((_a = this.message) !== null && _a !== void 0 ? _a : '', 'utf8');\r\n        writer.writeString((_b = this.language) !== null && _b !== void 0 ? _b : '', 'ascii');\r\n    }\r\n    toString() {\r\n        return `${super.toString()}: ${this.message}`;\r\n    }\r\n}\r\nexports.DebugMessage = DebugMessage;\r\nclass ServiceRequestMessage extends sshMessage_1.SshMessage {\r\n    get messageType() {\r\n        return 5;\r\n    }\r\n    onRead(reader) {\r\n        this.serviceName = reader.readString('ascii');\r\n    }\r\n    onWrite(writer) {\r\n        writer.writeString(this.validateField(this.serviceName, 'service name'), 'ascii');\r\n    }\r\n}\r\nexports.ServiceRequestMessage = ServiceRequestMessage;\r\nclass ServiceAcceptMessage extends sshMessage_1.SshMessage {\r\n    get messageType() {\r\n        return 6;\r\n    }\r\n    onRead(reader) {\r\n        this.serviceName = reader.readString('ascii');\r\n    }\r\n    onWrite(writer) {\r\n        writer.writeString(this.validateField(this.serviceName, 'service name'), 'ascii');\r\n    }\r\n}\r\nexports.ServiceAcceptMessage = ServiceAcceptMessage;\r\nclass SessionRequestMessage extends sshMessage_1.SshMessage {\r\n    constructor(requestType, wantReply) {\r\n        super();\r\n        this.requestType = requestType;\r\n        this.wantReply = wantReply !== null && wantReply !== void 0 ? wantReply : false;\r\n    }\r\n    get messageType() {\r\n        return 80;\r\n    }\r\n    onRead(reader) {\r\n        this.requestType = reader.readString('ascii');\r\n        this.wantReply = reader.readBoolean();\r\n    }\r\n    onWrite(writer) {\r\n        writer.writeString(this.validateField(this.requestType, 'request type'), 'ascii');\r\n        writer.writeBoolean(this.wantReply);\r\n    }\r\n    toString() {\r\n        return `${super.toString()} (requestType=${this.requestType})`;\r\n    }\r\n}\r\nexports.SessionRequestMessage = SessionRequestMessage;\r\nclass SessionRequestSuccessMessage extends sshMessage_1.SshMessage {\r\n    get messageType() {\r\n        return 81;\r\n    }\r\n    onRead(reader) { }\r\n    onWrite(writer) { }\r\n}\r\nexports.SessionRequestSuccessMessage = SessionRequestSuccessMessage;\r\nclass SessionRequestFailureMessage extends sshMessage_1.SshMessage {\r\n    get messageType() {\r\n        return 82;\r\n    }\r\n    onRead(reader) { }\r\n    onWrite(writer) { }\r\n}\r\nexports.SessionRequestFailureMessage = SessionRequestFailureMessage;\r\nclass ExtensionInfoMessage extends sshMessage_1.SshMessage {\r\n    constructor() {\r\n        // https://tools.ietf.org/html/draft-ietf-curdle-ssh-ext-info-15\r\n        super(...arguments);\r\n        this.extensionInfo = {};\r\n    }\r\n    get messageType() {\r\n        return 7;\r\n    }\r\n    onRead(reader) {\r\n        const count = reader.readUInt32();\r\n        this.extensionInfo = {};\r\n        for (let i = 0; i < count; i++) {\r\n            const key = reader.readString('ascii');\r\n            const value = reader.readString('utf8');\r\n            this.extensionInfo[key] = value;\r\n        }\r\n    }\r\n    onWrite(writer) {\r\n        const keys = Object.keys(this.extensionInfo);\r\n        writer.writeUInt32(keys.length);\r\n        for (let key of keys) {\r\n            writer.writeString(key, 'ascii');\r\n            writer.writeString(this.extensionInfo[key] || '', 'utf8');\r\n        }\r\n    }\r\n    toString() {\r\n        let extensionInfoDetails = '';\r\n        for (const [key, value] of Object.entries(this.extensionInfo)) {\r\n            if (extensionInfoDetails) {\r\n                extensionInfoDetails += '; ';\r\n            }\r\n            extensionInfoDetails += key;\r\n            if (value) {\r\n                extensionInfoDetails += '=' + value;\r\n            }\r\n        }\r\n        return `${super.toString()} (${extensionInfoDetails})`;\r\n    }\r\n}\r\nexports.ExtensionInfoMessage = ExtensionInfoMessage;\r\nExtensionInfoMessage.serverIndicator = 'ext-info-c';\r\nExtensionInfoMessage.clientIndicator = 'ext-info-c';\r\nclass SessionChannelRequestMessage extends SessionRequestMessage {\r\n    onRead(reader) {\r\n        super.onRead(reader);\r\n        this.senderChannel = reader.readUInt32();\r\n        const request = new connectionMessages_1.ChannelRequestMessage();\r\n        request.read(reader);\r\n        this.request = request;\r\n    }\r\n    onWrite(writer) {\r\n        super.onWrite(writer);\r\n        writer.writeUInt32(this.validateField(this.senderChannel, 'sender channel'));\r\n        this.validateField(this.request, 'request message').write(writer);\r\n    }\r\n}\r\nexports.SessionChannelRequestMessage = SessionChannelRequestMessage;\r\nclass SessionReconnectRequestMessage extends SessionRequestMessage {\r\n    onRead(reader) {\r\n        super.onRead(reader);\r\n        this.clientReconnectToken = reader.readBinary();\r\n        this.lastReceivedSequenceNumber = reader.readUInt64();\r\n    }\r\n    onWrite(writer) {\r\n        super.onWrite(writer);\r\n        writer.writeBinary(this.validateField(this.clientReconnectToken, 'clientReconnectToken'));\r\n        writer.writeUInt64(this.validateField(this.lastReceivedSequenceNumber, 'lastReceivedSequenceNumber'));\r\n    }\r\n}\r\nexports.SessionReconnectRequestMessage = SessionReconnectRequestMessage;\r\nclass SessionReconnectResponseMessage extends SessionRequestSuccessMessage {\r\n    onRead(reader) {\r\n        super.onRead(reader);\r\n        this.serverReconnectToken = reader.readBinary();\r\n        this.lastReceivedSequenceNumber = reader.readUInt64();\r\n    }\r\n    onWrite(writer) {\r\n        super.onWrite(writer);\r\n        writer.writeBinary(this.validateField(this.serverReconnectToken, 'serverReconnectToken'));\r\n        writer.writeUInt64(this.validateField(this.lastReceivedSequenceNumber, 'lastReceivedSequenceNumber'));\r\n    }\r\n}\r\nexports.SessionReconnectResponseMessage = SessionReconnectResponseMessage;\r\nvar SshReconnectFailureReason;\r\n(function (SshReconnectFailureReason) {\r\n    /** No reason was specified. */\r\n    SshReconnectFailureReason[SshReconnectFailureReason[\"none\"] = 0] = \"none\";\r\n    /**\r\n     * Reconnection failed due to an unknown server-side error.\r\n     */\r\n    SshReconnectFailureReason[SshReconnectFailureReason[\"unknownServerFailure\"] = 1] = \"unknownServerFailure\";\r\n    /**\r\n     * The session ID requested by the client for reconnection was not found among\r\n     * the server's reconnectable sessions.\r\n     */\r\n    SshReconnectFailureReason[SshReconnectFailureReason[\"sessionNotFound\"] = 2] = \"sessionNotFound\";\r\n    /**\r\n     * The reconnect token supplied by the client was invalid when checked by the server.\r\n     * The validation ensures that the client knows a secret key negotiated in the\r\n     * previously connected session.\r\n     */\r\n    SshReconnectFailureReason[SshReconnectFailureReason[\"invalidClientReconnectToken\"] = 3] = \"invalidClientReconnectToken\";\r\n    /**\r\n     * The server was unable to re-send dropped messages that were requested by the client.\r\n     */\r\n    SshReconnectFailureReason[SshReconnectFailureReason[\"serverDroppedMessages\"] = 4] = \"serverDroppedMessages\";\r\n    /**\r\n     * Reconnection failed due to an unknown client-side error.\r\n     */\r\n    SshReconnectFailureReason[SshReconnectFailureReason[\"unknownClientFailure\"] = 101] = \"unknownClientFailure\";\r\n    /**\r\n     * The host key supplied by the reconnected server did not match the host key from the\r\n     * original session; the client refused to reconnect to a different host.\r\n     */\r\n    SshReconnectFailureReason[SshReconnectFailureReason[\"differentServerHostKey\"] = 102] = \"differentServerHostKey\";\r\n    /**\r\n     * The reconnect token supplied by the server was invalid when checked by the client.\r\n     * The validation ensures that the server knows a secret key negotiated in the\r\n     * previously connected session.\r\n     */\r\n    SshReconnectFailureReason[SshReconnectFailureReason[\"invalidServerReconnectToken\"] = 103] = \"invalidServerReconnectToken\";\r\n    /**\r\n     * The client was unable to re-send dropped messages that were requested by the server.\r\n     */\r\n    SshReconnectFailureReason[SshReconnectFailureReason[\"clientDroppedMessages\"] = 104] = \"clientDroppedMessages\";\r\n})(SshReconnectFailureReason = exports.SshReconnectFailureReason || (exports.SshReconnectFailureReason = {}));\r\nclass SessionReconnectFailureMessage extends SessionRequestFailureMessage {\r\n    onRead(reader) {\r\n        if (reader.available > 0) {\r\n            this.reasonCode = reader.readUInt32();\r\n            this.description = reader.readString('utf8');\r\n            this.language = reader.readString('ascii');\r\n        }\r\n    }\r\n    onWrite(writer) {\r\n        writer.writeUInt32(this.validateField(this.reasonCode, 'reason code'));\r\n        writer.writeString(this.description || '', 'utf8');\r\n        writer.writeString(this.language || 'en', 'ascii');\r\n    }\r\n    toString() {\r\n        return `${super.toString} (${SshReconnectFailureReason[this.reasonCode || 0]}: ${this.description})`;\r\n    }\r\n}\r\nexports.SessionReconnectFailureMessage = SessionReconnectFailureMessage;\r\nsshMessage_1.SshMessage.index.set(1, DisconnectMessage);\r\nsshMessage_1.SshMessage.index.set(2, IgnoreMessage);\r\nsshMessage_1.SshMessage.index.set(3, UnimplementedMessage);\r\nsshMessage_1.SshMessage.index.set(5, ServiceRequestMessage);\r\nsshMessage_1.SshMessage.index.set(6, ServiceAcceptMessage);\r\nsshMessage_1.SshMessage.index.set(7, ExtensionInfoMessage);\r\nsshMessage_1.SshMessage.index.set(80, SessionRequestMessage);\r\nsshMessage_1.SshMessage.index.set(81, SessionRequestSuccessMessage);\r\nsshMessage_1.SshMessage.index.set(82, SessionRequestFailureMessage);\r\n//# sourceMappingURL=transportMessages.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ChannelMetrics = void 0;\r\n/**\r\n * Collects cumulative measurements about a channel.\r\n */\r\nclass ChannelMetrics {\r\n    /* @internal */\r\n    constructor() {\r\n        this.bytesSentSum = 0;\r\n        this.bytesReceivedSum = 0;\r\n    }\r\n    /**\r\n     * Gets the total cumulative number of bytes sent for the duration of the channel,\r\n     * not including message framing, padding, and MAC bytes.\r\n     */\r\n    get bytesSent() {\r\n        return this.bytesSentSum;\r\n    }\r\n    /**\r\n     * Gets the total cumulative number of bytes received for the duration of the channel,\r\n     * not including message framing, padding, and MAC bytes.\r\n     */\r\n    get bytesReceived() {\r\n        return this.bytesReceivedSum;\r\n    }\r\n    /* @internal */\r\n    addBytesSent(count) {\r\n        this.bytesSentSum += count;\r\n    }\r\n    /* @internal */\r\n    addBytesReceived(count) {\r\n        this.bytesReceivedSum += count;\r\n    }\r\n    toString() {\r\n        return `Bytes S/R: ${this.bytesSent} / ${this.bytesReceived}; `;\r\n    }\r\n}\r\nexports.ChannelMetrics = ChannelMetrics;\r\n//# sourceMappingURL=channelMetrics.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SessionContour = void 0;\r\nconst errors_1 = require(\"../errors\");\r\nconst queue_1 = require(\"../util/queue\");\r\nconst semaphore_1 = require(\"../util/semaphore\");\r\n/**\r\n * Collects session metrics over time, producing an outline of the timing, speed,\r\n * and quantity of bytes sent/received during the session.\r\n *\r\n * Metrics are recorded across a number of equal time intervals. As the session time\r\n * increases, intervals are expanded to keep the number of intervals under the configured\r\n * maximum. Each expansion doubles the length of all intervals, while combining the metrics\r\n * within each pair of combined intervals. Therefore, a longer session has longer intervals\r\n * and less-granular metrics. In this way, the memory usage (and serialized size) of the\r\n * session contour remains roughly constant regardless of the length of the session.\r\n *\r\n * Metrics exposed via the collection properties on this class may be momentarily\r\n * inconsistent (but will not throw exceptions) if continued session operation causes\r\n * intervals to be expanded while the data is being read concurrently. To avoid any\r\n * inconsistency, hold a lock on the <see cref=\"SessionContour\" /> instance while reading\r\n * data. (Or wait until the session ends.)\r\n *\r\n * A session contour can be exported in a compact form suitable for logging or telemetry.\r\n * Use the code in `SessionContour.kql` to chart a session contour in Azure Data Explorer.\r\n */\r\nclass SessionContour {\r\n    /**\r\n     * Creates a new instance of the `SessionContour` class.\r\n     *\r\n     * @param maxIntervals Maximum number of metric intervals to record,\r\n     * defaults to 256. Must be a power of two.\r\n     */\r\n    constructor(maxIntervals = 256) {\r\n        /** Current size of the metrics interval, in milliseconds. */\r\n        this.intervalMs = SessionContour.initialInterval;\r\n        /** Number of intervals for which metrics have been recorded. */\r\n        this.count = 0;\r\n        this.updateQueue = new queue_1.Queue();\r\n        this.updateSemaphore = new semaphore_1.Semaphore(0);\r\n        this.disposed = false;\r\n        if (maxIntervals < 2 || (maxIntervals & (maxIntervals - 1)) !== 0) {\r\n            throw new Error('Contour intervals must be a power of two.');\r\n        }\r\n        this.maxIntervals = maxIntervals;\r\n        this.intervalBytesSent = new Array(maxIntervals);\r\n        this.intervalBytesReceived = new Array(maxIntervals);\r\n        this.intervalLatencyMin = new Array(maxIntervals);\r\n        this.intervalLatencyMax = new Array(maxIntervals);\r\n        this.intervalLatencySum = new Array(maxIntervals);\r\n        this.intervalLatencyCount = new Array(maxIntervals);\r\n        this.intervalLatencyAvg = new Array(maxIntervals);\r\n        this.intervalBytesSent.fill(0);\r\n        this.intervalBytesReceived.fill(0);\r\n        this.intervalLatencyMin.fill(0);\r\n        this.intervalLatencyMax.fill(0);\r\n        this.intervalLatencySum.fill(0);\r\n        this.intervalLatencyCount.fill(0);\r\n        this.intervalLatencyAvg.fill(0);\r\n    }\r\n    /**\r\n     * Gets the current number of contour intervals with recorded metrics. This is always\r\n     * less than `maxIntervals`.\r\n     */\r\n    get intervalCount() {\r\n        return this.count;\r\n    }\r\n    /**\r\n     * Gets the current time span of each contour interval, in milliseconds. This interval time\r\n     * span is doubled as necesary such that the entire duration of the session is always covered\r\n     * by fewer intervals than the maximum.\r\n     */\r\n    get interval() {\r\n        return this.intervalMs;\r\n    }\r\n    /**\r\n     * Gets the total number of bytes sent for each interval during the session,\r\n     * including all channels and non-channel protocol messages, and including message\r\n     * framing, padding, and MAC bytes. The number of values is equal to `intervalCount`.\r\n     */\r\n    get bytesSent() {\r\n        return this.intervalBytesSent.slice(0, this.count);\r\n    }\r\n    /**\r\n     * Gets the total number of bytes received for each interval during the session,\r\n     * including all channels and non-channel protocol messages, and including message\r\n     * framing, padding, and MAC bytes. The number of values is equal to `intervalCount`.\r\n     */\r\n    get bytesReceived() {\r\n        return this.intervalBytesReceived.slice(0, this.count);\r\n    }\r\n    /**\r\n     * Gets the minimum recorded round-trip connection latency between client and server for\r\n     * each interval during the session. The number of values is equal to `intervalCount`.\r\n     */\r\n    get latencyMinMs() {\r\n        return this.intervalLatencyMin.slice(0, this.count);\r\n    }\r\n    /**\r\n     * Gets the maximum recorded round-trip connection latency between client and server for\r\n     * each interval during the session. The number of values is equal to `intervalCount`.\r\n     */\r\n    get latencyMaxMs() {\r\n        return this.intervalLatencyMax.slice(0, this.count);\r\n    }\r\n    /**\r\n     * Gets the average recorded round-trip connection latency between client and server for\r\n     * each interval during the session. The number of values is equal to `intervalCount`.\r\n     */\r\n    get latencyAverageMs() {\r\n        return this.intervalLatencyAvg.slice(0, this.count);\r\n    }\r\n    onMessageSent(e) {\r\n        this.updateQueue.enqueue({\r\n            time: e.time,\r\n            bytesSent: e.size,\r\n        });\r\n        this.updateSemaphore.tryRelease();\r\n    }\r\n    onMessageReceived(e) {\r\n        this.updateQueue.enqueue({\r\n            time: e.time,\r\n            bytesReceived: e.size,\r\n        });\r\n        this.updateSemaphore.tryRelease();\r\n    }\r\n    onLatencyUpdated(e) {\r\n        this.updateQueue.enqueue(e);\r\n        this.updateSemaphore.tryRelease();\r\n    }\r\n    onSessionClosed() {\r\n        this.updateSemaphore.tryRelease();\r\n    }\r\n    /**\r\n     * Starts collecting session metrics, and processes the metrics in a backgroud loop until\r\n     * cancelled or until the session is closed or the `SessionContour` instance is disposed.\r\n     */\r\n    async collectMetrics(sessionMetrics, cancellation) {\r\n        if (!sessionMetrics)\r\n            throw new TypeError('A session metrics object is required.');\r\n        if (this.disposed)\r\n            throw new errors_1.ObjectDisposedError(this);\r\n        const eventRegistrations = [];\r\n        eventRegistrations.push(sessionMetrics.onMessageSent(this.onMessageSent.bind(this)));\r\n        eventRegistrations.push(sessionMetrics.onMessageReceived(this.onMessageReceived.bind(this)));\r\n        eventRegistrations.push(sessionMetrics.onLatencyUpdated(this.onLatencyUpdated.bind(this)));\r\n        eventRegistrations.push(sessionMetrics.onSessionClosed(this.onSessionClosed.bind(this)));\r\n        try {\r\n            while (!(cancellation === null || cancellation === void 0 ? void 0 : cancellation.isCancellationRequested)) {\r\n                try {\r\n                    await this.updateSemaphore.wait(cancellation);\r\n                }\r\n                catch (e) {\r\n                    // The semaphore was disposed.\r\n                    break;\r\n                }\r\n                const update = this.updateQueue.dequeue();\r\n                if (!update) {\r\n                    // The semaphore was released without enqueueing an update item.\r\n                    break;\r\n                }\r\n                const intervalIndex = this.updateInterval(update.time);\r\n                if (update.bytesSent) {\r\n                    this.intervalBytesSent[intervalIndex] += update.bytesSent;\r\n                }\r\n                if (update.bytesReceived) {\r\n                    this.intervalBytesReceived[intervalIndex] += update.bytesReceived;\r\n                }\r\n                const latency = update.latency;\r\n                if (latency) {\r\n                    if (!this.intervalLatencyMin[intervalIndex] ||\r\n                        latency < this.intervalLatencyMin[intervalIndex]) {\r\n                        this.intervalLatencyMin[intervalIndex] = latency;\r\n                    }\r\n                    if (!this.intervalLatencyMax[intervalIndex] ||\r\n                        latency > this.intervalLatencyMax[intervalIndex]) {\r\n                        this.intervalLatencyMax[intervalIndex] = latency;\r\n                    }\r\n                    this.intervalLatencySum[intervalIndex] += latency;\r\n                    this.intervalLatencyCount[intervalIndex]++;\r\n                    this.intervalLatencyAvg[intervalIndex] =\r\n                        this.intervalLatencySum[intervalIndex] / this.intervalLatencyCount[intervalIndex];\r\n                }\r\n            }\r\n            if (this.disposed) {\r\n                this.updateSemaphore.dispose();\r\n            }\r\n        }\r\n        finally {\r\n            for (let eventRegistration of eventRegistrations) {\r\n                eventRegistration.dispose();\r\n            }\r\n        }\r\n    }\r\n    updateInterval(time) {\r\n        let intervalIndex = Math.floor(time / this.intervalMs);\r\n        if (intervalIndex >= this.intervalCount) {\r\n            // Expand as needed to accomodate the current time interval.\r\n            while (intervalIndex >= this.maxIntervals) {\r\n                this.expandIntervals();\r\n                intervalIndex = Math.floor(time / this.intervalMs);\r\n            }\r\n            this.count = intervalIndex + 1;\r\n        }\r\n        return intervalIndex;\r\n    }\r\n    expandIntervals() {\r\n        const combineLatency = (a, b, f) => a === 0 ? b : b === 0 ? a : f(a, b);\r\n        const halfMaxIntervals = this.maxIntervals / 2;\r\n        for (let i = 0; i < halfMaxIntervals; i++) {\r\n            const iA = 2 * i;\r\n            const iB = 2 * i + 1;\r\n            this.intervalBytesSent[i] = this.intervalBytesSent[iA] + this.intervalBytesSent[iB];\r\n            this.intervalBytesReceived[i] =\r\n                this.intervalBytesReceived[iA] + this.intervalBytesReceived[iB];\r\n            this.intervalLatencyMin[i] = combineLatency(this.intervalLatencyMin[iA], this.intervalLatencyMin[iB], Math.min);\r\n            this.intervalLatencyMax[i] = combineLatency(this.intervalLatencyMax[iA], this.intervalLatencyMax[iB], Math.max);\r\n            this.intervalLatencySum[i] = this.intervalLatencySum[iA] + this.intervalLatencySum[iB];\r\n            const countSum = this.intervalLatencyCount[iA] + this.intervalLatencyCount[iB];\r\n            this.intervalLatencyCount[i] = countSum;\r\n            this.intervalLatencyAvg[i] =\r\n                countSum === 0 ? 0 : this.intervalLatencySum[i] / this.intervalLatencyCount[i];\r\n        }\r\n        this.intervalBytesSent.fill(0, halfMaxIntervals, this.maxIntervals);\r\n        this.intervalBytesReceived.fill(0, halfMaxIntervals, this.maxIntervals);\r\n        this.intervalLatencyMin.fill(0, halfMaxIntervals, this.maxIntervals);\r\n        this.intervalLatencyMax.fill(0, halfMaxIntervals, this.maxIntervals);\r\n        this.intervalLatencySum.fill(0, halfMaxIntervals, this.maxIntervals);\r\n        this.intervalLatencyCount.fill(0, halfMaxIntervals, this.maxIntervals);\r\n        this.intervalLatencyAvg.fill(0, halfMaxIntervals, this.maxIntervals);\r\n        this.intervalMs *= 2;\r\n    }\r\n    dispose() {\r\n        this.disposed = true;\r\n        // The semaphore will be disposed after all remaining updates have been processed.\r\n        this.updateSemaphore.tryRelease();\r\n    }\r\n    /**\r\n     * Serializes the session contour into a compact form suitable for recording in\r\n     * logs or telemetry.\r\n     *\r\n     * This compact serialization format uses one byte per metric per interval, so there is\r\n     * some loss of precision, but generally not so much that it affects a visualization. A\r\n     * scale factor for each metric is automatically determined and included in the serialized\r\n     * header. The size of the serialized encoded data will be a little under 7 bytes per\r\n     * interval. With the default interval maximum (256), that comes out to less than 1.75 KB.\r\n     *\r\n     * Use the code in `SessionContour.kql` to decode and chart this output in\r\n     * Azure Data Explorer.\r\n     */\r\n    export() {\r\n        // Time and value scales are in log2 form, determined based on the maximum\r\n        // value in each series. This allows for a reasonable range of precision for each\r\n        // value (with byte values ranging from 0-255). For example a max latency in the\r\n        // 500ms range will get a scale factor of 1 (because ceil(log2(500/255)) = 1), so\r\n        // each serialized value (0-255) is half the actual value (0-510).\r\n        const getScale = (values) => Math.max(0, Math.ceil(Math.log2(Math.max(...values) / 255)));\r\n        const applyReverseScale = (value, scale) => Math.round(value / Math.pow(2, scale));\r\n        const bytes = Buffer.alloc(3 + (2 + this.intervalCount) * 5);\r\n        const version = 1;\r\n        const timeScale = Math.log2(this.interval / SessionContour.initialInterval);\r\n        bytes[0] = version;\r\n        bytes[1] = 5; // Number of metrics per interval\r\n        bytes[2] = timeScale;\r\n        bytes[3] = getScale(this.latencyMinMs);\r\n        bytes[4] = getScale(this.latencyMaxMs);\r\n        bytes[5] = getScale(this.latencyAverageMs);\r\n        bytes[6] = getScale(this.bytesSent);\r\n        bytes[7] = getScale(this.bytesReceived);\r\n        bytes[8] = SessionMetric.latencyMin;\r\n        bytes[9] = SessionMetric.latencyMax;\r\n        bytes[10] = SessionMetric.latencyAverage;\r\n        bytes[11] = SessionMetric.bytesSent;\r\n        bytes[12] = SessionMetric.bytesReceived;\r\n        for (let i = 0; i < this.intervalCount; i++) {\r\n            const offset = 13 + 5 * i;\r\n            bytes[offset + 0] = applyReverseScale(this.intervalLatencyMin[i], bytes[3]);\r\n            bytes[offset + 1] = applyReverseScale(this.intervalLatencyMax[i], bytes[4]);\r\n            bytes[offset + 2] = applyReverseScale(this.intervalLatencyAvg[i], bytes[5]);\r\n            bytes[offset + 3] = applyReverseScale(this.intervalBytesSent[i], bytes[6]);\r\n            bytes[offset + 4] = applyReverseScale(this.intervalBytesReceived[i], bytes[7]);\r\n        }\r\n        return bytes.toString('base64');\r\n    }\r\n    /**\r\n     * Deserializes a session contour that was previously exported.\r\n     *\r\n     * Due to loss in precision, some values in the deserialized contour will not exactly match\r\n     * the original, but they will be close.\r\n     */\r\n    static import(contourBase64) {\r\n        const bytes = Buffer.from(contourBase64, 'base64');\r\n        if (bytes.length < 3) {\r\n            throw new Error('Invalid session contour string.');\r\n        }\r\n        const version = bytes[0];\r\n        const metricsPerInterval = bytes[1];\r\n        const timeScale = bytes[2];\r\n        if (version !== 1) {\r\n            throw new Error(`Unsupported session contour version: ${version}`);\r\n        }\r\n        const intervalCount = (bytes.length - 3) / metricsPerInterval - 2;\r\n        if (intervalCount < 1 || bytes.length !== 3 + metricsPerInterval * (intervalCount + 2)) {\r\n            throw new Error(`Incomplete session contour string.`);\r\n        }\r\n        const maxIntervals = Math.pow(2, Math.ceil(Math.log2(intervalCount)));\r\n        const sessionContour = new SessionContour(maxIntervals);\r\n        sessionContour.intervalMs = Math.pow(2, timeScale) * SessionContour.initialInterval;\r\n        sessionContour.count = intervalCount;\r\n        const scales = new Array(metricsPerInterval);\r\n        for (let m = 0; m < metricsPerInterval; m++) {\r\n            scales[m] = Math.pow(2, bytes[3 + m]);\r\n        }\r\n        const ids = new Array(metricsPerInterval);\r\n        for (let m = 0; m < metricsPerInterval; m++) {\r\n            ids[m] = bytes[3 + metricsPerInterval + m];\r\n        }\r\n        for (let i = 0; i < intervalCount; i++) {\r\n            const offset = 3 + (2 + i) * metricsPerInterval;\r\n            for (let m = 0; m < metricsPerInterval; m++) {\r\n                switch (ids[m]) {\r\n                    case SessionMetric.latencyMin:\r\n                        sessionContour.intervalLatencyMin[i] = bytes[offset + m] * scales[m];\r\n                        break;\r\n                    case SessionMetric.latencyMax:\r\n                        sessionContour.intervalLatencyMax[i] = bytes[offset + m] * scales[m];\r\n                        break;\r\n                    case SessionMetric.latencyAverage:\r\n                        sessionContour.intervalLatencyAvg[i] = sessionContour.intervalLatencySum[i] =\r\n                            bytes[offset + m] * scales[m];\r\n                        sessionContour.intervalLatencyCount[i] = bytes[offset + m] === 0 ? 0 : 1;\r\n                        break;\r\n                    case SessionMetric.bytesSent:\r\n                        sessionContour.intervalBytesSent[i] = bytes[offset + m] * scales[m];\r\n                        break;\r\n                    case SessionMetric.bytesReceived:\r\n                        sessionContour.intervalBytesReceived[i] = bytes[offset + m] * scales[m];\r\n                        break;\r\n                    default:\r\n                        // Ignore any unknown metrics\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n        return sessionContour;\r\n    }\r\n}\r\nexports.SessionContour = SessionContour;\r\nSessionContour.initialInterval = 1000; // 1 second (in milliseconds)\r\nvar SessionMetric;\r\n(function (SessionMetric) {\r\n    SessionMetric[SessionMetric[\"none\"] = 0] = \"none\";\r\n    SessionMetric[SessionMetric[\"latencyMin\"] = 1] = \"latencyMin\";\r\n    SessionMetric[SessionMetric[\"latencyMax\"] = 2] = \"latencyMax\";\r\n    SessionMetric[SessionMetric[\"latencyAverage\"] = 3] = \"latencyAverage\";\r\n    SessionMetric[SessionMetric[\"bytesSent\"] = 11] = \"bytesSent\";\r\n    SessionMetric[SessionMetric[\"bytesReceived\"] = 12] = \"bytesReceived\";\r\n})(SessionMetric || (SessionMetric = {}));\r\n//# sourceMappingURL=sessionContour.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SessionMetrics = void 0;\r\nconst vscode_jsonrpc_1 = require(\"vscode-jsonrpc\");\r\n/**\r\n * Collects current and cumulative measurements about a session.\r\n */\r\nclass SessionMetrics {\r\n    /* @internal */\r\n    constructor() {\r\n        this.startTime = 0;\r\n        this.messagesSentCount = 0;\r\n        this.messagesReceivedCount = 0;\r\n        this.bytesSentSum = 0;\r\n        this.bytesReceivedSum = 0;\r\n        this.reconnectionsCount = 0;\r\n        this.currentLatency = 0;\r\n        this.minLatency = 0;\r\n        this.maxLatency = 0;\r\n        this.latencySum = 0;\r\n        this.latencyCount = 0;\r\n        this.messageSentEmitter = new vscode_jsonrpc_1.Emitter();\r\n        this.onMessageSent = this.messageSentEmitter.event;\r\n        this.messageReceivedEmitter = new vscode_jsonrpc_1.Emitter();\r\n        this.onMessageReceived = this.messageReceivedEmitter.event;\r\n        this.latencyUpdatedEmitter = new vscode_jsonrpc_1.Emitter();\r\n        this.onLatencyUpdated = this.latencyUpdatedEmitter.event;\r\n        this.sessionClosedEmitter = new vscode_jsonrpc_1.Emitter();\r\n        this.onSessionClosed = this.sessionClosedEmitter.event;\r\n        if (typeof performance === 'object' && performance.now) {\r\n            Object.defineProperty(this, 'time', { get: this.browserTime });\r\n        }\r\n        else if (typeof process === 'object' && process.hrtime) {\r\n            Object.defineProperty(this, 'time', { get: this.nodejsTime });\r\n        }\r\n        this.startTime = this.time;\r\n    }\r\n    /**\r\n     * Gets the current stopwatch value in milliseconds (possibly including fractional milliseconds),\r\n     * used for measuring latency.\r\n     */\r\n    /* @internal */\r\n    get time() {\r\n        // The SessionMetrics constructor may replace this with either of the below\r\n        // high-precision implementations, depending on availability of platform APIs.\r\n        return Date.now() - this.startTime;\r\n    }\r\n    browserTime() {\r\n        // Use the browser high-resolution time API.\r\n        // Note the precision may be reduced for pricacy depending on browser and page policy.\r\n        return performance.now() - this.startTime;\r\n    }\r\n    nodejsTime() {\r\n        // Use Node.js high-resolution time API.\r\n        const [s, ns] = process.hrtime();\r\n        return s * 1000 + ns / 1000000 - this.startTime;\r\n    }\r\n    /**\r\n     * Gets the total cumulative number of messages sent for the duration of the session,\r\n     * including all channels and non-channel protocol messages.\r\n     */\r\n    get messagesSent() {\r\n        return this.messagesSentCount;\r\n    }\r\n    /**\r\n     * Gets the total cumulative number of messages received for the duration of the session,\r\n     * including all channels and non-channel protocol messages.\r\n     */\r\n    get messagesReceived() {\r\n        return this.messagesReceivedCount;\r\n    }\r\n    /**\r\n     * Gets the total cumulative number of bytes sent for the duration of the session,\r\n     * including all channels and non-channel protocol messages, and including message\r\n     * framing, padding, and MAC bytes.\r\n     */\r\n    get bytesSent() {\r\n        return this.bytesSentSum;\r\n    }\r\n    /**\r\n     * Gets the total cumulative number of bytes received for the duration of the session,\r\n     * including all channels and non-channel protocol messages, and including message\r\n     * framing, padding, and MAC bytes.\r\n     */\r\n    get bytesReceived() {\r\n        return this.bytesReceivedSum;\r\n    }\r\n    /**\r\n     * Gets the number of times the session has reconnected.\r\n     * </summary>\r\n     * <remarks>\r\n     * Reconnection requires both sides to support the\r\n     * <see cref=\"SshProtocolExtensionNames.SessionReconnect\" /> protocol extension.\r\n     */\r\n    get reconnections() {\r\n        return this.reconnectionsCount;\r\n    }\r\n    /**\r\n     * Gets the average measured round-trip connection latency between client and server\r\n     * over the duration of the session, in milliseconds.\r\n     * </summary>\r\n     * <remarks>\r\n     * Latency measurement requires both sides to support the\r\n     * <see cref=\"SshProtocolExtensionNames.SessionLatency\" /> protocol extension.\r\n     * If not supported, this Sum will be 0.\r\n     */\r\n    get latencyAverageMs() {\r\n        return this.latencyCount === 0 ? 0 : this.latencySum / this.latencyCount;\r\n    }\r\n    /**\r\n     * Gets the minimum measured round-trip connection latency between client and server\r\n     * over the duration of the session, in milliseconds.\r\n     * </summary>\r\n     * <remarks>\r\n     * Latency measurement requires both sides to support the\r\n     * <see cref=\"SshProtocolExtensionNames.SessionLatency\" /> protocol extension.\r\n     * If not supported, this Sum will be 0.\r\n     */\r\n    get latencyMinMs() {\r\n        return this.minLatency;\r\n    }\r\n    /**\r\n     * Gets the maximum measured round-trip connection latency between client and server\r\n     * over the duration of the session, in milliseconds.\r\n     * </summary>\r\n     * <remarks>\r\n     * Latency measurement requires both sides to support the\r\n     * <see cref=\"SshProtocolExtensionNames.SessionLatency\" /> protocol extension.\r\n     * If not supported, this Sum will be 0.\r\n     */\r\n    get latencyMaxMs() {\r\n        return this.maxLatency;\r\n    }\r\n    /**\r\n     * Gets the most recent measurement of round-trip connection latency between client and\r\n     * server, in milliseconds.\r\n     * </summary>\r\n     * <remarks>\r\n     * Latency measurement requires both sides to support the\r\n     * <see cref=\"SshProtocolExtensionNames.SessionLatency\" /> protocol extension.\r\n     * If not supported or the session is not currently connected, this Sum will be 0.\r\n     */\r\n    get latencyCurrentMs() {\r\n        return this.currentLatency;\r\n    }\r\n    /* @internal */\r\n    addMessageSent(size) {\r\n        this.messagesSentCount++;\r\n        this.bytesSentSum += size;\r\n        this.messageSentEmitter.fire({ time: this.time, size });\r\n    }\r\n    /* @internal */\r\n    addMessageReceived(size) {\r\n        this.messagesReceivedCount++;\r\n        this.bytesReceivedSum += size;\r\n        this.messageReceivedEmitter.fire({ time: this.time, size });\r\n    }\r\n    /* @internal */\r\n    addReconnection() {\r\n        this.reconnectionsCount++;\r\n    }\r\n    /* @internal */\r\n    updateLatency(latencyMs) {\r\n        if (latencyMs < 0) {\r\n            throw new Error('Measured latency cannot be negative.');\r\n        }\r\n        this.currentLatency = latencyMs;\r\n        if (latencyMs === 0) {\r\n            // Disconnected.\r\n            return;\r\n        }\r\n        if (this.minLatency === 0 || latencyMs < this.minLatency) {\r\n            this.minLatency = latencyMs;\r\n        }\r\n        if (this.maxLatency === 0 || latencyMs > this.maxLatency) {\r\n            this.maxLatency = latencyMs;\r\n        }\r\n        // Enable computing the average.\r\n        this.latencySum += latencyMs;\r\n        this.latencyCount++;\r\n        this.latencyUpdatedEmitter.fire({ time: this.time, latency: latencyMs });\r\n    }\r\n    /* @internal */\r\n    close() {\r\n        this.currentLatency = 0;\r\n        this.sessionClosedEmitter.fire();\r\n    }\r\n    toString() {\r\n        let s = `Messages S/R: ${this.messagesSent} / ${this.messagesReceived}; ` +\r\n            `Bytes S/R: ${this.bytesSent} / ${this.bytesReceived}; ` +\r\n            `Reconnections: ${this.reconnections}; `;\r\n        // Show extra precision for a low-latency connection.\r\n        const precision = this.minLatency >= 10 ? 1 : this.minLatency >= 1 ? 10 : 100;\r\n        if (this.maxLatency > 0) {\r\n            const min = Math.round(this.minLatency * precision) / precision;\r\n            const avg = Math.round((this.latencySum / this.latencyCount) * precision) / precision;\r\n            const max = Math.round(this.maxLatency * precision) / precision;\r\n            s += `Latency Min-Avg-Max: ${min} - ${avg} - ${max} ms; `;\r\n        }\r\n        if (this.currentLatency > 0) {\r\n            const current = Math.round(this.currentLatency * precision) / precision;\r\n            s += `Current Latency: ${current} ms; `;\r\n        }\r\n        return s;\r\n    }\r\n}\r\nexports.SessionMetrics = SessionMetrics;\r\n//# sourceMappingURL=sessionMetrics.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.MultiChannelStream = void 0;\r\nconst vscode_jsonrpc_1 = require(\"vscode-jsonrpc\");\r\nconst trace_1 = require(\"./trace\");\r\nconst sshStream_1 = require(\"./sshStream\");\r\nconst sshSession_1 = require(\"./sshSession\");\r\nconst sshSessionConfiguration_1 = require(\"./sshSessionConfiguration\");\r\nconst transportMessages_1 = require(\"./messages/transportMessages\");\r\nconst connectionService_1 = require(\"./services/connectionService\");\r\n/**\r\n * This class allows to establish an ssh session with no security beign defined.\r\n * Both side could open multiple channel to send/receive data.\r\n */\r\nclass MultiChannelStream {\r\n    constructor(transportStream) {\r\n        this.transportStream = transportStream;\r\n        this.disposed = false;\r\n        this.disposables = [];\r\n        this.closedEmitter = new vscode_jsonrpc_1.Emitter();\r\n        this.onClosed = this.closedEmitter.event;\r\n        this.channelOpeningEmitter = new vscode_jsonrpc_1.Emitter();\r\n        if (!transportStream)\r\n            throw new TypeError('transportStream is required.');\r\n        const noSecurityConfig = new sshSessionConfiguration_1.SshSessionConfiguration(false);\r\n        this.session = new sshSession_1.SshSession(noSecurityConfig);\r\n        this.session.onClosed(this.onSessionClosed, this, this.disposables);\r\n        this.session.onChannelOpening(this.onSessionChannelOpening, this, this.disposables);\r\n    }\r\n    get isClosed() {\r\n        return this.disposed || this.session.isClosed;\r\n    }\r\n    get onChannelOpening() {\r\n        if (!this.isClosed) {\r\n            this.session.activateService(connectionService_1.ConnectionService);\r\n        }\r\n        return this.channelOpeningEmitter.event;\r\n    }\r\n    /**\r\n     * Connects ssh session.\r\n     * @param cancellation optional cancellation token.\r\n     */\r\n    async connect(cancellation) {\r\n        await this.session.connect(this.transportStream, cancellation);\r\n    }\r\n    /**\r\n     * Accept a new channel on the ssh session.\r\n     * @param channelType optional channel type\r\n     * @param cancellation optional cancellation token.\r\n     */\r\n    async acceptChannel(channelType, cancellation) {\r\n        await this.session.connect(this.transportStream, cancellation);\r\n        const channel = await this.session.acceptChannel(channelType, cancellation);\r\n        return channel;\r\n    }\r\n    /**\r\n     * Accept a remote ssh stream.\r\n     * @param channelType optional channel type\r\n     * @param cancellation optional cancellation token.\r\n     */\r\n    async acceptStream(channelType, cancellation) {\r\n        return new sshStream_1.SshStream(await this.acceptChannel(channelType, cancellation));\r\n    }\r\n    /**\r\n     * Open a channel to a remote ssh session\r\n     * @param channelType optional channel type\r\n     * @param cancellation optional cancellation token.\r\n     */\r\n    async openChannel(channelType, cancellation) {\r\n        await this.session.connect(this.transportStream, cancellation);\r\n        const channel = await this.session.openChannel(channelType !== null && channelType !== void 0 ? channelType : null, cancellation);\r\n        return channel;\r\n    }\r\n    /**\r\n     * open a stream to a remote ssh session\r\n     * @param channelType optional channel type\r\n     * @param cancellation optional cancellation token.\r\n     */\r\n    async openStream(channelType, cancellation) {\r\n        return new sshStream_1.SshStream(await this.openChannel(channelType, cancellation));\r\n    }\r\n    /**\r\n     * Connect ssh session and run it until closed.\r\n     * @param cancellation optional cancellation token.\r\n     */\r\n    async connectAndRunUntilClosed(cancellation) {\r\n        const disposables = [];\r\n        const sessionClosedPromise = new Promise((resolve, reject) => {\r\n            cancellation === null || cancellation === void 0 ? void 0 : cancellation.onCancellationRequested(reject, null, disposables);\r\n            this.session.onClosed(resolve, null, disposables);\r\n        });\r\n        try {\r\n            await this.connect(cancellation);\r\n            await sessionClosedPromise;\r\n        }\r\n        finally {\r\n            disposables.forEach((d) => d.dispose());\r\n            await this.close();\r\n        }\r\n    }\r\n    dispose() {\r\n        if (!this.disposed) {\r\n            this.disposed = true;\r\n            this.session.dispose();\r\n            this.unsubscribe();\r\n            try {\r\n                if (this.transportStream)\r\n                    this.transportStream.close().catch((e) => {\r\n                        (0, trace_1.trace)('Error closing transport stream: ' + e.message);\r\n                    });\r\n            }\r\n            catch (e) {\r\n                if (!(e instanceof Error))\r\n                    throw e;\r\n                (0, trace_1.trace)('Error closing transport stream: ' + e.message);\r\n            }\r\n        }\r\n    }\r\n    async close() {\r\n        if (!this.disposed) {\r\n            this.disposed = true;\r\n            await this.session.close(transportMessages_1.SshDisconnectReason.none, 'SshSession disposed');\r\n            this.session.dispose();\r\n            this.unsubscribe();\r\n            await this.transportStream.close();\r\n        }\r\n    }\r\n    onSessionClosed(e) {\r\n        this.unsubscribe();\r\n        this.closedEmitter.fire(e);\r\n    }\r\n    onSessionChannelOpening(e) {\r\n        this.channelOpeningEmitter.fire(e);\r\n    }\r\n    unsubscribe() {\r\n        this.disposables.forEach((d) => d.dispose());\r\n        this.disposables = [];\r\n    }\r\n}\r\nexports.MultiChannelStream = MultiChannelStream;\r\n//# sourceMappingURL=multiChannelStream.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar AuthenticationService_1;\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.AuthenticationService = void 0;\r\nconst trace_1 = require(\"../trace\");\r\nconst sshService_1 = require(\"./sshService\");\r\nconst authenticationMessages_1 = require(\"../messages/authenticationMessages\");\r\nconst vscode_jsonrpc_1 = require(\"vscode-jsonrpc\");\r\nconst sshData_1 = require(\"../io/sshData\");\r\nconst transportMessages_1 = require(\"../messages/transportMessages\");\r\nconst sshAuthenticatingEventArgs_1 = require(\"../events/sshAuthenticatingEventArgs\");\r\nconst connectionService_1 = require(\"./connectionService\");\r\nconst serviceActivation_1 = require(\"./serviceActivation\");\r\nconst queue_1 = require(\"../util/queue\");\r\n/**\r\n * Handles SSH protocol messages related to client authentication.\r\n */\r\nlet AuthenticationService = AuthenticationService_1 = class AuthenticationService extends sshService_1.SshService {\r\n    constructor(session) {\r\n        var _a;\r\n        super(session);\r\n        this.authenticationFailureCount = 0;\r\n        this.disposeCancellationSource = new vscode_jsonrpc_1.CancellationTokenSource();\r\n        const algorithmName = (_a = session.algorithms) === null || _a === void 0 ? void 0 : _a.publicKeyAlgorithmName;\r\n        if (!algorithmName) {\r\n            throw new Error('Algorithms not initialized.');\r\n        }\r\n        this.publicKeyAlgorithmName = algorithmName;\r\n    }\r\n    handleMessage(message, cancellation) {\r\n        if (message instanceof authenticationMessages_1.AuthenticationSuccessMessage) {\r\n            return this.handleSuccessMessage(message);\r\n        }\r\n        else if (message instanceof authenticationMessages_1.AuthenticationFailureMessage) {\r\n            return this.handleFailureMessage(message);\r\n        }\r\n        else if (message instanceof authenticationMessages_1.AuthenticationRequestMessage) {\r\n            return this.handleAuthenticationRequestMessage(message, cancellation);\r\n        }\r\n        else {\r\n            throw new Error(`Message not implemented: ${message}`);\r\n        }\r\n    }\r\n    async handleAuthenticationRequestMessage(message, cancellation) {\r\n        (0, trace_1.trace)(`Authentication request: ${message.methodName}`);\r\n        if (message.methodName === \"publickey\" /* publicKey */ ||\r\n            message.methodName === \"hostbased\" /* hostBased */) {\r\n            return this.handlePublicKeyRequestMessage(message.convertTo(new authenticationMessages_1.PublicKeyRequestMessage()), cancellation);\r\n        }\r\n        else if (message.methodName === \"password\" /* password */) {\r\n            return this.handlePasswordRequestMessage(message.convertTo(new authenticationMessages_1.PasswordRequestMessage()), cancellation);\r\n        }\r\n        else if (message.methodName === \"none\" /* none */) {\r\n            return this.handleAuthenticating(message, new sshAuthenticatingEventArgs_1.SshAuthenticatingEventArgs(sshAuthenticatingEventArgs_1.SshAuthenticationType.clientNone, { username: message.username }, cancellation));\r\n        }\r\n        else {\r\n            const failureMessage = new authenticationMessages_1.AuthenticationFailureMessage();\r\n            failureMessage.methodNames = [\r\n                \"publickey\" /* publicKey */,\r\n                \"password\" /* password */,\r\n                \"hostbased\" /* hostBased */,\r\n            ];\r\n            await this.session.sendMessage(failureMessage, cancellation);\r\n        }\r\n    }\r\n    async handlePublicKeyRequestMessage(message, cancellation) {\r\n        var _a, _b, _c;\r\n        const publicKeyAlg = this.session.config.getPublicKeyAlgorithm(message.keyAlgorithmName);\r\n        if (!publicKeyAlg) {\r\n            const failureMessage = new authenticationMessages_1.AuthenticationFailureMessage();\r\n            failureMessage.methodNames = [\r\n                \"publickey\" /* publicKey */,\r\n                \"password\" /* password */,\r\n            ];\r\n            await this.session.sendMessage(failureMessage, cancellation);\r\n            return;\r\n        }\r\n        const publicKey = publicKeyAlg.createKeyPair();\r\n        await publicKey.setPublicKeyBytes(message.publicKey);\r\n        let args;\r\n        if (message.methodName === \"hostbased\" /* hostBased */) {\r\n            args = new sshAuthenticatingEventArgs_1.SshAuthenticatingEventArgs(sshAuthenticatingEventArgs_1.SshAuthenticationType.clientHostBased, {\r\n                username: (_a = message.username) !== null && _a !== void 0 ? _a : '',\r\n                publicKey: publicKey,\r\n                clientHostname: message.clientHostname,\r\n                clientUsername: message.clientUsername,\r\n            });\r\n        }\r\n        else if (!message.hasSignature) {\r\n            args = new sshAuthenticatingEventArgs_1.SshAuthenticatingEventArgs(sshAuthenticatingEventArgs_1.SshAuthenticationType.clientPublicKeyQuery, {\r\n                username: (_b = message.username) !== null && _b !== void 0 ? _b : '',\r\n                publicKey: publicKey,\r\n            });\r\n        }\r\n        else {\r\n            // Verify that the signature matches the public key.\r\n            const signature = publicKeyAlg.readSignatureData(message.signature);\r\n            const sessionId = this.session.sessionId;\r\n            if (sessionId == null) {\r\n                throw new Error('Session ID not initialized.');\r\n            }\r\n            const writer = new sshData_1.SshDataWriter(Buffer.alloc(sessionId.length + message.payloadWithoutSignature.length + 20));\r\n            writer.writeBinary(sessionId);\r\n            writer.write(message.payloadWithoutSignature);\r\n            const signedData = writer.toBuffer();\r\n            const verifier = publicKeyAlg.createVerifier(publicKey);\r\n            const verified = await verifier.verify(signedData, signature);\r\n            if (!verified) {\r\n                await this.handleAuthenticationFailure('Public key authentication failed: invalid signature.', cancellation);\r\n            }\r\n            args = new sshAuthenticatingEventArgs_1.SshAuthenticatingEventArgs(sshAuthenticatingEventArgs_1.SshAuthenticationType.clientPublicKey, {\r\n                username: (_c = message.username) !== null && _c !== void 0 ? _c : '',\r\n                publicKey: publicKey,\r\n            });\r\n        }\r\n        // Raise an Authenticating event that allows handlers to do additional verification\r\n        // of the client's username and public key.\r\n        await this.handleAuthenticating(message, args, cancellation);\r\n    }\r\n    async handlePasswordRequestMessage(message, cancellation) {\r\n        var _a, _b;\r\n        // Raise an Authenticating event that allows handlers to do verification\r\n        // of the client's username and password.\r\n        const args = new sshAuthenticatingEventArgs_1.SshAuthenticatingEventArgs(sshAuthenticatingEventArgs_1.SshAuthenticationType.clientPassword, {\r\n            username: (_a = message.username) !== null && _a !== void 0 ? _a : '',\r\n            password: (_b = message.password) !== null && _b !== void 0 ? _b : '',\r\n        });\r\n        await this.handleAuthenticating(message, args, cancellation);\r\n    }\r\n    async handleAuthenticating(requestMessage, args, cancellation) {\r\n        var _a;\r\n        let authenticatedPrincipal = null;\r\n        try {\r\n            authenticatedPrincipal = await this.session.raiseAuthenticatingEvent(args);\r\n        }\r\n        catch (e) {\r\n            if (!(e instanceof Error))\r\n                throw e;\r\n            (0, trace_1.trace)('Error while authenticating client: ' + ((_a = e.message) !== null && _a !== void 0 ? _a : e));\r\n            authenticatedPrincipal = null;\r\n        }\r\n        if (authenticatedPrincipal) {\r\n            if (args.authenticationType === sshAuthenticatingEventArgs_1.SshAuthenticationType.clientPublicKeyQuery) {\r\n                const publicKeyRequest = requestMessage;\r\n                const okMessage = new authenticationMessages_1.PublicKeyOKMessage();\r\n                okMessage.keyAlgorithmName = publicKeyRequest.keyAlgorithmName;\r\n                okMessage.publicKey = publicKeyRequest.publicKey;\r\n                await this.session.sendMessage(okMessage, cancellation);\r\n            }\r\n            else {\r\n                this.session.principal = authenticatedPrincipal;\r\n                if (requestMessage.serviceName) {\r\n                    this.session.activateService(requestMessage.serviceName);\r\n                }\r\n                (0, trace_1.trace)(`${sshAuthenticatingEventArgs_1.SshAuthenticationType[args.authenticationType]} authentication succeeded.`);\r\n                await this.session.sendMessage(new authenticationMessages_1.AuthenticationSuccessMessage(), cancellation);\r\n            }\r\n        }\r\n        else {\r\n            await this.handleAuthenticationFailure(`${sshAuthenticatingEventArgs_1.SshAuthenticationType[args.authenticationType]} authentication failed.`);\r\n        }\r\n    }\r\n    async handleAuthenticationFailure(message, cancellation) {\r\n        this.authenticationFailureCount++;\r\n        (0, trace_1.trace)(message);\r\n        const failureMessage = new authenticationMessages_1.AuthenticationFailureMessage();\r\n        failureMessage.methodNames = [\r\n            \"publickey\" /* publicKey */,\r\n            \"password\" /* password */,\r\n            \"hostbased\" /* hostBased */,\r\n        ];\r\n        await this.session.sendMessage(failureMessage, cancellation);\r\n        // Allow trying again with another authentication method. But prevent unlimited tries.\r\n        if (this.authenticationFailureCount >= this.session.config.maxClientAuthenticationAttempts) {\r\n            await this.session.close(transportMessages_1.SshDisconnectReason.noMoreAuthMethodsAvailable, 'Authentication failed.');\r\n        }\r\n    }\r\n    async authenticateClient(credentials, cancellation) {\r\n        var _a, _b, _c, _d;\r\n        this.clientAuthenticationMethods = new queue_1.Queue();\r\n        for (let publicKey of (_a = credentials.publicKeys) !== null && _a !== void 0 ? _a : []) {\r\n            if (!publicKey)\r\n                continue;\r\n            const username = (_b = credentials.username) !== null && _b !== void 0 ? _b : '';\r\n            let privateKey = publicKey;\r\n            const privateKeyProvider = credentials.privateKeyProvider;\r\n            this.clientAuthenticationMethods.enqueue(async (cancellation2) => {\r\n                if (!privateKey.hasPrivateKey) {\r\n                    if (privateKeyProvider == null) {\r\n                        throw new Error('A private key provider is required.');\r\n                    }\r\n                    privateKey = await privateKeyProvider(publicKey, cancellation2 !== null && cancellation2 !== void 0 ? cancellation2 : vscode_jsonrpc_1.CancellationToken.None);\r\n                }\r\n                if (privateKey) {\r\n                    await this.requestPublicKeyAuthentication(username, privateKey, cancellation2);\r\n                }\r\n                else {\r\n                    await this.session.close(transportMessages_1.SshDisconnectReason.authCancelledByUser);\r\n                }\r\n            });\r\n        }\r\n        const passwordCredentialProvider = credentials.passwordProvider;\r\n        if (passwordCredentialProvider) {\r\n            this.clientAuthenticationMethods.enqueue(async (cancellation2) => {\r\n                var _a;\r\n                const passwordCredentialPromise = passwordCredentialProvider(cancellation2 !== null && cancellation2 !== void 0 ? cancellation2 : vscode_jsonrpc_1.CancellationToken.None);\r\n                const passwordCredential = passwordCredentialPromise\r\n                    ? await passwordCredentialPromise\r\n                    : null;\r\n                if (passwordCredential) {\r\n                    await this.requestPasswordAuthentication((_a = passwordCredential[0]) !== null && _a !== void 0 ? _a : '', passwordCredential[1], cancellation2);\r\n                }\r\n                else {\r\n                    await this.session.close(transportMessages_1.SshDisconnectReason.authCancelledByUser);\r\n                }\r\n            });\r\n        }\r\n        else if (credentials.password) {\r\n            const username = (_c = credentials.username) !== null && _c !== void 0 ? _c : '';\r\n            const password = credentials.password;\r\n            this.clientAuthenticationMethods.enqueue(async (cancellation2) => {\r\n                await this.requestPasswordAuthentication(username, password, cancellation2);\r\n            });\r\n        }\r\n        if (this.clientAuthenticationMethods.size === 0) {\r\n            const username = (_d = credentials.username) !== null && _d !== void 0 ? _d : '';\r\n            this.clientAuthenticationMethods.enqueue(async (cancellation2) => {\r\n                await this.requestUsernameAuthentication(username, cancellation2);\r\n            });\r\n        }\r\n        const firstAuthMethod = this.clientAuthenticationMethods.dequeue();\r\n        await firstAuthMethod(cancellation);\r\n    }\r\n    async requestUsernameAuthentication(username, cancellation) {\r\n        const authMessage = new authenticationMessages_1.AuthenticationRequestMessage();\r\n        authMessage.serviceName = connectionService_1.ConnectionService.serviceName;\r\n        authMessage.methodName = \"none\" /* none */;\r\n        authMessage.username = username;\r\n        await this.session.sendMessage(authMessage, cancellation);\r\n        // Assume the included service request succeeds, without waiting for an auth success\r\n        // message. If not, a following channel open request will fail anyway.\r\n        this.session.activateService(connectionService_1.ConnectionService);\r\n    }\r\n    async requestPublicKeyAuthentication(username, key, cancellation) {\r\n        const algorithm = this.session.config.publicKeyAlgorithms.find((a) => (a === null || a === void 0 ? void 0 : a.keyAlgorithmName) === key.keyAlgorithmName);\r\n        if (!algorithm) {\r\n            throw new Error(`Public key algorithm '${key.keyAlgorithmName}' is not in session config.`);\r\n        }\r\n        const authMessage = new authenticationMessages_1.PublicKeyRequestMessage();\r\n        authMessage.serviceName = connectionService_1.ConnectionService.serviceName;\r\n        authMessage.username = username;\r\n        authMessage.keyAlgorithmName = algorithm.name;\r\n        authMessage.publicKey = (await key.getPublicKeyBytes(algorithm.name));\r\n        authMessage.signature = await this.createAuthenticationSignature(authMessage, algorithm, key);\r\n        await this.session.sendMessage(authMessage, cancellation);\r\n        if (this.clientAuthenticationMethods.size === 0) {\r\n            // There are no remaining auth methods. Assume the service request\r\n            // included here succeeds, without waiting for an auth success message\r\n            // If not, a following channel open request will fail anyway.\r\n            this.session.activateService(connectionService_1.ConnectionService);\r\n        }\r\n    }\r\n    async requestPasswordAuthentication(username, password, cancellation) {\r\n        const authMessage = new authenticationMessages_1.PasswordRequestMessage();\r\n        authMessage.serviceName = connectionService_1.ConnectionService.serviceName;\r\n        authMessage.username = username;\r\n        authMessage.password = password;\r\n        await this.session.sendMessage(authMessage, cancellation);\r\n        // Assume the included service request succeeds, without waiting for an auth success\r\n        // message. If not, a following channel open request will fail anyway.\r\n        this.session.activateService(connectionService_1.ConnectionService);\r\n    }\r\n    handleFailureMessage(message) {\r\n        this.session.onAuthenticationComplete(false);\r\n    }\r\n    handleSuccessMessage(message) {\r\n        // The authentication request included the connection service name.\r\n        // So it should be registered when authentication succeeded.\r\n        this.session.activateService(connectionService_1.ConnectionService);\r\n        this.session.onAuthenticationComplete(true);\r\n    }\r\n    async createAuthenticationSignature(requestMessage, algorithm, key) {\r\n        const sessionId = this.session.sessionId;\r\n        if (sessionId == null) {\r\n            throw new Error('Session ID not initialized.');\r\n        }\r\n        const writer = new sshData_1.SshDataWriter(Buffer.alloc(requestMessage.publicKey.length + (requestMessage.username || '').length + 400));\r\n        writer.writeBinary(sessionId);\r\n        writer.writeByte(requestMessage.messageType);\r\n        writer.writeString(requestMessage.username || '', 'utf8');\r\n        writer.writeString(requestMessage.serviceName || '', 'ascii');\r\n        writer.writeString(\"publickey\" /* publicKey */, 'ascii');\r\n        writer.writeBoolean(true);\r\n        writer.writeString(requestMessage.keyAlgorithmName, 'ascii');\r\n        writer.writeBinary(requestMessage.publicKey);\r\n        const signer = algorithm.createSigner(key);\r\n        const signature = await signer.sign(writer.toBuffer());\r\n        return algorithm.createSignatureData(signature);\r\n    }\r\n};\r\nAuthenticationService.serviceName = 'ssh-userauth';\r\nAuthenticationService = AuthenticationService_1 = __decorate([\r\n    (0, serviceActivation_1.serviceActivation)({ serviceRequest: AuthenticationService_1.serviceName })\r\n], AuthenticationService);\r\nexports.AuthenticationService = AuthenticationService;\r\n//# sourceMappingURL=authenticationService.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar ConnectionService_1;\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ConnectionService = void 0;\r\nconst trace_1 = require(\"../trace\");\r\nconst sshService_1 = require(\"./sshService\");\r\nconst connectionMessages_1 = require(\"../messages/connectionMessages\");\r\nconst promiseCompletionSource_1 = require(\"../util/promiseCompletionSource\");\r\nconst sshChannel_1 = require(\"../sshChannel\");\r\nconst cancellation_1 = require(\"../util/cancellation\");\r\nconst errors_1 = require(\"../errors\");\r\nconst sshChannelOpeningEventArgs_1 = require(\"../events/sshChannelOpeningEventArgs\");\r\nconst serviceActivation_1 = require(\"./serviceActivation\");\r\nlet ConnectionService = ConnectionService_1 = class ConnectionService extends sshService_1.SshService {\r\n    constructor(session) {\r\n        super(session);\r\n        this.channelCounter = 0;\r\n        this.channelMap = new Map();\r\n        this.nonAcceptedChannels = new Map();\r\n        this.pendingChannels = new Map();\r\n        this.pendingAcceptChannels = new Map();\r\n    }\r\n    get channels() {\r\n        return Array.from(this.channelMap.values());\r\n    }\r\n    close(e) {\r\n        for (let channel of this.channelMap.values()) {\r\n            channel.close(e);\r\n        }\r\n    }\r\n    dispose() {\r\n        const channels = [...this.channelMap.values()];\r\n        let channelCompletions = [...this.pendingChannels.values()].map((pc) => pc.completionSource);\r\n        if (this.pendingAcceptChannels.size > 0) {\r\n            channelCompletions = channelCompletions.concat([...this.pendingAcceptChannels.values()].reduce((a, b) => a.concat(b)));\r\n        }\r\n        for (let channel of channels) {\r\n            channel.dispose();\r\n        }\r\n        for (let channelCompletion of channelCompletions) {\r\n            channelCompletion.reject(new errors_1.SshConnectionError('Session closed.'));\r\n        }\r\n        super.dispose();\r\n    }\r\n    async acceptChannel(channelType, cancellation) {\r\n        const completionSource = new promiseCompletionSource_1.PromiseCompletionSource();\r\n        let cancellationRegistration;\r\n        if (cancellation) {\r\n            if (cancellation.isCancellationRequested)\r\n                throw new cancellation_1.CancellationError();\r\n            cancellationRegistration = cancellation.onCancellationRequested(() => {\r\n                const list = this.pendingAcceptChannels.get(channelType);\r\n                if (list) {\r\n                    const index = list.findIndex((item) => Object.is(item, completionSource));\r\n                    if (index >= 0) {\r\n                        list.splice(index, 1);\r\n                    }\r\n                }\r\n                completionSource.reject(new cancellation_1.CancellationError());\r\n            });\r\n        }\r\n        let channel = null;\r\n        channel =\r\n            Array.from(this.nonAcceptedChannels.values()).find((c) => c.channelType === channelType) ||\r\n                null;\r\n        if (channel) {\r\n            // Found a channel that was already opened but not accepted.\r\n            this.nonAcceptedChannels.delete(channel.channelId);\r\n        }\r\n        else {\r\n            // Set up the completion source to wait for a channel of the requested type.\r\n            let list = this.pendingAcceptChannels.get(channelType);\r\n            if (!list) {\r\n                list = [];\r\n                this.pendingAcceptChannels.set(channelType, list);\r\n            }\r\n            list.push(completionSource);\r\n        }\r\n        try {\r\n            return channel || (await completionSource.promise);\r\n        }\r\n        finally {\r\n            if (cancellationRegistration)\r\n                cancellationRegistration.dispose();\r\n        }\r\n    }\r\n    async openChannel(openMessage, completionSource, cancellation) {\r\n        const channelId = ++this.channelCounter;\r\n        openMessage.senderChannel = channelId;\r\n        let cancellationRegistration = null;\r\n        if (cancellation) {\r\n            if (cancellation.isCancellationRequested)\r\n                throw new cancellation_1.CancellationError();\r\n            cancellationRegistration = cancellation.onCancellationRequested(() => {\r\n                if (this.pendingChannels.delete(channelId)) {\r\n                    completionSource.reject(new cancellation_1.CancellationError());\r\n                }\r\n            });\r\n        }\r\n        this.pendingChannels.set(channelId, {\r\n            openMessage: openMessage,\r\n            completionSource: completionSource,\r\n            cancellationRegistration: cancellationRegistration,\r\n        });\r\n        await this.session.sendMessage(openMessage);\r\n        return channelId;\r\n    }\r\n    handleMessage(message, cancellation) {\r\n        if (message instanceof connectionMessages_1.ChannelDataMessage) {\r\n            return this.handleDataMessage(message);\r\n        }\r\n        else if (message instanceof connectionMessages_1.ChannelWindowAdjustMessage) {\r\n            return this.handleAdjustWindowMessage(message);\r\n        }\r\n        else if (message instanceof connectionMessages_1.ChannelEofMessage) {\r\n            return this.handleEofMessage(message);\r\n        }\r\n        else if (message instanceof connectionMessages_1.ChannelOpenMessage) {\r\n            return this.handleOpenMessage(message, cancellation);\r\n        }\r\n        else if (message instanceof connectionMessages_1.ChannelCloseMessage) {\r\n            return this.handleCloseMessage(message);\r\n        }\r\n        else if (message instanceof connectionMessages_1.ChannelOpenConfirmationMessage) {\r\n            return this.handleOpenConfirmationMessage(message, cancellation);\r\n        }\r\n        else if (message instanceof connectionMessages_1.ChannelOpenFailureMessage) {\r\n            return this.handleOpenFailureMessage(message);\r\n        }\r\n        else if (message instanceof connectionMessages_1.ChannelRequestMessage) {\r\n            return this.handleRequestMessage(message, cancellation);\r\n        }\r\n        else if (message instanceof connectionMessages_1.ChannelSuccessMessage) {\r\n            return this.handleSuccessMessage(message);\r\n        }\r\n        else if (message instanceof connectionMessages_1.ChannelFailureMessage) {\r\n            return this.handleFailureMessage(message);\r\n        }\r\n        else {\r\n            throw new Error(`Message not implemented: ${message}`);\r\n        }\r\n    }\r\n    async handleOpenMessage(message, cancellation) {\r\n        if (!this.session.canAcceptRequests) {\r\n            (0, trace_1.trace)('Channel open request blocked because the session is not yet authenticated.');\r\n            const openFailureMessage = new connectionMessages_1.ChannelOpenFailureMessage();\r\n            openFailureMessage.recipientChannel = message.senderChannel;\r\n            openFailureMessage.reasonCode = connectionMessages_1.SshChannelOpenFailureReason.administrativelyProhibited;\r\n            openFailureMessage.description = 'Authenticate before opening channels.';\r\n            await this.session.sendMessage(openFailureMessage, cancellation);\r\n            return;\r\n        }\r\n        else if (!message.channelType) {\r\n            const openFailureMessage = new connectionMessages_1.ChannelOpenFailureMessage();\r\n            openFailureMessage.recipientChannel = message.senderChannel;\r\n            openFailureMessage.reasonCode = connectionMessages_1.SshChannelOpenFailureReason.unknownChannelType;\r\n            openFailureMessage.description = 'Channel type not specified.';\r\n            await this.session.sendMessage(openFailureMessage, cancellation);\r\n            return;\r\n        }\r\n        const channel = new sshChannel_1.SshChannel(this, message.channelType, message.senderChannel, message.initialWindowSize, message.maximumPacketSize, ++this.channelCounter);\r\n        const args = new sshChannelOpeningEventArgs_1.SshChannelOpeningEventArgs(message, channel, true);\r\n        try {\r\n            await this.session.handleChannelOpening(args, cancellation);\r\n        }\r\n        catch (e) {\r\n            channel.dispose();\r\n            throw e;\r\n        }\r\n        if (args.failureReason !== connectionMessages_1.SshChannelOpenFailureReason.none) {\r\n            const failureMessage = new connectionMessages_1.ChannelOpenFailureMessage();\r\n            failureMessage.recipientChannel = channel.remoteChannelId;\r\n            failureMessage.reasonCode = args.failureReason;\r\n            failureMessage.description = args.failureDescription || undefined;\r\n            try {\r\n                await this.session.sendMessage(failureMessage, cancellation);\r\n            }\r\n            finally {\r\n                channel.dispose();\r\n            }\r\n            return;\r\n        }\r\n        // The session might have been closed while opening the channel.\r\n        if (this.session.isClosed) {\r\n            channel.dispose();\r\n            return;\r\n        }\r\n        this.channelMap.set(channel.channelId, channel);\r\n        const confirmationMessage = new connectionMessages_1.ChannelOpenConfirmationMessage();\r\n        confirmationMessage.recipientChannel = channel.remoteChannelId;\r\n        confirmationMessage.senderChannel = channel.channelId;\r\n        confirmationMessage.initialWindowSize = message.initialWindowSize;\r\n        confirmationMessage.maximumPacketSize = message.maximumPacketSize;\r\n        await this.session.sendMessage(confirmationMessage, cancellation);\r\n        // Check if there are any accept operations waiting on this channel type.\r\n        let accepted = false;\r\n        const list = this.pendingAcceptChannels.get(channel.channelType);\r\n        while (list && list.length > 0) {\r\n            const acceptCompletionSource = list.shift();\r\n            acceptCompletionSource.resolve(channel);\r\n            accepted = true;\r\n            break;\r\n        }\r\n        if (!accepted) {\r\n            this.nonAcceptedChannels.set(channel.channelId, channel);\r\n        }\r\n        this.onChannelOpenCompleted(channel.channelId, channel);\r\n        channel.enableSending();\r\n    }\r\n    handleCloseMessage(message) {\r\n        const channel = this.findChannelById(message.recipientChannel);\r\n        if (channel) {\r\n            channel.handleClose();\r\n        }\r\n    }\r\n    async handleOpenConfirmationMessage(message, cancellation) {\r\n        var _a;\r\n        let completionSource = null;\r\n        let openMessage;\r\n        const pendingChannel = this.pendingChannels.get(message.recipientChannel);\r\n        if (pendingChannel) {\r\n            openMessage = pendingChannel.openMessage;\r\n            completionSource = pendingChannel.completionSource;\r\n            if (pendingChannel.cancellationRegistration) {\r\n                pendingChannel.cancellationRegistration.dispose();\r\n            }\r\n            this.pendingChannels.delete(message.recipientChannel);\r\n        }\r\n        else if (this.channelMap.has(message.recipientChannel)) {\r\n            throw new Error('Duplicate channel ID.');\r\n        }\r\n        else {\r\n            throw new Error('Channel confirmation was not requested.');\r\n        }\r\n        const channel = new sshChannel_1.SshChannel(this, openMessage.channelType || sshChannel_1.SshChannel.sessionChannelType, message.senderChannel, message.initialWindowSize, message.maximumPacketSize, message.recipientChannel);\r\n        this.channelMap.set(channel.channelId, channel);\r\n        const args = new sshChannelOpeningEventArgs_1.SshChannelOpeningEventArgs(openMessage, channel, false);\r\n        await this.session.handleChannelOpening(args, cancellation);\r\n        if (completionSource) {\r\n            if (args.failureReason === connectionMessages_1.SshChannelOpenFailureReason.none) {\r\n                completionSource.resolve(channel);\r\n            }\r\n            else {\r\n                completionSource.reject(new errors_1.SshChannelError((_a = args.failureDescription) !== null && _a !== void 0 ? _a : 'Channel open failure.', args.failureReason));\r\n                return;\r\n            }\r\n        }\r\n        else {\r\n            this.onChannelOpenCompleted(channel.channelId, channel);\r\n        }\r\n        channel.enableSending();\r\n    }\r\n    handleOpenFailureMessage(message) {\r\n        let completionSource = null;\r\n        const pendingChannel = this.pendingChannels.get(message.recipientChannel);\r\n        if (pendingChannel) {\r\n            completionSource = pendingChannel.completionSource;\r\n            if (pendingChannel.cancellationRegistration) {\r\n                pendingChannel.cancellationRegistration.dispose();\r\n            }\r\n            this.pendingChannels.delete(message.recipientChannel);\r\n        }\r\n        if (completionSource != null) {\r\n            completionSource.reject(new errors_1.SshChannelError(message.description || 'Channel open rejected.', message.reasonCode));\r\n        }\r\n        else {\r\n            this.onChannelOpenCompleted(message.recipientChannel, null);\r\n        }\r\n    }\r\n    async handleRequestMessage(message, cancellation) {\r\n        const channel = this.findChannelById(message.recipientChannel);\r\n        if (!channel) {\r\n            (0, trace_1.trace)(`Invalid channel ID ${message.recipientChannel} in channel request message.`);\r\n            return;\r\n        }\r\n        await channel.handleRequest(message, cancellation);\r\n    }\r\n    handleSuccessMessage(message) {\r\n        const channel = this.findChannelById(message.recipientChannel);\r\n        if (!channel) {\r\n            (0, trace_1.trace)(`Invalid channel ID ${message.recipientChannel} in channel success message.`);\r\n            return;\r\n        }\r\n        channel.handleResponse(true);\r\n    }\r\n    handleFailureMessage(message) {\r\n        const channel = this.findChannelById(message.recipientChannel);\r\n        if (!channel) {\r\n            (0, trace_1.trace)(`Invalid channel ID ${message.recipientChannel} in channel failure message.`);\r\n            return;\r\n        }\r\n        channel.handleResponse(false);\r\n    }\r\n    handleDataMessage(message) {\r\n        const channel = this.findChannelById(message.recipientChannel);\r\n        if (channel) {\r\n            return channel.handleDataReceived(message.data);\r\n        }\r\n    }\r\n    handleAdjustWindowMessage(message) {\r\n        const channel = this.findChannelById(message.recipientChannel);\r\n        if (channel) {\r\n            channel.adjustRemoteWindow(message.bytesToAdd);\r\n        }\r\n    }\r\n    handleEofMessage(message) {\r\n        const channel = this.findChannelById(message.recipientChannel);\r\n        if (channel) {\r\n            channel.handleEof();\r\n        }\r\n    }\r\n    onChannelOpenCompleted(channelId, channel) {\r\n        if (channel) {\r\n            (0, trace_1.trace)(`${this.session} ChannelOpenCompleted(${channel})`);\r\n        }\r\n        else {\r\n            (0, trace_1.trace)(`${this.session} ChannelOpenCompleted(${channelId} failed)`);\r\n        }\r\n    }\r\n    findChannelById(id) {\r\n        var _a;\r\n        const channel = (_a = this.channelMap.get(id)) !== null && _a !== void 0 ? _a : null;\r\n        return channel;\r\n    }\r\n    _removeChannel(channel) {\r\n        this.channelMap.delete(channel.channelId);\r\n        this.pendingChannels.delete(channel.channelId);\r\n    }\r\n};\r\nConnectionService.serviceName = 'ssh-connection';\r\nConnectionService = ConnectionService_1 = __decorate([\r\n    (0, serviceActivation_1.serviceActivation)({ serviceRequest: ConnectionService_1.serviceName })\r\n], ConnectionService);\r\nexports.ConnectionService = ConnectionService;\r\n//# sourceMappingURL=connectionService.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar KeyExchangeService_1;\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.KeyExchangeService = void 0;\r\nconst trace_1 = require(\"../trace\");\r\nconst buffer_1 = require(\"buffer\");\r\nconst sshSession_1 = require(\"../sshSession\");\r\nconst sshService_1 = require(\"./sshService\");\r\nconst bigInt_1 = require(\"../io/bigInt\");\r\nconst kexMessages_1 = require(\"../messages/kexMessages\");\r\nconst sshAlgorithms_1 = require(\"../algorithms/sshAlgorithms\");\r\nconst sshData_1 = require(\"../io/sshData\");\r\nconst errors_1 = require(\"../errors\");\r\nconst transportMessages_1 = require(\"../messages/transportMessages\");\r\nconst sshSessionAlgorithms_1 = require(\"../sshSessionAlgorithms\");\r\nconst vscode_jsonrpc_1 = require(\"vscode-jsonrpc\");\r\nconst serviceActivation_1 = require(\"./serviceActivation\");\r\nclass ExchangeContext {\r\n}\r\nconst serverExtensionInfoSignal = 'ext-info-s';\r\nconst clientExtensionInfoSignal = 'ext-info-c';\r\nlet KeyExchangeService = KeyExchangeService_1 = class KeyExchangeService extends sshService_1.SshService {\r\n    constructor(session, isClientSession) {\r\n        super(session);\r\n        this.isClientSession = isClientSession;\r\n        this.isInitialExchange = false;\r\n        this.exchangeContext = null;\r\n    }\r\n    get exchanging() {\r\n        return !!this.exchangeContext;\r\n    }\r\n    async startKeyExchange(isInitialExchange) {\r\n        this.isInitialExchange = isInitialExchange;\r\n        this.exchangeContext = new ExchangeContext();\r\n        const kexInitMessage = this.createKeyExchangeInitMessage();\r\n        let kexGuessMessage = null;\r\n        if (this.isClientSession) {\r\n            if (isInitialExchange && this.session.config.enableKeyExchangeGuess) {\r\n                kexGuessMessage = await this.createKeyExchangeGuessMessage();\r\n                kexInitMessage.firstKexPacketFollows = !!kexGuessMessage;\r\n            }\r\n            this.exchangeContext.clientKexInitPayload = kexInitMessage.toBuffer();\r\n        }\r\n        else {\r\n            this.exchangeContext.serverKexInitPayload = kexInitMessage.toBuffer();\r\n        }\r\n        return [kexInitMessage, kexGuessMessage];\r\n    }\r\n    finishKeyExchange() {\r\n        const newAlgorithms = this.exchangeContext.newAlgorithms;\r\n        this.exchangeContext = null;\r\n        return newAlgorithms;\r\n    }\r\n    abortKeyExchange() {\r\n        this.exchangeContext = null;\r\n    }\r\n    createKeyExchangeInitMessage() {\r\n        // Reference RFC 8308: Signaling of Extension Negotiation in Key Exchange.\r\n        const extinfo = this.isClientSession ? clientExtensionInfoSignal : serverExtensionInfoSignal;\r\n        const config = this.session.config;\r\n        const message = new kexMessages_1.KeyExchangeInitMessage();\r\n        message.keyExchangeAlgorithms = (0, sshAlgorithms_1.algorithmNames)(config.keyExchangeAlgorithms).concat(extinfo);\r\n        message.serverHostKeyAlgorithms = this.getPublicKeyAlgorithms();\r\n        message.encryptionAlgorithmsClientToServer = message.encryptionAlgorithmsServerToClient = (0, sshAlgorithms_1.algorithmNames)(config.encryptionAlgorithms);\r\n        message.macAlgorithmsClientToServer = message.macAlgorithmsServerToClient = (0, sshAlgorithms_1.algorithmNames)(config.hmacAlgorithms);\r\n        message.compressionAlgorithmsClientToServer = message.compressionAlgorithmsServerToClient = (0, sshAlgorithms_1.algorithmNames)(config.compressionAlgorithms);\r\n        message.languagesClientToServer = [''];\r\n        message.languagesServerToClient = [''];\r\n        message.firstKexPacketFollows = false;\r\n        message.reserved = 0;\r\n        return message;\r\n    }\r\n    /**\r\n     * Gets the list of public key algorithms that the current session can support.\r\n     * For a server session the list is filtered based on the available private keys.\r\n     */\r\n    getPublicKeyAlgorithms() {\r\n        var _a, _b;\r\n        let publicKeyAlgorithms = [...this.session.config.publicKeyAlgorithms];\r\n        if (publicKeyAlgorithms.length > 1 && !this.isClientSession) {\r\n            const privateKeyAlgorithms = (_b = (_a = this.session.credentials) === null || _a === void 0 ? void 0 : _a.publicKeys) === null || _b === void 0 ? void 0 : _b.map((k) => k.keyAlgorithmName);\r\n            if (privateKeyAlgorithms) {\r\n                publicKeyAlgorithms = publicKeyAlgorithms.filter((a) => a && privateKeyAlgorithms.includes(a.keyAlgorithmName));\r\n            }\r\n        }\r\n        const publicKeyAlgorithmNames = (0, sshAlgorithms_1.algorithmNames)(publicKeyAlgorithms);\r\n        return publicKeyAlgorithmNames;\r\n    }\r\n    async createKeyExchangeGuessMessage() {\r\n        if (!this.exchangeContext) {\r\n            throw new Error('Key exchange was not started.');\r\n        }\r\n        // Select the first key exchange algorithm as the \"guess\". (They are in preferential order.)\r\n        const kexAlgorithm = this.session.config.keyExchangeAlgorithms[0];\r\n        if (!kexAlgorithm) {\r\n            return null;\r\n        }\r\n        this.exchangeContext.keyExchange = kexAlgorithm.name;\r\n        this.exchangeContext.exchange = kexAlgorithm.createKeyExchange();\r\n        this.exchangeContext.exchangeValue = await this.exchangeContext.exchange.startKeyExchange();\r\n        const guess = new kexMessages_1.KeyExchangeDhInitMessage();\r\n        guess.e = this.exchangeContext.exchangeValue;\r\n        return guess;\r\n    }\r\n    handleMessage(message, cancellation) {\r\n        if (message instanceof kexMessages_1.KeyExchangeInitMessage) {\r\n            return this.handleInitMessage(message, cancellation);\r\n        }\r\n        else if (message instanceof kexMessages_1.KeyExchangeDhInitMessage) {\r\n            return this.handleDhInitMessage(message, cancellation);\r\n        }\r\n        else if (message instanceof kexMessages_1.KeyExchangeDhReplyMessage) {\r\n            return this.handleDhReplyMessage(message, cancellation);\r\n        }\r\n        else {\r\n            throw new Error(`Message not implemented: ${message}`);\r\n        }\r\n    }\r\n    async handleInitMessage(message, cancellation) {\r\n        var _a, _b, _c, _d, _e;\r\n        if (!this.exchangeContext) {\r\n            throw new Error('Key exchange was not started.');\r\n        }\r\n        const config = this.session.config;\r\n        this.exchangeContext.keyExchange = this.chooseAlgorithm('KeyExchange', (0, sshAlgorithms_1.algorithmNames)(config.keyExchangeAlgorithms), message.keyExchangeAlgorithms);\r\n        if (this.exchangeContext.keyExchange === 'none') {\r\n            (0, trace_1.trace)('Client and server negotiated no security. Cancelling key-exchange.');\r\n            this.exchangeContext.newAlgorithms = new sshSessionAlgorithms_1.SshSessionAlgorithms();\r\n            await this.session.handleNewKeysMessage(new kexMessages_1.NewKeysMessage(), cancellation);\r\n            return;\r\n        }\r\n        this.exchangeContext.publicKey = this.chooseAlgorithm('PublicKey', this.getPublicKeyAlgorithms(), message.serverHostKeyAlgorithms);\r\n        this.exchangeContext.clientEncryption = this.chooseAlgorithm('ClientEncryption', (0, sshAlgorithms_1.algorithmNames)(config.encryptionAlgorithms), message.encryptionAlgorithmsClientToServer);\r\n        this.exchangeContext.serverEncryption = this.chooseAlgorithm('ServerEncryption', (0, sshAlgorithms_1.algorithmNames)(config.encryptionAlgorithms), message.encryptionAlgorithmsServerToClient);\r\n        this.exchangeContext.clientHmac = this.chooseAlgorithm('ClientHmac', (0, sshAlgorithms_1.algorithmNames)(config.hmacAlgorithms), message.macAlgorithmsClientToServer);\r\n        this.exchangeContext.serverHmac = this.chooseAlgorithm('ServerHmac', (0, sshAlgorithms_1.algorithmNames)(config.hmacAlgorithms), message.macAlgorithmsServerToClient);\r\n        this.exchangeContext.clientCompression = this.chooseAlgorithm('ClientCompression', (0, sshAlgorithms_1.algorithmNames)(config.compressionAlgorithms), message.compressionAlgorithmsClientToServer);\r\n        this.exchangeContext.serverCompression = this.chooseAlgorithm('ServerCompression', (0, sshAlgorithms_1.algorithmNames)(config.compressionAlgorithms), message.compressionAlgorithmsServerToClient);\r\n        let extensionInfoSignal;\r\n        if (this.isClientSession) {\r\n            this.exchangeContext.serverKexInitPayload = message.toBuffer();\r\n            // If the exchange value is already initialized then this side sent a guess.\r\n            const alreadySentGuess = !!this.exchangeContext.exchangeValue;\r\n            // Check if the negotiated algorithm is the one preferred by THIS side.\r\n            // This means if there was a \"guess\" at kex initialization then it was correct.\r\n            const negotiatedKexAlgorthmIsPreferred = this.exchangeContext.keyExchange === ((_a = config.keyExchangeAlgorithms[0]) === null || _a === void 0 ? void 0 : _a.name);\r\n            // If a guess was not sent, or the guess was wrong, send the init message now.\r\n            if (!alreadySentGuess || !negotiatedKexAlgorthmIsPreferred) {\r\n                const kexAlgorithm = config.getKeyExchangeAlgorithm(this.exchangeContext.keyExchange);\r\n                this.exchangeContext.exchange = kexAlgorithm.createKeyExchange();\r\n                this.exchangeContext.exchangeValue = await this.exchangeContext.exchange.startKeyExchange();\r\n                const reply = new kexMessages_1.KeyExchangeDhInitMessage();\r\n                reply.e = this.exchangeContext.exchangeValue;\r\n                await this.session.sendMessage(reply, cancellation);\r\n            }\r\n            extensionInfoSignal = serverExtensionInfoSignal;\r\n        }\r\n        else {\r\n            if (message.firstKexPacketFollows) {\r\n                // The remote side indicated it is sending a guess immediately following.\r\n                // Check if the negotiated algorithm is the one preferred by the OTHER side.\r\n                // If so, the following \"guess\" will be correct. Otherwise it must be ignored.\r\n                const negotiatedKexAlgorthmIsPreferred = this.exchangeContext.keyExchange === ((_b = message.keyExchangeAlgorithms) === null || _b === void 0 ? void 0 : _b[0]);\r\n                const guessResult = negotiatedKexAlgorthmIsPreferred ? 'correct' : 'incorrect';\r\n                (0, trace_1.trace)(`Client's KeyExchange guess was ${guessResult}.`);\r\n                this.exchangeContext.discardGuessedInit = !negotiatedKexAlgorthmIsPreferred;\r\n                if (negotiatedKexAlgorthmIsPreferred &&\r\n                    this.session.remoteVersion.isVsSsh &&\r\n                    ((_c = this.session.remoteVersion.version) === null || _c === void 0 ? void 0 : _c.startsWith('2.'))) {\r\n                    // VS-SSH v2 had a bug in the logic for determining whether the guess was correct.\r\n                    // Use that alternate logic here to preserve compatibility.\r\n                    const clientAndServerHaveSamePreference = ((_d = message.keyExchangeAlgorithms) === null || _d === void 0 ? void 0 : _d[0]) === ((_e = config.keyExchangeAlgorithms[0]) === null || _e === void 0 ? void 0 : _e.name);\r\n                    if (!clientAndServerHaveSamePreference) {\r\n                        (0, trace_1.trace)('Ignoring correct guess for compatibility with older client.');\r\n                        this.exchangeContext.discardGuessedInit = true;\r\n                    }\r\n                }\r\n            }\r\n            this.exchangeContext.clientKexInitPayload = message.toBuffer();\r\n            extensionInfoSignal = clientExtensionInfoSignal;\r\n        }\r\n        if (this.isInitialExchange && message.keyExchangeAlgorithms.includes(extensionInfoSignal)) {\r\n            // The extension info message will be blocked in the queue\r\n            // until immediately after the key-exchange is done.\r\n            await this.session.sendExtensionInfo(cancellation);\r\n        }\r\n    }\r\n    async handleDhInitMessage(message, cancellation) {\r\n        var _a, _b, _c, _d, _e, _f, _g;\r\n        if (this.isClientSession) {\r\n            return;\r\n        }\r\n        const serverSession = this.session;\r\n        if (!this.exchangeContext ||\r\n            !this.exchangeContext.keyExchange ||\r\n            !this.exchangeContext.publicKey) {\r\n            throw new errors_1.SshConnectionError('Key exchange not started.', transportMessages_1.SshDisconnectReason.protocolError);\r\n        }\r\n        if (this.exchangeContext.discardGuessedInit) {\r\n            // Algorithm negotiation determined that an incorrect guess would be received.\r\n            this.exchangeContext.discardGuessedInit = false;\r\n            return;\r\n        }\r\n        const kexAlg = this.session.config.getKeyExchangeAlgorithm(this.exchangeContext.keyExchange);\r\n        if (!kexAlg) {\r\n            throw new errors_1.SshConnectionError('Key exchange not supported for algorithm: ' + this.exchangeContext.keyExchange, transportMessages_1.SshDisconnectReason.keyExchangeFailed);\r\n        }\r\n        const publicKeyAlg = this.session.config.getPublicKeyAlgorithm(this.exchangeContext.publicKey);\r\n        if (!publicKeyAlg) {\r\n            throw new errors_1.SshConnectionError('Public key algorithm not supported: ' + this.exchangeContext.publicKey, transportMessages_1.SshDisconnectReason.keyExchangeFailed);\r\n        }\r\n        let privateKey = null;\r\n        if ((_a = serverSession.credentials) === null || _a === void 0 ? void 0 : _a.publicKeys) {\r\n            const publicKey = serverSession.credentials.publicKeys.find((k) => k.keyAlgorithmName === publicKeyAlg.keyAlgorithmName);\r\n            privateKey = publicKey !== null && publicKey !== void 0 ? publicKey : null;\r\n            if ((privateKey === null || privateKey === void 0 ? void 0 : privateKey.hasPrivateKey) === false) {\r\n                if (!serverSession.credentials.privateKeyProvider) {\r\n                    throw new Error('A private key provider is required.');\r\n                }\r\n                privateKey = await serverSession.credentials.privateKeyProvider(publicKey, cancellation !== null && cancellation !== void 0 ? cancellation : vscode_jsonrpc_1.CancellationToken.None);\r\n            }\r\n        }\r\n        if (privateKey == null) {\r\n            throw new errors_1.SshConnectionError('Private key not found for algorithm: ' + this.exchangeContext.publicKey, transportMessages_1.SshDisconnectReason.keyExchangeFailed);\r\n        }\r\n        const clientEncryption = this.session.config.getEncryptionAlgorithm(this.exchangeContext.clientEncryption);\r\n        const serverEncryption = this.session.config.getEncryptionAlgorithm(this.exchangeContext.serverEncryption);\r\n        const serverHmac = this.session.config.getHmacAlgorithm(this.exchangeContext.serverHmac);\r\n        const clientHmac = this.session.config.getHmacAlgorithm(this.exchangeContext.clientHmac);\r\n        const keyExchange = kexAlg.createKeyExchange();\r\n        const clientExchangeValue = message.e || buffer_1.Buffer.alloc(0);\r\n        const serverExchangeValue = await keyExchange.startKeyExchange();\r\n        const sharedSecret = await keyExchange.decryptKeyExchange(clientExchangeValue);\r\n        const hostKeyAndCerts = await privateKey.getPublicKeyBytes(publicKeyAlg.name);\r\n        if (!hostKeyAndCerts) {\r\n            throw new errors_1.SshConnectionError('Public key not set.', transportMessages_1.SshDisconnectReason.keyExchangeFailed);\r\n        }\r\n        const exchangeHash = await this.computeExchangeHash(keyExchange, hostKeyAndCerts, clientExchangeValue, serverExchangeValue, sharedSecret);\r\n        if (!this.session.sessionId) {\r\n            this.session.sessionId = exchangeHash;\r\n        }\r\n        const [clientCipherIV, serverCipherIV, clientCipherKey, serverCipherKey, clientHmacKey, serverHmacKey,] = await this.computeKeys(keyExchange, sharedSecret, exchangeHash, clientEncryption, serverEncryption, clientHmac, serverHmac);\r\n        const cipher = (_b = (await (serverEncryption === null || serverEncryption === void 0 ? void 0 : serverEncryption.createCipher(true, serverCipherKey, serverCipherIV)))) !== null && _b !== void 0 ? _b : null;\r\n        const decipher = (_c = (await (clientEncryption === null || clientEncryption === void 0 ? void 0 : clientEncryption.createCipher(false, clientCipherKey, clientCipherIV)))) !== null && _c !== void 0 ? _c : null;\r\n        const signer = (_d = (await (serverHmac === null || serverHmac === void 0 ? void 0 : serverHmac.createSigner(serverHmacKey)))) !== null && _d !== void 0 ? _d : null;\r\n        const verifier = (_e = (await (clientHmac === null || clientHmac === void 0 ? void 0 : clientHmac.createVerifier(clientHmacKey)))) !== null && _e !== void 0 ? _e : null;\r\n        const algorithms = new sshSessionAlgorithms_1.SshSessionAlgorithms();\r\n        algorithms.publicKeyAlgorithmName = this.exchangeContext.publicKey;\r\n        algorithms.cipher = cipher;\r\n        algorithms.decipher = decipher;\r\n        algorithms.signer = signer;\r\n        algorithms.verifier = verifier;\r\n        algorithms.messageSigner = ((_f = cipher) === null || _f === void 0 ? void 0 : _f.authenticatedEncryption)\r\n            ? cipher\r\n            : signer;\r\n        algorithms.messageVerifier = ((_g = decipher) === null || _g === void 0 ? void 0 : _g.authenticatedEncryption)\r\n            ? decipher\r\n            : verifier;\r\n        algorithms.compressor = this.session.config.getCompressionAlgorithm(this.exchangeContext.serverCompression);\r\n        algorithms.decompressor = this.session.config.getCompressionAlgorithm(this.exchangeContext.clientCompression);\r\n        this.exchangeContext.newAlgorithms = algorithms;\r\n        // Wipe the keys from memory after they are stored in native key objects.\r\n        if (clientCipherIV)\r\n            clientCipherIV.fill(0);\r\n        if (clientCipherKey)\r\n            clientCipherKey.fill(0);\r\n        if (clientHmacKey)\r\n            clientHmacKey.fill(0);\r\n        if (serverCipherIV)\r\n            serverCipherIV.fill(0);\r\n        if (serverCipherKey)\r\n            serverCipherKey.fill(0);\r\n        if (serverHmacKey)\r\n            serverHmacKey.fill(0);\r\n        const exchangeSigner = publicKeyAlg.createSigner(privateKey);\r\n        let signature = await exchangeSigner.sign(exchangeHash);\r\n        signature = publicKeyAlg.createSignatureData(signature);\r\n        const reply = new kexMessages_1.KeyExchangeDhReplyMessage();\r\n        reply.hostKey = hostKeyAndCerts;\r\n        reply.f = serverExchangeValue;\r\n        reply.signature = signature;\r\n        await this.session.sendMessage(reply, cancellation);\r\n        await this.session.sendMessage(new kexMessages_1.NewKeysMessage(), cancellation);\r\n    }\r\n    async handleDhReplyMessage(message, cancellation) {\r\n        var _a, _b, _c, _d, _e, _f, _g, _h;\r\n        if (!this.isClientSession) {\r\n            return;\r\n        }\r\n        if (!this.exchangeContext) {\r\n            throw new errors_1.SshConnectionError('Key exchange was not started.', transportMessages_1.SshDisconnectReason.protocolError);\r\n        }\r\n        const config = this.session.config;\r\n        const keyExchange = this.exchangeContext.exchange;\r\n        const publicKeyAlgorithmName = this.exchangeContext.publicKey;\r\n        const publicKeyAlg = config.getPublicKeyAlgorithm(publicKeyAlgorithmName);\r\n        const clientEncryption = config.getEncryptionAlgorithm(this.exchangeContext.clientEncryption);\r\n        const serverEncryption = config.getEncryptionAlgorithm(this.exchangeContext.serverEncryption);\r\n        const serverHmac = config.getHmacAlgorithm(this.exchangeContext.serverHmac);\r\n        const clientHmac = config.getHmacAlgorithm(this.exchangeContext.clientHmac);\r\n        const clientExchangeValue = this.exchangeContext.exchangeValue;\r\n        const serverExchangeValue = message.f;\r\n        if (!keyExchange || !clientExchangeValue) {\r\n            throw new errors_1.SshConnectionError('Failed to initialize crypto after key exchange.', transportMessages_1.SshDisconnectReason.keyExchangeFailed);\r\n        }\r\n        // Load the server's public key bytes into a key-pair instance.\r\n        this.hostKey = publicKeyAlg.createKeyPair();\r\n        await this.hostKey.setPublicKeyBytes(message.hostKey);\r\n        const sharedSecret = await keyExchange.decryptKeyExchange(serverExchangeValue);\r\n        const hostKeyAndCerts = message.hostKey;\r\n        const exchangeHash = await this.computeExchangeHash(keyExchange, hostKeyAndCerts, clientExchangeValue, serverExchangeValue, sharedSecret);\r\n        const signature = publicKeyAlg.readSignatureData(message.signature);\r\n        const exchangeVerifier = publicKeyAlg.createVerifier(this.hostKey);\r\n        let verified;\r\n        try {\r\n            verified = await exchangeVerifier.verify(exchangeHash, signature);\r\n        }\r\n        catch (e) {\r\n            if (!(e instanceof Error))\r\n                throw e;\r\n            (0, trace_1.trace)(`Server public key verification error: ${(_a = e.message) !== null && _a !== void 0 ? _a : e}`);\r\n            throw new errors_1.SshConnectionError('Server public key verification failed: ' + ((_b = e.message) !== null && _b !== void 0 ? _b : e), transportMessages_1.SshDisconnectReason.hostKeyNotVerifiable);\r\n        }\r\n        if (verified) {\r\n            (0, trace_1.trace)('Server public key verification succeeded.');\r\n        }\r\n        else {\r\n            (0, trace_1.trace)('Server public key verification failed.');\r\n            throw new errors_1.SshConnectionError('Server public key verification failed.', transportMessages_1.SshDisconnectReason.hostKeyNotVerifiable);\r\n        }\r\n        if (this.session.sessionId == null) {\r\n            this.session.sessionId = exchangeHash;\r\n        }\r\n        const [clientCipherIV, serverCipherIV, clientCipherKey, serverCipherKey, clientHmacKey, serverHmacKey,] = await this.computeKeys(keyExchange, sharedSecret, exchangeHash, clientEncryption, serverEncryption, clientHmac, serverHmac);\r\n        const cipher = (_c = (await (clientEncryption === null || clientEncryption === void 0 ? void 0 : clientEncryption.createCipher(true, clientCipherKey, clientCipherIV)))) !== null && _c !== void 0 ? _c : null;\r\n        const decipher = (_d = (await (serverEncryption === null || serverEncryption === void 0 ? void 0 : serverEncryption.createCipher(false, serverCipherKey, serverCipherIV)))) !== null && _d !== void 0 ? _d : null;\r\n        const signer = (_e = (await (clientHmac === null || clientHmac === void 0 ? void 0 : clientHmac.createSigner(clientHmacKey)))) !== null && _e !== void 0 ? _e : null;\r\n        const verifier = (_f = (await (serverHmac === null || serverHmac === void 0 ? void 0 : serverHmac.createVerifier(serverHmacKey)))) !== null && _f !== void 0 ? _f : null;\r\n        const algorithms = new sshSessionAlgorithms_1.SshSessionAlgorithms();\r\n        algorithms.publicKeyAlgorithmName = publicKeyAlgorithmName;\r\n        algorithms.cipher = cipher;\r\n        algorithms.decipher = decipher;\r\n        algorithms.signer = signer;\r\n        algorithms.verifier = verifier;\r\n        algorithms.messageSigner = ((_g = cipher) === null || _g === void 0 ? void 0 : _g.authenticatedEncryption)\r\n            ? cipher\r\n            : signer;\r\n        algorithms.messageVerifier = ((_h = decipher) === null || _h === void 0 ? void 0 : _h.authenticatedEncryption)\r\n            ? decipher\r\n            : verifier;\r\n        algorithms.compressor = config.getCompressionAlgorithm(this.exchangeContext.clientCompression);\r\n        algorithms.decompressor = config.getCompressionAlgorithm(this.exchangeContext.serverCompression);\r\n        this.exchangeContext.newAlgorithms = algorithms;\r\n        // Wipe the keys from memory after they are stored in native key objects.\r\n        if (clientCipherIV)\r\n            clientCipherIV.fill(0);\r\n        if (clientCipherKey)\r\n            clientCipherKey.fill(0);\r\n        if (clientHmacKey)\r\n            clientHmacKey.fill(0);\r\n        if (serverCipherIV)\r\n            serverCipherIV.fill(0);\r\n        if (serverCipherKey)\r\n            serverCipherKey.fill(0);\r\n        if (serverHmacKey)\r\n            serverHmacKey.fill(0);\r\n        await this.session.sendMessage(new kexMessages_1.NewKeysMessage(), cancellation);\r\n    }\r\n    chooseAlgorithm(label, localAlgorithms, remoteAlgorithms) {\r\n        var _a;\r\n        // Ensure consistent results if the client and server list the same algorithms\r\n        // in different order of preference.\r\n        let serverAlgorithms;\r\n        let clientAlgorithms;\r\n        if (this.isClientSession) {\r\n            serverAlgorithms = remoteAlgorithms || [];\r\n            clientAlgorithms = localAlgorithms;\r\n        }\r\n        else {\r\n            serverAlgorithms = localAlgorithms;\r\n            clientAlgorithms = remoteAlgorithms || [];\r\n        }\r\n        const negotiationDetail = `${label} negotiation: ` +\r\n            `Server (${serverAlgorithms.join(', ')}) ` +\r\n            `Client (${clientAlgorithms.join(', ')})`;\r\n        if (this.session.remoteVersion.isVsSsh &&\r\n            ((_a = this.session.remoteVersion.version) === null || _a === void 0 ? void 0 : _a.startsWith('2.'))) {\r\n            // Older versions of ths library got this backward. Swap for back-compatibility.\r\n            const temp = serverAlgorithms;\r\n            serverAlgorithms = clientAlgorithms;\r\n            clientAlgorithms = temp;\r\n        }\r\n        for (let client of clientAlgorithms) {\r\n            for (let server of serverAlgorithms) {\r\n                if (server === client) {\r\n                    const result = server;\r\n                    (0, trace_1.trace)(`${negotiationDetail} => ${result}`);\r\n                    return result;\r\n                }\r\n            }\r\n        }\r\n        throw new Error(`Failed ${negotiationDetail}`);\r\n    }\r\n    async computeExchangeHash(kex, hostKeyAndCerts, clientExchangeValue, serverExchangeValue, sharedSecret) {\r\n        if (!this.session.remoteVersion) {\r\n            throw new Error('Key exchange not completed.');\r\n        }\r\n        const writer = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(2048));\r\n        if (this.isClientSession) {\r\n            writer.writeString(sshSession_1.SshSession.localVersion.toString(), 'ascii');\r\n            writer.writeString(this.session.remoteVersion.toString(), 'ascii');\r\n        }\r\n        else {\r\n            writer.writeString(this.session.remoteVersion.toString(), 'ascii');\r\n            writer.writeString(sshSession_1.SshSession.localVersion.toString(), 'ascii');\r\n        }\r\n        writer.writeBinary(this.exchangeContext.clientKexInitPayload);\r\n        writer.writeBinary(this.exchangeContext.serverKexInitPayload);\r\n        writer.writeBinary(hostKeyAndCerts);\r\n        // These values are formatted as bigints (with leading zeroes if the first bit is high)\r\n        // even though they might not really be bigints, depending on the key-exchange algorithm.\r\n        writer.writeBigInt(bigInt_1.BigInt.fromBytes(clientExchangeValue, { unsigned: true }));\r\n        writer.writeBigInt(bigInt_1.BigInt.fromBytes(serverExchangeValue, { unsigned: true }));\r\n        writer.writeBigInt(bigInt_1.BigInt.fromBytes(sharedSecret, { unsigned: true }));\r\n        const hash = await kex.sign(writer.toBuffer());\r\n        return hash;\r\n    }\r\n    async computeKeys(keyExchange, sharedSecret, exchangeHash, clientEncryption, serverEncryption, clientHmac, serverHmac) {\r\n        var _a, _b;\r\n        const writer = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(4 /* mpint header */ +\r\n            sharedSecret.length +\r\n            exchangeHash.length +\r\n            Math.max(1 /* letter */ + ((_b = (_a = this.session.sessionId) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0), keyExchange.digestLength)));\r\n        writer.writeBinary(sharedSecret);\r\n        writer.write(exchangeHash);\r\n        const offset = writer.position;\r\n        const clientCipherIV = clientEncryption &&\r\n            (await this.computeKey(keyExchange, writer, offset, clientEncryption.blockLength, 'A'));\r\n        const serverCipherIV = serverEncryption &&\r\n            (await this.computeKey(keyExchange, writer, offset, serverEncryption.blockLength, 'B'));\r\n        const clientCipherKey = clientEncryption &&\r\n            (await this.computeKey(keyExchange, writer, offset, clientEncryption.keyLength, 'C'));\r\n        const serverCipherKey = serverEncryption &&\r\n            (await this.computeKey(keyExchange, writer, offset, serverEncryption.keyLength, 'D'));\r\n        const clientHmacKey = clientHmac &&\r\n            (await this.computeKey(keyExchange, writer, offset, clientHmac.keyLength, 'E'));\r\n        const serverHmacKey = serverHmac &&\r\n            (await this.computeKey(keyExchange, writer, offset, serverHmac.keyLength, 'F'));\r\n        return [\r\n            clientCipherIV,\r\n            serverCipherIV,\r\n            clientCipherKey,\r\n            serverCipherKey,\r\n            clientHmacKey,\r\n            serverHmacKey,\r\n        ];\r\n    }\r\n    async computeKey(keyExchange, writer, writerOffset, blockSize, letter) {\r\n        const keyBuffer = buffer_1.Buffer.alloc(blockSize);\r\n        let keyBufferIndex = 0;\r\n        let currentHashLength = 0;\r\n        let currentHash = null;\r\n        if (!this.session.sessionId) {\r\n            throw new Error('Session ID not set.');\r\n        }\r\n        while (keyBufferIndex < blockSize) {\r\n            writer.position = writerOffset;\r\n            if (!currentHash) {\r\n                writer.writeByte(letter.charCodeAt(0));\r\n                writer.write(this.session.sessionId);\r\n            }\r\n            else {\r\n                writer.write(currentHash);\r\n            }\r\n            currentHash = await keyExchange.sign(writer.toBuffer());\r\n            currentHashLength = Math.min(currentHash.length, blockSize - keyBufferIndex);\r\n            currentHash.copy(keyBuffer, keyBufferIndex);\r\n            keyBufferIndex += currentHashLength;\r\n        }\r\n        if (currentHash) {\r\n            currentHash.fill(0);\r\n        }\r\n        return keyBuffer;\r\n    }\r\n};\r\nKeyExchangeService.serviceName = 'ssh-keyexchange';\r\nKeyExchangeService = KeyExchangeService_1 = __decorate([\r\n    (0, serviceActivation_1.serviceActivation)({ serviceRequest: KeyExchangeService_1.serviceName })\r\n], KeyExchangeService);\r\nexports.KeyExchangeService = KeyExchangeService;\r\n//# sourceMappingURL=keyExchangeService.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.findService = exports.serviceActivation = void 0;\r\n/**\r\n * Decorator applied to suclasses of `SshService` that declares how the service gets activated.\r\n */\r\nfunction serviceActivation(activation) {\r\n    return (constructor) => {\r\n        if (!constructor.activations) {\r\n            constructor.activations = [];\r\n        }\r\n        constructor.activations.push(activation);\r\n    };\r\n}\r\nexports.serviceActivation = serviceActivation;\r\n/**\r\n * Locates a service type in configuration, using a predicate to check service activation\r\n * attributes.\r\n *\r\n * @param serviceConfigs Service configuration dictionary from `SshSessionConfiguration.services`.\r\n * @param predicate Function to test whether a service activation attribute matches some condition.\r\n * @returns Service type (constructor), or null if no service type satisfies the predicate.\r\n */\r\nfunction findService(serviceConfigs, predicate) {\r\n    for (let serviceType of serviceConfigs.keys()) {\r\n        const activations = serviceType.activations;\r\n        let foundActivation = false;\r\n        for (let activation of activations) {\r\n            foundActivation = true;\r\n            if (predicate(activation)) {\r\n                return serviceType;\r\n            }\r\n        }\r\n        if (!foundActivation) {\r\n            throw new Error(`SSH service type '${serviceType.name}' must have one or more ` +\r\n                `'serviceActivation' decorators.`);\r\n        }\r\n    }\r\n    return null;\r\n}\r\nexports.findService = findService;\r\n//# sourceMappingURL=serviceActivation.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SshService = void 0;\r\n/**\r\n * Base class for SSH session services that handle incoming requests.\r\n *\r\n * Services can be on either the server side or the client side, because either side may\r\n * send requests to the other's services.\r\n *\r\n * Service subclasses must have one or more `serviceActivation` decorators applied to them to\r\n * declare the type(s) of requests that cause the service to be activated. Only one instance\r\n * of each service type gets activated for a session, even if there are multiple activation\r\n * rules. After activation, a service remains active for the duration of the session,\r\n * handling any additional requests, until it is disposed when the session is disposed.\r\n *\r\n * To enable activation of a service, add the service type to\r\n * `SshSessionConfiguration.services`. When a service is activated, the session raises a\r\n * `SshSession.serviceActivated` event.\r\n */\r\nclass SshService {\r\n    constructor(session) {\r\n        this.session = session;\r\n    }\r\n    dispose() { }\r\n    /**\r\n     * Services that are activated via session requests must override this method to handle\r\n     * incoming session requests.\r\n     *\r\n     * Implementations must send a success or failure response message if\r\n     * `SessionRequestMessage.wantReply` is true.\r\n     */\r\n    async onSessionRequest(request, cancellation) {\r\n        this.session.raiseSessionRequest(request);\r\n    }\r\n    /**\r\n     * Services that are activated via channel types must override this method to handle\r\n     * incoming requests to open a channel.\r\n     *\r\n     * Implementations may set `SshChannelOpeningEventArgs.failureReason`\r\n     * to block opening of the channel. The default behavior allows the channel to open.\r\n     *\r\n     * Requests on the opened channel will not be directed to `onChannelRequest`\r\n     * unless the service also declares activation on specific channel request(s). Otherwise,\r\n     * an implementation of this method may add any event-handlers to the\r\n     * `SshChannelOpeningEventArgs.channel` including a request event handler.\r\n     */\r\n    async onChannelOpening(request, cancellation) {\r\n        this.session.raiseChannelOpening(request);\r\n    }\r\n    /**\r\n     * Services that are activated via channel requests must override this method to handle\r\n     * incoming channel requests.\r\n     *\r\n     * Implementations must set `SshRequestEventArgs.isAuthorized` to `true` or `false` to\r\n     * indicate whether the request was allowed.\r\n     */\r\n    async onChannelRequest(channel, request, cancellation) { }\r\n    /**\r\n     * Sends any message.\r\n     */\r\n    async sendMessage(message, cancellation) {\r\n        await this.session.sendMessage(message, cancellation);\r\n    }\r\n}\r\nexports.SshService = SshService;\r\n//# sourceMappingURL=sshService.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SshChannel = void 0;\r\nconst trace_1 = require(\"./trace\");\r\nconst vscode_jsonrpc_1 = require(\"vscode-jsonrpc\");\r\nconst serviceActivation_1 = require(\"./services/serviceActivation\");\r\nconst connectionMessages_1 = require(\"./messages/connectionMessages\");\r\nconst transportMessages_1 = require(\"./messages/transportMessages\");\r\nconst channelMetrics_1 = require(\"./metrics/channelMetrics\");\r\nconst promiseCompletionSource_1 = require(\"./util/promiseCompletionSource\");\r\nconst errors_1 = require(\"./errors\");\r\nconst sshRequestEventArgs_1 = require(\"./events/sshRequestEventArgs\");\r\nconst sshChannelClosedEventArgs_1 = require(\"./events/sshChannelClosedEventArgs\");\r\nconst cancellation_1 = require(\"./util/cancellation\");\r\nconst semaphore_1 = require(\"./util/semaphore\");\r\n/**\r\n * Represents a channel on an SSH session. A session may include multiple channels, which\r\n * are multiplexed over the connection. Each channel within a session has a unique integer ID.\r\n */\r\nclass SshChannel {\r\n    /* @internal */\r\n    constructor(connectionService, channelType, remoteChannelId, remoteWindowSize, remoteMaxPacketSize, channelId) {\r\n        this.connectionService = connectionService;\r\n        this.channelType = channelType;\r\n        this.remoteChannelId = remoteChannelId;\r\n        this.remoteWindowSize = remoteWindowSize;\r\n        this.remoteMaxPacketSize = remoteMaxPacketSize;\r\n        this.channelId = channelId;\r\n        this.remoteClosed = false;\r\n        this.localClosed = false;\r\n        this.sentEof = false;\r\n        this.disposed = false;\r\n        this.openSendingWindowCompletionSource = null;\r\n        this.requestCompletionSource = null;\r\n        this.sendSemaphore = new semaphore_1.Semaphore(0);\r\n        /**\r\n         * Gets an object that reports measurements about the channel.\r\n         */\r\n        this.metrics = new channelMetrics_1.ChannelMetrics();\r\n        this.dataReceivedEmitter = new vscode_jsonrpc_1.Emitter();\r\n        /**\r\n         * Event raised when a data message is received on the channel.\r\n         *\r\n         * Users of a channel MUST add a `onDataReceived` event handler immediately after a\r\n         * channel is opened/accepted, or else all session communication will be blocked.\r\n         * (The `SshStream` class does this automatically.)\r\n         *\r\n         * The event handler must call `adjustWindow` when the data has been consumed,\r\n         * to notify the remote side that it may send more data.\r\n         */\r\n        this.onDataReceived = this.dataReceivedEmitter.event;\r\n        this.eofEmitter = new vscode_jsonrpc_1.Emitter();\r\n        /**\r\n         * Event raised when an EOF message is received on the channel.\r\n         */\r\n        this.onEof = this.eofEmitter.event;\r\n        this.closedEmitter = new vscode_jsonrpc_1.Emitter();\r\n        this.onClosed = this.closedEmitter.event;\r\n        this.requestEmitter = new vscode_jsonrpc_1.Emitter();\r\n        this.onRequest = this\r\n            .requestEmitter.event;\r\n        this.windowSize = SshChannel.initialWindowSize;\r\n        this.maxPacketSize = SshChannel.dataPacketSize;\r\n    }\r\n    get session() {\r\n        return this.connectionService.session;\r\n    }\r\n    get isClosed() {\r\n        return this.localClosed || this.remoteClosed;\r\n    }\r\n    /**\r\n     * Sends a channel request and waits for a response.\r\n     *\r\n     * Note if `wantReply` is `false`, this method returns `true` immediately after sending the\r\n     * request, without waiting for a reply.\r\n     *\r\n     * @returns The authorization status of the response; if false, the other side denied the\r\n     * request.\r\n     * @throws `ObjectDisposedError` if the channel was closed before sending the request.\r\n     * @throws `SshChannelError` if the channel was closed while waiting for a reply to the request.\r\n     */\r\n    async request(request, cancellation) {\r\n        if (!request)\r\n            throw new TypeError('Request is required.');\r\n        if (this.disposed)\r\n            throw new errors_1.ObjectDisposedError(this);\r\n        request.recipientChannel = this.remoteChannelId;\r\n        if (!request.wantReply) {\r\n            // If a reply is not requested, there's no need to set up a completion source.\r\n            await this.session.sendMessage(request, cancellation);\r\n            return true;\r\n        }\r\n        if (this.requestCompletionSource != null) {\r\n            throw new Error('Another request is already pending.');\r\n        }\r\n        // Capture as a local variable because the member may change.\r\n        const requestCompletionSource = new promiseCompletionSource_1.PromiseCompletionSource();\r\n        this.requestCompletionSource = requestCompletionSource;\r\n        if (cancellation) {\r\n            if (cancellation.isCancellationRequested)\r\n                throw new cancellation_1.CancellationError();\r\n            cancellation.onCancellationRequested(() => {\r\n                requestCompletionSource.reject(new cancellation_1.CancellationError());\r\n            });\r\n        }\r\n        await this.session.sendMessage(request, cancellation);\r\n        return await requestCompletionSource.promise;\r\n    }\r\n    async send(data, cancellation) {\r\n        if (this.disposed)\r\n            throw new errors_1.ObjectDisposedError(this);\r\n        if (data.length === 0) {\r\n            await this.sendEof();\r\n            return;\r\n        }\r\n        else if (this.sentEof) {\r\n            throw new Error('Cannot send more data after EOF.');\r\n        }\r\n        // Prevent out-of-order message chunks even if the caller does not await.\r\n        // Also don't send until the channel is fully opened.\r\n        await this.sendSemaphore.wait(cancellation);\r\n        try {\r\n            let offset = 0;\r\n            let count = data.length;\r\n            while (count > 0) {\r\n                let packetSize = Math.min(Math.min(this.remoteWindowSize, this.remoteMaxPacketSize), count);\r\n                while (packetSize === 0) {\r\n                    if (!this.openSendingWindowCompletionSource) {\r\n                        this.openSendingWindowCompletionSource = new promiseCompletionSource_1.PromiseCompletionSource();\r\n                    }\r\n                    (0, trace_1.trace)(`${this} send window is full. Waiting for window adjustment before sending.`);\r\n                    await (0, cancellation_1.withCancellation)(this.openSendingWindowCompletionSource.promise, cancellation);\r\n                    this.openSendingWindowCompletionSource = null;\r\n                    packetSize = Math.min(Math.min(this.remoteWindowSize, this.remoteMaxPacketSize), count);\r\n                }\r\n                const msg = new connectionMessages_1.ChannelDataMessage();\r\n                msg.recipientChannel = this.remoteChannelId;\r\n                // Unfortunately the data must be copied to a new buffer at this point\r\n                // to ensure it is still available to be re-sent later in case of disconnect.\r\n                msg.data = Buffer.from(data.slice(offset, offset + packetSize));\r\n                await this.session.sendMessage(msg, cancellation);\r\n                this.remoteWindowSize -= packetSize;\r\n                count -= packetSize;\r\n                offset += packetSize;\r\n                this.metrics.addBytesSent(packetSize);\r\n            }\r\n        }\r\n        finally {\r\n            this.sendSemaphore.tryRelease();\r\n        }\r\n    }\r\n    /* @internal */\r\n    enableSending() {\r\n        this.sendSemaphore.tryRelease();\r\n    }\r\n    async sendEof(cancellation) {\r\n        if (this.sentEof) {\r\n            return;\r\n        }\r\n        await this.sendSemaphore.wait(cancellation);\r\n        try {\r\n            this.sentEof = true;\r\n            const msg = new connectionMessages_1.ChannelEofMessage();\r\n            msg.recipientChannel = this.remoteChannelId;\r\n            await this.session.sendMessage(msg, cancellation);\r\n        }\r\n        finally {\r\n            this.sendSemaphore.tryRelease();\r\n        }\r\n    }\r\n    /* @internal */\r\n    async handleRequest(request, cancellation) {\r\n        if (!request.requestType) {\r\n            throw new errors_1.SshConnectionError('Channel request type not specified.', transportMessages_1.SshDisconnectReason.protocolError);\r\n        }\r\n        if (request.requestType === connectionMessages_1.ChannelRequestType.exitStatus) {\r\n            const signal = new connectionMessages_1.ChannelSignalMessage();\r\n            request.convertTo(signal);\r\n            this.exitStatus = signal.exitStatus;\r\n            return true;\r\n        }\r\n        else if (request.requestType === connectionMessages_1.ChannelRequestType.exitSignal) {\r\n            const signal = new connectionMessages_1.ChannelSignalMessage();\r\n            request.convertTo(signal);\r\n            this.exitSignal = signal.exitSignal;\r\n            this.exitErrorMessage = signal.errorMessage;\r\n            return true;\r\n        }\r\n        else if (request.requestType === connectionMessages_1.ChannelRequestType.signal) {\r\n            const signal = new connectionMessages_1.ChannelSignalMessage();\r\n            request.convertTo(signal);\r\n        }\r\n        const args = new sshRequestEventArgs_1.SshRequestEventArgs(request.requestType, request, this.session.principal);\r\n        const serviceType = (0, serviceActivation_1.findService)(this.session.config.services, (a) => (!a.channelType || a.channelType === this.channelType) &&\r\n            a.channelRequest === request.requestType);\r\n        await this.sendSemaphore.wait(cancellation);\r\n        try {\r\n            if (serviceType) {\r\n                // A service was configured for activation via this session request type.\r\n                const service = this.session.activateService(serviceType);\r\n                // `onChannelRequest` should really be 'protected internal'.\r\n                await service.onChannelRequest(this, args, cancellation);\r\n            }\r\n            else {\r\n                this.requestEmitter.fire(args);\r\n            }\r\n            if (request.wantReply) {\r\n                let replyMessage;\r\n                if (args.isAuthorized) {\r\n                    const successMessage = new connectionMessages_1.ChannelSuccessMessage();\r\n                    successMessage.recipientChannel = this.remoteChannelId;\r\n                    replyMessage = successMessage;\r\n                }\r\n                else {\r\n                    const failureMessage = new connectionMessages_1.ChannelFailureMessage();\r\n                    failureMessage.recipientChannel = this.remoteChannelId;\r\n                    replyMessage = failureMessage;\r\n                }\r\n                await this.session.sendMessage(replyMessage, cancellation);\r\n            }\r\n        }\r\n        finally {\r\n            this.sendSemaphore.tryRelease();\r\n        }\r\n        return args.isAuthorized || false;\r\n    }\r\n    /* @internal */\r\n    handleResponse(result) {\r\n        if (this.requestCompletionSource) {\r\n            this.requestCompletionSource.resolve(result);\r\n            this.requestCompletionSource = null;\r\n        }\r\n    }\r\n    /* @internal */\r\n    handleDataReceived(data) {\r\n        this.metrics.addBytesReceived(data.length);\r\n        // DataReceived handler is to adjust the window when it's done with the data.\r\n        this.dataReceivedEmitter.fire(data);\r\n    }\r\n    /**\r\n     * Adjusts the local receiving window size by the specified amount, notifying\r\n     * the remote side that it is free to send more data.\r\n     *\r\n     * This method MUST be called either immediately or eventually by the\r\n     * `onDataReceived` event handler as incoming data is processed.\r\n     */\r\n    adjustWindow(messageLength) {\r\n        if (this.disposed)\r\n            return;\r\n        this.windowSize -= messageLength;\r\n        if (this.windowSize <= this.maxPacketSize) {\r\n            const windowAdjustMessage = new connectionMessages_1.ChannelWindowAdjustMessage();\r\n            windowAdjustMessage.recipientChannel = this.remoteChannelId;\r\n            windowAdjustMessage.bytesToAdd = SshChannel.initialWindowSize - this.windowSize;\r\n            this.windowSize = SshChannel.initialWindowSize;\r\n            this.session.sendMessage(windowAdjustMessage).catch((e) => {\r\n                (0, trace_1.trace)(`Error sending window adjust message: ${e.message || JSON.stringify(e)}`);\r\n            });\r\n        }\r\n    }\r\n    /* @internal */\r\n    adjustRemoteWindow(bytesToAdd) {\r\n        this.remoteWindowSize += bytesToAdd;\r\n        if (this.openSendingWindowCompletionSource) {\r\n            this.openSendingWindowCompletionSource.resolve(undefined);\r\n        }\r\n    }\r\n    /* @internal */\r\n    handleEof() {\r\n        (0, trace_1.trace)(`${this} EOF received.`);\r\n        this.eofEmitter.fire();\r\n    }\r\n    close(exitStatusOrSignal, errorMessage, cancellation) {\r\n        if (exitStatusOrSignal instanceof Error) {\r\n            const error = exitStatusOrSignal;\r\n            if (!this.localClosed) {\r\n                this.localClosed = true;\r\n                (0, trace_1.trace)(`${this} Closed: ${error.message}`);\r\n                this.closedEmitter.fire(new sshChannelClosedEventArgs_1.SshChannelClosedEventArgs(error));\r\n            }\r\n            this.disposeInternal();\r\n            return;\r\n        }\r\n        if (typeof exitStatusOrSignal === 'number') {\r\n            return this.closeWithStatus(exitStatusOrSignal, errorMessage);\r\n        }\r\n        else if (typeof exitStatusOrSignal === 'string') {\r\n            return this.closeWithSignal(exitStatusOrSignal, errorMessage, cancellation);\r\n        }\r\n        else {\r\n            return this.closeDefault(exitStatusOrSignal);\r\n        }\r\n    }\r\n    async closeDefault(cancellation) {\r\n        var _a;\r\n        if (!this.remoteClosed && !this.localClosed) {\r\n            this.remoteClosed = true;\r\n            await this.sendSemaphore.wait(cancellation);\r\n            try {\r\n                const closeMessage = new connectionMessages_1.ChannelCloseMessage();\r\n                closeMessage.recipientChannel = this.remoteChannelId;\r\n                await this.session.sendMessage(closeMessage);\r\n            }\r\n            catch (e) {\r\n                // The session was already closed.\r\n            }\r\n            finally {\r\n                this.sendSemaphore.tryRelease();\r\n            }\r\n        }\r\n        if (!this.localClosed) {\r\n            this.localClosed = true;\r\n            const closedMessage = this.raiseClosedEvent();\r\n            (_a = this.requestCompletionSource) === null || _a === void 0 ? void 0 : _a.reject(new errors_1.SshChannelError(closedMessage));\r\n        }\r\n        this.disposeInternal();\r\n    }\r\n    async closeWithStatus(exitStatus, cancellation) {\r\n        if (!this.remoteClosed && !this.localClosed) {\r\n            this.exitStatus = exitStatus;\r\n            const signalMessage = new connectionMessages_1.ChannelSignalMessage();\r\n            signalMessage.recipientChannel = this.remoteChannelId;\r\n            signalMessage.exitStatus = exitStatus;\r\n            await this.session.sendMessage(signalMessage);\r\n        }\r\n        await this.closeDefault(cancellation);\r\n    }\r\n    async closeWithSignal(exitSignal, errorMessage, cancellation) {\r\n        if (!this.remoteClosed && !this.localClosed) {\r\n            this.exitSignal = exitSignal;\r\n            this.exitErrorMessage = errorMessage;\r\n            const signalMessage = new connectionMessages_1.ChannelSignalMessage();\r\n            signalMessage.recipientChannel = this.remoteChannelId;\r\n            signalMessage.exitSignal = exitSignal;\r\n            signalMessage.errorMessage = errorMessage;\r\n            await this.session.sendMessage(signalMessage);\r\n        }\r\n        await this.closeDefault(cancellation);\r\n    }\r\n    /* @internal */\r\n    handleClose() {\r\n        var _a;\r\n        if (!this.localClosed) {\r\n            this.localClosed = true;\r\n            const closedMessage = this.raiseClosedEvent(true);\r\n            (_a = this.requestCompletionSource) === null || _a === void 0 ? void 0 : _a.reject(new errors_1.SshChannelError(closedMessage));\r\n        }\r\n        this.disposeInternal();\r\n    }\r\n    raiseClosedEvent(closedByRemote = false) {\r\n        const metricsMessage = ` (S: ${this.metrics.bytesSent}, R: ${this.metrics.bytesReceived})`;\r\n        const originMessage = closedByRemote ? 'remotely' : 'locally';\r\n        let closedMessage;\r\n        let args;\r\n        if (typeof this.exitStatus !== 'undefined') {\r\n            args = new sshChannelClosedEventArgs_1.SshChannelClosedEventArgs(this.exitStatus);\r\n            closedMessage = `${this} closed ${originMessage}: status=${this.exitStatus}`;\r\n        }\r\n        else if (typeof this.exitSignal !== 'undefined') {\r\n            args = new sshChannelClosedEventArgs_1.SshChannelClosedEventArgs(this.exitSignal, this.exitErrorMessage);\r\n            closedMessage = `${this} closed ${originMessage}: signal=${this.exitSignal} ${this.exitErrorMessage}`;\r\n        }\r\n        else {\r\n            args = new sshChannelClosedEventArgs_1.SshChannelClosedEventArgs();\r\n            closedMessage = `${this} closed ${originMessage}.`;\r\n        }\r\n        (0, trace_1.trace)(closedMessage + metricsMessage);\r\n        this.closedEmitter.fire(args);\r\n        return closedMessage;\r\n    }\r\n    dispose() {\r\n        var _a;\r\n        if (!this.disposed && !this.localClosed) {\r\n            if (!this.remoteClosed) {\r\n                this.remoteClosed = true;\r\n                const closeMessage = new connectionMessages_1.ChannelCloseMessage();\r\n                closeMessage.recipientChannel = this.remoteChannelId;\r\n                this.session.sendMessage(closeMessage).catch((e) => {\r\n                    // The session was already closed, or some other sending error occurred.\r\n                    // The details have already been traced.\r\n                });\r\n            }\r\n            const message = this.session.isClosed ? `${this.session} closed.` : `${this} disposed.`;\r\n            (0, trace_1.trace)(message);\r\n            const args = new sshChannelClosedEventArgs_1.SshChannelClosedEventArgs('SIGABRT', message);\r\n            this.localClosed = true;\r\n            this.closedEmitter.fire(args);\r\n            (_a = this.requestCompletionSource) === null || _a === void 0 ? void 0 : _a.reject(new errors_1.SshChannelError(message));\r\n        }\r\n        this.disposeInternal();\r\n    }\r\n    disposeInternal() {\r\n        var _a;\r\n        if (this.disposed)\r\n            return;\r\n        this.disposed = true;\r\n        (_a = this.requestCompletionSource) === null || _a === void 0 ? void 0 : _a.reject(new errors_1.ObjectDisposedError(this));\r\n        this.connectionService._removeChannel(this);\r\n        this.sendSemaphore.dispose();\r\n    }\r\n    toString() {\r\n        return `SshChannel(Type: ${this.channelType}, Id: ${this.channelId}, RemoteId: ${this.remoteChannelId})`;\r\n    }\r\n}\r\nexports.SshChannel = SshChannel;\r\nSshChannel.sessionChannelType = 'session';\r\nSshChannel.dataPacketSize = 32 * 1024;\r\nSshChannel.initialWindowSize = SshChannel.dataPacketSize * 32;\r\n//# sourceMappingURL=sshChannel.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SshClientSession = void 0;\r\nconst trace_1 = require(\"./trace\");\r\nconst sshSession_1 = require(\"./sshSession\");\r\nconst transportMessages_1 = require(\"./messages/transportMessages\");\r\nconst sshAuthenticatingEventArgs_1 = require(\"./events/sshAuthenticatingEventArgs\");\r\nconst promiseCompletionSource_1 = require(\"./util/promiseCompletionSource\");\r\nconst cancellation_1 = require(\"./util/cancellation\");\r\nconst sshSessionConfiguration_1 = require(\"./sshSessionConfiguration\");\r\nconst authenticationService_1 = require(\"./services/authenticationService\");\r\nconst connectionService_1 = require(\"./services/connectionService\");\r\nconst errors_1 = require(\"./errors\");\r\n/**\r\n * The client side of an SSH session. Extends the base `SshSession` class to\r\n * support client authentication.\r\n */\r\nclass SshClientSession extends sshSession_1.SshSession {\r\n    constructor(config) {\r\n        super(config, true);\r\n        this.serviceRequests = new Map();\r\n        this.clientAuthCompletion = null;\r\n    }\r\n    /**\r\n     * Attempts to authenticate both the server and client.\r\n     *\r\n     * This method must be called only after encrypting the session. It is equivalent\r\n     * to calling both `authenticateServer()` and `authenticateClient()` and waiting on\r\n     * both results.\r\n     *\r\n     * @returns `true` if authentication succeeded, `false` if it failed.\r\n     */\r\n    async authenticate(clientCredentials, cancellation) {\r\n        const serverAuthenticated = await this.authenticateServer(cancellation);\r\n        if (!serverAuthenticated) {\r\n            return false;\r\n        }\r\n        const clientAuthenticated = await this.authenticateClient(clientCredentials, cancellation);\r\n        if (!clientAuthenticated) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Triggers server authentication by invoking the `authenticating` event with\r\n     * the verified server host key.\r\n     *\r\n     * This method must be called only after encrypting the session. It does not wait for any\r\n     * further message exchange with the server, since the server host key would have already\r\n     * been obtained during the key-exchange.\r\n     *\r\n     * @returns `true` if authentication succeeded, `false` if it failed.\r\n     */\r\n    async authenticateServer(cancellation) {\r\n        if (!(this.kexService && this.kexService.hostKey)) {\r\n            throw new Error('Encrypt the session before authenticating.');\r\n        }\r\n        try {\r\n            // Raise an Authenticating event that allows handlers to do verification\r\n            // of the host key and return a principal for the server.\r\n            this.principal = await this.raiseAuthenticatingEvent(new sshAuthenticatingEventArgs_1.SshAuthenticatingEventArgs(sshAuthenticatingEventArgs_1.SshAuthenticationType.serverPublicKey, {\r\n                publicKey: this.kexService.hostKey,\r\n            }, cancellation));\r\n        }\r\n        catch (e) {\r\n            if (!(e instanceof Error))\r\n                throw e;\r\n            (0, trace_1.trace)('Error while authenticating server: ' + e.message);\r\n            throw e;\r\n        }\r\n        if (!this.principal) {\r\n            await this.close(transportMessages_1.SshDisconnectReason.hostKeyNotVerifiable, 'Server authentication failed.');\r\n            (0, trace_1.trace)(`${this} server authentication failed.`);\r\n            return false;\r\n        }\r\n        (0, trace_1.trace)(`${this} server authenticated.`);\r\n        return true;\r\n    }\r\n    /* @internal */\r\n    authenticateClient(credentials, callbackOrCancellation, cancellation) {\r\n        if (!credentials) {\r\n            throw new TypeError('A credentials object is required.');\r\n        }\r\n        if (typeof callbackOrCancellation === 'function') {\r\n            return this.authenticateClientWithCompletion(credentials, callbackOrCancellation, cancellation);\r\n        }\r\n        else {\r\n            return new Promise(async (resolve, reject) => {\r\n                await this.authenticateClientWithCompletion(credentials, (err, result) => {\r\n                    if (err)\r\n                        reject(err);\r\n                    else\r\n                        resolve(result);\r\n                }, callbackOrCancellation);\r\n            });\r\n        }\r\n    }\r\n    async authenticateClientWithCompletion(credentials, callback, cancellation) {\r\n        this.clientAuthCompletion = new promiseCompletionSource_1.PromiseCompletionSource();\r\n        this.clientAuthCompletion.promise.then((result) => callback(undefined, result), (err) => callback(err));\r\n        if (cancellation) {\r\n            if (cancellation.isCancellationRequested)\r\n                throw new cancellation_1.CancellationError();\r\n            cancellation.onCancellationRequested((e) => {\r\n                if (this.clientAuthCompletion) {\r\n                    this.clientAuthCompletion.reject(new cancellation_1.CancellationError());\r\n                }\r\n            });\r\n        }\r\n        let authService = this.getService(authenticationService_1.AuthenticationService);\r\n        if (!authService) {\r\n            const serviceRequestMessage = new transportMessages_1.ServiceRequestMessage();\r\n            serviceRequestMessage.serviceName = authenticationService_1.AuthenticationService.serviceName;\r\n            await this.sendMessage(serviceRequestMessage, cancellation);\r\n            // Assume the service request is accepted, without waiting for an accept message.\r\n            // (If not, the following auth requests will fail anyway.)\r\n            authService = this.activateService(authenticationService_1.AuthenticationService);\r\n        }\r\n        await authService.authenticateClient(credentials, cancellation);\r\n    }\r\n    /* @internal */\r\n    onAuthenticationComplete(success) {\r\n        if (success) {\r\n            (0, trace_1.trace)(`${this} client authenticated.`);\r\n        }\r\n        else {\r\n            (0, trace_1.trace)(`${this} client authentication failed.`);\r\n        }\r\n        if (this.clientAuthCompletion) {\r\n            this.clientAuthCompletion.resolve(success);\r\n            this.clientAuthCompletion = null;\r\n        }\r\n    }\r\n    /**\r\n     * Sends a request for a service and waits for a response.\r\n     *\r\n     * @param serviceName Name of the service to be requested.\r\n     * @param cancellation Optional cancellation token.\r\n     * @returns A promise that resolves when the service request has been accepted.\r\n     *\r\n     * If the server does not accept the service request, it will disconnect the session.\r\n     */\r\n    async requestService(serviceName, cancellation) {\r\n        let sendRequest = false;\r\n        let completion = this.serviceRequests.get(serviceName);\r\n        if (!completion) {\r\n            completion = new promiseCompletionSource_1.PromiseCompletionSource();\r\n            this.serviceRequests.set(serviceName, completion);\r\n            sendRequest = true;\r\n        }\r\n        if (sendRequest) {\r\n            const requestMessage = new transportMessages_1.ServiceRequestMessage();\r\n            requestMessage.serviceName = serviceName;\r\n            await this.sendMessage(requestMessage, cancellation);\r\n        }\r\n        await completion.promise;\r\n    }\r\n    /* @internal */\r\n    async handleServiceAcceptMessage(message, cancellation) {\r\n        const completion = this.serviceRequests.get(message.serviceName);\r\n        completion === null || completion === void 0 ? void 0 : completion.resolve(true);\r\n    }\r\n    async openChannel(channelTypeOrOpenMessageOrCancellation, initialRequestOrCancellation, cancellation) {\r\n        if (!this.connectionService) {\r\n            // Authentication must have been skipped, meaning there was no\r\n            // connection service request sent yet. Send it now, and assume\r\n            // it is accepted without waiting for a response.\r\n            const serviceRequestMessage = new transportMessages_1.ServiceRequestMessage();\r\n            serviceRequestMessage.serviceName = connectionService_1.ConnectionService.serviceName;\r\n            await this.sendMessage(serviceRequestMessage, cancellation);\r\n        }\r\n        return await super.openChannel(channelTypeOrOpenMessageOrCancellation, initialRequestOrCancellation, cancellation);\r\n    }\r\n    /* @internal */\r\n    handleDisconnected() {\r\n        if (this.reconnecting) {\r\n            this.reconnecting = false;\r\n            return false;\r\n        }\r\n        return super.handleDisconnected();\r\n    }\r\n    /**\r\n     * Call instead of `connect()` to reconnect to a prior session instead of connecting\r\n     * a new session.\r\n     * @param stream A new stream that has just (re-) connected to the server.\r\n     * @param cancellation Optional cancellation token.\r\n     * @returns True if reconnect succeeded, false if the server declined the reconnect\r\n     * request or reconnect session validation failed. In the case of a false return value,\r\n     * retrying is unlikely to succeed.\r\n     * @throws {SshConnectionError} There was a problem connecting to or communicating with\r\n     * the server; retrying may still succeed if connectivity is restored.\r\n     * @throws {SshReconnectError} Reconnect failed for some reason other than a communication\r\n     * issue: see the `failureReason` property of the error. Retrying is unlikely to succeed,\r\n     * unless the specific error condition can be addressed.\r\n     */\r\n    async reconnect(stream, cancellation) {\r\n        if (this.isClosed) {\r\n            throw new errors_1.ObjectDisposedError(this);\r\n        }\r\n        else if (this.isConnected) {\r\n            throw new Error('Already connected.');\r\n        }\r\n        if (!this.protocol) {\r\n            throw new Error('The session was never previously connected.');\r\n        }\r\n        if (this.reconnecting) {\r\n            throw new Error('Already reconnecting.');\r\n        }\r\n        this.reconnecting = true;\r\n        try {\r\n            await this.reconnectInternal(stream, cancellation);\r\n        }\r\n        finally {\r\n            this.reconnecting = false;\r\n        }\r\n    }\r\n    async reconnectInternal(stream, cancellation) {\r\n        var _a, _b, _c, _d, _e, _f;\r\n        const previousSessionId = this.sessionId;\r\n        const previousProtocolInstance = this.protocol;\r\n        const previousHostKey = (_a = this.kexService) === null || _a === void 0 ? void 0 : _a.hostKey;\r\n        if (!previousSessionId ||\r\n            !previousProtocolInstance ||\r\n            !this.kexService ||\r\n            !previousHostKey ||\r\n            !((_b = previousProtocolInstance.extensions) === null || _b === void 0 ? void 0 : _b.has(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionReconnect))) {\r\n            throw new Error('Reconnect was not enabled for this session.');\r\n        }\r\n        let newSessionId;\r\n        try {\r\n            // Reconnecting will temporarily create a new session ID.\r\n            this.sessionId = null;\r\n            await this.connect(stream, cancellation);\r\n            if (!this.sessionId || !this.algorithms || !this.algorithms.signer) {\r\n                throw new Error('Session is not encrypted.');\r\n            }\r\n            // Ensure the client is not reconnecting to a different server.\r\n            const newHostKey = this.kexService.hostKey;\r\n            const newHostPublicKey = !newHostKey ? null : await newHostKey.getPublicKeyBytes();\r\n            const previousHostPublicKey = await previousHostKey.getPublicKeyBytes();\r\n            if (!newHostPublicKey ||\r\n                !previousHostPublicKey ||\r\n                !newHostPublicKey.equals(previousHostPublicKey)) {\r\n                const message = 'The server host key is different.';\r\n                (0, trace_1.trace)(`Reconnection failed: ${message}`);\r\n                throw new errors_1.SshReconnectError(message, transportMessages_1.SshReconnectFailureReason.differentServerHostKey);\r\n            }\r\n            newSessionId = this.sessionId;\r\n        }\r\n        catch (e) {\r\n            // Restore the previous protocol instance so reconnect may be attempted again.\r\n            this.protocol = previousProtocolInstance;\r\n            super.handleDisconnected();\r\n            throw e;\r\n        }\r\n        finally {\r\n            // Restore the previous session ID and host key for the reconnected session.\r\n            this.sessionId = previousSessionId;\r\n            this.kexService.hostKey = previousHostKey;\r\n        }\r\n        const reconnectToken = await this.createReconnectToken(previousSessionId, newSessionId);\r\n        const reconnectRequest = new transportMessages_1.SessionReconnectRequestMessage();\r\n        reconnectRequest.requestType = \"session-reconnect@microsoft.com\" /* sessionReconnect */;\r\n        reconnectRequest.clientReconnectToken = reconnectToken;\r\n        reconnectRequest.lastReceivedSequenceNumber = previousProtocolInstance.lastIncomingSequence;\r\n        reconnectRequest.wantReply = true;\r\n        const response = await this.requestResponse(reconnectRequest, transportMessages_1.SessionReconnectResponseMessage, transportMessages_1.SessionReconnectFailureMessage, cancellation);\r\n        if (response instanceof transportMessages_1.SessionReconnectFailureMessage) {\r\n            const reason = (_c = response.reasonCode) !== null && _c !== void 0 ? _c : transportMessages_1.SshReconnectFailureReason.unknownServerFailure;\r\n            const message = (_d = response.description) !== null && _d !== void 0 ? _d : 'The server rejected the reconnect request.';\r\n            (0, trace_1.trace)(`Reconnection failed: ${message}`);\r\n            // Restore the previous protocol instance so reconnect may be attempted again.\r\n            this.protocol = previousProtocolInstance;\r\n            throw new errors_1.SshReconnectError(message, reason);\r\n        }\r\n        if (!this.verifyReconnectToken(previousSessionId, newSessionId, (_e = response.serverReconnectToken) !== null && _e !== void 0 ? _e : Buffer.alloc(0))) {\r\n            const message = 'The reconnect token provided by the server was invalid.';\r\n            (0, trace_1.trace)(`Reconnection failed: ${message}`);\r\n            throw new errors_1.SshReconnectError(message, transportMessages_1.SshReconnectFailureReason.invalidServerReconnectToken);\r\n        }\r\n        (0, trace_1.trace)('Reconnect request was accepted by the server.');\r\n        // Re-send lost messages.\r\n        const messagesToResend = previousProtocolInstance.getSentMessages(((_f = response.lastReceivedSequenceNumber) !== null && _f !== void 0 ? _f : 0) + 1);\r\n        if (!messagesToResend) {\r\n            const message = 'Client is unable to re-send messages requested by the server.';\r\n            (0, trace_1.trace)(`Reconnection failed: ${message}`);\r\n            throw new errors_1.SshReconnectError(message, transportMessages_1.SshReconnectFailureReason.clientDroppedMessages);\r\n        }\r\n        let count = 0;\r\n        for (let message of messagesToResend) {\r\n            await this.sendMessage(message, cancellation);\r\n            count++;\r\n        }\r\n        // Now the session is fully reconnected!\r\n        previousProtocolInstance.dispose();\r\n        this.metrics.addReconnection();\r\n        (0, trace_1.trace)(`Reconnected. Re-sent ${count} dropped messages.`);\r\n    }\r\n    dispose() {\r\n        if (this.clientAuthCompletion) {\r\n            this.clientAuthCompletion.reject(new errors_1.ObjectDisposedError(this));\r\n        }\r\n        super.dispose();\r\n    }\r\n}\r\nexports.SshClientSession = SshClientSession;\r\n//# sourceMappingURL=sshClientSession.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SshRpcMessageStream = void 0;\r\nconst rpc = require(\"vscode-jsonrpc\");\r\nconst buffer_1 = require(\"buffer\");\r\nconst sshData_1 = require(\"./io/sshData\");\r\nconst contentLengthHeaderPrefix = 'Content-Length: ';\r\nconst headersSeparator = '\\r\\n\\r\\n';\r\nclass SshRpcMessageReader {\r\n    constructor(channel) {\r\n        this.channel = channel;\r\n        this.errorEmitter = new rpc.Emitter();\r\n        this.closeEmitter = new rpc.Emitter();\r\n        this.partialMessageEmitter = new rpc.Emitter();\r\n        this.callback = null;\r\n        this.messageBuffer = new sshData_1.SshDataWriter(buffer_1.Buffer.alloc(1024));\r\n        this.headersLength = null;\r\n        this.messageLength = null;\r\n        this.onError = this.errorEmitter.event;\r\n        this.onClose = this.closeEmitter.event;\r\n        this.onPartialMessage = this.partialMessageEmitter.event;\r\n        this.eventRegistration = this.channel.onDataReceived(this.onDataReceived.bind(this));\r\n        this.channel.onClosed((e) => {\r\n            if (e.error) {\r\n                this.errorEmitter.fire(e.error);\r\n            }\r\n            // Note: we always want to fire a close event to avoid the rpc connection\r\n            // to be used. After the event any usage of the rpc message connection will\r\n            // throw an error with this code: ConnectionErrors.Closed\r\n            this.closeEmitter.fire();\r\n        });\r\n    }\r\n    listen(callback) {\r\n        this.callback = callback;\r\n    }\r\n    dispose() {\r\n        if (this.eventRegistration) {\r\n            this.eventRegistration.dispose();\r\n        }\r\n    }\r\n    onDataReceived(data) {\r\n        this.messageBuffer.write(data);\r\n        this.channel.adjustWindow(data.length);\r\n        // In case of recursion, the `data` might have already been a slice of the message buffer,\r\n        // but it could have been invalidated by expansion during write() above.\r\n        data = this.messageBuffer.toBuffer();\r\n        if (this.messageLength === null) {\r\n            const headersEnd = data.indexOf(headersSeparator);\r\n            if (headersEnd < 0) {\r\n                return; // Wait for more data.\r\n            }\r\n            const headers = data.slice(0, headersEnd).toString();\r\n            if (!headers.startsWith(contentLengthHeaderPrefix)) {\r\n                throw new Error(`Message does not start with JSON-RPC headers.\\n${headers}`);\r\n            }\r\n            this.headersLength = headersEnd + headersSeparator.length;\r\n            this.messageLength = parseInt(headers.substr(contentLengthHeaderPrefix.length, headersEnd - contentLengthHeaderPrefix.length), 10);\r\n        }\r\n        const position = this.messageBuffer.position;\r\n        const totalLength = this.headersLength + this.messageLength;\r\n        if (position >= totalLength) {\r\n            if (this.callback) {\r\n                const messageJson = data.slice(this.headersLength, totalLength).toString();\r\n                let message;\r\n                try {\r\n                    message = JSON.parse(messageJson);\r\n                }\r\n                catch (e) {\r\n                    if (!(e instanceof Error))\r\n                        throw e;\r\n                    throw new Error(`Failed to parse JSON-RPC message: ${e.message}\\n${messageJson}`);\r\n                }\r\n                this.callback(message);\r\n            }\r\n            this.messageLength = null;\r\n            this.messageBuffer.position = 0;\r\n            if (position > totalLength) {\r\n                // Recursively receive the remaining data, which will cause it\r\n                // to be copied to the beginning of the buffer;\r\n                this.onDataReceived(data.slice(totalLength));\r\n            }\r\n        }\r\n    }\r\n}\r\nclass SshRpcMessageWriter {\r\n    constructor(channel) {\r\n        this.channel = channel;\r\n        this.errorEmitter = new rpc.Emitter();\r\n        this.closeEmitter = new rpc.Emitter();\r\n        this.onError = this.errorEmitter.event;\r\n        this.onClose = this.closeEmitter.event;\r\n        this.channel.onClosed((e) => {\r\n            if (e.error) {\r\n                this.errorEmitter.fire([\r\n                    e.error,\r\n                    (e.errorMessage && { jsonrpc: e.errorMessage }) || undefined,\r\n                    e.exitStatus,\r\n                ]);\r\n            }\r\n            this.closeEmitter.fire();\r\n        });\r\n    }\r\n    write(message) {\r\n        const messageJson = JSON.stringify(message);\r\n        const messageData = buffer_1.Buffer.from(messageJson);\r\n        const headerData = buffer_1.Buffer.from(contentLengthHeaderPrefix + messageData.length + headersSeparator);\r\n        const data = buffer_1.Buffer.alloc(headerData.length + messageData.length);\r\n        headerData.copy(data, 0);\r\n        messageData.copy(data, headerData.length);\r\n        this.channel.send(data).catch((e) => {\r\n            this.errorEmitter.fire([e, undefined, undefined]);\r\n        });\r\n    }\r\n    dispose() { }\r\n}\r\nclass SshRpcMessageStream {\r\n    constructor(channel) {\r\n        this.reader = new SshRpcMessageReader(channel);\r\n        this.writer = new SshRpcMessageWriter(channel);\r\n    }\r\n}\r\nexports.SshRpcMessageStream = SshRpcMessageStream;\r\n//# sourceMappingURL=sshRpcMessageStream.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SshServerSession = void 0;\r\nconst sshSession_1 = require(\"./sshSession\");\r\nconst vscode_jsonrpc_1 = require(\"vscode-jsonrpc\");\r\nconst transportMessages_1 = require(\"./messages/transportMessages\");\r\nconst errors_1 = require(\"./errors\");\r\nconst sshSessionConfiguration_1 = require(\"./sshSessionConfiguration\");\r\nconst trace_1 = require(\"./trace\");\r\n/**\r\n * The server side of an SSH session. Extends the base `SshSession` class\r\n * to support host authentication.\r\n */\r\nclass SshServerSession extends sshSession_1.SshSession {\r\n    constructor(config, reconnectableSessions) {\r\n        super(config, false);\r\n        this.reconnectedEmitter = new vscode_jsonrpc_1.Emitter();\r\n        this.onReconnected = this.reconnectedEmitter.event;\r\n        /**\r\n         * Gets or sets credentials and/or credential callbacks for authenticating the session.\r\n         */\r\n        this.credentials = { publicKeys: [] };\r\n        const enableReconnect = config.protocolExtensions.includes(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionReconnect);\r\n        if (enableReconnect && !reconnectableSessions) {\r\n            throw new Error('When reconnect is enabled, server sessions require a reference to a ' +\r\n                'shared collection to track reconnectable sessions.');\r\n        }\r\n        else if (!enableReconnect && reconnectableSessions) {\r\n            throw new Error('When reconnect is not enabled, the reconnectable sessions collection ' +\r\n                'is not applicable.');\r\n        }\r\n        this.reconnectableSessions = reconnectableSessions;\r\n    }\r\n    /* @internal */\r\n    async handleServiceRequestMessage(message, cancellation) {\r\n        const service = this.activateService(message.serviceName);\r\n        if (service) {\r\n            const acceptMessage = new transportMessages_1.ServiceAcceptMessage();\r\n            acceptMessage.serviceName = message.serviceName;\r\n            await this.sendMessage(acceptMessage, cancellation);\r\n        }\r\n        else {\r\n            throw new errors_1.SshConnectionError(`Service \"${message.serviceName}\" not available.`, transportMessages_1.SshDisconnectReason.serviceNotAvailable);\r\n        }\r\n    }\r\n    /* @internal */\r\n    async handleRequestMessage(message, cancellation) {\r\n        var _a;\r\n        if (message.requestType === \"session-reconnect@microsoft.com\" /* sessionReconnect */ &&\r\n            ((_a = this.config.protocolExtensions) === null || _a === void 0 ? void 0 : _a.includes(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionReconnect))) {\r\n            const reconnectRequest = message.convertTo(new transportMessages_1.SessionReconnectRequestMessage());\r\n            await this.reconnect(reconnectRequest, cancellation);\r\n            // reconnect() handles sending the response message.\r\n            return;\r\n        }\r\n        await super.handleRequestMessage(message, cancellation);\r\n    }\r\n    /* @internal */\r\n    async enableReconnect(cancellation) {\r\n        await super.enableReconnect(cancellation);\r\n        if (!this.reconnectableSessions.includes(this)) {\r\n            this.reconnectableSessions.push(this);\r\n        }\r\n    }\r\n    /* @internal */\r\n    handleDisconnected() {\r\n        if (this.reconnecting) {\r\n            // Prevent closing the session while reconnecting.\r\n            return true;\r\n        }\r\n        return super.handleDisconnected();\r\n    }\r\n    /**\r\n     * Attempts to reconnect the client to a disconnected server session.\r\n     *\r\n     * If reconnection is successful, the current server session is disposed because the client\r\n     * gets reconnected to a different server session.\r\n     */\r\n    /* @internal */\r\n    async reconnect(reconnectRequest, cancellation) {\r\n        var _a, _b, _c;\r\n        if (!this.reconnectableSessions) {\r\n            throw new Error('Disconnected sessions collection ' +\r\n                'should have been initialied when reconnect is enabled.');\r\n        }\r\n        // Try to find the requested server session in the list of available disconnected\r\n        // server sessions, by validating the reconnect token.\r\n        let reconnectSession;\r\n        for (let reconnectableSession of this.reconnectableSessions) {\r\n            if (reconnectableSession !== this &&\r\n                (await this.verifyReconnectToken(reconnectableSession.sessionId, this.sessionId, (_a = reconnectRequest.clientReconnectToken) !== null && _a !== void 0 ? _a : Buffer.alloc(0)))) {\r\n                reconnectSession = reconnectableSession;\r\n                this.reconnectableSessions.splice(this.reconnectableSessions.indexOf(reconnectSession), 1);\r\n                break;\r\n            }\r\n        }\r\n        if (!reconnectSession || reconnectSession.isClosed) {\r\n            const message = 'Requested reconnect session was not found or ' +\r\n                'the reconnect token provided by the client was invalid.';\r\n            (0, trace_1.trace)(`Reconnect failed: ${message}`);\r\n            const failure = new transportMessages_1.SessionReconnectFailureMessage();\r\n            failure.reasonCode = transportMessages_1.SshReconnectFailureReason.sessionNotFound;\r\n            failure.description = message;\r\n            await this.sendMessage(failure, cancellation);\r\n            return;\r\n        }\r\n        const messagesToResend = reconnectSession.protocol.getSentMessages(((_b = reconnectRequest.lastReceivedSequenceNumber) !== null && _b !== void 0 ? _b : 0) + 1);\r\n        if (!messagesToResend) {\r\n            // Messages are not available from requested sequence number.\r\n            // Restore the current session protocol and put the old session back in the collection.\r\n            this.reconnectableSessions.push(reconnectSession);\r\n            const message = 'Server is unable to re-send messages requested by the client.';\r\n            (0, trace_1.trace)(`Reconnect failed: ${message}`);\r\n            const failure = new transportMessages_1.SessionReconnectFailureMessage();\r\n            failure.reasonCode = transportMessages_1.SshReconnectFailureReason.serverDroppedMessages;\r\n            failure.description = message;\r\n            await this.sendMessage(failure, cancellation);\r\n            return;\r\n        }\r\n        const responseMessage = new transportMessages_1.SessionReconnectResponseMessage();\r\n        responseMessage.serverReconnectToken = await this.createReconnectToken(reconnectSession.sessionId, this.sessionId);\r\n        responseMessage.lastReceivedSequenceNumber = reconnectSession.protocol.lastIncomingSequence;\r\n        await this.sendMessage(responseMessage, cancellation);\r\n        try {\r\n            reconnectSession.reconnecting = true;\r\n            // Ensure the old connection is disconnected before switching over to the new one.\r\n            (_c = reconnectSession.protocol) === null || _c === void 0 ? void 0 : _c.dispose();\r\n            while (reconnectSession.isConnected) {\r\n                await new Promise((resolve) => setTimeout(() => resolve(), 5));\r\n            }\r\n            // Move this session's protocol instance over to the reconnected session.\r\n            reconnectSession.protocol = this.protocol;\r\n            reconnectSession.protocol.kexService = reconnectSession.kexService;\r\n            this.protocol = undefined;\r\n            // Re-send the lost messages that the client requested.\r\n            for (let message of messagesToResend) {\r\n                await reconnectSession.sendMessage(message, cancellation);\r\n            }\r\n            // Now this server session is invalid because the client reconnected to another one.\r\n            this.dispose();\r\n        }\r\n        finally {\r\n            reconnectSession.reconnecting = false;\r\n        }\r\n        this.reconnectableSessions.push(reconnectSession);\r\n        reconnectSession.metrics.addReconnection();\r\n        // Restart the message loop for the reconnected session.\r\n        reconnectSession.processMessages().catch((e) => {\r\n            (0, trace_1.trace)(`Unhandled error processing messages: ${e.message || JSON.stringify(e)}`);\r\n        });\r\n        (0, trace_1.trace)(`Session reconnected. Re-sent ${messagesToResend.length} dropped messages.`);\r\n        // Notify event listeners about the successful reconnection.\r\n        reconnectSession.reconnectedEmitter.fire();\r\n    }\r\n    dispose() {\r\n        if (this.reconnectableSessions) {\r\n            const index = this.reconnectableSessions.indexOf(this);\r\n            if (index >= 0) {\r\n                this.reconnectableSessions.splice(index, 1);\r\n            }\r\n        }\r\n        super.dispose();\r\n    }\r\n}\r\nexports.SshServerSession = SshServerSession;\r\n//# sourceMappingURL=sshServerSession.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SshSession = void 0;\r\nconst trace_1 = require(\"./trace\");\r\nconst buffer_1 = require(\"buffer\");\r\nconst vscode_jsonrpc_1 = require(\"vscode-jsonrpc\");\r\nconst sshSessionConfiguration_1 = require(\"./sshSessionConfiguration\");\r\nconst sshChannel_1 = require(\"./sshChannel\");\r\nconst sshVersionInfo_1 = require(\"./sshVersionInfo\");\r\nconst sshProtocol_1 = require(\"./io/sshProtocol\");\r\nconst keyExchangeService_1 = require(\"./services/keyExchangeService\");\r\nconst serviceActivation_1 = require(\"./services/serviceActivation\");\r\nconst connectionService_1 = require(\"./services/connectionService\");\r\nconst authenticationService_1 = require(\"./services/authenticationService\");\r\nconst kexMessages_1 = require(\"./messages/kexMessages\");\r\nconst connectionMessages_1 = require(\"./messages/connectionMessages\");\r\nconst authenticationMessages_1 = require(\"./messages/authenticationMessages\");\r\nconst transportMessages_1 = require(\"./messages/transportMessages\");\r\nconst sessionMetrics_1 = require(\"./metrics/sessionMetrics\");\r\nconst promiseCompletionSource_1 = require(\"./util/promiseCompletionSource\");\r\nconst sshSessionClosedEventArgs_1 = require(\"./events/sshSessionClosedEventArgs\");\r\nconst sshRequestEventArgs_1 = require(\"./events/sshRequestEventArgs\");\r\nconst sshAlgorithms_1 = require(\"./algorithms/sshAlgorithms\");\r\nconst cancellation_1 = require(\"./util/cancellation\");\r\nconst errors_1 = require(\"./errors\");\r\nconst semaphore_1 = require(\"./util/semaphore\");\r\n/**\r\n * Base class for an SSH server or client connection; coordinates high-level SSH\r\n * protocol details and dispatches messages to registered internal services.\r\n * Enables opening and accepting `SshChannel` instances.\r\n */\r\nclass SshSession {\r\n    constructor(config, isClientSession) {\r\n        this.config = config;\r\n        this.remoteVersion = null;\r\n        this.activatedServices = new Map();\r\n        this.connectionService = null;\r\n        this.requestHandler = null;\r\n        this.blockedMessages = [];\r\n        this.blockedMessagesSemaphore = new semaphore_1.Semaphore(1);\r\n        this.connected = false;\r\n        this.disposed = false;\r\n        /**\r\n         * Gets an object that reports current and cumulative measurements about the session.\r\n         */\r\n        this.metrics = new sessionMetrics_1.SessionMetrics();\r\n        /* @internal */\r\n        this.reconnecting = false;\r\n        this.sessionId = null;\r\n        this.principalValue = null;\r\n        this.authenticatingEmitter = new vscode_jsonrpc_1.Emitter();\r\n        /**\r\n         * Event that is raised when a client or server is requesting authentication.\r\n         *\r\n         * See `SshAuthenticationType` for a description of the different authentication\r\n         * methods and how they map to the event-args object.\r\n         *\r\n         * After validating the credentials, the event handler must set the\r\n         * `SshAuthenticatingEventArgs.authenticationPromise` property to a task that\r\n         * resolves to a principal object to indicate successful authentication. That principal will\r\n         * then be associated with the sesssion as the `principal` property.\r\n         */\r\n        this.onAuthenticating = this.authenticatingEmitter.event;\r\n        this.closedEmitter = new vscode_jsonrpc_1.Emitter();\r\n        this.onClosed = this.closedEmitter.event;\r\n        this.disconnectedEmitter = new vscode_jsonrpc_1.Emitter();\r\n        this.onDisconnected = this.disconnectedEmitter.event;\r\n        this.serviceActivatedEmitter = new vscode_jsonrpc_1.Emitter();\r\n        this.onServiceActivated = this.serviceActivatedEmitter.event;\r\n        this.channelOpeningEmitter = new vscode_jsonrpc_1.Emitter();\r\n        this.onChannelOpening = this.channelOpeningEmitter.event;\r\n        this.requestEmitter = new vscode_jsonrpc_1.Emitter();\r\n        this.onRequest = this\r\n            .requestEmitter.event;\r\n        if (!config)\r\n            throw new TypeError('Session configuration is required.');\r\n        if (!config.keyExchangeAlgorithms.find((a) => !!a)) {\r\n            if (config.encryptionAlgorithms.length > 0 &&\r\n                config.encryptionAlgorithms.indexOf(null) < 0) {\r\n                throw new Error('Encryption requires a key-exchange algorithm to be configured.');\r\n            }\r\n            else if (config.hmacAlgorithms.length > 0 && config.hmacAlgorithms.indexOf(null) < 0) {\r\n                throw new Error('HMAC requires a key-exchange algorithm to be configured.');\r\n            }\r\n            else if (config.publicKeyAlgorithms.length > 0 &&\r\n                config.publicKeyAlgorithms.indexOf(null) < 0) {\r\n                throw new Error('Host authentication requires a key-exchange algorithm to be configured.');\r\n            }\r\n            // No key exchange, no encryption, no HMAC.\r\n            this.kexService = null;\r\n        }\r\n        else {\r\n            this.kexService = new keyExchangeService_1.KeyExchangeService(this, isClientSession !== null && isClientSession !== void 0 ? isClientSession : false);\r\n        }\r\n    }\r\n    get algorithms() {\r\n        return this.protocol ? this.protocol.algorithms : null;\r\n    }\r\n    /**\r\n     * Gets an object containing claims about the server or client on the\r\n     * other end of the session, or `null` if the session is not authenticated.\r\n     *\r\n     * This property is initially `null` for an unauthenticated session. On\r\n     * successful authentication, the session Authenticating event handler\r\n     * provides a Task that returns a principal that is stored here.\r\n     */\r\n    get principal() {\r\n        return this.principalValue;\r\n    }\r\n    /* @internal */\r\n    set principal(value) {\r\n        this.principalValue = value;\r\n    }\r\n    get isConnected() {\r\n        return this.connected;\r\n    }\r\n    get isClosed() {\r\n        return this.disposed;\r\n    }\r\n    get services() {\r\n        return [...this.activatedServices.values()];\r\n    }\r\n    get channels() {\r\n        var _a, _b;\r\n        return (_b = (_a = this.connectionService) === null || _a === void 0 ? void 0 : _a.channels) !== null && _b !== void 0 ? _b : [];\r\n    }\r\n    get protocolExtensions() {\r\n        var _a;\r\n        return ((_a = this.protocol) === null || _a === void 0 ? void 0 : _a.extensions) || null;\r\n    }\r\n    /**\r\n     * Gets an activated service instance by type.\r\n     *\r\n     * @returns The service instance, or `null` if the service has not been activated.\r\n     */\r\n    getService(serviceType) {\r\n        const service = this.activatedServices.get(serviceType);\r\n        return service ? service : null;\r\n    }\r\n    /* @internal */\r\n    activateService(serviceTypeOrName) {\r\n        let serviceType;\r\n        if (typeof serviceTypeOrName === 'function') {\r\n            serviceType = serviceTypeOrName;\r\n        }\r\n        else {\r\n            let serviceName = serviceTypeOrName;\r\n            serviceType = (0, serviceActivation_1.findService)(this.config.services, (a) => a.serviceRequest === serviceName);\r\n            if (!serviceType) {\r\n                return null;\r\n            }\r\n        }\r\n        let activatedService = this.activatedServices.get(serviceType);\r\n        if (!activatedService) {\r\n            if (!this.config.services.has(serviceType)) {\r\n                throw new Error(`Service type not configured: ${serviceType.name}`);\r\n            }\r\n            const serviceConfig = this.config.services.get(serviceType);\r\n            activatedService = new serviceType(this, serviceConfig);\r\n            // This service is maintained in a separate member because it is accessed frequently.\r\n            if (serviceType === connectionService_1.ConnectionService) {\r\n                this.connectionService = activatedService;\r\n            }\r\n            this.activatedServices.set(serviceType, activatedService);\r\n            this.serviceActivatedEmitter.fire(activatedService);\r\n        }\r\n        return activatedService;\r\n    }\r\n    async connect(stream, cancellation) {\r\n        if (!stream)\r\n            throw new TypeError('A session stream is required.');\r\n        if (this.disposed)\r\n            throw new errors_1.ObjectDisposedError(this);\r\n        if (!this.connectPromise) {\r\n            this.connectPromise = this.doConnect(stream, cancellation);\r\n        }\r\n        await this.connectPromise;\r\n    }\r\n    async doConnect(stream, cancellation) {\r\n        (0, trace_1.trace)(`${this} ${this.reconnecting ? 're' : ''}connecting...`);\r\n        this.protocol = new sshProtocol_1.SshProtocol(stream, this.config, this.metrics);\r\n        this.protocol.kexService = this.kexService;\r\n        await this.exchangeVersions(cancellation);\r\n        if (this.kexService) {\r\n            await this.encrypt(cancellation);\r\n        }\r\n        else {\r\n            // When encrypting, the key-exchange step will wait on the version-exchange.\r\n            // When not encrypting, it must be directly awaited.\r\n            await (0, cancellation_1.withCancellation)(this.versionExchangePromise, cancellation);\r\n            this.connected = true;\r\n        }\r\n        this.processMessages().catch((e) => {\r\n            (0, trace_1.trace)(`Unhandled error processing messages: ${e.message || JSON.stringify(e)}`);\r\n        });\r\n    }\r\n    async exchangeVersions(cancellation) {\r\n        const writePromise = this.protocol.writeProtocolVersion(SshSession.localVersion.toString(), cancellation);\r\n        const readPromise = this.protocol.readProtocolVersion(cancellation);\r\n        // Don't wait for and verify the other side's version info yet.\r\n        // Instead save a promise that can be awaited later.\r\n        this.versionExchangePromise = readPromise.then(async (remoteVersion) => {\r\n            (0, trace_1.trace)(`Local version: ${SshSession.localVersion}, remote version: ${remoteVersion}`);\r\n            let errorMessage;\r\n            const remoteVersionInfo = sshVersionInfo_1.SshVersionInfo.tryParse(remoteVersion);\r\n            if (remoteVersionInfo) {\r\n                this.remoteVersion = remoteVersionInfo;\r\n                if (remoteVersionInfo.protocolVersion === '2.0') {\r\n                    return;\r\n                }\r\n                errorMessage =\r\n                    `Remote SSH version ${this.remoteVersion} is not supported. ` +\r\n                        'This library only supports SSH v2.0.';\r\n            }\r\n            else {\r\n                errorMessage = `Could not parse remote SSH version ${remoteVersion}`;\r\n            }\r\n            await this.close(transportMessages_1.SshDisconnectReason.protocolVersionNotSupported, errorMessage, new Error(errorMessage));\r\n        });\r\n        await writePromise;\r\n    }\r\n    async encrypt(cancellation) {\r\n        var _a, _b;\r\n        const protocol = this.protocol;\r\n        if (!protocol)\r\n            throw new errors_1.ObjectDisposedError(this);\r\n        await protocol.considerReExchange(true, cancellation);\r\n        // Ensure the protocol version has been received before receiving any messages.\r\n        await (0, cancellation_1.withCancellation)(this.versionExchangePromise, cancellation);\r\n        this.connected = true;\r\n        let message = null;\r\n        while (!this.isClosed &&\r\n            !((_a = this.protocol) === null || _a === void 0 ? void 0 : _a.algorithms) &&\r\n            !(message instanceof transportMessages_1.DisconnectMessage)) {\r\n            message = await protocol.receiveMessage(cancellation);\r\n            if (!message) {\r\n                break;\r\n            }\r\n            await this.dispatchMessage(message, cancellation);\r\n        }\r\n        if (!((_b = this.protocol) === null || _b === void 0 ? void 0 : _b.algorithms)) {\r\n            throw new errors_1.SshConnectionError('Session closed while encrypting.', transportMessages_1.SshDisconnectReason.connectionLost);\r\n        }\r\n        else if (this.protocol.algorithms.cipher) {\r\n            (0, trace_1.trace)(`${this} encrypted.`);\r\n        }\r\n    }\r\n    /* @internal */\r\n    async processMessages() {\r\n        var _a;\r\n        this.connected = true;\r\n        while (!this.disposed) {\r\n            const protocol = this.protocol;\r\n            if (!protocol) {\r\n                break;\r\n            }\r\n            let message = null;\r\n            try {\r\n                message = await protocol.receiveMessage();\r\n            }\r\n            catch (e) {\r\n                if (!(e instanceof Error))\r\n                    throw e;\r\n                let reason = transportMessages_1.SshDisconnectReason.protocolError;\r\n                if (e instanceof errors_1.SshConnectionError) {\r\n                    reason = (_a = e.reason) !== null && _a !== void 0 ? _a : reason;\r\n                }\r\n                else {\r\n                    (0, trace_1.trace)(`Error receiving message: ${e.message || JSON.stringify(e)}`);\r\n                }\r\n                await this.close(reason, e.message, e);\r\n            }\r\n            if (!message) {\r\n                await this.close(transportMessages_1.SshDisconnectReason.connectionLost, 'Connection lost.');\r\n                break;\r\n            }\r\n            try {\r\n                await this.dispatchMessage(message);\r\n            }\r\n            catch (e) {\r\n                if (!(e instanceof Error))\r\n                    throw e;\r\n                (0, trace_1.trace)(`Error handling ${message}: ${e.message || JSON.stringify(e)}`);\r\n                await this.close(transportMessages_1.SshDisconnectReason.protocolError, e.message, e);\r\n            }\r\n        }\r\n        this.connected = false;\r\n    }\r\n    /**\r\n     * Checks whether the session is in a state that allows requests, such as session requests\r\n     * and open-channel requests.\r\n     *\r\n     * A session with disabled crypto (no key-exchange service) always allows requests. A\r\n     * session with enabled crypto does not allow requests until the first key-exchange has\r\n     * completed (algorithms are negotiated). If the negotiated algorithms enabled encryption,\r\n     * then the session must be authenticated (have a principal) before allowing requests.\r\n     */\r\n    /* @internal */\r\n    get canAcceptRequests() {\r\n        var _a;\r\n        return (!this.kexService ||\r\n            (!!((_a = this.protocol) === null || _a === void 0 ? void 0 : _a.algorithms) && (!this.protocol.algorithms.cipher || !!this.principal)));\r\n    }\r\n    async sendMessage(message, cancellation) {\r\n        var _a, _b;\r\n        if (!message)\r\n            throw new TypeError('Message expected.');\r\n        if (cancellation && cancellation.isCancellationRequested)\r\n            throw new cancellation_1.CancellationError();\r\n        const protocol = this.protocol;\r\n        if (!protocol || this.disposed) {\r\n            throw new errors_1.ObjectDisposedError(this);\r\n        }\r\n        // Delay sending messages if in the middle of a key (re-)exchange.\r\n        if (this.kexService &&\r\n            this.kexService.exchanging &&\r\n            message.messageType > 4 &&\r\n            (message.messageType < 20 || message.messageType > 49)) {\r\n            this.blockedMessages.push(message);\r\n            return;\r\n        }\r\n        await this.blockedMessagesSemaphore.wait(cancellation);\r\n        let result;\r\n        try {\r\n            result = await protocol.sendMessage(message, cancellation);\r\n            this.blockedMessagesSemaphore.release();\r\n        }\r\n        catch (e) {\r\n            this.blockedMessagesSemaphore.release();\r\n            if (e instanceof errors_1.SshConnectionError) {\r\n                const ce = e;\r\n                if (ce.reason === transportMessages_1.SshDisconnectReason.connectionLost &&\r\n                    ((_a = this.protocolExtensions) === null || _a === void 0 ? void 0 : _a.has(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionReconnect))) {\r\n                    // Connection-lost error when reconnect is enabled. Don't throw an error;\r\n                    // the message will remain in the reconnect message cache and will be re-sent\r\n                    // upon reconnection.\r\n                    return;\r\n                }\r\n            }\r\n            if (!(e instanceof Error))\r\n                throw e;\r\n            (0, trace_1.trace)(`Error sending ${message}: ${e.message || JSON.stringify(e)}`);\r\n            throw e;\r\n        }\r\n        if (!result) {\r\n            // Sending failed due to a closed stream, but don't throw when reconnect is enabled.\r\n            // In that case the sent message is buffered and will be re-sent after reconnecting.\r\n            if (!((_b = this.protocolExtensions) === null || _b === void 0 ? void 0 : _b.has(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionReconnect))) {\r\n                throw new errors_1.SshConnectionError('Session disconnected.', transportMessages_1.SshDisconnectReason.connectionLost);\r\n            }\r\n        }\r\n    }\r\n    dispatchMessage(message, cancellation) {\r\n        var _a;\r\n        if (message instanceof connectionMessages_1.ConnectionMessage && this.connectionService) {\r\n            return this.connectionService.handleMessage(message, cancellation);\r\n        }\r\n        else if (message instanceof kexMessages_1.NewKeysMessage) {\r\n            return this.handleNewKeysMessage(message, cancellation);\r\n        }\r\n        else if (message instanceof kexMessages_1.KeyExchangeMessage) {\r\n            return this.handleKeyExchangeMessage(message, cancellation);\r\n        }\r\n        else if (message instanceof authenticationMessages_1.AuthenticationMessage) {\r\n            return (_a = this.getService(authenticationService_1.AuthenticationService)) === null || _a === void 0 ? void 0 : _a.handleMessage(message, cancellation);\r\n        }\r\n        else if (message instanceof transportMessages_1.ServiceRequestMessage) {\r\n            return this.handleServiceRequestMessage(message, cancellation);\r\n        }\r\n        else if (message instanceof transportMessages_1.ServiceAcceptMessage) {\r\n            return this.handleServiceAcceptMessage(message, cancellation);\r\n        }\r\n        else if (message instanceof transportMessages_1.SessionRequestMessage) {\r\n            return this.handleRequestMessage(message, cancellation);\r\n        }\r\n        else if (message instanceof transportMessages_1.SessionRequestSuccessMessage) {\r\n            return this.handleRequestSuccessMessage(message);\r\n        }\r\n        else if (message instanceof transportMessages_1.SessionRequestFailureMessage) {\r\n            return this.handleRequestFailureMessage(message);\r\n        }\r\n        else if (message instanceof transportMessages_1.ExtensionInfoMessage) {\r\n            return this.handleExtensionInfoMessage(message, cancellation);\r\n        }\r\n        else if (message instanceof transportMessages_1.UnimplementedMessage) {\r\n            return this.handleUnimplementedMessage(message, cancellation);\r\n        }\r\n        else if (message instanceof transportMessages_1.DebugMessage) {\r\n            return this.handleDebugMessage(message);\r\n        }\r\n        else {\r\n            // Ignore any other message types.\r\n        }\r\n    }\r\n    /* @internal */\r\n    async handleRequestMessage(message, cancellation) {\r\n        var _a;\r\n        let result = false;\r\n        if (message.requestType === \"initial-channel-request@microsoft.com\" /* initialChannelRequest */ &&\r\n            this.config.protocolExtensions.includes(sshSessionConfiguration_1.SshProtocolExtensionNames.openChannelRequest)) {\r\n            const sessionChannelRequest = message.convertTo(new transportMessages_1.SessionChannelRequestMessage());\r\n            const remoteChannelId = sessionChannelRequest.senderChannel;\r\n            const channel = this.channels.find((c) => c.remoteChannelId === remoteChannelId);\r\n            if (channel && sessionChannelRequest.request) {\r\n                sessionChannelRequest.request.wantReply = false; // Avoid redundant reply\r\n                result = await channel.handleRequest(sessionChannelRequest.request, cancellation);\r\n            }\r\n        }\r\n        else if (message.requestType === \"enable-session-reconnect@microsoft.com\" /* enableSessionReconnect */ &&\r\n            ((_a = this.config.protocolExtensions) === null || _a === void 0 ? void 0 : _a.includes(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionReconnect))) {\r\n            if (!this.protocol.incomingMessagesHaveReconnectInfo) {\r\n                // Starting immediately after this message, all incoming messages include\r\n                // an extra field or two after the payload.\r\n                this.protocol.incomingMessagesHaveReconnectInfo = true;\r\n                this.protocol.incomingMessagesHaveLatencyInfo = this.protocol.extensions.has(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionLatency);\r\n                result = true;\r\n            }\r\n        }\r\n        else if (!this.canAcceptRequests) {\r\n            (0, trace_1.trace)('Session request blocked because the session is not yet authenticated.');\r\n            result = false;\r\n        }\r\n        else {\r\n            const args = new sshRequestEventArgs_1.SshRequestEventArgs(message.requestType || '', message, this.principal);\r\n            const serviceType = (0, serviceActivation_1.findService)(this.config.services, (a) => a.sessionRequest === message.requestType);\r\n            if (serviceType) {\r\n                // A service was configured for activation via this session request type.\r\n                const service = this.activateService(serviceType);\r\n                // `onSessionRequest` should really be 'protected internal'.\r\n                await service.onSessionRequest(args, cancellation);\r\n                // The service should have handled sending the response message, if any.\r\n                return;\r\n            }\r\n            else {\r\n                // Raise a request event to let an event listener handle this request.\r\n                this.raiseSessionRequest(args);\r\n            }\r\n            result = args.isAuthorized || false;\r\n        }\r\n        if (message.wantReply) {\r\n            await this.sendMessage(result ? new transportMessages_1.SessionRequestSuccessMessage() : new transportMessages_1.SessionRequestFailureMessage(), cancellation);\r\n        }\r\n    }\r\n    /* @internal */\r\n    raiseSessionRequest(args) {\r\n        this.requestEmitter.fire(args);\r\n    }\r\n    /* @internal */\r\n    async handleServiceRequestMessage(message, cancellation) {\r\n        // Do nothing. Subclasses may override.\r\n    }\r\n    /* @internal */\r\n    async handleServiceAcceptMessage(message, cancellation) {\r\n        // Do nothing. Subclasses may override.\r\n    }\r\n    async handleKeyExchangeMessage(message, cancellation) {\r\n        if (!this.kexService) {\r\n            if (message instanceof kexMessages_1.KeyExchangeInitMessage && this.protocol) {\r\n                // This side didn't configure security, but the other side still wants to negotiate.\r\n                // Start the KEX sequence just to try to negotiate 'none'.\r\n                this.kexService = this.activateService(keyExchangeService_1.KeyExchangeService);\r\n                this.protocol.kexService = this.kexService;\r\n                await this.protocol.considerReExchange(true, cancellation);\r\n            }\r\n            else {\r\n                await this.close(transportMessages_1.SshDisconnectReason.keyExchangeFailed);\r\n                return;\r\n            }\r\n        }\r\n        return this.kexService.handleMessage(message, cancellation);\r\n    }\r\n    /* @internal */\r\n    async handleNewKeysMessage(message, cancellation) {\r\n        try {\r\n            await this.blockedMessagesSemaphore.wait(cancellation);\r\n            await this.protocol.handleNewKeys(cancellation);\r\n            try {\r\n                // Send messages that were blocked during key exchange.\r\n                while (this.blockedMessages.length > 0) {\r\n                    const blockedMessage = this.blockedMessages.shift();\r\n                    if (!this.protocol)\r\n                        throw new errors_1.ObjectDisposedError(this);\r\n                    await this.protocol.sendMessage(blockedMessage, cancellation);\r\n                }\r\n            }\r\n            catch (e) {\r\n                if (!(e instanceof Error))\r\n                    throw e;\r\n                await this.close(transportMessages_1.SshDisconnectReason.protocolError, undefined, e);\r\n            }\r\n        }\r\n        finally {\r\n            this.blockedMessagesSemaphore.release();\r\n        }\r\n    }\r\n    async handleUnimplementedMessage(message, cancellation) {\r\n        if (message.unimplementedMessageType !== undefined) {\r\n            // Received a message type that is unimplemented by this side.\r\n            // Send a reply to inform the other side.\r\n            await this.sendMessage(message, cancellation);\r\n        }\r\n        else {\r\n            // This is a reply indicating this side previously sent a message type\r\n            // that is not implemented by the other side. It has already been traced.\r\n        }\r\n    }\r\n    handleDebugMessage(message) {\r\n        if (message.message) {\r\n            (0, trace_1.trace)(message.message);\r\n        }\r\n    }\r\n    /* @internal */\r\n    async raiseAuthenticatingEvent(args) {\r\n        (0, trace_1.trace)(`${this} Authenticating(${args})`);\r\n        this.authenticatingEmitter.fire(args);\r\n        let authPromise = args.authenticationPromise;\r\n        if (!authPromise) {\r\n            authPromise = Promise.resolve(null);\r\n        }\r\n        const principal = await authPromise;\r\n        return principal;\r\n    }\r\n    /**\r\n     * Sends a session request and waits for a response.\r\n     *\r\n     * Note if `wantReply` is `false`, this method returns `true` immediately after sending\r\n     * the request, without waiting for a response.\r\n     *\r\n     * @returns The authorization status of the response; if `false`, the other side denied the\r\n     * request.\r\n     */\r\n    async request(request, cancellation) {\r\n        if (!request)\r\n            throw new TypeError('Request is required.');\r\n        if (!request.wantReply) {\r\n            await this.sendMessage(request, cancellation);\r\n            return true;\r\n        }\r\n        const response = await this.requestResponse(request, transportMessages_1.SessionRequestSuccessMessage, transportMessages_1.SessionRequestFailureMessage, cancellation);\r\n        return response instanceof transportMessages_1.SessionRequestSuccessMessage;\r\n    }\r\n    /**\r\n     * Sends a session request and waits for a specific type of success or failure message.\r\n     *\r\n     * @returns The success or failure response message.\r\n     */\r\n    async requestResponse(request, successType, failureType, cancellation) {\r\n        if (!request)\r\n            throw new TypeError('Request is required.');\r\n        if (!successType)\r\n            throw new TypeError('Success response type is required.');\r\n        if (!failureType)\r\n            throw new TypeError('Failure response type is required.');\r\n        if (this.requestHandler) {\r\n            throw new Error('Another request is already pending.');\r\n        }\r\n        request.wantReply = true;\r\n        // Capture as a local variable because the member may change.\r\n        const requestCompletionSource = new promiseCompletionSource_1.PromiseCompletionSource();\r\n        if (cancellation) {\r\n            if (cancellation.isCancellationRequested)\r\n                throw new cancellation_1.CancellationError();\r\n            cancellation.onCancellationRequested(() => {\r\n                this.requestHandler = null;\r\n                requestCompletionSource.reject(new cancellation_1.CancellationError());\r\n            });\r\n        }\r\n        this.requestHandler = (err, result) => {\r\n            var _a, _b;\r\n            this.requestHandler = null;\r\n            if (err) {\r\n                requestCompletionSource.reject(err);\r\n            }\r\n            else if (result instanceof transportMessages_1.SessionRequestFailureMessage) {\r\n                const failure = (_a = result === null || result === void 0 ? void 0 : result.convertTo(new failureType(), true)) !== null && _a !== void 0 ? _a : null;\r\n                requestCompletionSource.resolve(failure);\r\n            }\r\n            else if (result instanceof transportMessages_1.SessionRequestSuccessMessage) {\r\n                // Make a copy of the response message because the continuation may be\r\n                // asynchronous; meanwhile the receive buffer will be re-used.\r\n                const success = (_b = result === null || result === void 0 ? void 0 : result.convertTo(new successType(), true)) !== null && _b !== void 0 ? _b : null;\r\n                requestCompletionSource.resolve(success);\r\n            }\r\n            else {\r\n                requestCompletionSource.reject(new Error('Unknown response message type.'));\r\n            }\r\n        };\r\n        await this.sendMessage(request, cancellation);\r\n        return await requestCompletionSource.promise;\r\n    }\r\n    handleRequestSuccessMessage(message) {\r\n        if (this.requestHandler) {\r\n            this.requestHandler(undefined, message);\r\n        }\r\n    }\r\n    handleRequestFailureMessage(message) {\r\n        if (this.requestHandler) {\r\n            this.requestHandler(undefined, message);\r\n        }\r\n    }\r\n    async acceptChannel(channelTypeOrCancellation, cancellation) {\r\n        const channelType = typeof channelTypeOrCancellation === 'string' ? channelTypeOrCancellation : undefined;\r\n        if (!cancellation && typeof channelTypeOrCancellation === 'object')\r\n            cancellation = channelTypeOrCancellation;\r\n        this.activateService(connectionService_1.ConnectionService);\r\n        // Prepare to accept the channel before connecting. This ensures that if the channel\r\n        // open request comes in immediately after connecting then the channel won't be missed\r\n        // in case of a task scheduling delay.\r\n        const acceptPromise = this.connectionService.acceptChannel(channelType || sshChannel_1.SshChannel.sessionChannelType, cancellation);\r\n        return await acceptPromise;\r\n    }\r\n    async openChannel(channelTypeOrOpenMessageOrCancellation, initialRequestOrCancellation, cancellation) {\r\n        let openMessage;\r\n        if (typeof channelTypeOrOpenMessageOrCancellation === 'string' ||\r\n            channelTypeOrOpenMessageOrCancellation === null) {\r\n            openMessage = new connectionMessages_1.ChannelOpenMessage();\r\n            openMessage.channelType =\r\n                channelTypeOrOpenMessageOrCancellation !== null && channelTypeOrOpenMessageOrCancellation !== void 0 ? channelTypeOrOpenMessageOrCancellation : sshChannel_1.SshChannel.sessionChannelType;\r\n        }\r\n        else if (channelTypeOrOpenMessageOrCancellation instanceof connectionMessages_1.ChannelOpenMessage) {\r\n            openMessage = channelTypeOrOpenMessageOrCancellation;\r\n        }\r\n        else {\r\n            openMessage = new connectionMessages_1.ChannelOpenMessage();\r\n            openMessage.channelType = sshChannel_1.SshChannel.sessionChannelType;\r\n            cancellation = channelTypeOrOpenMessageOrCancellation;\r\n        }\r\n        if (initialRequestOrCancellation instanceof connectionMessages_1.ChannelRequestMessage) {\r\n            return await this.openChannelWithInitialRequest(openMessage, initialRequestOrCancellation, cancellation);\r\n        }\r\n        else if (!cancellation && initialRequestOrCancellation !== null) {\r\n            cancellation = initialRequestOrCancellation;\r\n        }\r\n        this.activateService(connectionService_1.ConnectionService);\r\n        const completionSource = new promiseCompletionSource_1.PromiseCompletionSource();\r\n        await this.connectionService.openChannel(openMessage, completionSource, cancellation);\r\n        return await completionSource.promise;\r\n    }\r\n    async openChannelWithInitialRequest(openMessage, initialRequest, cancellation) {\r\n        var _a;\r\n        this.activateService(connectionService_1.ConnectionService);\r\n        const completionSource = new promiseCompletionSource_1.PromiseCompletionSource();\r\n        const channelId = await this.connectionService.openChannel(openMessage, completionSource, cancellation);\r\n        if (cancellation) {\r\n            if (cancellation.isCancellationRequested)\r\n                throw new cancellation_1.CancellationError();\r\n            cancellation.onCancellationRequested(() => completionSource.reject(new cancellation_1.CancellationError()));\r\n        }\r\n        let channel;\r\n        let requestResult;\r\n        const isExtensionSupported = this.config.protocolExtensions.includes(sshSessionConfiguration_1.SshProtocolExtensionNames.openChannelRequest) &&\r\n            ((_a = this.protocolExtensions) === null || _a === void 0 ? void 0 : _a.has(sshSessionConfiguration_1.SshProtocolExtensionNames.openChannelRequest));\r\n        if (isExtensionSupported === false) {\r\n            // The local or remote side definitely doesn't support this extension. Just send a\r\n            // normal channel request after waiting for the channel open confirmation.\r\n            channel = await completionSource.promise;\r\n            requestResult = await channel.request(initialRequest, cancellation);\r\n        }\r\n        else {\r\n            // The remote side does or might support this extension. If uncertain then a reply\r\n            // is required.\r\n            const wantReply = initialRequest.wantReply || isExtensionSupported === undefined;\r\n            // Send the initial channel request message BEFORE waiting for the\r\n            // channel open confirmation.\r\n            const sessionRequest = new transportMessages_1.SessionChannelRequestMessage();\r\n            sessionRequest.requestType = \"initial-channel-request@microsoft.com\" /* initialChannelRequest */;\r\n            sessionRequest.senderChannel = channelId;\r\n            sessionRequest.request = initialRequest;\r\n            sessionRequest.wantReply = wantReply;\r\n            const requestPromise = this.request(sessionRequest, cancellation);\r\n            // Wait for the channel open confirmation.\r\n            channel = await completionSource.promise;\r\n            if (!wantReply) {\r\n                requestResult = true;\r\n            }\r\n            else {\r\n                // Wait for the response to the initial channel request.\r\n                requestResult = await requestPromise;\r\n                if (!requestResult && isExtensionSupported === undefined) {\r\n                    // The initial request failed. This could be because the other side doesn't\r\n                    // support the initial-request extension or because the request was denied.\r\n                    // Try sending the request again as a regular channel request.\r\n                    requestResult = await channel.request(initialRequest);\r\n                }\r\n            }\r\n        }\r\n        if (!requestResult) {\r\n            // The regular request still failed, so close the channel and throw.\r\n            await channel.close();\r\n            throw new Error('The initial channel request was denied.');\r\n        }\r\n        return channel;\r\n    }\r\n    /* @internal */\r\n    async handleChannelOpening(args, cancellation) {\r\n        const serviceType = (0, serviceActivation_1.findService)(this.config.services, (a) => a.channelType === args.channel.channelType && !a.channelRequest);\r\n        if (serviceType) {\r\n            // A service was configured for activation via this channel type.\r\n            const service = this.activateService(serviceType);\r\n            // `onChannelOpening` should really be 'protected internal'.\r\n            await service.onChannelOpening(args, cancellation);\r\n        }\r\n        else {\r\n            this.raiseChannelOpening(args);\r\n        }\r\n    }\r\n    /* @internal */\r\n    raiseChannelOpening(args) {\r\n        this.channelOpeningEmitter.fire(args);\r\n    }\r\n    /* @internal */\r\n    async sendExtensionInfo(cancellation) {\r\n        const message = new transportMessages_1.ExtensionInfoMessage();\r\n        message.extensionInfo = {};\r\n        for (let extensionName of this.config.protocolExtensions) {\r\n            if (extensionName === sshSessionConfiguration_1.SshProtocolExtensionNames.serverSignatureAlgorithms) {\r\n                // Send the list of enabled host key signature algorithms.\r\n                const publicKeyAlgorithms = Array.from(new Set((0, sshAlgorithms_1.algorithmNames)(this.config.publicKeyAlgorithms))).join(',');\r\n                message.extensionInfo[extensionName] = publicKeyAlgorithms;\r\n            }\r\n            else {\r\n                message.extensionInfo[extensionName] = '';\r\n            }\r\n        }\r\n        await this.sendMessage(message, cancellation);\r\n    }\r\n    async handleExtensionInfoMessage(message, cancellation) {\r\n        if (!this.protocol) {\r\n            return;\r\n        }\r\n        this.protocol.extensions = new Map();\r\n        const proposedExtensions = message.extensionInfo;\r\n        if (!proposedExtensions) {\r\n            return;\r\n        }\r\n        for (let extensionName of this.config.protocolExtensions) {\r\n            const proposedExtension = message.extensionInfo[extensionName];\r\n            if (typeof proposedExtension === 'string') {\r\n                this.protocol.extensions.set(extensionName, proposedExtension);\r\n            }\r\n        }\r\n        if (this.protocol.extensions.has(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionReconnect)) {\r\n            await this.enableReconnect(cancellation);\r\n        }\r\n    }\r\n    async close(reason, message, error) {\r\n        var _a, _b, _c;\r\n        if (this.disposed || !this.connected) {\r\n            return;\r\n        }\r\n        this.connected = false;\r\n        (0, trace_1.trace)(`${this} Close(${transportMessages_1.SshDisconnectReason[reason]}, \"${message || ''}\")`);\r\n        if (reason !== transportMessages_1.SshDisconnectReason.connectionLost) {\r\n            try {\r\n                const disconnectMessage = new transportMessages_1.DisconnectMessage();\r\n                disconnectMessage.reasonCode = reason;\r\n                disconnectMessage.description = message || '';\r\n                await ((_a = this.protocol) === null || _a === void 0 ? void 0 : _a.sendMessage(disconnectMessage));\r\n            }\r\n            catch (e) {\r\n                // Already disconnected.\r\n            }\r\n        }\r\n        else if (this.handleDisconnected()) {\r\n            // Keep the session in a disconnected (but not closed) state.\r\n            (_b = this.protocol) === null || _b === void 0 ? void 0 : _b.dispose();\r\n            (0, trace_1.trace)(`${this} disconnected.`);\r\n            this.disconnectedEmitter.fire();\r\n            return;\r\n        }\r\n        this.disposed = true;\r\n        if (error) {\r\n            (_c = this.connectionService) === null || _c === void 0 ? void 0 : _c.close(error);\r\n        }\r\n        this.closedEmitter.fire(new sshSessionClosedEventArgs_1.SshSessionClosedEventArgs(reason, message || 'Disconnected.', error || null));\r\n        this.dispose();\r\n    }\r\n    /* @internal */\r\n    handleDisconnected() {\r\n        var _a, _b;\r\n        this.connectPromise = undefined;\r\n        (_a = this.kexService) === null || _a === void 0 ? void 0 : _a.abortKeyExchange();\r\n        if (!((_b = this.protocolExtensions) === null || _b === void 0 ? void 0 : _b.has(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionReconnect))) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    dispose() {\r\n        var _a, _b;\r\n        if (!this.disposed) {\r\n            (0, trace_1.trace)(`${this} disposed.`);\r\n            this.disposed = true;\r\n            this.closedEmitter.fire(new sshSessionClosedEventArgs_1.SshSessionClosedEventArgs(transportMessages_1.SshDisconnectReason.none, 'SshSession disposed', null));\r\n        }\r\n        if (this.requestHandler) {\r\n            this.requestHandler(new errors_1.SshConnectionError('Connection closed.'));\r\n        }\r\n        this.metrics.close();\r\n        // Dispose the connection service before other services, to ensure\r\n        // channels are disposed before services that work with them.\r\n        (_a = this.connectionService) === null || _a === void 0 ? void 0 : _a.dispose();\r\n        for (let service of this.activatedServices.values()) {\r\n            if (service !== this.connectionService) {\r\n                service.dispose();\r\n            }\r\n        }\r\n        this.activatedServices.clear();\r\n        (_b = this.protocol) === null || _b === void 0 ? void 0 : _b.dispose();\r\n        this.protocol = undefined;\r\n    }\r\n    /* @internal */\r\n    async enableReconnect(cancellation) {\r\n        var _a;\r\n        try {\r\n            // Ensure no other messages are sent in the middle of turning this on.\r\n            await this.blockedMessagesSemaphore.wait();\r\n            // This should not be done during a key-exchange, however that should never\r\n            // be the case since the EnableSessionReconnectRequest is sent in response\r\n            // to an ExtensionInfo message which is sent in response to a NewKeys message.\r\n            // So a key exchange just finished and won't be restarted again soon.\r\n            if ((_a = this.kexService) === null || _a === void 0 ? void 0 : _a.exchanging) {\r\n                (0, trace_1.trace)('Failed to initialize session reconnect because a key-exchange was in-progress.');\r\n            }\r\n            else {\r\n                // Send the message indicating reconnect message tracking is starting.\r\n                const enableReconnectMessage = new transportMessages_1.SessionRequestMessage(\"enable-session-reconnect@microsoft.com\" /* enableSessionReconnect */, false);\r\n                await this.protocol.sendMessage(enableReconnectMessage, cancellation);\r\n                // Start using the protocol extensions that include an extra field or two\r\n                // with every sent message.\r\n                if (this.protocol) {\r\n                    this.protocol.outgoingMessagesHaveReconnectInfo = true;\r\n                    this.protocol.outgoingMessagesHaveLatencyInfo = this.protocol.extensions.has(sshSessionConfiguration_1.SshProtocolExtensionNames.sessionLatency);\r\n                }\r\n            }\r\n            this.blockedMessagesSemaphore.release();\r\n        }\r\n        catch (e) {\r\n            // This is not in a finally block because the semaphore must be released before\r\n            // the call to close() which tries to send a message.\r\n            this.blockedMessagesSemaphore.release();\r\n            if (e instanceof Error) {\r\n                await this.close(transportMessages_1.SshDisconnectReason.protocolError, undefined, e);\r\n            }\r\n            throw e;\r\n        }\r\n    }\r\n    /* @internal */\r\n    async createReconnectToken(previousSessionId, newSessionId) {\r\n        // To generate the reconnect token, combine the old session ID and new (re-negotiated)\r\n        // session ID and sign the result using the new negotiated HMAC algorithm and key. This\r\n        // proves that the old (secret) session ID is known while not disclosing it, and also\r\n        // prevents replay attacks.\r\n        const reconnectToken = await this.algorithms.signer.sign(buffer_1.Buffer.concat([previousSessionId, newSessionId]));\r\n        return reconnectToken;\r\n    }\r\n    /* @internal */\r\n    async verifyReconnectToken(previousSessionId, newSessionId, reconnectToken) {\r\n        const result = await this.algorithms.verifier.verify(buffer_1.Buffer.concat([previousSessionId, newSessionId]), reconnectToken);\r\n        return result;\r\n    }\r\n    toString() {\r\n        return this.constructor.name;\r\n    }\r\n}\r\nexports.SshSession = SshSession;\r\nSshSession.localVersion = sshVersionInfo_1.SshVersionInfo.getLocalVersion();\r\n//# sourceMappingURL=sshSession.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SshSessionAlgorithms = void 0;\r\nclass SshSessionAlgorithms {\r\n    dispose() {\r\n        if (this.cipher)\r\n            this.cipher.dispose();\r\n        if (this.decipher)\r\n            this.decipher.dispose();\r\n        if (this.signer)\r\n            this.signer.dispose();\r\n        if (this.verifier)\r\n            this.verifier.dispose();\r\n    }\r\n}\r\nexports.SshSessionAlgorithms = SshSessionAlgorithms;\r\n//# sourceMappingURL=sshSessionAlgorithms.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SshSessionConfiguration = exports.SshProtocolExtensionNames = void 0;\r\nconst sshAlgorithms_1 = require(\"./algorithms/sshAlgorithms\");\r\nconst keyExchangeService_1 = require(\"./services/keyExchangeService\");\r\nconst connectionService_1 = require(\"./services/connectionService\");\r\nconst authenticationService_1 = require(\"./services/authenticationService\");\r\nvar SshProtocolExtensionNames;\r\n(function (SshProtocolExtensionNames) {\r\n    /**\r\n     * Lists host key signature algorithms enabled by the sender.\r\n     *\r\n     * This is a \"standard\" protocol extension supported by most SSH implementations.\r\n     */\r\n    SshProtocolExtensionNames[\"serverSignatureAlgorithms\"] = \"server-sig-algs\";\r\n    /**\r\n     * An optimization that enables sending an initial channel request without\r\n     * waiting for a channel open confirmation message.\r\n     */\r\n    SshProtocolExtensionNames[\"openChannelRequest\"] = \"open-channel-request@microsoft.com\";\r\n    /**\r\n     * Enables reconnecting to a session that was recently disconnected.\r\n     */\r\n    SshProtocolExtensionNames[\"sessionReconnect\"] = \"session-reconnect@microsoft.com\";\r\n    /**\r\n     * Enables continual latency measurements between client and server.\r\n     *\r\n     * This extension requires that the reconnect extension is also enabled, because\r\n     * it leverages some of the session history info for reconnect to compute latency.\r\n     */\r\n    SshProtocolExtensionNames[\"sessionLatency\"] = \"session-latency@microsoft.com\";\r\n})(SshProtocolExtensionNames = exports.SshProtocolExtensionNames || (exports.SshProtocolExtensionNames = {}));\r\n/**\r\n * Specifies the sets of algorithms and other configuration for an SSH session.\r\n *\r\n * Each collection of algorithms is in order of preference. Server and client\r\n * negotiate the most-preferred algorithm that is supported by both.\r\n */\r\nclass SshSessionConfiguration {\r\n    constructor(useSecurity = true) {\r\n        /**\r\n         * Gets the protocol extensions that are enabled for the session.\r\n         */\r\n        this.protocolExtensions = [];\r\n        /**\r\n         * Gets a dictionary that maps from service types to service configuration objects.\r\n         *\r\n         * Service types must extend the `SshService` abstract class.\r\n         *\r\n         * The service configuration object is passed to the service constructor upon activation.\r\n         */\r\n        this.services = new Map();\r\n        /**\r\n         * Gets the collection of algorithms that are enabled for key exchange.\r\n         *\r\n         * Client and server sides negotiate which of these algorithms will be used.\r\n         *\r\n         * If this collection includes `null`, and if negotiation selects it, then the session is\r\n         * allowed to skip key exchange and connect with no security of any kind: No key exchange,\r\n         * no authentication, no encryption, no HMAC, and no compression.\r\n         */\r\n        this.keyExchangeAlgorithms = [];\r\n        /**\r\n         * Gets the collection of algorithms that are enabled for server (host) and client\r\n         * public-key authentication.\r\n         *\r\n         * Client and server sides negotiate which of these algorithms will be used.\r\n         */\r\n        this.publicKeyAlgorithms = [];\r\n        /*\r\n         * Gets the collection of algorithms that are enabled for encryption.\r\n         *\r\n         * Client and server sides negotiate which of these algorithms will be used.\r\n         */\r\n        this.encryptionAlgorithms = [];\r\n        /**\r\n         * Gets the collection of algorithms that are enabled for message integrity (HMAC).\r\n         *\r\n         * Client and server sides negotiate which of these algorithms will be used.\r\n         */\r\n        this.hmacAlgorithms = [];\r\n        /**\r\n         * Gets the collection of algorithms that are enabled for message compression.\r\n         *\r\n         * Client and server sides negotiate which of these algorithms will be used.\r\n         */\r\n        this.compressionAlgorithms = [];\r\n        /**\r\n         * Gets or sets the number of times the server will allow a client to attempt to\r\n         * authenticate.\r\n         *\r\n         * The default value is 5.\r\n         *\r\n         * This setting applies only to server sessions. If the client has failed to authenticate\r\n         * after the maximum number of atttempts, the server will close the session.\r\n         *\r\n         * The SSH protocol allows a client to make multiple attempts to authenticate with\r\n         * the server, e.g. to find which public key algorithm a server will support, or to\r\n         * retry a mis-typed password. This maximum prevents unlimited retries, which would\r\n         * make it easier to \"guess\" a password.\r\n         *\r\n         * In certain applications the server may only support a single authentication method\r\n         * (which is not a typed password). Then it could be appropriate to set this value to 1.\r\n         */\r\n        this.maxClientAuthenticationAttempts = 5;\r\n        /**\r\n         * Gets or sets whether the client sends a key-exchange \"guess\" message before receiving\r\n         * the server's key-exchange algorithm preferences, slightly reducing the time to connect.\r\n         *\r\n         * This setting only applies to client sessions. (The server always supports the option when\r\n         * used by a client.)\r\n         *\r\n         * The \"guess\" mechanism is somewhat ambiguously defined in the SSH protocol spec, and as\r\n         * a result is not implemented or incorrectly implemented by some server implementations,\r\n         * including older versions of this library. Therefore it is disabled in the default\r\n         * configuration, and should only be enabled when connecting to a known-good server.\r\n         */\r\n        this.enableKeyExchangeGuess = false;\r\n        /* @internal */\r\n        this.keyRotationThreshold = 512 * 1024 * 1024; // 0.5 GiB;\r\n        this.protocolExtensions.push(SshProtocolExtensionNames.serverSignatureAlgorithms);\r\n        this.protocolExtensions.push(SshProtocolExtensionNames.openChannelRequest);\r\n        this.services.set(keyExchangeService_1.KeyExchangeService, null);\r\n        this.services.set(connectionService_1.ConnectionService, null);\r\n        this.services.set(authenticationService_1.AuthenticationService, null);\r\n        if (useSecurity) {\r\n            this.keyExchangeAlgorithms.push(sshAlgorithms_1.SshAlgorithms.keyExchange.ecdhNistp384Sha384);\r\n            this.keyExchangeAlgorithms.push(sshAlgorithms_1.SshAlgorithms.keyExchange.ecdhNistp256Sha256);\r\n            this.keyExchangeAlgorithms.push(sshAlgorithms_1.SshAlgorithms.keyExchange.dhGroup16Sha512);\r\n            this.keyExchangeAlgorithms.push(sshAlgorithms_1.SshAlgorithms.keyExchange.dhGroup14Sha256);\r\n            this.publicKeyAlgorithms.push(sshAlgorithms_1.SshAlgorithms.publicKey.rsaWithSha512);\r\n            this.publicKeyAlgorithms.push(sshAlgorithms_1.SshAlgorithms.publicKey.rsaWithSha256);\r\n            this.publicKeyAlgorithms.push(sshAlgorithms_1.SshAlgorithms.publicKey.ecdsaSha2Nistp384);\r\n            this.publicKeyAlgorithms.push(sshAlgorithms_1.SshAlgorithms.publicKey.ecdsaSha2Nistp256);\r\n            ////this.encryptionAlgorithms.push(SshAlgorithms.encryption.aes256Cbc);\r\n            this.encryptionAlgorithms.push(sshAlgorithms_1.SshAlgorithms.encryption.aes256Gcm);\r\n            this.encryptionAlgorithms.push(sshAlgorithms_1.SshAlgorithms.encryption.aes256Ctr);\r\n            this.hmacAlgorithms.push(sshAlgorithms_1.SshAlgorithms.hmac.hmacSha512Etm);\r\n            this.hmacAlgorithms.push(sshAlgorithms_1.SshAlgorithms.hmac.hmacSha256Etm);\r\n            this.hmacAlgorithms.push(sshAlgorithms_1.SshAlgorithms.hmac.hmacSha512);\r\n            this.hmacAlgorithms.push(sshAlgorithms_1.SshAlgorithms.hmac.hmacSha256);\r\n        }\r\n        else {\r\n            this.keyExchangeAlgorithms.push(sshAlgorithms_1.SshAlgorithms.keyExchange.none);\r\n            this.publicKeyAlgorithms.push(sshAlgorithms_1.SshAlgorithms.publicKey.none);\r\n            this.encryptionAlgorithms.push(sshAlgorithms_1.SshAlgorithms.encryption.none);\r\n            this.hmacAlgorithms.push(sshAlgorithms_1.SshAlgorithms.hmac.none);\r\n        }\r\n        this.compressionAlgorithms.push(sshAlgorithms_1.SshAlgorithms.compression.none);\r\n    }\r\n    /**\r\n     * Adds a service to the configuration.\r\n     */\r\n    addService(serviceType, serviceConfig) {\r\n        if (this.services.has(serviceType)) {\r\n            throw new Error('Duplicate service entry.');\r\n        }\r\n        this.services.set(serviceType, serviceConfig);\r\n    }\r\n    getKeyExchangeAlgorithm(name) {\r\n        return this.getAlgorithm(name, this.keyExchangeAlgorithms);\r\n    }\r\n    getPublicKeyAlgorithm(name) {\r\n        return this.getAlgorithm(name, this.publicKeyAlgorithms);\r\n    }\r\n    getEncryptionAlgorithm(name) {\r\n        return this.getAlgorithm(name, this.encryptionAlgorithms);\r\n    }\r\n    getHmacAlgorithm(name) {\r\n        return this.getAlgorithm(name, this.hmacAlgorithms);\r\n    }\r\n    getCompressionAlgorithm(name) {\r\n        return this.getAlgorithm(name, this.compressionAlgorithms);\r\n    }\r\n    getAlgorithm(name, collection) {\r\n        const algorithm = collection.find((a) => (a ? a.name === name : false));\r\n        if (!algorithm) {\r\n            if (name === 'none') {\r\n                return null;\r\n            }\r\n            throw new Error('Algorithm not found: ' + name);\r\n        }\r\n        return algorithm;\r\n    }\r\n}\r\nexports.SshSessionConfiguration = SshSessionConfiguration;\r\n//# sourceMappingURL=sshSessionConfiguration.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SshStream = void 0;\r\nconst promiseCompletionSource_1 = require(\"./util/promiseCompletionSource\");\r\nconst stream_1 = require(\"stream\");\r\n/**\r\n * Adapts an SshChannel as a Readable+Writable stream.\r\n */\r\nclass SshStream extends stream_1.Duplex {\r\n    constructor(channel) {\r\n        let readPaused = null;\r\n        super({\r\n            async write(chunk, encoding, cb) {\r\n                let error;\r\n                try {\r\n                    let buffer;\r\n                    if (typeof chunk === 'string') {\r\n                        buffer = Buffer.from(chunk, encoding);\r\n                    }\r\n                    else if (chunk instanceof Buffer) {\r\n                        buffer = chunk;\r\n                    }\r\n                    else {\r\n                        throw new Error('Unsupported chunk type: ' + typeof chunk);\r\n                    }\r\n                    await channel.send(buffer);\r\n                }\r\n                catch (e) {\r\n                    if (!(e instanceof Error))\r\n                        throw e;\r\n                    error = e;\r\n                }\r\n                if (cb) {\r\n                    cb(error);\r\n                }\r\n            },\r\n            async writev(chunks, cb) {\r\n                let error;\r\n                try {\r\n                    if (chunks.length === 1) {\r\n                        return this.write(chunks[0].chunk, chunks[0].encoding, cb);\r\n                    }\r\n                    else {\r\n                        function BufferReduce(accumulator, chunk) {\r\n                            if (chunk.chunk instanceof Buffer) {\r\n                                return accumulator + chunk.chunk.length;\r\n                            }\r\n                            else {\r\n                                throw new Error('Unsupported chunk type: ' + typeof chunk.chunk);\r\n                            }\r\n                        }\r\n                        const totalLength = chunks.reduce(BufferReduce, 0);\r\n                        const singleBuffer = Buffer.alloc(totalLength);\r\n                        let singleBufferIndex = 0;\r\n                        for (let i = 0; i < chunks.length; i++) {\r\n                            chunks[i].chunk.copy(singleBuffer, singleBufferIndex);\r\n                            singleBufferIndex += chunks[i].chunk.length;\r\n                        }\r\n                        await channel.send(singleBuffer);\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    if (!(e instanceof Error))\r\n                        throw e;\r\n                    error = e;\r\n                }\r\n                if (cb) {\r\n                    cb(error);\r\n                }\r\n            },\r\n            async final(cb) {\r\n                let error;\r\n                try {\r\n                    await channel.close();\r\n                }\r\n                catch (e) {\r\n                    if (!(e instanceof Error))\r\n                        throw e;\r\n                    error = e;\r\n                }\r\n                if (cb) {\r\n                    cb(error);\r\n                }\r\n            },\r\n            read() {\r\n                if (readPaused) {\r\n                    readPaused.resolve();\r\n                    readPaused = null;\r\n                }\r\n            },\r\n        });\r\n        const self = this;\r\n        channel.onDataReceived(async (data) => {\r\n            const buffer = Buffer.alloc(data.length);\r\n            data.copy(buffer);\r\n            const result = self.push(buffer);\r\n            // Our flow control isn't great. Once we hit the highWaterMark,\r\n            // we stop adjusting the SSH window until our own reader has caught up,\r\n            // and then *all* the data received and buffered in the interim suddenly\r\n            // gets 'adjusted' so that we tend to be somewhat choppy about adjusting the window.\r\n            // Improving this would require that we know when the data we push gets passed to\r\n            // the Duplex reader, and I don't think there's a way to get that notification.\r\n            // So I suspect we'd have to dump Duplex and implement the stream ourselves.\r\n            if (!result) {\r\n                if (!readPaused) {\r\n                    readPaused = new promiseCompletionSource_1.PromiseCompletionSource();\r\n                }\r\n                await readPaused.promise;\r\n            }\r\n            // Notify the channel that the data has been consumed and more data may be sent.\r\n            channel.adjustWindow(buffer.length);\r\n        });\r\n        channel.onClosed(() => {\r\n            self.push(null);\r\n        });\r\n        this.channel = channel;\r\n    }\r\n    toString() {\r\n        return `SshStream(Channel Type: ${this.channel.channelType}, Id: ${this.channel.channelId}, RemoteId: ${this.channel.remoteChannelId})`;\r\n    }\r\n}\r\nexports.SshStream = SshStream;\r\n//# sourceMappingURL=sshStream.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SshVersionInfo = void 0;\r\nconst packageJson = require(\"./package.json\");\r\nconst packageName = packageJson.name.replace(/^@\\w+\\//, ''); // Strip scope from name.\r\nconst packageVersion = packageJson.version;\r\n/**\r\n * Parses the SSH software name and version from the version string exchanged via the\r\n * initial packets sent between client and server.\r\n */\r\nclass SshVersionInfo {\r\n    constructor(versionString, protocolVersion, name, version) {\r\n        this.versionString = versionString;\r\n        this.protocolVersion = protocolVersion;\r\n        this.name = name;\r\n        this.version = version;\r\n    }\r\n    /**\r\n     * Attempts to parse an SSH version string into a version info object.\r\n     */\r\n    static tryParse(versionString) {\r\n        if (!versionString) {\r\n            throw new TypeError('Version string expected.');\r\n        }\r\n        if (!versionString.startsWith('SSH-')) {\r\n            return null;\r\n        }\r\n        const firstDashIndex = 3;\r\n        const secondDashIndex = versionString.indexOf('-', firstDashIndex + 1);\r\n        if (secondDashIndex <= 0) {\r\n            return null;\r\n        }\r\n        const protocolVersion = versionString.substring(firstDashIndex + 1, secondDashIndex);\r\n        if (!/^\\d+\\.\\d+$/.test(protocolVersion)) {\r\n            return null;\r\n        }\r\n        let name;\r\n        let version;\r\n        const nameAndVersion = versionString.substring(secondDashIndex + 1);\r\n        const spaceIndex = nameAndVersion.indexOf(' ');\r\n        const lastUnderscoreBeforeSpace = nameAndVersion.lastIndexOf('_', spaceIndex >= 0 ? spaceIndex : nameAndVersion.length - 1);\r\n        if (lastUnderscoreBeforeSpace >= 0) {\r\n            name = nameAndVersion.substring(0, lastUnderscoreBeforeSpace).replace(/_/g, ' ');\r\n            // Ignore any non-digit characters after the version.\r\n            version = nameAndVersion.substring(lastUnderscoreBeforeSpace + 1);\r\n            for (let i = 0; i < version.length; i++) {\r\n                const c = version[i];\r\n                if (!(c >= '0' && c <= '9') && c !== '.') {\r\n                    version = version.substring(0, i);\r\n                    break;\r\n                }\r\n            }\r\n            if (!/^\\d+(\\.\\d+)*$/.test(version)) {\r\n                version = null;\r\n            }\r\n        }\r\n        else {\r\n            name = nameAndVersion;\r\n            version = null;\r\n        }\r\n        return new SshVersionInfo(versionString, protocolVersion, name, version);\r\n    }\r\n    /**\r\n     * Gets the version info for the current SSH library.\r\n     */\r\n    static getLocalVersion() {\r\n        const protocolVersion = '2.0';\r\n        const versionString = `SSH-${protocolVersion}-${packageName}_${packageVersion}`;\r\n        return new SshVersionInfo(versionString, protocolVersion, packageName, packageVersion);\r\n    }\r\n    /** Returns the original SSH version string that was parsed. */\r\n    toString() {\r\n        return this.versionString;\r\n    }\r\n    /**\r\n     * Gets a value indicating whether this version info represents some version of\r\n     * this library.\r\n     */\r\n    get isVsSsh() {\r\n        return this.isVsSshCS || this.isVsSshTS;\r\n    }\r\n    get isVsSshCS() {\r\n        return this.name === 'Microsoft.VisualStudio.Ssh';\r\n    }\r\n    get isVsSshTS() {\r\n        return this.name === 'vs-ssh';\r\n    }\r\n}\r\nexports.SshVersionInfo = SshVersionInfo;\r\n//# sourceMappingURL=sshVersionInfo.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.WebSocketStream = exports.NodeStream = exports.BaseStream = void 0;\r\nconst buffer_1 = require(\"buffer\");\r\nconst vscode_jsonrpc_1 = require(\"vscode-jsonrpc\");\r\nconst cancellation_1 = require(\"./util/cancellation\");\r\nconst errors_1 = require(\"./errors\");\r\nfunction handleCancellation(reject, cancellation) {\r\n    if (cancellation) {\r\n        if (cancellation.isCancellationRequested) {\r\n            reject(new cancellation_1.CancellationError());\r\n        }\r\n        else {\r\n            cancellation.onCancellationRequested(() => {\r\n                reject(new cancellation_1.CancellationError());\r\n            });\r\n        }\r\n    }\r\n}\r\n/**\r\n * Base class for stream adapters.\r\n */\r\nclass BaseStream {\r\n    constructor() {\r\n        this.incomingData = [];\r\n        this.pendingReads = [];\r\n        this.error = null;\r\n        this.disposed = false;\r\n        this.closedEmitter = new vscode_jsonrpc_1.Emitter();\r\n        this.closed = this.closedEmitter.event;\r\n    }\r\n    onData(data) {\r\n        while (this.pendingReads.length > 0) {\r\n            const read = this.pendingReads.shift();\r\n            if (read.count >= data.length) {\r\n                // This read operation consumes all of the incoming data.\r\n                read.resolve(data);\r\n                return;\r\n            }\r\n            else {\r\n                // This read operation consumes part of the incoming data.\r\n                const readData = data.slice(0, read.count);\r\n                data = data.slice(read.count);\r\n                read.resolve(readData);\r\n            }\r\n        }\r\n        this.incomingData.push(data);\r\n    }\r\n    onEnd() {\r\n        while (this.pendingReads.length > 0) {\r\n            const read = this.pendingReads.shift();\r\n            read.resolve(null);\r\n        }\r\n        this.incomingData.push(buffer_1.Buffer.alloc(0));\r\n    }\r\n    onError(error) {\r\n        if (!this.error) {\r\n            this.error = error;\r\n        }\r\n        while (this.pendingReads.length > 0) {\r\n            const read = this.pendingReads.shift();\r\n            read.reject(error);\r\n        }\r\n    }\r\n    async read(count, cancellation) {\r\n        if (this.disposed)\r\n            throw new errors_1.ObjectDisposedError(this);\r\n        if (this.incomingData.length > 0) {\r\n            // Consume data that has already arrived.\r\n            let data = this.incomingData[0];\r\n            if (data.length === 0) {\r\n                // Reached the end of the stream.\r\n                return null;\r\n            }\r\n            else if (count >= data.length) {\r\n                // Consuming the whole chunk.\r\n                this.incomingData.shift();\r\n            }\r\n            else {\r\n                // Consuming part of the chunk.\r\n                this.incomingData[0] = data.slice(count);\r\n                data = data.slice(0, count);\r\n            }\r\n            return data;\r\n        }\r\n        else if (this.error) {\r\n            throw this.error;\r\n        }\r\n        else {\r\n            // Wait for more data to arrive.\r\n            return await new Promise((resolve, reject) => {\r\n                if (cancellation) {\r\n                    if (cancellation.isCancellationRequested) {\r\n                        reject(new cancellation_1.CancellationError());\r\n                        return;\r\n                    }\r\n                    cancellation.onCancellationRequested(() => {\r\n                        // Discard any pending reads that use this cancellation token.\r\n                        for (let i = 0; i < this.pendingReads.length; i++) {\r\n                            if (Object.is(cancellation, this.pendingReads[i].cancellation)) {\r\n                                const read = this.pendingReads.splice(i--, 1)[0];\r\n                                read.reject(new cancellation_1.CancellationError());\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n                this.pendingReads.push({ count, resolve, reject, cancellation });\r\n            });\r\n        }\r\n    }\r\n    dispose() {\r\n        if (!this.disposed) {\r\n            this.disposed = true;\r\n            const error = new errors_1.ObjectDisposedError(this);\r\n            this.onError(error);\r\n            this.fireOnClose(error);\r\n        }\r\n    }\r\n    fireOnClose(error) {\r\n        this.closedEmitter.fire({ error });\r\n    }\r\n    get isDisposed() {\r\n        return this.disposed;\r\n    }\r\n}\r\nexports.BaseStream = BaseStream;\r\n/**\r\n * Stream adapter for a Node.js Socket, Duplex stream, or Readable/Writable stream pair.\r\n */\r\nclass NodeStream extends BaseStream {\r\n    constructor(duplexOrReadStream, writeStream) {\r\n        super();\r\n        if (!duplexOrReadStream)\r\n            throw new TypeError('Duplex or Readable/Writable stream are required.');\r\n        this.readStream = duplexOrReadStream;\r\n        this.writeStream = writeStream || duplexOrReadStream;\r\n        this.readStream.on('data', this.onData.bind(this));\r\n        this.readStream.on('end', this.onEnd.bind(this));\r\n        this.readStream.on('error', this.onError.bind(this));\r\n        this.readStream.on('close', () => {\r\n            this.onEnd();\r\n            this.fireOnClose();\r\n        });\r\n    }\r\n    async write(data, cancellation) {\r\n        if (!data)\r\n            throw new TypeError('Data is required.');\r\n        if (this.disposed)\r\n            throw new errors_1.ObjectDisposedError(this);\r\n        return new Promise((resolve, reject) => {\r\n            handleCancellation(reject, cancellation);\r\n            this.writeStream.write(data, (err) => {\r\n                if (!err) {\r\n                    resolve();\r\n                }\r\n                else {\r\n                    reject(err);\r\n                }\r\n            });\r\n        });\r\n    }\r\n    async close(error, cancellation) {\r\n        if (this.disposed)\r\n            throw new errors_1.ObjectDisposedError(this);\r\n        await new Promise((resolve, reject) => {\r\n            handleCancellation(reject, cancellation);\r\n            this.writeStream.end(resolve);\r\n        });\r\n        this.disposed = true;\r\n        this.onError(error || new errors_1.ObjectDisposedError(this));\r\n        this.closedEmitter.fire({ error });\r\n    }\r\n    dispose() {\r\n        if (!this.disposed) {\r\n            const error = new errors_1.ObjectDisposedError(this);\r\n            this.readStream.destroy(error);\r\n            this.writeStream.destroy(error);\r\n        }\r\n        super.dispose();\r\n    }\r\n}\r\nexports.NodeStream = NodeStream;\r\n/**\r\n * Stream adapter for a browser websocket.\r\n */\r\nclass WebSocketStream extends BaseStream {\r\n    constructor(websocket) {\r\n        super();\r\n        this.websocket = websocket;\r\n        if (!websocket)\r\n            throw new TypeError('WebSocket is required.');\r\n        if (typeof websocket.binaryType === 'string' &&\r\n            websocket.binaryType !== 'arraybuffer') {\r\n            throw new Error('WebSocket must use arraybuffer binary type.');\r\n        }\r\n        websocket.onmessage = (e) => {\r\n            this.onData(buffer_1.Buffer.from(e.data));\r\n        };\r\n        websocket.onclose = (e) => {\r\n            if (e.wasClean) {\r\n                this.onEnd();\r\n            }\r\n            else {\r\n                const error = new Error(e.reason);\r\n                error.code = e.code;\r\n                this.onError(error);\r\n            }\r\n        };\r\n    }\r\n    async write(data, cancellation) {\r\n        if (!data)\r\n            throw new TypeError('Data is required.');\r\n        if (this.disposed)\r\n            throw new errors_1.ObjectDisposedError(this);\r\n        if ('readyState' in this.websocket) {\r\n            if (this.websocket.readyState === 2 /* Closing */ ||\r\n                this.websocket.readyState === 3 /* Closed */) {\r\n                throw new DOMException('WebSocket is already in CLOSING or CLOSED state.', 'InvalidStateError');\r\n            }\r\n        }\r\n        this.websocket.send(data);\r\n    }\r\n    async close(error, cancellation) {\r\n        if (this.disposed)\r\n            throw new errors_1.ObjectDisposedError(this);\r\n        if (!error) {\r\n            this.websocket.close();\r\n        }\r\n        else {\r\n            const code = typeof error.code === 'number' ? error.code : undefined;\r\n            this.websocket.close(code, error.message);\r\n        }\r\n        this.disposed = true;\r\n        this.closedEmitter.fire({ error });\r\n        this.onError(error || new Error('Stream closed.'));\r\n    }\r\n    dispose() {\r\n        if (!this.disposed) {\r\n            this.websocket.close();\r\n        }\r\n        super.dispose();\r\n    }\r\n}\r\nexports.WebSocketStream = WebSocketStream;\r\n//# sourceMappingURL=streams.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.traceData = exports.trace = void 0;\r\n// To enable tracing in node, set the `DEBUG` environment variable to `vs-ssh`.\r\n// To enable tracing in a browser, set `window.localStorage.debug = 'vs-ssh'`\r\n// To include data messages, use `vs-ssh,vs-ssh:data`.\r\nconst packageJson = require(\"./package.json\");\r\nconst packageName = packageJson.name.replace(/^@\\w+\\//, ''); // Strip scope from name.\r\nconst debug = require(\"debug\");\r\nconst trace = debug(packageName);\r\nexports.trace = trace;\r\nconst traceSsh = debug(packageName + ':ssh');\r\nconst traceData = debug(packageName + ':data');\r\nexports.traceData = traceData;\r\n// DEBUG='vs-ssh:*' should also enable core tracing.\r\nif (traceSsh.enabled) {\r\n    trace.enabled = true;\r\n}\r\n//# sourceMappingURL=trace.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.withCancellation = exports.CancellationError = exports.CancellationTokenSource = exports.CancellationToken = void 0;\r\nconst vscode_jsonrpc_1 = require(\"vscode-jsonrpc\");\r\nObject.defineProperty(exports, \"CancellationToken\", { enumerable: true, get: function () { return vscode_jsonrpc_1.CancellationToken; } });\r\nObject.defineProperty(exports, \"CancellationTokenSource\", { enumerable: true, get: function () { return vscode_jsonrpc_1.CancellationTokenSource; } });\r\n/**\r\n * Error thrown when an operation is cancelled via a CancellationToken.\r\n */\r\nclass CancellationError extends Error {\r\n    constructor(message) {\r\n        super(message || 'Operation cancelled.');\r\n    }\r\n}\r\nexports.CancellationError = CancellationError;\r\nfunction withCancellation(promise, cancellation) {\r\n    if (!cancellation) {\r\n        return promise;\r\n    }\r\n    return Promise.race([\r\n        promise,\r\n        new Promise((resolve, reject) => {\r\n            if (cancellation.isCancellationRequested) {\r\n                reject(new CancellationError());\r\n            }\r\n            else {\r\n                cancellation.onCancellationRequested(() => {\r\n                    reject(new CancellationError());\r\n                });\r\n            }\r\n        }),\r\n    ]);\r\n}\r\nexports.withCancellation = withCancellation;\r\n//# sourceMappingURL=cancellation.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.PromiseCompletionSource = void 0;\r\nclass PromiseCompletionSource {\r\n    constructor() {\r\n        this.promise = new Promise((resolve, reject) => {\r\n            this.resolve = resolve;\r\n            this.reject = reject;\r\n        });\r\n    }\r\n    resolve(result) { }\r\n    reject(e) { }\r\n}\r\nexports.PromiseCompletionSource = PromiseCompletionSource;\r\n//# sourceMappingURL=promiseCompletionSource.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Queue = void 0;\r\n/**\r\n * Generic iterable queue implementation using an auto-expanding circular array buffer.\r\n * Designed to be more efficient for high-volume use compared to a simpler JS queue using\r\n * `Array.shift()` (which would cause a lot of allocations).\r\n */\r\nclass Queue {\r\n    constructor() {\r\n        this.array = new Array();\r\n        this.first = 0;\r\n        this.count = 0;\r\n        /**\r\n         * The version is incremented upon any changes to the queue, so that any iterators can detect the\r\n         * change and become invalid. `MAX_SAFE_INTEGER` is 2^53-1 so this isn't likely to ever overflow.\r\n         */\r\n        this.version = 0;\r\n    }\r\n    /**\r\n     * Gets the current size of the queue.\r\n     */\r\n    get size() {\r\n        return this.count;\r\n    }\r\n    /**\r\n     * Adds an item to the end of the queue.\r\n     */\r\n    enqueue(item) {\r\n        if (this.count === this.array.length) {\r\n            const newArray = new Array(Math.max(16, this.count * 2));\r\n            for (let i = 0; i < this.count; i++) {\r\n                newArray[i] = this.array[(this.first + i) % this.count];\r\n            }\r\n            this.array = newArray;\r\n            this.first = 0;\r\n        }\r\n        this.array[(this.first + this.count) % this.array.length] = item;\r\n        this.count++;\r\n        this.version++;\r\n    }\r\n    /**\r\n     * Removes an item from the front of the queue.\r\n     * @returns The removed item, or `undefined` if the queue is empty.\r\n     */\r\n    dequeue() {\r\n        if (this.count === 0)\r\n            return undefined;\r\n        const item = this.array[this.first];\r\n        this.array[this.first] = undefined; // Allow the item to be GC'd.\r\n        this.first = (this.first + 1) % this.array.length;\r\n        this.count--;\r\n        this.version++;\r\n        return item;\r\n    }\r\n    /**\r\n     * Gets the item at the front of the queue without removing it.\r\n     * @returns The front item, or `undefined` if the queue is empty.\r\n     */\r\n    peek() {\r\n        if (this.count === 0)\r\n            return undefined;\r\n        const item = this.array[this.first];\r\n        return item;\r\n    }\r\n    /**\r\n     * Clears the queue.\r\n     */\r\n    clear() {\r\n        this.first = 0;\r\n        this.count = 0;\r\n        this.array.fill(undefined); // Allow items to be GC'd.\r\n        this.version++;\r\n    }\r\n    /**\r\n     * Creates an iterator over the items in the queue.\r\n     * (Any changes to the queue will invalidate the iterator.)\r\n     */\r\n    *[Symbol.iterator]() {\r\n        const iteratorVersion = this.version;\r\n        for (let i = 0; i < this.count; i++) {\r\n            const item = this.array[(this.first + i) % this.array.length];\r\n            yield item;\r\n            if (this.version !== iteratorVersion) {\r\n                throw new Error('Iterator is invalid due to changes in the collection.');\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.Queue = Queue;\r\n//# sourceMappingURL=queue.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Semaphore = void 0;\r\nconst promiseCompletionSource_1 = require(\"./promiseCompletionSource\");\r\nconst cancellation_1 = require(\"./cancellation\");\r\nconst errors_1 = require(\"../errors\");\r\n/**\r\n * Semaphore-like object that allows multiple awaiters to coordinate exclusive access to a resource.\r\n */\r\nclass Semaphore {\r\n    /**\r\n     * Creates a new semaphore instance.\r\n     * @param initialCount Optional initial count. Defaults to 0.\r\n     */\r\n    constructor(initialCount = 0) {\r\n        this.completions = [];\r\n        this.disposed = false;\r\n        this.count = initialCount;\r\n    }\r\n    /**\r\n     * Gets the current available count of the semaphore.\r\n     */\r\n    get currentCount() {\r\n        return this.count;\r\n    }\r\n    /**\r\n     * Releases the semaphore, increasing the available count or unblicking one or more awaiters.\r\n     * @param releaseCount Optional specified count to release. Defaults to 1.\r\n     * @returns The previous count (before release).\r\n     */\r\n    release(releaseCount = 1) {\r\n        if (this.disposed)\r\n            throw new errors_1.ObjectDisposedError(this);\r\n        const previousCount = this.count;\r\n        for (; releaseCount > 0; releaseCount--) {\r\n            if (this.completions.length > 0) {\r\n                // Something is waiting on the semaphore.\r\n                // Remove and complete the wait without incrementing the count.\r\n                const completion = this.completions.shift();\r\n                completion.resolve(true);\r\n            }\r\n            else {\r\n                // Nothing is currently waiting on the semaphore. Increment the available count.\r\n                this.count++;\r\n            }\r\n        }\r\n        return previousCount;\r\n    }\r\n    /**\r\n     * Releases the semaphore, but does not throw an `ObjectDisposedError` if it is already disposed.\r\n     */\r\n    tryRelease() {\r\n        try {\r\n            this.release();\r\n        }\r\n        catch (e) {\r\n            if (!(e instanceof errors_1.ObjectDisposedError)) {\r\n                throw e;\r\n            }\r\n        }\r\n    }\r\n    async wait(timeoutOrCancellation, cancellation) {\r\n        const millisecondsTimeout = typeof timeoutOrCancellation === 'number' ? timeoutOrCancellation : undefined;\r\n        if (typeof cancellation === 'undefined' && typeof timeoutOrCancellation === 'object') {\r\n            cancellation = timeoutOrCancellation;\r\n        }\r\n        if (this.disposed)\r\n            throw new errors_1.ObjectDisposedError(this);\r\n        if (cancellation === null || cancellation === void 0 ? void 0 : cancellation.isCancellationRequested)\r\n            throw new cancellation_1.CancellationError();\r\n        if (this.count > 0) {\r\n            // The semaphore is available now.\r\n            this.count--;\r\n            return true;\r\n        }\r\n        else if (millisecondsTimeout === 0) {\r\n            // The semaphore is not available and the caller doesn't want to wait.\r\n            return false;\r\n        }\r\n        else {\r\n            const completion = new promiseCompletionSource_1.PromiseCompletionSource();\r\n            this.completions.push(completion);\r\n            // Start with a promise that completes with `true` when the wait succeeds.\r\n            const promises = [completion.promise];\r\n            if (millisecondsTimeout) {\r\n                // Race against a promise that completes with `false` when the timeout expires.\r\n                promises.push(new Promise((resolve) => setTimeout(() => resolve(false), millisecondsTimeout)));\r\n            }\r\n            if (cancellation) {\r\n                // Race against a promise that throws when the cancellation token is cancelled.\r\n                const cancellationCompletion = new promiseCompletionSource_1.PromiseCompletionSource();\r\n                cancellation.onCancellationRequested(() => {\r\n                    cancellationCompletion.reject(new cancellation_1.CancellationError());\r\n                });\r\n                promises.push(cancellationCompletion.promise);\r\n            }\r\n            if (await Promise.race(promises)) {\r\n                // The wait succeeded.\r\n                return true;\r\n            }\r\n            else {\r\n                // The wait timed out. Remove the (not-completed) completion from the array.\r\n                const completionIndex = this.completions.indexOf(completion);\r\n                if (completionIndex >= 0)\r\n                    this.completions.splice(completionIndex, 1);\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Disposes the semaphore and throws a diposed error to any awaiters.\r\n     */\r\n    dispose() {\r\n        if (this.disposed)\r\n            return;\r\n        this.disposed = true;\r\n        for (let completion of this.completions) {\r\n            completion.reject(new errors_1.ObjectDisposedError(this));\r\n        }\r\n        this.completions.splice(0, this.completions.length);\r\n        this.count = 0;\r\n    }\r\n}\r\nexports.Semaphore = Semaphore;\r\n//# sourceMappingURL=semaphore.js.map","/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n * See LICENSE file in root directory for full license.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar eventTargetShim = require('event-target-shim');\n\n/**\n * The signal class.\n * @see https://dom.spec.whatwg.org/#abortsignal\n */\nclass AbortSignal extends eventTargetShim.EventTarget {\n    /**\n     * AbortSignal cannot be constructed directly.\n     */\n    constructor() {\n        super();\n        throw new TypeError(\"AbortSignal cannot be constructed directly\");\n    }\n    /**\n     * Returns `true` if this `AbortSignal`'s `AbortController` has signaled to abort, and `false` otherwise.\n     */\n    get aborted() {\n        const aborted = abortedFlags.get(this);\n        if (typeof aborted !== \"boolean\") {\n            throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? \"null\" : typeof this}`);\n        }\n        return aborted;\n    }\n}\neventTargetShim.defineEventAttribute(AbortSignal.prototype, \"abort\");\n/**\n * Create an AbortSignal object.\n */\nfunction createAbortSignal() {\n    const signal = Object.create(AbortSignal.prototype);\n    eventTargetShim.EventTarget.call(signal);\n    abortedFlags.set(signal, false);\n    return signal;\n}\n/**\n * Abort a given signal.\n */\nfunction abortSignal(signal) {\n    if (abortedFlags.get(signal) !== false) {\n        return;\n    }\n    abortedFlags.set(signal, true);\n    signal.dispatchEvent({ type: \"abort\" });\n}\n/**\n * Aborted flag for each instances.\n */\nconst abortedFlags = new WeakMap();\n// Properties should be enumerable.\nObject.defineProperties(AbortSignal.prototype, {\n    aborted: { enumerable: true },\n});\n// `toString()` should return `\"[object AbortSignal]\"`\nif (typeof Symbol === \"function\" && typeof Symbol.toStringTag === \"symbol\") {\n    Object.defineProperty(AbortSignal.prototype, Symbol.toStringTag, {\n        configurable: true,\n        value: \"AbortSignal\",\n    });\n}\n\n/**\n * The AbortController.\n * @see https://dom.spec.whatwg.org/#abortcontroller\n */\nclass AbortController {\n    /**\n     * Initialize this controller.\n     */\n    constructor() {\n        signals.set(this, createAbortSignal());\n    }\n    /**\n     * Returns the `AbortSignal` object associated with this object.\n     */\n    get signal() {\n        return getSignal(this);\n    }\n    /**\n     * Abort and signal to any observers that the associated activity is to be aborted.\n     */\n    abort() {\n        abortSignal(getSignal(this));\n    }\n}\n/**\n * Associated signals.\n */\nconst signals = new WeakMap();\n/**\n * Get the associated signal of a given controller.\n */\nfunction getSignal(controller) {\n    const signal = signals.get(controller);\n    if (signal == null) {\n        throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? \"null\" : typeof controller}`);\n    }\n    return signal;\n}\n// Properties should be enumerable.\nObject.defineProperties(AbortController.prototype, {\n    signal: { enumerable: true },\n    abort: { enumerable: true },\n});\nif (typeof Symbol === \"function\" && typeof Symbol.toStringTag === \"symbol\") {\n    Object.defineProperty(AbortController.prototype, Symbol.toStringTag, {\n        configurable: true,\n        value: \"AbortController\",\n    });\n}\n\nexports.AbortController = AbortController;\nexports.AbortSignal = AbortSignal;\nexports.default = AbortController;\n\nmodule.exports = AbortController\nmodule.exports.AbortController = module.exports[\"default\"] = AbortController\nmodule.exports.AbortSignal = AbortSignal\n//# sourceMappingURL=abort-controller.js.map\n","/*!\n * ansi-colors <https://github.com/doowb/ansi-colors>\n *\n * Copyright (c) 2015-2017, Brian Woodward.\n * Released under the MIT License.\n */\n\n'use strict';\n\n/**\n * Module dependencies\n */\n\nvar wrap = require('ansi-wrap');\n\n/**\n * Wrap a string with ansi codes to create a black background.\n *\n * ```js\n * console.log(colors.bgblack('some string'));\n * ```\n *\n * @param  {string} message String to wrap with ansi codes.\n * @return {string} Wrapped string\n * @api public\n * @name  bgblack\n */\n\nexports.bgblack = function bgblack(message) {\n  return wrap(40, 49, message);\n};\n\n/**\n * Wrap a string with ansi codes to create a blue background.\n *\n * ```js\n * console.log(colors.bgblue('some string'));\n * ```\n *\n * @param  {string} message String to wrap with ansi codes.\n * @return {string} Wrapped string\n * @api public\n * @name  bgblue\n */\n\nexports.bgblue = function bgblue(message) {\n  return wrap(44, 49, message);\n};\n\n/**\n * Wrap a string with ansi codes to create a cyan background.\n *\n * ```js\n * console.log(colors.bgcyan('some string'));\n * ```\n *\n * @param  {string} message String to wrap with ansi codes.\n * @return {string} Wrapped string\n * @api public\n * @name  bgcyan\n */\n\nexports.bgcyan = function bgcyan(message) {\n  return wrap(46, 49, message);\n};\n\n/**\n * Wrap a string with ansi codes to create a green background.\n *\n * ```js\n * console.log(colors.bggreen('some string'));\n * ```\n *\n * @param  {string} message String to wrap with ansi codes.\n * @return {string} Wrapped string\n * @api public\n * @name  bggreen\n */\n\nexports.bggreen = function bggreen(message) {\n  return wrap(42, 49, message);\n};\n\n/**\n * Wrap a string with ansi codes to create a magenta background.\n *\n * ```js\n * console.log(colors.bgmagenta('some string'));\n * ```\n *\n * @param  {string} message String to wrap with ansi codes.\n * @return {string} Wrapped string\n * @api public\n * @name  bgmagenta\n */\n\nexports.bgmagenta = function bgmagenta(message) {\n  return wrap(45, 49, message);\n};\n\n/**\n * Wrap a string with ansi codes to create a red background.\n *\n * ```js\n * console.log(colors.bgred('some string'));\n * ```\n *\n * @param  {string} message String to wrap with ansi codes.\n * @return {string} Wrapped string\n * @api public\n * @name  bgred\n */\n\nexports.bgred = function bgred(message) {\n  return wrap(41, 49, message);\n};\n\n/**\n * Wrap a string with ansi codes to create a white background.\n *\n * ```js\n * console.log(colors.bgwhite('some string'));\n * ```\n *\n * @param  {string} message String to wrap with ansi codes.\n * @return {string} Wrapped string\n * @api public\n * @name  bgwhite\n */\n\nexports.bgwhite = function bgwhite(message) {\n  return wrap(47, 49, message);\n};\n\n/**\n * Wrap a string with ansi codes to create a yellow background.\n *\n * ```js\n * console.log(colors.bgyellow('some string'));\n * ```\n *\n * @param  {string} message String to wrap with ansi codes.\n * @return {string} Wrapped string\n * @api public\n * @name  bgyellow\n */\n\nexports.bgyellow = function bgyellow(message) {\n  return wrap(43, 49, message);\n};\n\n/**\n * Wrap a string with ansi codes to create black text.\n *\n * ```js\n * console.log(colors.black('some string'));\n * ```\n *\n * @param  {string} message String to wrap with ansi codes.\n * @return {string} Wrapped string\n * @api public\n * @name  black\n */\n\nexports.black = function black(message) {\n  return wrap(30, 39, message);\n};\n\n/**\n * Wrap a string with ansi codes to create blue text.\n *\n * ```js\n * console.log(colors.blue('some string'));\n * ```\n *\n * @param  {string} message String to wrap with ansi codes.\n * @return {string} Wrapped string\n * @api public\n * @name  blue\n */\n\nexports.blue = function blue(message) {\n  return wrap(34, 39, message);\n};\n\n/**\n * Wrap a string with ansi codes to create bold text.\n *\n * ```js\n * console.log(colors.bold('some string'));\n * ```\n *\n * @param  {string} message String to wrap with ansi codes.\n * @return {string} Wrapped string\n * @api public\n * @name  bold\n */\n\nexports.bold = function bold(message) {\n  return wrap(1, 22, message);\n};\n\n/**\n * Wrap a string with ansi codes to create cyan text.\n *\n * ```js\n * console.log(colors.cyan('some string'));\n * ```\n *\n * @param  {string} message String to wrap with ansi codes.\n * @return {string} Wrapped string\n * @api public\n * @name  cyan\n */\n\nexports.cyan = function cyan(message) {\n  return wrap(36, 39, message);\n};\n\n/**\n * Wrap a string with ansi codes to create dim text.\n *\n * ```js\n * console.log(colors.dim('some string'));\n * ```\n *\n * @param  {string} message String to wrap with ansi codes.\n * @return {string} Wrapped string\n * @api public\n * @name  dim\n */\n\nexports.dim = function dim(message) {\n  return wrap(2, 22, message);\n};\n\n/**\n * Wrap a string with ansi codes to create gray text.\n *\n * ```js\n * console.log(colors.gray('some string'));\n * ```\n *\n * @param  {string} message String to wrap with ansi codes.\n * @return {string} Wrapped string\n * @api public\n * @name  gray\n */\n\nexports.gray = function gray(message) {\n  return wrap(90, 39, message);\n};\n\n/**\n * Wrap a string with ansi codes to create green text.\n *\n * ```js\n * console.log(colors.green('some string'));\n * ```\n *\n * @param  {string} message String to wrap with ansi codes.\n * @return {string} Wrapped string\n * @api public\n * @name  green\n */\n\nexports.green = function green(message) {\n  return wrap(32, 39, message);\n};\n\n/**\n * Wrap a string with ansi codes to create grey text.\n *\n * ```js\n * console.log(colors.grey('some string'));\n * ```\n *\n * @param  {string} message String to wrap with ansi codes.\n * @return {string} Wrapped string\n * @api public\n * @name  grey\n */\n\nexports.grey = function grey(message) {\n  return wrap(90, 39, message);\n};\n\n/**\n * Wrap a string with ansi codes to create hidden text.\n *\n * ```js\n * console.log(colors.hidden('some string'));\n * ```\n *\n * @param  {string} message String to wrap with ansi codes.\n * @return {string} Wrapped string\n * @api public\n * @name  hidden\n */\n\nexports.hidden = function hidden(message) {\n  return wrap(8, 28, message);\n};\n\n/**\n * Wrap a string with ansi codes to create inverse text.\n *\n * ```js\n * console.log(colors.inverse('some string'));\n * ```\n *\n * @param  {string} message String to wrap with ansi codes.\n * @return {string} Wrapped string\n * @api public\n * @name  inverse\n */\n\nexports.inverse = function inverse(message) {\n  return wrap(7, 27, message);\n};\n\n/**\n * Wrap a string with ansi codes to create italic text.\n *\n * ```js\n * console.log(colors.italic('some string'));\n * ```\n *\n * @param  {string} message String to wrap with ansi codes.\n * @return {string} Wrapped string\n * @api public\n * @name  italic\n */\n\nexports.italic = function italic(message) {\n  return wrap(3, 23, message);\n};\n\n/**\n * Wrap a string with ansi codes to create magenta text.\n *\n * ```js\n * console.log(colors.magenta('some string'));\n * ```\n *\n * @param  {string} message String to wrap with ansi codes.\n * @return {string} Wrapped string\n * @api public\n * @name  magenta\n */\n\nexports.magenta = function magenta(message) {\n  return wrap(35, 39, message);\n};\n\n/**\n * Wrap a string with ansi codes to create red text.\n *\n * ```js\n * console.log(colors.red('some string'));\n * ```\n *\n * @param  {string} message String to wrap with ansi codes.\n * @return {string} Wrapped string\n * @api public\n * @name  red\n */\n\nexports.red = function red(message) {\n  return wrap(31, 39, message);\n};\n\n/**\n * Wrap a string with ansi codes to reset ansi colors currently on the string.\n *\n * ```js\n * console.log(colors.reset('some string'));\n * ```\n *\n * @param  {string} message String to wrap with ansi codes.\n * @return {string} Wrapped string\n * @api public\n * @name  reset\n */\n\nexports.reset = function reset(message) {\n  return wrap(0, 0, message);\n};\n\n/**\n * Wrap a string with ansi codes to add a strikethrough to the text.\n *\n * ```js\n * console.log(colors.strikethrough('some string'));\n * ```\n *\n * @param  {string} message String to wrap with ansi codes.\n * @return {string} Wrapped string\n * @api public\n * @name  strikethrough\n */\n\nexports.strikethrough = function strikethrough(message) {\n  return wrap(9, 29, message);\n};\n\n/**\n * Wrap a string with ansi codes to underline the text.\n *\n * ```js\n * console.log(colors.underline('some string'));\n * ```\n *\n * @param  {string} message String to wrap with ansi codes.\n * @return {string} Wrapped string\n * @api public\n * @name  underline\n */\n\nexports.underline = function underline(message) {\n  return wrap(4, 24, message);\n};\n\n/**\n * Wrap a string with ansi codes to create white text.\n *\n * ```js\n * console.log(colors.white('some string'));\n * ```\n *\n * @param  {string} message String to wrap with ansi codes.\n * @return {string} Wrapped string\n * @api public\n * @name  white\n */\n\nexports.white = function white(message) {\n  return wrap(37, 39, message);\n};\n\n/**\n * Wrap a string with ansi codes to create yellow text.\n *\n * ```js\n * console.log(colors.yellow('some string'));\n * ```\n *\n * @param  {string} message String to wrap with ansi codes.\n * @return {string} Wrapped string\n * @api public\n * @name  yellow\n */\n\nexports.yellow = function yellow(message) {\n  return wrap(33, 39, message);\n};\n","'use strict';\n\nmodule.exports = ({onlyFirst = false} = {}) => {\n\tconst pattern = [\n\t\t'[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)',\n\t\t'(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))'\n\t].join('|');\n\n\treturn new RegExp(pattern, onlyFirst ? undefined : 'g');\n};\n","'use strict';\n\nmodule.exports = function(a, b, msg) {\n  return '\\u001b['+ a + 'm' + msg + '\\u001b[' + b + 'm';\n};\n","\"use strict\";\r\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar CorrelationContextManager_1 = require(\"./CorrelationContextManager\");\r\nvar events_1 = require(\"events\");\r\n/**\r\n * Type of span. Can be used to specify additional relationships between spans\r\n * in addition to a parent/child relationship.\r\n */\r\nvar SpanKind;\r\n(function (SpanKind) {\r\n    /** Default value. Indicates that the span is used internally. */\r\n    SpanKind[SpanKind[\"INTERNAL\"] = 0] = \"INTERNAL\";\r\n    /**\r\n     * Indicates that the span covers server-side handling of an RPC or other\r\n     * remote request.\r\n     */\r\n    SpanKind[SpanKind[\"SERVER\"] = 1] = \"SERVER\";\r\n    /**\r\n     * Indicates that the span covers the client-side wrapper around an RPC or\r\n     * other remote request.\r\n     */\r\n    SpanKind[SpanKind[\"CLIENT\"] = 2] = \"CLIENT\";\r\n    /**\r\n     * Indicates that the span describes producer sending a message to a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    SpanKind[SpanKind[\"PRODUCER\"] = 3] = \"PRODUCER\";\r\n    /**\r\n     * Indicates that the span describes consumer receiving a message from a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    SpanKind[SpanKind[\"CONSUMER\"] = 4] = \"CONSUMER\";\r\n})(SpanKind = exports.SpanKind || (exports.SpanKind = {}));\r\nvar OpenTelemetryScopeManagerWrapper = (function () {\r\n    function OpenTelemetryScopeManagerWrapper() {\r\n    }\r\n    OpenTelemetryScopeManagerWrapper.prototype.active = function () {\r\n        var _this = this;\r\n        var context = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();\r\n        return __assign({}, context, { getValue: function (key) {\r\n                // todo: lazy import activeSymbol from opentelemetry/api\r\n                if (!_this._activeSymbol) {\r\n                    _this._activeSymbol = key;\r\n                    return context;\r\n                }\r\n                if (key === _this._activeSymbol) {\r\n                    return context;\r\n                }\r\n                return false;\r\n            }, setValue: function () { } });\r\n    };\r\n    OpenTelemetryScopeManagerWrapper.prototype.with = function (span, fn) {\r\n        var parentSpanId = span.parentSpanId;\r\n        var name = span.name;\r\n        var correlationContext = OpenTelemetryScopeManagerWrapper._spanToContext(span, parentSpanId, name);\r\n        return CorrelationContextManager_1.CorrelationContextManager.runWithContext(correlationContext, fn)();\r\n    };\r\n    OpenTelemetryScopeManagerWrapper.prototype.bind = function (target) {\r\n        if (typeof target === \"function\") {\r\n            return CorrelationContextManager_1.CorrelationContextManager.wrapCallback(target);\r\n        }\r\n        else if (target instanceof events_1.EventEmitter) {\r\n            CorrelationContextManager_1.CorrelationContextManager.wrapEmitter(target);\r\n        }\r\n        return target;\r\n    };\r\n    OpenTelemetryScopeManagerWrapper.prototype.enable = function () {\r\n        CorrelationContextManager_1.CorrelationContextManager.enable();\r\n        return this;\r\n    };\r\n    OpenTelemetryScopeManagerWrapper.prototype.disable = function () {\r\n        CorrelationContextManager_1.CorrelationContextManager.disable();\r\n        return this;\r\n    };\r\n    OpenTelemetryScopeManagerWrapper._spanToContext = function (span, parentSpanId, name) {\r\n        var _parentId = parentSpanId ? \"|\" + span.context().traceId + \".\" + parentSpanId + \".\" : span.context().traceId;\r\n        var context = __assign({}, span.context(), { traceFlags: span.context().traceFlags.toString() });\r\n        var correlationContext = CorrelationContextManager_1.CorrelationContextManager.spanToContextObject(context, _parentId, name);\r\n        return correlationContext;\r\n    };\r\n    return OpenTelemetryScopeManagerWrapper;\r\n}());\r\nexports.OpenTelemetryScopeManagerWrapper = OpenTelemetryScopeManagerWrapper;\r\nexports.AsyncScopeManager = new OpenTelemetryScopeManagerWrapper();\r\n//# sourceMappingURL=AsyncHooksScopeManager.js.map","\"use strict\";\r\nvar DiagChannel = require(\"./diagnostic-channel/initialization\");\r\nvar AutoCollectConsole = (function () {\r\n    function AutoCollectConsole(client) {\r\n        if (!!AutoCollectConsole.INSTANCE) {\r\n            throw new Error(\"Console logging adapter tracking should be configured from the applicationInsights object\");\r\n        }\r\n        this._client = client;\r\n        AutoCollectConsole.INSTANCE = this;\r\n    }\r\n    AutoCollectConsole.prototype.enable = function (isEnabled, collectConsoleLog) {\r\n        if (DiagChannel.IsInitialized) {\r\n            require(\"./diagnostic-channel/console.sub\").enable(isEnabled && collectConsoleLog, this._client);\r\n            require(\"./diagnostic-channel/bunyan.sub\").enable(isEnabled, this._client);\r\n            require(\"./diagnostic-channel/winston.sub\").enable(isEnabled, this._client);\r\n        }\r\n    };\r\n    AutoCollectConsole.prototype.isInitialized = function () {\r\n        return this._isInitialized;\r\n    };\r\n    AutoCollectConsole.prototype.dispose = function () {\r\n        AutoCollectConsole.INSTANCE = null;\r\n        this.enable(false, false);\r\n    };\r\n    AutoCollectConsole._methodNames = [\"debug\", \"info\", \"log\", \"warn\", \"error\"];\r\n    return AutoCollectConsole;\r\n}());\r\nmodule.exports = AutoCollectConsole;\r\n//# sourceMappingURL=Console.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Logging = require(\"../Library/Logging\");\r\nvar DiagChannel = require(\"./diagnostic-channel/initialization\");\r\nvar Traceparent = require(\"../Library/Traceparent\");\r\nvar Tracestate = require(\"../Library/Tracestate\");\r\nvar HttpRequestParser = require(\"./HttpRequestParser\");\r\nvar CorrelationContextManager = (function () {\r\n    function CorrelationContextManager() {\r\n    }\r\n    /**\r\n     *  Provides the current Context.\r\n     *  The context is the most recent one entered into for the current\r\n     *  logical chain of execution, including across asynchronous calls.\r\n     */\r\n    CorrelationContextManager.getCurrentContext = function () {\r\n        if (!CorrelationContextManager.enabled) {\r\n            return null;\r\n        }\r\n        var context = CorrelationContextManager.session.get(CorrelationContextManager.CONTEXT_NAME);\r\n        if (context === undefined) {\r\n            return null;\r\n        }\r\n        return context;\r\n    };\r\n    /**\r\n     *  A helper to generate objects conforming to the CorrelationContext interface\r\n     */\r\n    CorrelationContextManager.generateContextObject = function (operationId, parentId, operationName, correlationContextHeader, traceparent, tracestate) {\r\n        parentId = parentId || operationId;\r\n        if (this.enabled) {\r\n            return {\r\n                operation: {\r\n                    name: operationName,\r\n                    id: operationId,\r\n                    parentId: parentId,\r\n                    traceparent: traceparent,\r\n                    tracestate: tracestate\r\n                },\r\n                customProperties: new CustomPropertiesImpl(correlationContextHeader)\r\n            };\r\n        }\r\n        return null;\r\n    };\r\n    CorrelationContextManager.spanToContextObject = function (spanContext, parentId, name) {\r\n        var traceContext = new Traceparent();\r\n        traceContext.traceId = spanContext.traceId;\r\n        traceContext.spanId = spanContext.spanId;\r\n        traceContext.traceFlag = spanContext.traceFlags || Traceparent.DEFAULT_TRACE_FLAG;\r\n        traceContext.parentId = parentId;\r\n        return CorrelationContextManager.generateContextObject(traceContext.traceId, traceContext.parentId, name, null, traceContext);\r\n    };\r\n    /**\r\n     *  Runs a function inside a given Context.\r\n     *  All logical children of the execution path that entered this Context\r\n     *  will receive this Context object on calls to GetCurrentContext.\r\n     */\r\n    CorrelationContextManager.runWithContext = function (context, fn) {\r\n        if (CorrelationContextManager.enabled) {\r\n            return CorrelationContextManager.session.bind(fn, (_a = {}, _a[CorrelationContextManager.CONTEXT_NAME] = context, _a))();\r\n        }\r\n        else {\r\n            return fn();\r\n        }\r\n        var _a;\r\n    };\r\n    /**\r\n     * Wrapper for cls-hooked bindEmitter method\r\n     */\r\n    CorrelationContextManager.wrapEmitter = function (emitter) {\r\n        if (CorrelationContextManager.enabled) {\r\n            CorrelationContextManager.session.bindEmitter(emitter);\r\n        }\r\n    };\r\n    /**\r\n     *  Patches a callback to restore the correct Context when getCurrentContext\r\n     *  is run within it. This is necessary if automatic correlation fails to work\r\n     *  with user-included libraries.\r\n     *\r\n     *  The supplied callback will be given the same context that was present for\r\n     *  the call to wrapCallback.  */\r\n    CorrelationContextManager.wrapCallback = function (fn, context) {\r\n        if (CorrelationContextManager.enabled) {\r\n            return CorrelationContextManager.session.bind(fn, context ? (_a = {},\r\n                _a[CorrelationContextManager.CONTEXT_NAME] = context,\r\n                _a) : undefined);\r\n        }\r\n        return fn;\r\n        var _a;\r\n    };\r\n    /**\r\n     *  Enables the CorrelationContextManager.\r\n     */\r\n    CorrelationContextManager.enable = function (forceClsHooked) {\r\n        if (this.enabled) {\r\n            return;\r\n        }\r\n        if (!this.isNodeVersionCompatible()) {\r\n            this.enabled = false;\r\n            return;\r\n        }\r\n        if (!CorrelationContextManager.hasEverEnabled) {\r\n            this.forceClsHooked = forceClsHooked;\r\n            this.hasEverEnabled = true;\r\n            if (typeof this.cls === \"undefined\") {\r\n                if ((CorrelationContextManager.forceClsHooked === true) || (CorrelationContextManager.forceClsHooked === undefined && CorrelationContextManager.shouldUseClsHooked())) {\r\n                    this.cls = require('cls-hooked');\r\n                }\r\n                else {\r\n                    this.cls = require('continuation-local-storage');\r\n                }\r\n            }\r\n            CorrelationContextManager.session = this.cls.createNamespace(\"AI-CLS-Session\");\r\n            DiagChannel.registerContextPreservation(function (cb) {\r\n                return CorrelationContextManager.session.bind(cb);\r\n            });\r\n        }\r\n        this.enabled = true;\r\n    };\r\n    CorrelationContextManager.startOperation = function (context, request) {\r\n        var traceContext = context && context.traceContext || null;\r\n        var spanContext = context && context.traceId\r\n            ? context\r\n            : null;\r\n        var headers = context && context.headers;\r\n        if (spanContext) {\r\n            var traceparent = new Traceparent(\"00-\" + spanContext.traceId + \"-\" + spanContext.spanId + \"-01\");\r\n            var tracestate = new Tracestate(spanContext.tracestate);\r\n            var correlationContext = CorrelationContextManager.generateContextObject(spanContext.traceId, \"|\" + spanContext.traceId + \".\" + spanContext.spanId + \".\", typeof request === \"string\" ? request : \"\", undefined, traceparent, tracestate);\r\n            return correlationContext;\r\n        }\r\n        // AzFunction TraceContext available\r\n        if (traceContext) {\r\n            var traceparent = new Traceparent(traceContext.traceparent);\r\n            var tracestate = new Tracestate(traceContext.tracestate);\r\n            var parser = typeof request === \"object\"\r\n                ? new HttpRequestParser(request)\r\n                : null;\r\n            var correlationContext = CorrelationContextManager.generateContextObject(traceparent.traceId, traceparent.parentId, typeof request === \"string\"\r\n                ? request\r\n                : parser.getOperationName({}), parser && parser.getCorrelationContextHeader() || undefined, traceparent, tracestate);\r\n            return correlationContext;\r\n        }\r\n        // No TraceContext available, parse as http.IncomingMessage\r\n        if (headers) {\r\n            var traceparent = new Traceparent(headers.traceparent);\r\n            var tracestate = new Tracestate(headers.tracestate);\r\n            var parser = new HttpRequestParser(context);\r\n            var correlationContext = CorrelationContextManager.generateContextObject(traceparent.traceId, traceparent.parentId, parser.getOperationName({}), parser.getCorrelationContextHeader(), traceparent, tracestate);\r\n            return correlationContext;\r\n        }\r\n        Logging.warn(\"startOperation was called with invalid arguments\", arguments);\r\n        return null;\r\n    };\r\n    /**\r\n     *  Disables the CorrelationContextManager.\r\n     */\r\n    CorrelationContextManager.disable = function () {\r\n        this.enabled = false;\r\n    };\r\n    /**\r\n     * Reset the namespace\r\n     */\r\n    CorrelationContextManager.reset = function () {\r\n        if (CorrelationContextManager.hasEverEnabled) {\r\n            CorrelationContextManager.session = null;\r\n            CorrelationContextManager.session = this.cls.createNamespace('AI-CLS-Session');\r\n        }\r\n    };\r\n    /**\r\n     *  Reports if CorrelationContextManager is able to run in this environment\r\n     */\r\n    CorrelationContextManager.isNodeVersionCompatible = function () {\r\n        var nodeVer = process.versions.node.split(\".\");\r\n        return parseInt(nodeVer[0]) > 3 || (parseInt(nodeVer[0]) > 2 && parseInt(nodeVer[1]) > 2);\r\n    };\r\n    /**\r\n     * We only want to use cls-hooked when it uses async_hooks api (8.2+), else\r\n     * use async-listener (plain -cls)\r\n     */\r\n    CorrelationContextManager.shouldUseClsHooked = function () {\r\n        var nodeVer = process.versions.node.split(\".\");\r\n        return (parseInt(nodeVer[0]) > 8) || (parseInt(nodeVer[0]) >= 8 && parseInt(nodeVer[1]) >= 2);\r\n    };\r\n    /**\r\n     * A TypeError is triggered by cls-hooked for node [8.0, 8.2)\r\n     * @internal Used in tests only\r\n     */\r\n    CorrelationContextManager.canUseClsHooked = function () {\r\n        var nodeVer = process.versions.node.split(\".\");\r\n        var greater800 = (parseInt(nodeVer[0]) > 8) || (parseInt(nodeVer[0]) >= 8 && parseInt(nodeVer[1]) >= 0);\r\n        var less820 = (parseInt(nodeVer[0]) < 8) || (parseInt(nodeVer[0]) <= 8 && parseInt(nodeVer[1]) < 2);\r\n        var greater470 = parseInt(nodeVer[0]) > 4 || (parseInt(nodeVer[0]) >= 4 && parseInt(nodeVer[1]) >= 7); // cls-hooked requires node 4.7+\r\n        return !(greater800 && less820) && greater470;\r\n    };\r\n    CorrelationContextManager.enabled = false;\r\n    CorrelationContextManager.hasEverEnabled = false;\r\n    CorrelationContextManager.forceClsHooked = undefined; // true: use cls-hooked, false: use cls, undefined: choose based on node version\r\n    CorrelationContextManager.CONTEXT_NAME = \"ApplicationInsights-Context\";\r\n    return CorrelationContextManager;\r\n}());\r\nexports.CorrelationContextManager = CorrelationContextManager;\r\nvar CustomPropertiesImpl = (function () {\r\n    function CustomPropertiesImpl(header) {\r\n        this.props = [];\r\n        this.addHeaderData(header);\r\n    }\r\n    CustomPropertiesImpl.prototype.addHeaderData = function (header) {\r\n        var keyvals = header ? header.split(\", \") : [];\r\n        this.props = keyvals.map(function (keyval) {\r\n            var parts = keyval.split(\"=\");\r\n            return { key: parts[0], value: parts[1] };\r\n        }).concat(this.props);\r\n    };\r\n    CustomPropertiesImpl.prototype.serializeToHeader = function () {\r\n        return this.props.map(function (keyval) {\r\n            return keyval.key + \"=\" + keyval.value;\r\n        }).join(\", \");\r\n    };\r\n    CustomPropertiesImpl.prototype.getProperty = function (prop) {\r\n        for (var i = 0; i < this.props.length; ++i) {\r\n            var keyval = this.props[i];\r\n            if (keyval.key === prop) {\r\n                return keyval.value;\r\n            }\r\n        }\r\n        return;\r\n    };\r\n    // TODO: Strictly according to the spec, properties which are recieved from\r\n    // an incoming request should be left untouched, while we may add our own new\r\n    // properties. The logic here will need to change to track that.\r\n    CustomPropertiesImpl.prototype.setProperty = function (prop, val) {\r\n        if (CustomPropertiesImpl.bannedCharacters.test(prop) || CustomPropertiesImpl.bannedCharacters.test(val)) {\r\n            Logging.warn(\"Correlation context property keys and values must not contain ',' or '='. setProperty was called with key: \" + prop + \" and value: \" + val);\r\n            return;\r\n        }\r\n        for (var i = 0; i < this.props.length; ++i) {\r\n            var keyval = this.props[i];\r\n            if (keyval.key === prop) {\r\n                keyval.value = val;\r\n                return;\r\n            }\r\n        }\r\n        this.props.push({ key: prop, value: val });\r\n    };\r\n    CustomPropertiesImpl.bannedCharacters = /[,=]/;\r\n    return CustomPropertiesImpl;\r\n}());\r\n//# sourceMappingURL=CorrelationContextManager.js.map","\"use strict\";\r\nvar AutoCollectExceptions = (function () {\r\n    function AutoCollectExceptions(client) {\r\n        if (!!AutoCollectExceptions.INSTANCE) {\r\n            throw new Error(\"Exception tracking should be configured from the applicationInsights object\");\r\n        }\r\n        AutoCollectExceptions.INSTANCE = this;\r\n        this._client = client;\r\n        // Only use for 13.7.0+\r\n        var nodeVer = process.versions.node.split(\".\");\r\n        AutoCollectExceptions._canUseUncaughtExceptionMonitor = parseInt(nodeVer[0]) > 13 || (parseInt(nodeVer[0]) === 13 && parseInt(nodeVer[1]) >= 7);\r\n    }\r\n    AutoCollectExceptions.prototype.isInitialized = function () {\r\n        return this._isInitialized;\r\n    };\r\n    AutoCollectExceptions.prototype.enable = function (isEnabled) {\r\n        var _this = this;\r\n        if (isEnabled) {\r\n            this._isInitialized = true;\r\n            var self = this;\r\n            if (!this._exceptionListenerHandle) {\r\n                // For scenarios like Promise.reject(), an error won't be passed to the handle. Create a placeholder\r\n                // error for these scenarios.\r\n                var handle = function (reThrow, name, error) {\r\n                    if (error === void 0) { error = new Error(AutoCollectExceptions._FALLBACK_ERROR_MESSAGE); }\r\n                    _this._client.trackException({ exception: error });\r\n                    _this._client.flush({ isAppCrashing: true });\r\n                    // only rethrow when we are the only listener\r\n                    if (reThrow && name && process.listeners(name).length === 1) {\r\n                        console.error(error);\r\n                        process.exit(1);\r\n                    }\r\n                };\r\n                if (AutoCollectExceptions._canUseUncaughtExceptionMonitor) {\r\n                    // Node.js >= 13.7.0, use uncaughtExceptionMonitor. It handles both promises and exceptions\r\n                    this._exceptionListenerHandle = handle.bind(this, false, undefined); // never rethrows\r\n                    process.on(AutoCollectExceptions.UNCAUGHT_EXCEPTION_MONITOR_HANDLER_NAME, this._exceptionListenerHandle);\r\n                }\r\n                else {\r\n                    this._exceptionListenerHandle = handle.bind(this, true, AutoCollectExceptions.UNCAUGHT_EXCEPTION_HANDLER_NAME);\r\n                    this._rejectionListenerHandle = handle.bind(this, false, undefined); // never rethrows\r\n                    process.on(AutoCollectExceptions.UNCAUGHT_EXCEPTION_HANDLER_NAME, this._exceptionListenerHandle);\r\n                    process.on(AutoCollectExceptions.UNHANDLED_REJECTION_HANDLER_NAME, this._rejectionListenerHandle);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (this._exceptionListenerHandle) {\r\n                if (AutoCollectExceptions._canUseUncaughtExceptionMonitor) {\r\n                    process.removeListener(AutoCollectExceptions.UNCAUGHT_EXCEPTION_MONITOR_HANDLER_NAME, this._exceptionListenerHandle);\r\n                }\r\n                else {\r\n                    process.removeListener(AutoCollectExceptions.UNCAUGHT_EXCEPTION_HANDLER_NAME, this._exceptionListenerHandle);\r\n                    process.removeListener(AutoCollectExceptions.UNHANDLED_REJECTION_HANDLER_NAME, this._rejectionListenerHandle);\r\n                }\r\n                this._exceptionListenerHandle = undefined;\r\n                this._rejectionListenerHandle = undefined;\r\n                delete this._exceptionListenerHandle;\r\n                delete this._rejectionListenerHandle;\r\n            }\r\n        }\r\n    };\r\n    AutoCollectExceptions.prototype.dispose = function () {\r\n        AutoCollectExceptions.INSTANCE = null;\r\n        this.enable(false);\r\n        this._isInitialized = false;\r\n    };\r\n    AutoCollectExceptions.INSTANCE = null;\r\n    AutoCollectExceptions.UNCAUGHT_EXCEPTION_MONITOR_HANDLER_NAME = \"uncaughtExceptionMonitor\";\r\n    AutoCollectExceptions.UNCAUGHT_EXCEPTION_HANDLER_NAME = \"uncaughtException\";\r\n    AutoCollectExceptions.UNHANDLED_REJECTION_HANDLER_NAME = \"unhandledRejection\";\r\n    AutoCollectExceptions._RETHROW_EXIT_MESSAGE = \"Application Insights Rethrow Exception Handler\";\r\n    AutoCollectExceptions._FALLBACK_ERROR_MESSAGE = \"A promise was rejected without providing an error. Application Insights generated this error stack for you.\";\r\n    AutoCollectExceptions._canUseUncaughtExceptionMonitor = false;\r\n    return AutoCollectExceptions;\r\n}());\r\nmodule.exports = AutoCollectExceptions;\r\n//# sourceMappingURL=Exceptions.js.map","\"use strict\";\r\nvar os = require(\"os\");\r\nvar Constants = require(\"../Declarations/Constants\");\r\nvar Util = require(\"../Library/Util\");\r\nvar Context = require(\"../Library/Context\");\r\nvar AutoCollectHttpDependencies = require(\"../AutoCollection/HttpDependencies\");\r\nvar AIMS_URI = \"http://169.254.169.254/metadata/instance/compute\";\r\nvar AIMS_API_VERSION = \"api-version=2017-12-01\";\r\nvar AIMS_FORMAT = \"format=json\";\r\nvar ConnectionErrorMessage = \"ENETUNREACH\";\r\nvar HeartBeat = (function () {\r\n    function HeartBeat(client) {\r\n        this._collectionInterval = 900000;\r\n        this._vmData = {};\r\n        this._azInst_vmId = \"\";\r\n        this._azInst_subscriptionId = \"\";\r\n        this._azInst_osType = \"\";\r\n        if (!HeartBeat.INSTANCE) {\r\n            HeartBeat.INSTANCE = this;\r\n        }\r\n        this._isInitialized = false;\r\n        this._client = client;\r\n    }\r\n    HeartBeat.prototype.enable = function (isEnabled, config) {\r\n        var _this = this;\r\n        this._isEnabled = isEnabled;\r\n        if (this._isEnabled && !this._isInitialized) {\r\n            this._isInitialized = true;\r\n        }\r\n        if (isEnabled) {\r\n            if (!this._handle) {\r\n                this._handle = setInterval(function () { return _this.trackHeartBeat(config, function () { }); }, this._collectionInterval);\r\n                this._handle.unref(); // Allow the app to terminate even while this loop is going on\r\n            }\r\n        }\r\n        else {\r\n            if (this._handle) {\r\n                clearInterval(this._handle);\r\n                this._handle = null;\r\n            }\r\n        }\r\n    };\r\n    HeartBeat.prototype.isInitialized = function () {\r\n        return this._isInitialized;\r\n    };\r\n    HeartBeat.isEnabled = function () {\r\n        return HeartBeat.INSTANCE && HeartBeat.INSTANCE._isEnabled;\r\n    };\r\n    HeartBeat.prototype.trackHeartBeat = function (config, callback) {\r\n        var _this = this;\r\n        var waiting = false;\r\n        var properties = {};\r\n        var sdkVersion = Context.sdkVersion; // \"node\" or \"node-nativeperf\"\r\n        properties[\"sdk\"] = sdkVersion;\r\n        properties[\"osType\"] = os.type();\r\n        if (process.env.WEBSITE_SITE_NAME) {\r\n            properties[\"appSrv_SiteName\"] = process.env.WEBSITE_SITE_NAME || \"\";\r\n            properties[\"appSrv_wsStamp\"] = process.env.WEBSITE_HOME_STAMPNAME || \"\";\r\n            properties[\"appSrv_wsHost\"] = process.env.WEBSITE_HOSTNAME || \"\";\r\n        }\r\n        else if (process.env.FUNCTIONS_WORKER_RUNTIME) {\r\n            properties[\"azfunction_appId\"] = process.env.WEBSITE_HOSTNAME;\r\n        }\r\n        else if (config) {\r\n            if (this._isVM === undefined) {\r\n                waiting = true;\r\n                this._getAzureComputeMetadata(config, function () {\r\n                    if (_this._isVM && Object.keys(_this._vmData).length > 0) {\r\n                        properties[\"azInst_vmId\"] = _this._vmData[\"vmId\"] || \"\";\r\n                        properties[\"azInst_subscriptionId\"] = _this._vmData[\"subscriptionId\"] || \"\";\r\n                        properties[\"azInst_osType\"] = _this._vmData[\"osType\"] || \"\";\r\n                        _this._azInst_vmId = _this._vmData[\"vmId\"] || \"\";\r\n                        _this._azInst_subscriptionId = _this._vmData[\"subscriptionId\"] || \"\";\r\n                        _this._azInst_osType = _this._vmData[\"osType\"] || \"\";\r\n                    }\r\n                    _this._client.trackMetric({ name: Constants.HeartBeatMetricName, value: 0, properties: properties });\r\n                    callback();\r\n                });\r\n            }\r\n            else if (this._isVM) {\r\n                properties[\"azInst_vmId\"] = this._azInst_vmId;\r\n                properties[\"azInst_subscriptionId\"] = this._azInst_subscriptionId;\r\n                properties[\"azInst_osType\"] = this._azInst_osType;\r\n            }\r\n        }\r\n        if (!waiting) {\r\n            this._client.trackMetric({ name: Constants.HeartBeatMetricName, value: 0, properties: properties });\r\n            callback();\r\n        }\r\n    };\r\n    HeartBeat.prototype.dispose = function () {\r\n        HeartBeat.INSTANCE = null;\r\n        this.enable(false);\r\n        this._isInitialized = false;\r\n    };\r\n    HeartBeat.prototype._getAzureComputeMetadata = function (config, callback) {\r\n        var _this = this;\r\n        var metadataRequestUrl = AIMS_URI + \"?\" + AIMS_API_VERSION + \"&\" + AIMS_FORMAT;\r\n        var requestOptions = (_a = {\r\n                method: 'GET'\r\n            },\r\n            _a[AutoCollectHttpDependencies.disableCollectionRequestOption] = true,\r\n            _a.headers = {\r\n                \"Metadata\": \"True\",\r\n            },\r\n            _a);\r\n        var req = Util.makeRequest(config, metadataRequestUrl, requestOptions, function (res) {\r\n            if (res.statusCode === 200) {\r\n                // Success; VM\r\n                _this._isVM = true;\r\n                var virtualMachineData_1 = \"\";\r\n                res.on('data', function (data) {\r\n                    virtualMachineData_1 += data;\r\n                });\r\n                res.on('end', function () {\r\n                    _this._vmData = _this._isJSON(virtualMachineData_1) ? JSON.parse(virtualMachineData_1) : {};\r\n                    callback();\r\n                });\r\n            }\r\n            else {\r\n                // else Retry on next heartbeat metrics call\r\n                callback();\r\n            }\r\n        });\r\n        if (req) {\r\n            req.on('error', function (error) {\r\n                // Unable to contact endpoint.\r\n                // Do nothing for now.\r\n                if (error && error.message && error.message.indexOf(ConnectionErrorMessage) > -1) {\r\n                    _this._isVM = false; // confirm it's not in VM\r\n                }\r\n                // errors other than connect ENETUNREACH - retry\r\n                callback();\r\n            });\r\n            req.end();\r\n        }\r\n        var _a;\r\n    };\r\n    HeartBeat.prototype._isJSON = function (str) {\r\n        try {\r\n            return (JSON.parse(str) && !!str);\r\n        }\r\n        catch (e) {\r\n            return false;\r\n        }\r\n    };\r\n    return HeartBeat;\r\n}());\r\nmodule.exports = HeartBeat;\r\n//# sourceMappingURL=HeartBeat.js.map","\"use strict\";\r\nvar http = require(\"http\");\r\nvar https = require(\"https\");\r\nvar Logging = require(\"../Library/Logging\");\r\nvar Util = require(\"../Library/Util\");\r\nvar RequestResponseHeaders = require(\"../Library/RequestResponseHeaders\");\r\nvar HttpDependencyParser = require(\"./HttpDependencyParser\");\r\nvar CorrelationContextManager_1 = require(\"./CorrelationContextManager\");\r\nvar CorrelationIdManager = require(\"../Library/CorrelationIdManager\");\r\nvar Traceparent = require(\"../Library/Traceparent\");\r\nvar DiagChannel = require(\"./diagnostic-channel/initialization\");\r\nvar AutoCollectHttpDependencies = (function () {\r\n    function AutoCollectHttpDependencies(client) {\r\n        if (!!AutoCollectHttpDependencies.INSTANCE) {\r\n            throw new Error(\"Client request tracking should be configured from the applicationInsights object\");\r\n        }\r\n        AutoCollectHttpDependencies.INSTANCE = this;\r\n        this._client = client;\r\n    }\r\n    AutoCollectHttpDependencies.prototype.enable = function (isEnabled) {\r\n        this._isEnabled = isEnabled;\r\n        if (this._isEnabled && !this._isInitialized) {\r\n            this._initialize();\r\n        }\r\n        if (DiagChannel.IsInitialized) {\r\n            require(\"./diagnostic-channel/azure-coretracing.sub\").enable(true, this._client);\r\n            require(\"./diagnostic-channel/mongodb.sub\").enable(isEnabled, this._client);\r\n            require(\"./diagnostic-channel/mysql.sub\").enable(isEnabled, this._client);\r\n            require(\"./diagnostic-channel/redis.sub\").enable(isEnabled, this._client);\r\n            require(\"./diagnostic-channel/postgres.sub\").enable(isEnabled, this._client);\r\n        }\r\n    };\r\n    AutoCollectHttpDependencies.prototype.isInitialized = function () {\r\n        return this._isInitialized;\r\n    };\r\n    AutoCollectHttpDependencies.prototype._initialize = function () {\r\n        var _this = this;\r\n        this._isInitialized = true;\r\n        var originalGet = http.get;\r\n        var originalRequest = http.request;\r\n        var originalHttpsRequest = https.request;\r\n        var clientRequestPatch = function (request, options) {\r\n            var shouldCollect = !options[AutoCollectHttpDependencies.disableCollectionRequestOption] &&\r\n                !request[AutoCollectHttpDependencies.alreadyAutoCollectedFlag];\r\n            // If someone else patched traceparent headers onto this request\r\n            if (options.headers && options.headers['user-agent'] && options.headers['user-agent'].toString().indexOf('azsdk-js') !== -1) {\r\n                shouldCollect = false;\r\n            }\r\n            request[AutoCollectHttpDependencies.alreadyAutoCollectedFlag] = true;\r\n            if (request && options && shouldCollect) {\r\n                CorrelationContextManager_1.CorrelationContextManager.wrapEmitter(request);\r\n                AutoCollectHttpDependencies.trackRequest(_this._client, { options: options, request: request });\r\n            }\r\n        };\r\n        // On node >= v0.11.12 and < 9.0 (excluding 8.9.0) https.request just calls http.request (with additional options).\r\n        // On node < 0.11.12, 8.9.0, and 9.0 > https.request is handled separately\r\n        // Patch both and leave a flag to not double-count on versions that just call through\r\n        // We add the flag to both http and https to protect against strange double collection in other scenarios\r\n        http.request = function (options) {\r\n            var requestArgs = [];\r\n            for (var _i = 1; _i < arguments.length; _i++) {\r\n                requestArgs[_i - 1] = arguments[_i];\r\n            }\r\n            var request = originalRequest.call.apply(originalRequest, [http, options].concat(requestArgs));\r\n            clientRequestPatch(request, options);\r\n            return request;\r\n        };\r\n        https.request = function (options) {\r\n            var requestArgs = [];\r\n            for (var _i = 1; _i < arguments.length; _i++) {\r\n                requestArgs[_i - 1] = arguments[_i];\r\n            }\r\n            var request = originalHttpsRequest.call.apply(originalHttpsRequest, [https, options].concat(requestArgs));\r\n            clientRequestPatch(request, options);\r\n            return request;\r\n        };\r\n        // Node 8 calls http.request from http.get using a local reference!\r\n        // We have to patch .get manually in this case and can't just assume request is enough\r\n        // We have to replace the entire method in this case. We can't call the original.\r\n        // This is because calling the original will give us no chance to set headers as it internally does .end().\r\n        http.get = function (options) {\r\n            var requestArgs = [];\r\n            for (var _i = 1; _i < arguments.length; _i++) {\r\n                requestArgs[_i - 1] = arguments[_i];\r\n            }\r\n            var request = (_a = http.request).call.apply(_a, [http, options].concat(requestArgs));\r\n            request.end();\r\n            return request;\r\n            var _a;\r\n        };\r\n        https.get = function (options) {\r\n            var requestArgs = [];\r\n            for (var _i = 1; _i < arguments.length; _i++) {\r\n                requestArgs[_i - 1] = arguments[_i];\r\n            }\r\n            var request = (_a = https.request).call.apply(_a, [https, options].concat(requestArgs));\r\n            request.end();\r\n            return request;\r\n            var _a;\r\n        };\r\n    };\r\n    /**\r\n     * Tracks an outgoing request. Because it may set headers this method must be called before\r\n     * writing content to or ending the request.\r\n     */\r\n    AutoCollectHttpDependencies.trackRequest = function (client, telemetry) {\r\n        if (!telemetry.options || !telemetry.request || !client) {\r\n            Logging.info(\"AutoCollectHttpDependencies.trackRequest was called with invalid parameters: \", !telemetry.options, !telemetry.request, !client);\r\n            return;\r\n        }\r\n        var requestParser = new HttpDependencyParser(telemetry.options, telemetry.request);\r\n        var currentContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();\r\n        var uniqueRequestId;\r\n        var uniqueTraceparent;\r\n        if (currentContext && currentContext.operation && currentContext.operation.traceparent && Traceparent.isValidTraceId(currentContext.operation.traceparent.traceId)) {\r\n            currentContext.operation.traceparent.updateSpanId();\r\n            uniqueRequestId = currentContext.operation.traceparent.getBackCompatRequestId();\r\n        }\r\n        else if (CorrelationIdManager.w3cEnabled) {\r\n            // Start an operation now so that we can include the w3c headers in the outgoing request\r\n            var traceparent = new Traceparent();\r\n            uniqueTraceparent = traceparent.toString();\r\n            uniqueRequestId = traceparent.getBackCompatRequestId();\r\n        }\r\n        else {\r\n            uniqueRequestId = currentContext && currentContext.operation && (currentContext.operation.parentId + AutoCollectHttpDependencies.requestNumber++ + '.');\r\n        }\r\n        // Add the source correlationId to the request headers, if a value was not already provided.\r\n        // The getHeader/setHeader methods aren't available on very old Node versions, and\r\n        // are not included in the v0.10 type declarations currently used. So check if the\r\n        // methods exist before invoking them.\r\n        if (Util.canIncludeCorrelationHeader(client, requestParser.getUrl()) && telemetry.request.getHeader && telemetry.request.setHeader) {\r\n            if (client.config && client.config.correlationId) {\r\n                // getHeader returns \"any\" type in newer versions of node. In basic scenarios, this will be <string | string[] | number>, but could be modified to anything else via middleware\r\n                var correlationHeader = telemetry.request.getHeader(RequestResponseHeaders.requestContextHeader);\r\n                try {\r\n                    Util.safeIncludeCorrelationHeader(client, telemetry.request, correlationHeader);\r\n                }\r\n                catch (err) {\r\n                    Logging.warn(\"Request-Context header could not be set. Correlation of requests may be lost\", err);\r\n                }\r\n                if (currentContext && currentContext.operation) {\r\n                    try {\r\n                        telemetry.request.setHeader(RequestResponseHeaders.requestIdHeader, uniqueRequestId);\r\n                        // Also set legacy headers\r\n                        if (!client.config.ignoreLegacyHeaders) {\r\n                            telemetry.request.setHeader(RequestResponseHeaders.parentIdHeader, currentContext.operation.id);\r\n                            telemetry.request.setHeader(RequestResponseHeaders.rootIdHeader, uniqueRequestId);\r\n                        }\r\n                        // Set W3C headers, if available\r\n                        if (uniqueTraceparent || currentContext.operation.traceparent) {\r\n                            telemetry.request.setHeader(RequestResponseHeaders.traceparentHeader, uniqueTraceparent || currentContext.operation.traceparent.toString());\r\n                        }\r\n                        else if (CorrelationIdManager.w3cEnabled) {\r\n                            // should never get here since we set uniqueTraceparent above for the w3cEnabled scenario\r\n                            var traceparent = new Traceparent().toString();\r\n                            telemetry.request.setHeader(RequestResponseHeaders.traceparentHeader, traceparent);\r\n                        }\r\n                        if (currentContext.operation.tracestate) {\r\n                            var tracestate = currentContext.operation.tracestate.toString();\r\n                            if (tracestate) {\r\n                                telemetry.request.setHeader(RequestResponseHeaders.traceStateHeader, tracestate);\r\n                            }\r\n                        }\r\n                        var correlationContextHeader = currentContext.customProperties.serializeToHeader();\r\n                        if (correlationContextHeader) {\r\n                            telemetry.request.setHeader(RequestResponseHeaders.correlationContextHeader, correlationContextHeader);\r\n                        }\r\n                    }\r\n                    catch (err) {\r\n                        Logging.warn(\"Correlation headers could not be set. Correlation of requests may be lost.\", err);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // Collect dependency telemetry about the request when it finishes.\r\n        if (telemetry.request.on) {\r\n            telemetry.request.on('response', function (response) {\r\n                requestParser.onResponse(response);\r\n                var dependencyTelemetry = requestParser.getDependencyTelemetry(telemetry, uniqueRequestId);\r\n                dependencyTelemetry.contextObjects = dependencyTelemetry.contextObjects || {};\r\n                dependencyTelemetry.contextObjects[\"http.RequestOptions\"] = telemetry.options;\r\n                dependencyTelemetry.contextObjects[\"http.ClientRequest\"] = telemetry.request;\r\n                dependencyTelemetry.contextObjects[\"http.ClientResponse\"] = response;\r\n                client.trackDependency(dependencyTelemetry);\r\n            });\r\n            telemetry.request.on('error', function (e) {\r\n                requestParser.onError(e);\r\n                var dependencyTelemetry = requestParser.getDependencyTelemetry(telemetry, uniqueRequestId);\r\n                dependencyTelemetry.contextObjects = dependencyTelemetry.contextObjects || {};\r\n                dependencyTelemetry.contextObjects[\"http.RequestOptions\"] = telemetry.options;\r\n                dependencyTelemetry.contextObjects[\"http.ClientRequest\"] = telemetry.request;\r\n                dependencyTelemetry.contextObjects[\"Error\"] = e;\r\n                client.trackDependency(dependencyTelemetry);\r\n            });\r\n        }\r\n    };\r\n    AutoCollectHttpDependencies.prototype.dispose = function () {\r\n        AutoCollectHttpDependencies.INSTANCE = null;\r\n        this.enable(false);\r\n        this._isInitialized = false;\r\n    };\r\n    AutoCollectHttpDependencies.disableCollectionRequestOption = 'disableAppInsightsAutoCollection';\r\n    AutoCollectHttpDependencies.requestNumber = 1;\r\n    AutoCollectHttpDependencies.alreadyAutoCollectedFlag = '_appInsightsAutoCollected';\r\n    return AutoCollectHttpDependencies;\r\n}());\r\nmodule.exports = AutoCollectHttpDependencies;\r\n//# sourceMappingURL=HttpDependencies.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar url = require(\"url\");\r\nvar Contracts = require(\"../Declarations/Contracts\");\r\nvar Util = require(\"../Library/Util\");\r\nvar RequestResponseHeaders = require(\"../Library/RequestResponseHeaders\");\r\nvar RequestParser = require(\"./RequestParser\");\r\nvar CorrelationIdManager = require(\"../Library/CorrelationIdManager\");\r\n/**\r\n * Helper class to read data from the request/response objects and convert them into the telemetry contract\r\n */\r\nvar HttpDependencyParser = (function (_super) {\r\n    __extends(HttpDependencyParser, _super);\r\n    function HttpDependencyParser(requestOptions, request) {\r\n        var _this = _super.call(this) || this;\r\n        if (request && request.method && requestOptions) {\r\n            // The ClientRequest.method property isn't documented, but is always there.\r\n            _this.method = request.method;\r\n            _this.url = HttpDependencyParser._getUrlFromRequestOptions(requestOptions, request);\r\n            _this.startTime = +new Date();\r\n        }\r\n        return _this;\r\n    }\r\n    /**\r\n     * Called when the ClientRequest emits an error event.\r\n     */\r\n    HttpDependencyParser.prototype.onError = function (error) {\r\n        this._setStatus(undefined, error);\r\n    };\r\n    /**\r\n     * Called when the ClientRequest emits a response event.\r\n     */\r\n    HttpDependencyParser.prototype.onResponse = function (response) {\r\n        this._setStatus(response.statusCode, undefined);\r\n        this.correlationId = Util.getCorrelationContextTarget(response, RequestResponseHeaders.requestContextTargetKey);\r\n    };\r\n    /**\r\n     * Gets a dependency data contract object for a completed ClientRequest.\r\n     */\r\n    HttpDependencyParser.prototype.getDependencyTelemetry = function (baseTelemetry, dependencyId) {\r\n        var urlObject = url.parse(this.url);\r\n        urlObject.search = undefined;\r\n        urlObject.hash = undefined;\r\n        var dependencyName = this.method.toUpperCase() + \" \" + urlObject.pathname;\r\n        var remoteDependencyType = Contracts.RemoteDependencyDataConstants.TYPE_HTTP;\r\n        var remoteDependencyTarget = urlObject.hostname;\r\n        if (urlObject.port) {\r\n            remoteDependencyTarget += \":\" + urlObject.port;\r\n        }\r\n        if (this.correlationId) {\r\n            remoteDependencyType = Contracts.RemoteDependencyDataConstants.TYPE_AI;\r\n            if (this.correlationId !== CorrelationIdManager.correlationIdPrefix) {\r\n                remoteDependencyTarget += \" | \" + this.correlationId;\r\n            }\r\n        }\r\n        else {\r\n            remoteDependencyType = Contracts.RemoteDependencyDataConstants.TYPE_HTTP;\r\n        }\r\n        var dependencyTelemetry = {\r\n            id: dependencyId,\r\n            name: dependencyName,\r\n            data: this.url,\r\n            duration: this.duration,\r\n            success: this._isSuccess(),\r\n            resultCode: this.statusCode ? this.statusCode.toString() : null,\r\n            properties: this.properties || {},\r\n            dependencyTypeName: remoteDependencyType,\r\n            target: remoteDependencyTarget\r\n        };\r\n        if (baseTelemetry && baseTelemetry.time) {\r\n            dependencyTelemetry.time = baseTelemetry.time;\r\n        }\r\n        else if (this.startTime) {\r\n            dependencyTelemetry.time = new Date(this.startTime);\r\n        }\r\n        // We should keep any parameters the user passed in\r\n        // Except the fields defined above in requestTelemetry, which take priority\r\n        // Except the properties field, where they're merged instead, with baseTelemetry taking priority\r\n        if (baseTelemetry) {\r\n            // Copy missing fields\r\n            for (var key in baseTelemetry) {\r\n                if (!dependencyTelemetry[key]) {\r\n                    dependencyTelemetry[key] = baseTelemetry[key];\r\n                }\r\n            }\r\n            // Merge properties\r\n            if (baseTelemetry.properties) {\r\n                for (var key in baseTelemetry.properties) {\r\n                    dependencyTelemetry.properties[key] = baseTelemetry.properties[key];\r\n                }\r\n            }\r\n        }\r\n        return dependencyTelemetry;\r\n    };\r\n    /**\r\n     * Builds a URL from request options, using the same logic as http.request(). This is\r\n     * necessary because a ClientRequest object does not expose a url property.\r\n     */\r\n    HttpDependencyParser._getUrlFromRequestOptions = function (options, request) {\r\n        if (typeof options === 'string') {\r\n            if (options.indexOf(\"http://\") === 0 || options.indexOf(\"https://\") === 0) {\r\n                // protocol exists, parse normally\r\n                options = url.parse(options);\r\n            }\r\n            else {\r\n                // protocol not found, insert http/https where appropriate\r\n                var parsed = url.parse(options);\r\n                if (parsed.host === \"443\") {\r\n                    options = url.parse(\"https://\" + options);\r\n                }\r\n                else {\r\n                    options = url.parse(\"http://\" + options);\r\n                }\r\n            }\r\n        }\r\n        else if (options && typeof url.URL === 'function' && options instanceof url.URL) {\r\n            return url.format(options);\r\n        }\r\n        else {\r\n            // Avoid modifying the original options object.\r\n            var originalOptions_1 = options;\r\n            options = {};\r\n            if (originalOptions_1) {\r\n                Object.keys(originalOptions_1).forEach(function (key) {\r\n                    options[key] = originalOptions_1[key];\r\n                });\r\n            }\r\n        }\r\n        // Oddly, url.format ignores path and only uses pathname and search,\r\n        // so create them from the path, if path was specified\r\n        if (options.path) {\r\n            var parsedQuery = url.parse(options.path);\r\n            options.pathname = parsedQuery.pathname;\r\n            options.search = parsedQuery.search;\r\n        }\r\n        // Similarly, url.format ignores hostname and port if host is specified,\r\n        // even if host doesn't have the port, but http.request does not work\r\n        // this way. It will use the port if one is not specified in host,\r\n        // effectively treating host as hostname, but will use the port specified\r\n        // in host if it exists.\r\n        if (options.host && options.port) {\r\n            // Force a protocol so it will parse the host as the host, not path.\r\n            // It is discarded and not used, so it doesn't matter if it doesn't match\r\n            var parsedHost = url.parse(\"http://\" + options.host);\r\n            if (!parsedHost.port && options.port) {\r\n                options.hostname = options.host;\r\n                delete options.host;\r\n            }\r\n        }\r\n        // Mix in default values used by http.request and others\r\n        options.protocol = options.protocol || (request.agent && request.agent.protocol) || (request.protocol) || undefined;\r\n        options.hostname = options.hostname || 'localhost';\r\n        return url.format(options);\r\n    };\r\n    return HttpDependencyParser;\r\n}(RequestParser));\r\nmodule.exports = HttpDependencyParser;\r\n//# sourceMappingURL=HttpDependencyParser.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar url = require(\"url\");\r\nvar Contracts = require(\"../Declarations/Contracts\");\r\nvar Util = require(\"../Library/Util\");\r\nvar RequestResponseHeaders = require(\"../Library/RequestResponseHeaders\");\r\nvar RequestParser = require(\"./RequestParser\");\r\nvar CorrelationIdManager = require(\"../Library/CorrelationIdManager\");\r\nvar Tracestate = require(\"../Library/Tracestate\");\r\nvar Traceparent = require(\"../Library/Traceparent\");\r\n/**\r\n * Helper class to read data from the request/response objects and convert them into the telemetry contract\r\n */\r\nvar HttpRequestParser = (function (_super) {\r\n    __extends(HttpRequestParser, _super);\r\n    function HttpRequestParser(request, requestId) {\r\n        var _this = _super.call(this) || this;\r\n        if (request) {\r\n            _this.method = request.method;\r\n            _this.url = _this._getAbsoluteUrl(request);\r\n            _this.startTime = +new Date();\r\n            _this.socketRemoteAddress = request.socket && request.socket.remoteAddress;\r\n            _this.parseHeaders(request, requestId);\r\n            if (request.connection) {\r\n                _this.connectionRemoteAddress = request.connection.remoteAddress;\r\n                _this.legacySocketRemoteAddress = request.connection[\"socket\"] && request.connection[\"socket\"].remoteAddress;\r\n            }\r\n        }\r\n        return _this;\r\n    }\r\n    HttpRequestParser.prototype.onError = function (error, ellapsedMilliseconds) {\r\n        this._setStatus(undefined, error);\r\n        // This parameter is only for overrides. setStatus handles this internally for the autocollected case\r\n        if (ellapsedMilliseconds) {\r\n            this.duration = ellapsedMilliseconds;\r\n        }\r\n    };\r\n    HttpRequestParser.prototype.onResponse = function (response, ellapsedMilliseconds) {\r\n        this._setStatus(response.statusCode, undefined);\r\n        // This parameter is only for overrides. setStatus handles this internally for the autocollected case\r\n        if (ellapsedMilliseconds) {\r\n            this.duration = ellapsedMilliseconds;\r\n        }\r\n    };\r\n    HttpRequestParser.prototype.getRequestTelemetry = function (baseTelemetry) {\r\n        var requestTelemetry = {\r\n            id: this.requestId,\r\n            name: this.method + \" \" + url.parse(this.url).pathname,\r\n            url: this.url,\r\n            /*\r\n            See https://github.com/microsoft/ApplicationInsights-dotnet-server/blob/25d695e6a906fbe977f67be3966d25dbf1c50a79/Src/Web/Web.Shared.Net/RequestTrackingTelemetryModule.cs#L250\r\n            for reference\r\n            */\r\n            source: this.sourceCorrelationId,\r\n            duration: this.duration,\r\n            resultCode: this.statusCode ? this.statusCode.toString() : null,\r\n            success: this._isSuccess(),\r\n            properties: this.properties\r\n        };\r\n        if (baseTelemetry && baseTelemetry.time) {\r\n            requestTelemetry.time = baseTelemetry.time;\r\n        }\r\n        else if (this.startTime) {\r\n            requestTelemetry.time = new Date(this.startTime);\r\n        }\r\n        // We should keep any parameters the user passed in\r\n        // Except the fields defined above in requestTelemetry, which take priority\r\n        // Except the properties field, where they're merged instead, with baseTelemetry taking priority\r\n        if (baseTelemetry) {\r\n            // Copy missing fields\r\n            for (var key in baseTelemetry) {\r\n                if (!requestTelemetry[key]) {\r\n                    requestTelemetry[key] = baseTelemetry[key];\r\n                }\r\n            }\r\n            // Merge properties\r\n            if (baseTelemetry.properties) {\r\n                for (var key in baseTelemetry.properties) {\r\n                    requestTelemetry.properties[key] = baseTelemetry.properties[key];\r\n                }\r\n            }\r\n        }\r\n        return requestTelemetry;\r\n    };\r\n    HttpRequestParser.prototype.getRequestTags = function (tags) {\r\n        // create a copy of the context for requests since client info will be used here\r\n        var newTags = {};\r\n        for (var key in tags) {\r\n            newTags[key] = tags[key];\r\n        }\r\n        // don't override tags if they are already set\r\n        newTags[HttpRequestParser.keys.locationIp] = tags[HttpRequestParser.keys.locationIp] || this._getIp();\r\n        newTags[HttpRequestParser.keys.sessionId] = tags[HttpRequestParser.keys.sessionId] || this._getId(\"ai_session\");\r\n        newTags[HttpRequestParser.keys.userId] = tags[HttpRequestParser.keys.userId] || this._getId(\"ai_user\");\r\n        newTags[HttpRequestParser.keys.userAuthUserId] = tags[HttpRequestParser.keys.userAuthUserId] || this._getId(\"ai_authUser\");\r\n        newTags[HttpRequestParser.keys.operationName] = this.getOperationName(tags);\r\n        newTags[HttpRequestParser.keys.operationParentId] = this.getOperationParentId(tags);\r\n        newTags[HttpRequestParser.keys.operationId] = this.getOperationId(tags);\r\n        return newTags;\r\n    };\r\n    HttpRequestParser.prototype.getOperationId = function (tags) {\r\n        return tags[HttpRequestParser.keys.operationId] || this.operationId;\r\n    };\r\n    HttpRequestParser.prototype.getOperationParentId = function (tags) {\r\n        return tags[HttpRequestParser.keys.operationParentId] || this.parentId || this.getOperationId(tags);\r\n    };\r\n    HttpRequestParser.prototype.getOperationName = function (tags) {\r\n        return tags[HttpRequestParser.keys.operationName] || this.method + \" \" + url.parse(this.url).pathname;\r\n    };\r\n    HttpRequestParser.prototype.getRequestId = function () {\r\n        return this.requestId;\r\n    };\r\n    HttpRequestParser.prototype.getCorrelationContextHeader = function () {\r\n        return this.correlationContextHeader;\r\n    };\r\n    HttpRequestParser.prototype.getTraceparent = function () {\r\n        return this.traceparent;\r\n    };\r\n    HttpRequestParser.prototype.getTracestate = function () {\r\n        return this.tracestate;\r\n    };\r\n    HttpRequestParser.prototype.getLegacyRootId = function () {\r\n        return this.legacyRootId;\r\n    };\r\n    HttpRequestParser.prototype._getAbsoluteUrl = function (request) {\r\n        if (!request.headers) {\r\n            return request.url;\r\n        }\r\n        var encrypted = request.connection ? request.connection.encrypted : null;\r\n        var requestUrl = url.parse(request.url);\r\n        var pathName = requestUrl.pathname;\r\n        var search = requestUrl.search;\r\n        var absoluteUrl = url.format({\r\n            protocol: encrypted ? \"https\" : \"http\",\r\n            host: request.headers.host,\r\n            pathname: pathName,\r\n            search: search\r\n        });\r\n        return absoluteUrl;\r\n    };\r\n    HttpRequestParser.prototype._getIp = function () {\r\n        // regex to match ipv4 without port\r\n        // Note: including the port would cause the payload to be rejected by the data collector\r\n        var ipMatch = /[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}/;\r\n        var check = function (str) {\r\n            var results = ipMatch.exec(str);\r\n            if (results) {\r\n                return results[0];\r\n            }\r\n        };\r\n        var ip = check(this.rawHeaders[\"x-forwarded-for\"])\r\n            || check(this.rawHeaders[\"x-client-ip\"])\r\n            || check(this.rawHeaders[\"x-real-ip\"])\r\n            || check(this.connectionRemoteAddress)\r\n            || check(this.socketRemoteAddress)\r\n            || check(this.legacySocketRemoteAddress);\r\n        // node v12 returns this if the address is \"localhost\"\r\n        if (!ip\r\n            && this.connectionRemoteAddress\r\n            && this.connectionRemoteAddress.substr\r\n            && this.connectionRemoteAddress.substr(0, 2) === \"::\") {\r\n            ip = \"127.0.0.1\";\r\n        }\r\n        return ip;\r\n    };\r\n    HttpRequestParser.prototype._getId = function (name) {\r\n        var cookie = (this.rawHeaders && this.rawHeaders[\"cookie\"] &&\r\n            typeof this.rawHeaders[\"cookie\"] === 'string' && this.rawHeaders[\"cookie\"]) || \"\";\r\n        var value = HttpRequestParser.parseId(Util.getCookie(name, cookie));\r\n        return value;\r\n    };\r\n    /**\r\n     * Sets this operation's operationId, parentId, requestId (and legacyRootId, if necessary) based on this operation's traceparent\r\n     */\r\n    HttpRequestParser.prototype.setBackCompatFromThisTraceContext = function () {\r\n        // Set operationId\r\n        this.operationId = this.traceparent.traceId;\r\n        if (this.traceparent.legacyRootId) {\r\n            this.legacyRootId = this.traceparent.legacyRootId;\r\n        }\r\n        // Set parentId with existing spanId\r\n        this.parentId = this.traceparent.parentId;\r\n        // Update the spanId and set the current requestId\r\n        this.traceparent.updateSpanId();\r\n        this.requestId = this.traceparent.getBackCompatRequestId();\r\n    };\r\n    HttpRequestParser.prototype.parseHeaders = function (request, requestId) {\r\n        this.rawHeaders = request.headers || request.rawHeaders;\r\n        this.userAgent = request.headers && request.headers[\"user-agent\"];\r\n        this.sourceCorrelationId = Util.getCorrelationContextTarget(request, RequestResponseHeaders.requestContextSourceKey);\r\n        if (request.headers) {\r\n            var tracestateHeader = request.headers[RequestResponseHeaders.traceStateHeader]; // w3c header\r\n            var traceparentHeader = request.headers[RequestResponseHeaders.traceparentHeader]; // w3c header\r\n            var requestIdHeader = request.headers[RequestResponseHeaders.requestIdHeader]; // default AI header\r\n            var legacy_parentId = request.headers[RequestResponseHeaders.parentIdHeader]; // legacy AI header\r\n            var legacy_rootId = request.headers[RequestResponseHeaders.rootIdHeader]; // legacy AI header\r\n            this.correlationContextHeader = request.headers[RequestResponseHeaders.correlationContextHeader];\r\n            if (CorrelationIdManager.w3cEnabled && (traceparentHeader || tracestateHeader)) {\r\n                // Parse W3C Trace Context headers\r\n                this.traceparent = new Traceparent(traceparentHeader); // new traceparent is always created from this\r\n                this.tracestate = traceparentHeader && tracestateHeader && new Tracestate(tracestateHeader); // discard tracestate if no traceparent is present\r\n                this.setBackCompatFromThisTraceContext();\r\n            }\r\n            else if (requestIdHeader) {\r\n                // Parse AI headers\r\n                if (CorrelationIdManager.w3cEnabled) {\r\n                    this.traceparent = new Traceparent(null, requestIdHeader);\r\n                    this.setBackCompatFromThisTraceContext();\r\n                }\r\n                else {\r\n                    this.parentId = requestIdHeader;\r\n                    this.requestId = CorrelationIdManager.generateRequestId(this.parentId);\r\n                    this.operationId = CorrelationIdManager.getRootId(this.requestId);\r\n                }\r\n            }\r\n            else {\r\n                // Legacy fallback\r\n                if (CorrelationIdManager.w3cEnabled) {\r\n                    this.traceparent = new Traceparent();\r\n                    this.traceparent.parentId = legacy_parentId;\r\n                    this.traceparent.legacyRootId = legacy_rootId || legacy_parentId;\r\n                    this.setBackCompatFromThisTraceContext();\r\n                }\r\n                else {\r\n                    this.parentId = legacy_parentId;\r\n                    this.requestId = CorrelationIdManager.generateRequestId(legacy_rootId || this.parentId);\r\n                    this.correlationContextHeader = null;\r\n                    this.operationId = CorrelationIdManager.getRootId(this.requestId);\r\n                }\r\n            }\r\n            if (requestId) {\r\n                // For the scenarios that don't guarantee an AI-created context,\r\n                // override the requestId with the provided one.\r\n                this.requestId = requestId;\r\n                this.operationId = CorrelationIdManager.getRootId(this.requestId);\r\n            }\r\n        }\r\n    };\r\n    HttpRequestParser.parseId = function (cookieValue) {\r\n        var cookieParts = cookieValue.split(\"|\");\r\n        if (cookieParts.length > 0) {\r\n            return cookieParts[0];\r\n        }\r\n        return \"\"; // old behavior was to return \"\" for incorrect parsing\r\n    };\r\n    HttpRequestParser.keys = new Contracts.ContextTagKeys();\r\n    return HttpRequestParser;\r\n}(RequestParser));\r\nmodule.exports = HttpRequestParser;\r\n//# sourceMappingURL=HttpRequestParser.js.map","\"use strict\";\r\nvar http = require(\"http\");\r\nvar https = require(\"https\");\r\nvar Logging = require(\"../Library/Logging\");\r\nvar Util = require(\"../Library/Util\");\r\nvar RequestResponseHeaders = require(\"../Library/RequestResponseHeaders\");\r\nvar HttpRequestParser = require(\"./HttpRequestParser\");\r\nvar CorrelationContextManager_1 = require(\"./CorrelationContextManager\");\r\nvar AutoCollectPerformance = require(\"./Performance\");\r\nvar AutoCollectHttpRequests = (function () {\r\n    function AutoCollectHttpRequests(client) {\r\n        if (!!AutoCollectHttpRequests.INSTANCE) {\r\n            throw new Error(\"Server request tracking should be configured from the applicationInsights object\");\r\n        }\r\n        AutoCollectHttpRequests.INSTANCE = this;\r\n        this._client = client;\r\n    }\r\n    AutoCollectHttpRequests.prototype.enable = function (isEnabled) {\r\n        this._isEnabled = isEnabled;\r\n        // Autocorrelation requires automatic monitoring of incoming server requests\r\n        // Disabling autocollection but enabling autocorrelation will still enable\r\n        // request monitoring but will not produce request events\r\n        if ((this._isAutoCorrelating || this._isEnabled || AutoCollectPerformance.isEnabled()) && !this._isInitialized) {\r\n            this.useAutoCorrelation(this._isAutoCorrelating);\r\n            this._initialize();\r\n        }\r\n    };\r\n    AutoCollectHttpRequests.prototype.useAutoCorrelation = function (isEnabled, forceClsHooked) {\r\n        if (isEnabled && !this._isAutoCorrelating) {\r\n            CorrelationContextManager_1.CorrelationContextManager.enable(forceClsHooked);\r\n        }\r\n        else if (!isEnabled && this._isAutoCorrelating) {\r\n            CorrelationContextManager_1.CorrelationContextManager.disable();\r\n        }\r\n        this._isAutoCorrelating = isEnabled;\r\n    };\r\n    AutoCollectHttpRequests.prototype.isInitialized = function () {\r\n        return this._isInitialized;\r\n    };\r\n    AutoCollectHttpRequests.prototype.isAutoCorrelating = function () {\r\n        return this._isAutoCorrelating;\r\n    };\r\n    AutoCollectHttpRequests.prototype._generateCorrelationContext = function (requestParser) {\r\n        if (!this._isAutoCorrelating) {\r\n            return;\r\n        }\r\n        return CorrelationContextManager_1.CorrelationContextManager.generateContextObject(requestParser.getOperationId(this._client.context.tags), requestParser.getRequestId(), requestParser.getOperationName(this._client.context.tags), requestParser.getCorrelationContextHeader(), requestParser.getTraceparent(), requestParser.getTracestate());\r\n    };\r\n    AutoCollectHttpRequests.prototype._initialize = function () {\r\n        var _this = this;\r\n        this._isInitialized = true;\r\n        var wrapOnRequestHandler = function (onRequest) {\r\n            if (!onRequest) {\r\n                return undefined;\r\n            }\r\n            if (typeof onRequest !== 'function') {\r\n                throw new Error('onRequest handler must be a function');\r\n            }\r\n            return function (request, response) {\r\n                CorrelationContextManager_1.CorrelationContextManager.wrapEmitter(request);\r\n                CorrelationContextManager_1.CorrelationContextManager.wrapEmitter(response);\r\n                var shouldCollect = request && !request[AutoCollectHttpRequests.alreadyAutoCollectedFlag];\r\n                if (request && shouldCollect) {\r\n                    // Set up correlation context\r\n                    var requestParser_1 = new HttpRequestParser(request);\r\n                    var correlationContext = _this._generateCorrelationContext(requestParser_1);\r\n                    // Note: Check for if correlation is enabled happens within this method.\r\n                    // If not enabled, function will directly call the callback.\r\n                    CorrelationContextManager_1.CorrelationContextManager.runWithContext(correlationContext, function () {\r\n                        if (_this._isEnabled) {\r\n                            // Mark as auto collected\r\n                            request[AutoCollectHttpRequests.alreadyAutoCollectedFlag] = true;\r\n                            // Auto collect request\r\n                            AutoCollectHttpRequests.trackRequest(_this._client, { request: request, response: response }, requestParser_1);\r\n                        }\r\n                        if (typeof onRequest === \"function\") {\r\n                            onRequest(request, response);\r\n                        }\r\n                    });\r\n                }\r\n                else {\r\n                    if (typeof onRequest === \"function\") {\r\n                        onRequest(request, response);\r\n                    }\r\n                }\r\n            };\r\n        };\r\n        // The `http.createServer` function will instantiate a new http.Server object.\r\n        // Inside the Server's constructor, it is using addListener to register the\r\n        // onRequest handler. So there are two ways to inject the wrapped onRequest handler:\r\n        // 1) Overwrite Server.prototype.addListener (and .on()) globally and not patching\r\n        //    the http.createServer call. Or\r\n        // 2) Overwrite the http.createServer method and add a patched addListener to the\r\n        //    fresh server instance. This seems more stable for possible future changes as\r\n        //    it also covers the case where the Server might not use addListener to manage\r\n        //    the callback internally.\r\n        //    And also as long as the constructor uses addListener to add the handle, it is\r\n        //    ok to patch the addListener after construction only. Because if we would patch\r\n        //    the prototype one and the createServer method, we would wrap the handler twice\r\n        //    in case of the constructor call.\r\n        var wrapServerEventHandler = function (server) {\r\n            var originalAddListener = server.addListener.bind(server);\r\n            server.addListener = function (eventType, eventHandler) {\r\n                switch (eventType) {\r\n                    case 'request':\r\n                    case 'checkContinue':\r\n                        return originalAddListener(eventType, wrapOnRequestHandler(eventHandler));\r\n                    default:\r\n                        return originalAddListener(eventType, eventHandler);\r\n                }\r\n            };\r\n            // on is an alias to addListener only\r\n            server.on = server.addListener;\r\n        };\r\n        var originalHttpServer = http.createServer;\r\n        // options parameter was added in Node.js v9.6.0, v8.12.0\r\n        // function createServer(requestListener?: RequestListener): Server;\r\n        // function createServer(options: ServerOptions, requestListener?: RequestListener): Server;\r\n        http.createServer = function (param1, param2) {\r\n            // todo: get a pointer to the server so the IP address can be read from server.address\r\n            if (param2 && typeof param2 === 'function') {\r\n                var server = originalHttpServer(param1, wrapOnRequestHandler(param2));\r\n                wrapServerEventHandler(server);\r\n                return server;\r\n            }\r\n            else {\r\n                var server = originalHttpServer(wrapOnRequestHandler(param1));\r\n                wrapServerEventHandler(server);\r\n                return server;\r\n            }\r\n        };\r\n        var originalHttpsServer = https.createServer;\r\n        https.createServer = function (options, onRequest) {\r\n            var server = originalHttpsServer(options, wrapOnRequestHandler(onRequest));\r\n            wrapServerEventHandler(server);\r\n            return server;\r\n        };\r\n    };\r\n    /**\r\n     * Tracks a request synchronously (doesn't wait for response 'finish' event)\r\n     */\r\n    AutoCollectHttpRequests.trackRequestSync = function (client, telemetry) {\r\n        if (!telemetry.request || !telemetry.response || !client) {\r\n            Logging.info(\"AutoCollectHttpRequests.trackRequestSync was called with invalid parameters: \", !telemetry.request, !telemetry.response, !client);\r\n            return;\r\n        }\r\n        AutoCollectHttpRequests.addResponseCorrelationIdHeader(client, telemetry.response);\r\n        // store data about the request\r\n        var correlationContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();\r\n        var requestParser = new HttpRequestParser(telemetry.request, (correlationContext && correlationContext.operation.parentId));\r\n        // Overwrite correlation context with request parser results\r\n        if (correlationContext) {\r\n            correlationContext.operation.id = requestParser.getOperationId(client.context.tags) || correlationContext.operation.id;\r\n            correlationContext.operation.name = requestParser.getOperationName(client.context.tags) || correlationContext.operation.name;\r\n            correlationContext.operation.parentId = requestParser.getRequestId() || correlationContext.operation.parentId;\r\n            correlationContext.customProperties.addHeaderData(requestParser.getCorrelationContextHeader());\r\n        }\r\n        AutoCollectHttpRequests.endRequest(client, requestParser, telemetry, telemetry.duration, telemetry.error);\r\n    };\r\n    /**\r\n     * Tracks a request by listening to the response 'finish' event\r\n     */\r\n    AutoCollectHttpRequests.trackRequest = function (client, telemetry, _requestParser) {\r\n        if (!telemetry.request || !telemetry.response || !client) {\r\n            Logging.info(\"AutoCollectHttpRequests.trackRequest was called with invalid parameters: \", !telemetry.request, !telemetry.response, !client);\r\n            return;\r\n        }\r\n        // store data about the request\r\n        var correlationContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();\r\n        var requestParser = _requestParser || new HttpRequestParser(telemetry.request, correlationContext && correlationContext.operation.parentId);\r\n        if (Util.canIncludeCorrelationHeader(client, requestParser.getUrl())) {\r\n            AutoCollectHttpRequests.addResponseCorrelationIdHeader(client, telemetry.response);\r\n        }\r\n        // Overwrite correlation context with request parser results (if not an automatic track. we've already precalculated the correlation context in that case)\r\n        if (correlationContext && !_requestParser) {\r\n            correlationContext.operation.id = requestParser.getOperationId(client.context.tags) || correlationContext.operation.id;\r\n            correlationContext.operation.name = requestParser.getOperationName(client.context.tags) || correlationContext.operation.name;\r\n            correlationContext.operation.parentId = requestParser.getOperationParentId(client.context.tags) || correlationContext.operation.parentId;\r\n            correlationContext.customProperties.addHeaderData(requestParser.getCorrelationContextHeader());\r\n        }\r\n        // response listeners\r\n        if (telemetry.response.once) {\r\n            telemetry.response.once(\"finish\", function () {\r\n                AutoCollectHttpRequests.endRequest(client, requestParser, telemetry, null, null);\r\n            });\r\n        }\r\n        // track a failed request if an error is emitted\r\n        if (telemetry.request.on) {\r\n            telemetry.request.on(\"error\", function (error) {\r\n                AutoCollectHttpRequests.endRequest(client, requestParser, telemetry, null, error);\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * Add the target correlationId to the response headers, if not already provided.\r\n     */\r\n    AutoCollectHttpRequests.addResponseCorrelationIdHeader = function (client, response) {\r\n        if (client.config && client.config.correlationId &&\r\n            response.getHeader && response.setHeader && !response.headersSent) {\r\n            var correlationHeader = response.getHeader(RequestResponseHeaders.requestContextHeader);\r\n            Util.safeIncludeCorrelationHeader(client, response, correlationHeader);\r\n        }\r\n    };\r\n    AutoCollectHttpRequests.endRequest = function (client, requestParser, telemetry, ellapsedMilliseconds, error) {\r\n        if (error) {\r\n            requestParser.onError(error, ellapsedMilliseconds);\r\n        }\r\n        else {\r\n            requestParser.onResponse(telemetry.response, ellapsedMilliseconds);\r\n        }\r\n        var requestTelemetry = requestParser.getRequestTelemetry(telemetry);\r\n        requestTelemetry.tagOverrides = requestParser.getRequestTags(client.context.tags);\r\n        if (telemetry.tagOverrides) {\r\n            for (var key in telemetry.tagOverrides) {\r\n                requestTelemetry.tagOverrides[key] = telemetry.tagOverrides[key];\r\n            }\r\n        }\r\n        var legacyRootId = requestParser.getLegacyRootId();\r\n        if (legacyRootId) {\r\n            requestTelemetry.properties[\"ai_legacyRootId\"] = legacyRootId;\r\n        }\r\n        requestTelemetry.contextObjects = requestTelemetry.contextObjects || {};\r\n        requestTelemetry.contextObjects[\"http.ServerRequest\"] = telemetry.request;\r\n        requestTelemetry.contextObjects[\"http.ServerResponse\"] = telemetry.response;\r\n        client.trackRequest(requestTelemetry);\r\n    };\r\n    AutoCollectHttpRequests.prototype.dispose = function () {\r\n        AutoCollectHttpRequests.INSTANCE = null;\r\n        this.enable(false);\r\n        this._isInitialized = false;\r\n        CorrelationContextManager_1.CorrelationContextManager.disable();\r\n        this._isAutoCorrelating = false;\r\n    };\r\n    AutoCollectHttpRequests.alreadyAutoCollectedFlag = '_appInsightsAutoCollected';\r\n    return AutoCollectHttpRequests;\r\n}());\r\nmodule.exports = AutoCollectHttpRequests;\r\n//# sourceMappingURL=HttpRequests.js.map","\"use strict\";\r\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Config = require(\"../Library/Config\");\r\nvar Context = require(\"../Library/Context\");\r\nvar Logging = require(\"../Library/Logging\");\r\nvar AutoCollectNativePerformance = (function () {\r\n    function AutoCollectNativePerformance(client) {\r\n        this._disabledMetrics = {};\r\n        // Note: Only 1 instance of this can exist. So when we reconstruct this object,\r\n        // just disable old native instance and reset JS member variables\r\n        if (AutoCollectNativePerformance.INSTANCE) {\r\n            AutoCollectNativePerformance.INSTANCE.dispose();\r\n        }\r\n        AutoCollectNativePerformance.INSTANCE = this;\r\n        this._client = client;\r\n    }\r\n    /**\r\n     *  Reports if NativePerformance is able to run in this environment\r\n     */\r\n    AutoCollectNativePerformance.isNodeVersionCompatible = function () {\r\n        var nodeVer = process.versions.node.split(\".\");\r\n        return parseInt(nodeVer[0]) >= 6;\r\n    };\r\n    /**\r\n     * Start instance of native metrics agent.\r\n     *\r\n     * @param {boolean} isEnabled\r\n     * @param {number} [collectionInterval=60000]\r\n     * @memberof AutoCollectNativePerformance\r\n     */\r\n    AutoCollectNativePerformance.prototype.enable = function (isEnabled, disabledMetrics, collectionInterval) {\r\n        var _this = this;\r\n        if (disabledMetrics === void 0) { disabledMetrics = {}; }\r\n        if (collectionInterval === void 0) { collectionInterval = 60000; }\r\n        if (!AutoCollectNativePerformance.isNodeVersionCompatible()) {\r\n            return;\r\n        }\r\n        if (AutoCollectNativePerformance._metricsAvailable == undefined && isEnabled && !this._isInitialized) {\r\n            // Try to require in the native-metrics library. If it's found initialize it, else do nothing and never try again.\r\n            try {\r\n                var NativeMetricsEmitters = require(\"applicationinsights-native-metrics\");\r\n                AutoCollectNativePerformance._emitter = new NativeMetricsEmitters();\r\n                AutoCollectNativePerformance._metricsAvailable = true;\r\n                Logging.info(\"Native metrics module successfully loaded!\");\r\n            }\r\n            catch (err) {\r\n                // Package not available. Never try again\r\n                AutoCollectNativePerformance._metricsAvailable = false;\r\n                return;\r\n            }\r\n        }\r\n        this._isEnabled = isEnabled;\r\n        this._disabledMetrics = disabledMetrics;\r\n        if (this._isEnabled && !this._isInitialized) {\r\n            this._isInitialized = true;\r\n        }\r\n        // Enable the emitter if we were able to construct one\r\n        if (this._isEnabled && AutoCollectNativePerformance._emitter) {\r\n            // enable self\r\n            AutoCollectNativePerformance._emitter.enable(true, collectionInterval);\r\n            this._handle = setInterval(function () { return _this._trackNativeMetrics(); }, collectionInterval);\r\n            this._handle.unref();\r\n        }\r\n        else if (AutoCollectNativePerformance._emitter) {\r\n            // disable self\r\n            AutoCollectNativePerformance._emitter.enable(false);\r\n            if (this._handle) {\r\n                clearInterval(this._handle);\r\n                this._handle = undefined;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Cleanup this instance of AutoCollectNativePerformance\r\n     *\r\n     * @memberof AutoCollectNativePerformance\r\n     */\r\n    AutoCollectNativePerformance.prototype.dispose = function () {\r\n        this.enable(false);\r\n    };\r\n    /**\r\n     * Parse environment variable and overwrite isEnabled based on respective fields being set\r\n     *\r\n     * @private\r\n     * @static\r\n     * @param {(boolean | IDisabledExtendedMetrics)} collectExtendedMetrics\r\n     * @returns {(boolean | IDisabledExtendedMetrics)}\r\n     * @memberof AutoCollectNativePerformance\r\n     */\r\n    AutoCollectNativePerformance.parseEnabled = function (collectExtendedMetrics) {\r\n        var disableAll = process.env[Config.ENV_nativeMetricsDisableAll];\r\n        var individualOptOuts = process.env[Config.ENV_nativeMetricsDisablers];\r\n        // case 1: disable all env var set, RETURN with isEnabled=false\r\n        if (disableAll) {\r\n            return { isEnabled: false, disabledMetrics: {} };\r\n        }\r\n        // case 2: individual env vars set, RETURN with isEnabled=true, disabledMetrics={...}\r\n        if (individualOptOuts) {\r\n            var optOutsArr = individualOptOuts.split(\",\");\r\n            var disabledMetrics = {};\r\n            if (optOutsArr.length > 0) {\r\n                for (var _i = 0, optOutsArr_1 = optOutsArr; _i < optOutsArr_1.length; _i++) {\r\n                    var opt = optOutsArr_1[_i];\r\n                    disabledMetrics[opt] = true;\r\n                }\r\n            }\r\n            // case 2a: collectExtendedMetrics is an object, overwrite existing ones if they exist\r\n            if (typeof collectExtendedMetrics === \"object\") {\r\n                return { isEnabled: true, disabledMetrics: __assign({}, collectExtendedMetrics, disabledMetrics) };\r\n            }\r\n            // case 2b: collectExtendedMetrics is a boolean, set disabledMetrics as is\r\n            return { isEnabled: collectExtendedMetrics, disabledMetrics: disabledMetrics };\r\n        }\r\n        // case 4: no env vars set, input arg is a boolean, RETURN with isEnabled=collectExtendedMetrics, disabledMetrics={}\r\n        if (typeof collectExtendedMetrics === \"boolean\") {\r\n            return { isEnabled: collectExtendedMetrics, disabledMetrics: {} };\r\n        }\r\n        else {\r\n            // case 5: no env vars set, input arg is object, RETURN with isEnabled=true, disabledMetrics=collectExtendedMetrics\r\n            return { isEnabled: true, disabledMetrics: collectExtendedMetrics };\r\n        }\r\n    };\r\n    /**\r\n     * Trigger an iteration of native metrics collection\r\n     *\r\n     * @private\r\n     * @memberof AutoCollectNativePerformance\r\n     */\r\n    AutoCollectNativePerformance.prototype._trackNativeMetrics = function () {\r\n        var shouldSendAll = true;\r\n        if (typeof this._isEnabled !== \"object\") {\r\n            shouldSendAll = this._isEnabled;\r\n        }\r\n        if (shouldSendAll) {\r\n            this._trackGarbageCollection();\r\n            this._trackEventLoop();\r\n            this._trackHeapUsage();\r\n        }\r\n    };\r\n    /**\r\n     * Tracks garbage collection stats for this interval. One custom metric is sent per type of garbage\r\n     * collection that occurred during this collection interval.\r\n     *\r\n     * @private\r\n     * @memberof AutoCollectNativePerformance\r\n     */\r\n    AutoCollectNativePerformance.prototype._trackGarbageCollection = function () {\r\n        if (this._disabledMetrics.gc) {\r\n            return;\r\n        }\r\n        var gcData = AutoCollectNativePerformance._emitter.getGCData();\r\n        for (var gc in gcData) {\r\n            var metrics = gcData[gc].metrics;\r\n            var name_1 = gc + \" Garbage Collection Duration\";\r\n            var stdDev = Math.sqrt(metrics.sumSquares / metrics.count - Math.pow(metrics.total / metrics.count, 2)) || 0;\r\n            this._client.trackMetric({\r\n                name: name_1,\r\n                value: metrics.total,\r\n                count: metrics.count,\r\n                max: metrics.max,\r\n                min: metrics.min,\r\n                stdDev: stdDev,\r\n                tagOverrides: (_a = {},\r\n                    _a[this._client.context.keys.internalSdkVersion] = \"node-nativeperf:\" + Context.sdkVersion,\r\n                    _a)\r\n            });\r\n        }\r\n        var _a;\r\n    };\r\n    /**\r\n     * Tracks event loop ticks per interval as a custom metric. Also included in the metric is min/max/avg\r\n     * time spent in event loop for this interval.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     * @memberof AutoCollectNativePerformance\r\n     */\r\n    AutoCollectNativePerformance.prototype._trackEventLoop = function () {\r\n        if (this._disabledMetrics.loop) {\r\n            return;\r\n        }\r\n        var loopData = AutoCollectNativePerformance._emitter.getLoopData();\r\n        var metrics = loopData.loopUsage;\r\n        if (metrics.count == 0) {\r\n            return;\r\n        }\r\n        var name = \"Event Loop CPU Time\";\r\n        var stdDev = Math.sqrt(metrics.sumSquares / metrics.count - Math.pow(metrics.total / metrics.count, 2)) || 0;\r\n        this._client.trackMetric({\r\n            name: name,\r\n            value: metrics.total,\r\n            count: metrics.count,\r\n            min: metrics.min,\r\n            max: metrics.max,\r\n            stdDev: stdDev,\r\n            tagOverrides: (_a = {},\r\n                _a[this._client.context.keys.internalSdkVersion] = \"node-nativeperf:\" + Context.sdkVersion,\r\n                _a)\r\n        });\r\n        var _a;\r\n    };\r\n    /**\r\n     * Track heap memory usage metrics as a custom metric.\r\n     *\r\n     * @private\r\n     * @memberof AutoCollectNativePerformance\r\n     */\r\n    AutoCollectNativePerformance.prototype._trackHeapUsage = function () {\r\n        if (this._disabledMetrics.heap) {\r\n            return;\r\n        }\r\n        var memoryUsage = process.memoryUsage();\r\n        var heapUsed = memoryUsage.heapUsed, heapTotal = memoryUsage.heapTotal, rss = memoryUsage.rss;\r\n        this._client.trackMetric({\r\n            name: \"Memory Usage (Heap)\",\r\n            value: heapUsed,\r\n            count: 1,\r\n            tagOverrides: (_a = {},\r\n                _a[this._client.context.keys.internalSdkVersion] = \"node-nativeperf:\" + Context.sdkVersion,\r\n                _a)\r\n        });\r\n        this._client.trackMetric({\r\n            name: \"Memory Total (Heap)\",\r\n            value: heapTotal,\r\n            count: 1,\r\n            tagOverrides: (_b = {},\r\n                _b[this._client.context.keys.internalSdkVersion] = \"node-nativeperf:\" + Context.sdkVersion,\r\n                _b)\r\n        });\r\n        this._client.trackMetric({\r\n            name: \"Memory Usage (Non-Heap)\",\r\n            value: rss - heapTotal,\r\n            count: 1,\r\n            tagOverrides: (_c = {},\r\n                _c[this._client.context.keys.internalSdkVersion] = \"node-nativeperf:\" + Context.sdkVersion,\r\n                _c)\r\n        });\r\n        var _a, _b, _c;\r\n    };\r\n    return AutoCollectNativePerformance;\r\n}());\r\nexports.AutoCollectNativePerformance = AutoCollectNativePerformance;\r\n//# sourceMappingURL=NativePerformance.js.map","\"use strict\";\r\nvar os = require(\"os\");\r\nvar Constants = require(\"../Declarations/Constants\");\r\nvar AutoCollectPerformance = (function () {\r\n    /**\r\n     * @param enableLiveMetricsCounters - enable sending additional live metrics information (dependency metrics, exception metrics, committed memory)\r\n     */\r\n    function AutoCollectPerformance(client, collectionInterval, enableLiveMetricsCounters) {\r\n        if (collectionInterval === void 0) { collectionInterval = 60000; }\r\n        if (enableLiveMetricsCounters === void 0) { enableLiveMetricsCounters = false; }\r\n        this._lastIntervalRequestExecutionTime = 0; // the sum of durations which took place during from app start until last interval\r\n        this._lastIntervalDependencyExecutionTime = 0;\r\n        if (!AutoCollectPerformance.INSTANCE) {\r\n            AutoCollectPerformance.INSTANCE = this;\r\n        }\r\n        this._isInitialized = false;\r\n        this._client = client;\r\n        this._collectionInterval = collectionInterval;\r\n        this._enableLiveMetricsCounters = enableLiveMetricsCounters;\r\n    }\r\n    AutoCollectPerformance.prototype.enable = function (isEnabled, collectionInterval) {\r\n        var _this = this;\r\n        this._isEnabled = isEnabled;\r\n        if (this._isEnabled && !this._isInitialized) {\r\n            this._isInitialized = true;\r\n        }\r\n        if (isEnabled) {\r\n            if (!this._handle) {\r\n                this._lastCpus = os.cpus();\r\n                this._lastRequests = {\r\n                    totalRequestCount: AutoCollectPerformance._totalRequestCount,\r\n                    totalFailedRequestCount: AutoCollectPerformance._totalFailedRequestCount,\r\n                    time: +new Date\r\n                };\r\n                this._lastDependencies = {\r\n                    totalDependencyCount: AutoCollectPerformance._totalDependencyCount,\r\n                    totalFailedDependencyCount: AutoCollectPerformance._totalFailedDependencyCount,\r\n                    time: +new Date\r\n                };\r\n                this._lastExceptions = {\r\n                    totalExceptionCount: AutoCollectPerformance._totalExceptionCount,\r\n                    time: +new Date\r\n                };\r\n                if (typeof process.cpuUsage === 'function') {\r\n                    this._lastAppCpuUsage = process.cpuUsage();\r\n                }\r\n                this._lastHrtime = process.hrtime();\r\n                this._collectionInterval = collectionInterval || this._collectionInterval;\r\n                this._handle = setInterval(function () { return _this.trackPerformance(); }, this._collectionInterval);\r\n                this._handle.unref(); // Allow the app to terminate even while this loop is going on\r\n            }\r\n        }\r\n        else {\r\n            if (this._handle) {\r\n                clearInterval(this._handle);\r\n                this._handle = undefined;\r\n            }\r\n        }\r\n    };\r\n    AutoCollectPerformance.countRequest = function (duration, success) {\r\n        var durationMs;\r\n        if (!AutoCollectPerformance.isEnabled()) {\r\n            return;\r\n        }\r\n        if (typeof duration === 'string') {\r\n            // dependency duration is passed in as \"00:00:00.123\" by autocollectors\r\n            durationMs = +new Date('1970-01-01T' + duration + 'Z'); // convert to num ms, returns NaN if wrong\r\n        }\r\n        else if (typeof duration === 'number') {\r\n            durationMs = duration;\r\n        }\r\n        else {\r\n            return;\r\n        }\r\n        AutoCollectPerformance._intervalRequestExecutionTime += durationMs;\r\n        if (success === false) {\r\n            AutoCollectPerformance._totalFailedRequestCount++;\r\n        }\r\n        AutoCollectPerformance._totalRequestCount++;\r\n    };\r\n    AutoCollectPerformance.countException = function () {\r\n        AutoCollectPerformance._totalExceptionCount++;\r\n    };\r\n    AutoCollectPerformance.countDependency = function (duration, success) {\r\n        var durationMs;\r\n        if (!AutoCollectPerformance.isEnabled()) {\r\n            return;\r\n        }\r\n        if (typeof duration === 'string') {\r\n            // dependency duration is passed in as \"00:00:00.123\" by autocollectors\r\n            durationMs = +new Date('1970-01-01T' + duration + 'Z'); // convert to num ms, returns NaN if wrong\r\n        }\r\n        else if (typeof duration === 'number') {\r\n            durationMs = duration;\r\n        }\r\n        else {\r\n            return;\r\n        }\r\n        AutoCollectPerformance._intervalDependencyExecutionTime += durationMs;\r\n        if (success === false) {\r\n            AutoCollectPerformance._totalFailedDependencyCount++;\r\n        }\r\n        AutoCollectPerformance._totalDependencyCount++;\r\n    };\r\n    AutoCollectPerformance.prototype.isInitialized = function () {\r\n        return this._isInitialized;\r\n    };\r\n    AutoCollectPerformance.isEnabled = function () {\r\n        return AutoCollectPerformance.INSTANCE && AutoCollectPerformance.INSTANCE._isEnabled;\r\n    };\r\n    AutoCollectPerformance.prototype.trackPerformance = function () {\r\n        this._trackCpu();\r\n        this._trackMemory();\r\n        this._trackNetwork();\r\n        this._trackDependencyRate();\r\n        this._trackExceptionRate();\r\n    };\r\n    AutoCollectPerformance.prototype._trackCpu = function () {\r\n        // this reports total ms spent in each category since the OS was booted, to calculate percent it is necessary\r\n        // to find the delta since the last measurement\r\n        var cpus = os.cpus();\r\n        if (cpus && cpus.length && this._lastCpus && cpus.length === this._lastCpus.length) {\r\n            var totalUser = 0;\r\n            var totalSys = 0;\r\n            var totalNice = 0;\r\n            var totalIdle = 0;\r\n            var totalIrq = 0;\r\n            for (var i = 0; !!cpus && i < cpus.length; i++) {\r\n                var cpu = cpus[i];\r\n                var lastCpu = this._lastCpus[i];\r\n                var name = \"% cpu(\" + i + \") \";\r\n                var model = cpu.model;\r\n                var speed = cpu.speed;\r\n                var times = cpu.times;\r\n                var lastTimes = lastCpu.times;\r\n                // user cpu time (or) % CPU time spent in user space\r\n                var user = (times.user - lastTimes.user) || 0;\r\n                totalUser += user;\r\n                // system cpu time (or) % CPU time spent in kernel space\r\n                var sys = (times.sys - lastTimes.sys) || 0;\r\n                totalSys += sys;\r\n                // user nice cpu time (or) % CPU time spent on low priority processes\r\n                var nice = (times.nice - lastTimes.nice) || 0;\r\n                totalNice += nice;\r\n                // idle cpu time (or) % CPU time spent idle\r\n                var idle = (times.idle - lastTimes.idle) || 0;\r\n                totalIdle += idle;\r\n                // irq (or) % CPU time spent servicing/handling hardware interrupts\r\n                var irq = (times.irq - lastTimes.irq) || 0;\r\n                totalIrq += irq;\r\n            }\r\n            // Calculate % of total cpu time (user + system) this App Process used (Only supported by node v6.1.0+)\r\n            var appCpuPercent = undefined;\r\n            if (typeof process.cpuUsage === 'function') {\r\n                var appCpuUsage = process.cpuUsage();\r\n                var hrtime = process.hrtime();\r\n                var totalApp = ((appCpuUsage.user - this._lastAppCpuUsage.user) + (appCpuUsage.system - this._lastAppCpuUsage.system)) || 0;\r\n                if (typeof this._lastHrtime !== 'undefined' && this._lastHrtime.length === 2) {\r\n                    var elapsedTime = ((hrtime[0] - this._lastHrtime[0]) * 1e6 + (hrtime[1] - this._lastHrtime[1]) / 1e3) || 0; // convert to microseconds\r\n                    appCpuPercent = 100 * totalApp / (elapsedTime * cpus.length);\r\n                }\r\n                // Set previous\r\n                this._lastAppCpuUsage = appCpuUsage;\r\n                this._lastHrtime = hrtime;\r\n            }\r\n            var combinedTotal = (totalUser + totalSys + totalNice + totalIdle + totalIrq) || 1;\r\n            this._client.trackMetric({ name: Constants.PerformanceCounter.PROCESSOR_TIME, value: ((combinedTotal - totalIdle) / combinedTotal) * 100 });\r\n            this._client.trackMetric({ name: Constants.PerformanceCounter.PROCESS_TIME, value: appCpuPercent || ((totalUser / combinedTotal) * 100) });\r\n        }\r\n        this._lastCpus = cpus;\r\n    };\r\n    AutoCollectPerformance.prototype._trackMemory = function () {\r\n        var freeMem = os.freemem();\r\n        var usedMem = process.memoryUsage().rss;\r\n        var committedMemory = os.totalmem() - freeMem;\r\n        this._client.trackMetric({ name: Constants.PerformanceCounter.PRIVATE_BYTES, value: usedMem });\r\n        this._client.trackMetric({ name: Constants.PerformanceCounter.AVAILABLE_BYTES, value: freeMem });\r\n        // Only supported by quickpulse service\r\n        if (this._enableLiveMetricsCounters) {\r\n            this._client.trackMetric({ name: Constants.QuickPulseCounter.COMMITTED_BYTES, value: committedMemory });\r\n        }\r\n    };\r\n    AutoCollectPerformance.prototype._trackNetwork = function () {\r\n        // track total request counters\r\n        var lastRequests = this._lastRequests;\r\n        var requests = {\r\n            totalRequestCount: AutoCollectPerformance._totalRequestCount,\r\n            totalFailedRequestCount: AutoCollectPerformance._totalFailedRequestCount,\r\n            time: +new Date\r\n        };\r\n        var intervalRequests = (requests.totalRequestCount - lastRequests.totalRequestCount) || 0;\r\n        var intervalFailedRequests = (requests.totalFailedRequestCount - lastRequests.totalFailedRequestCount) || 0;\r\n        var elapsedMs = requests.time - lastRequests.time;\r\n        var elapsedSeconds = elapsedMs / 1000;\r\n        var averageRequestExecutionTime = ((AutoCollectPerformance._intervalRequestExecutionTime - this._lastIntervalRequestExecutionTime) / intervalRequests) || 0; // default to 0 in case no requests in this interval\r\n        this._lastIntervalRequestExecutionTime = AutoCollectPerformance._intervalRequestExecutionTime; // reset\r\n        if (elapsedMs > 0) {\r\n            var requestsPerSec = intervalRequests / elapsedSeconds;\r\n            var failedRequestsPerSec = intervalFailedRequests / elapsedSeconds;\r\n            this._client.trackMetric({ name: Constants.PerformanceCounter.REQUEST_RATE, value: requestsPerSec });\r\n            // Only send duration to live metrics if it has been updated!\r\n            if (!this._enableLiveMetricsCounters || intervalRequests > 0) {\r\n                this._client.trackMetric({ name: Constants.PerformanceCounter.REQUEST_DURATION, value: averageRequestExecutionTime });\r\n            }\r\n            // Only supported by quickpulse service\r\n            if (this._enableLiveMetricsCounters) {\r\n                this._client.trackMetric({ name: Constants.QuickPulseCounter.REQUEST_FAILURE_RATE, value: failedRequestsPerSec });\r\n            }\r\n        }\r\n        this._lastRequests = requests;\r\n    };\r\n    // Static counter is accumulated externally. Report the rate to client here\r\n    // Note: This is currently only used with QuickPulse client\r\n    AutoCollectPerformance.prototype._trackDependencyRate = function () {\r\n        if (this._enableLiveMetricsCounters) {\r\n            var lastDependencies = this._lastDependencies;\r\n            var dependencies = {\r\n                totalDependencyCount: AutoCollectPerformance._totalDependencyCount,\r\n                totalFailedDependencyCount: AutoCollectPerformance._totalFailedDependencyCount,\r\n                time: +new Date\r\n            };\r\n            var intervalDependencies = (dependencies.totalDependencyCount - lastDependencies.totalDependencyCount) || 0;\r\n            var intervalFailedDependencies = (dependencies.totalFailedDependencyCount - lastDependencies.totalFailedDependencyCount) || 0;\r\n            var elapsedMs = dependencies.time - lastDependencies.time;\r\n            var elapsedSeconds = elapsedMs / 1000;\r\n            var averageDependencyExecutionTime = ((AutoCollectPerformance._intervalDependencyExecutionTime - this._lastIntervalDependencyExecutionTime) / intervalDependencies) || 0;\r\n            this._lastIntervalDependencyExecutionTime = AutoCollectPerformance._intervalDependencyExecutionTime; // reset\r\n            if (elapsedMs > 0) {\r\n                var dependenciesPerSec = intervalDependencies / elapsedSeconds;\r\n                var failedDependenciesPerSec = intervalFailedDependencies / elapsedSeconds;\r\n                this._client.trackMetric({ name: Constants.QuickPulseCounter.DEPENDENCY_RATE, value: dependenciesPerSec });\r\n                this._client.trackMetric({ name: Constants.QuickPulseCounter.DEPENDENCY_FAILURE_RATE, value: failedDependenciesPerSec });\r\n                // redundant check for livemetrics, but kept for consistency w/ requests\r\n                // Only send duration to live metrics if it has been updated!\r\n                if (!this._enableLiveMetricsCounters || intervalDependencies > 0) {\r\n                    this._client.trackMetric({ name: Constants.QuickPulseCounter.DEPENDENCY_DURATION, value: averageDependencyExecutionTime });\r\n                }\r\n            }\r\n            this._lastDependencies = dependencies;\r\n        }\r\n    };\r\n    // Static counter is accumulated externally. Report the rate to client here\r\n    // Note: This is currently only used with QuickPulse client\r\n    AutoCollectPerformance.prototype._trackExceptionRate = function () {\r\n        if (this._enableLiveMetricsCounters) {\r\n            var lastExceptions = this._lastExceptions;\r\n            var exceptions = {\r\n                totalExceptionCount: AutoCollectPerformance._totalExceptionCount,\r\n                time: +new Date\r\n            };\r\n            var intervalExceptions = (exceptions.totalExceptionCount - lastExceptions.totalExceptionCount) || 0;\r\n            var elapsedMs = exceptions.time - lastExceptions.time;\r\n            var elapsedSeconds = elapsedMs / 1000;\r\n            if (elapsedMs > 0) {\r\n                var exceptionsPerSec = intervalExceptions / elapsedSeconds;\r\n                this._client.trackMetric({ name: Constants.QuickPulseCounter.EXCEPTION_RATE, value: exceptionsPerSec });\r\n            }\r\n            this._lastExceptions = exceptions;\r\n        }\r\n    };\r\n    AutoCollectPerformance.prototype.dispose = function () {\r\n        AutoCollectPerformance.INSTANCE = null;\r\n        this.enable(false);\r\n        this._isInitialized = false;\r\n    };\r\n    AutoCollectPerformance._totalRequestCount = 0;\r\n    AutoCollectPerformance._totalFailedRequestCount = 0;\r\n    AutoCollectPerformance._lastRequestExecutionTime = 0;\r\n    AutoCollectPerformance._totalDependencyCount = 0;\r\n    AutoCollectPerformance._totalFailedDependencyCount = 0;\r\n    AutoCollectPerformance._lastDependencyExecutionTime = 0;\r\n    AutoCollectPerformance._totalExceptionCount = 0;\r\n    AutoCollectPerformance._intervalDependencyExecutionTime = 0;\r\n    AutoCollectPerformance._intervalRequestExecutionTime = 0;\r\n    return AutoCollectPerformance;\r\n}());\r\nmodule.exports = AutoCollectPerformance;\r\n//# sourceMappingURL=Performance.js.map","\"use strict\";\r\n/**\r\n * Base class for helpers that read data from HTTP request/response objects and convert them\r\n * into the telemetry contract objects.\r\n */\r\nvar RequestParser = (function () {\r\n    function RequestParser() {\r\n    }\r\n    /**\r\n     * Gets a url parsed out from request options\r\n     */\r\n    RequestParser.prototype.getUrl = function () {\r\n        return this.url;\r\n    };\r\n    RequestParser.prototype.RequestParser = function () {\r\n        this.startTime = +new Date();\r\n    };\r\n    RequestParser.prototype._setStatus = function (status, error) {\r\n        var endTime = +new Date();\r\n        this.duration = endTime - this.startTime;\r\n        this.statusCode = status;\r\n        var properties = this.properties || {};\r\n        if (error) {\r\n            if (typeof error === \"string\") {\r\n                properties[\"error\"] = error;\r\n            }\r\n            else if (error instanceof Error) {\r\n                properties[\"error\"] = error.message;\r\n            }\r\n            else if (typeof error === \"object\") {\r\n                for (var key in error) {\r\n                    properties[key] = error[key] && error[key].toString && error[key].toString();\r\n                }\r\n            }\r\n        }\r\n        this.properties = properties;\r\n    };\r\n    RequestParser.prototype._isSuccess = function () {\r\n        return (0 < this.statusCode) && (this.statusCode < 400);\r\n    };\r\n    return RequestParser;\r\n}());\r\nmodule.exports = RequestParser;\r\n//# sourceMappingURL=RequestParser.js.map","\"use strict\";\r\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license. See LICENSE file in the project root for details.\r\nvar AsyncHooksScopeManager_1 = require(\"../AsyncHooksScopeManager\");\r\nvar Constants = require(\"../../Declarations/Constants\");\r\nfunction filterSpanAttributes(attributes) {\r\n    var newAttributes = __assign({}, attributes);\r\n    Object.keys(Constants.SpanAttribute).forEach(function (key) {\r\n        delete newAttributes[key];\r\n    });\r\n    return newAttributes;\r\n}\r\nfunction spanToTelemetryContract(span) {\r\n    var id = \"|\" + span.context().traceId + \".\" + span.context().spanId + \".\";\r\n    var duration = Math.round(span._duration[0] * 1e3 + span._duration[1] / 1e6);\r\n    var isHttp = ((span.attributes.component || \"\").toUpperCase() === Constants.DependencyTypeName.Http) || (!!span.attributes[Constants.SpanAttribute.HttpUrl]);\r\n    var isGrpc = (span.attributes.component || \"\").toLowerCase() === Constants.DependencyTypeName.Grpc;\r\n    if (isHttp) {\r\n        // Read http span attributes\r\n        var method = span.attributes[Constants.SpanAttribute.HttpMethod] || \"GET\";\r\n        var url = new URL(span.attributes[Constants.SpanAttribute.HttpUrl]);\r\n        var host = span.attributes[Constants.SpanAttribute.HttpHost] || url.host;\r\n        var port = span.attributes[Constants.SpanAttribute.HttpPort] || url.port || null;\r\n        var pathname = url.pathname || \"/\";\r\n        // Translate to AI Dependency format\r\n        var name_1 = method + \" \" + pathname;\r\n        var dependencyTypeName = Constants.DependencyTypeName.Http;\r\n        var target = port ? host + \":\" + port : host;\r\n        var data = url.toString();\r\n        var resultCode = span.attributes[Constants.SpanAttribute.HttpStatusCode] || span.status.code || 0;\r\n        var success = resultCode < 400; // Status.OK\r\n        return {\r\n            id: id, name: name_1, dependencyTypeName: dependencyTypeName,\r\n            target: target, data: data,\r\n            success: success, duration: duration,\r\n            url: data,\r\n            resultCode: String(resultCode),\r\n            properties: filterSpanAttributes(span.attributes)\r\n        };\r\n    }\r\n    else if (isGrpc) {\r\n        var method = span.attributes[Constants.SpanAttribute.GrpcMethod] || \"rpc\";\r\n        var service = span.attributes[Constants.SpanAttribute.GrpcService];\r\n        var name_2 = service ? method + \" \" + service : span.name;\r\n        return {\r\n            id: id, duration: duration, name: name_2,\r\n            target: service,\r\n            data: service || name_2,\r\n            url: service || name_2,\r\n            dependencyTypeName: Constants.DependencyTypeName.Grpc,\r\n            resultCode: String(span.status.code || 0),\r\n            success: span.status.code === 0,\r\n            properties: filterSpanAttributes(span.attributes),\r\n        };\r\n    }\r\n    else {\r\n        var name_3 = span.name;\r\n        var links = span.links && span.links.map(function (link) {\r\n            return {\r\n                operation_Id: link.spanContext.traceId,\r\n                id: link.spanContext.spanId\r\n            };\r\n        });\r\n        return {\r\n            id: id, duration: duration, name: name_3,\r\n            target: span.attributes[\"peer.address\"],\r\n            data: span.attributes[\"peer.address\"] || name_3,\r\n            url: span.attributes[\"peer.address\"] || name_3,\r\n            dependencyTypeName: span.kind === AsyncHooksScopeManager_1.SpanKind.INTERNAL ? Constants.DependencyTypeName.InProc : (span.attributes.component || span.name),\r\n            resultCode: String(span.status.code || 0),\r\n            success: span.status.code === 0,\r\n            properties: __assign({}, filterSpanAttributes(span.attributes), { \"_MS.links\": links || undefined }),\r\n        };\r\n    }\r\n}\r\nexports.spanToTelemetryContract = spanToTelemetryContract;\r\n//# sourceMappingURL=SpanParser.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar diagnostic_channel_1 = require(\"diagnostic-channel\");\r\nvar Traceparent = require(\"../../Library/Traceparent\");\r\nvar SpanParser = require(\"./SpanParser\");\r\nvar AsyncHooksScopeManager_1 = require(\"../AsyncHooksScopeManager\");\r\nvar clients = [];\r\nexports.subscriber = function (event) {\r\n    var span = event.data;\r\n    var telemetry = SpanParser.spanToTelemetryContract(span);\r\n    var spanContext = span.context();\r\n    var traceparent = new Traceparent();\r\n    traceparent.traceId = spanContext.traceId;\r\n    traceparent.spanId = spanContext.spanId;\r\n    traceparent.traceFlag = spanContext.traceFlags.toString();\r\n    traceparent.parentId = span.parentSpanId ? \"|\" + spanContext.traceId + \".\" + span.parentSpanId + \".\" : null;\r\n    AsyncHooksScopeManager_1.AsyncScopeManager.with(span, function () {\r\n        clients.forEach(function (client) {\r\n            if (span.kind === AsyncHooksScopeManager_1.SpanKind.SERVER) {\r\n                // Server or Consumer\r\n                client.trackRequest(telemetry);\r\n            }\r\n            else if (span.kind === AsyncHooksScopeManager_1.SpanKind.CLIENT || span.kind === AsyncHooksScopeManager_1.SpanKind.INTERNAL) {\r\n                // Client or Producer or Internal\r\n                client.trackDependency(telemetry);\r\n            }\r\n            // else - ignore producer/consumer spans for now until it is clear how this sdk should interpret them\r\n        });\r\n    });\r\n};\r\nfunction enable(enabled, client) {\r\n    if (enabled) {\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.subscribe(\"azure-coretracing\", exports.subscriber);\r\n        }\r\n        ;\r\n        clients.push(client);\r\n    }\r\n    else {\r\n        clients = clients.filter(function (c) { return c != client; });\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.unsubscribe(\"azure-coretracing\", exports.subscriber);\r\n        }\r\n    }\r\n}\r\nexports.enable = enable;\r\n//# sourceMappingURL=azure-coretracing.sub.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Contracts_1 = require(\"../../Declarations/Contracts\");\r\nvar diagnostic_channel_1 = require(\"diagnostic-channel\");\r\nvar clients = [];\r\n// Mapping from bunyan levels defined at https://github.com/trentm/node-bunyan/blob/master/lib/bunyan.js#L256\r\nvar bunyanToAILevelMap = {\r\n    10: Contracts_1.SeverityLevel.Verbose,\r\n    20: Contracts_1.SeverityLevel.Verbose,\r\n    30: Contracts_1.SeverityLevel.Information,\r\n    40: Contracts_1.SeverityLevel.Warning,\r\n    50: Contracts_1.SeverityLevel.Error,\r\n    60: Contracts_1.SeverityLevel.Critical,\r\n};\r\nvar subscriber = function (event) {\r\n    var message = event.data.result;\r\n    clients.forEach(function (client) {\r\n        var AIlevel = bunyanToAILevelMap[event.data.level];\r\n        if (message instanceof Error) {\r\n            client.trackException({ exception: (message) });\r\n        }\r\n        else {\r\n            client.trackTrace({ message: message, severity: AIlevel });\r\n        }\r\n    });\r\n};\r\nfunction enable(enabled, client) {\r\n    if (enabled) {\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.subscribe(\"bunyan\", subscriber);\r\n        }\r\n        ;\r\n        clients.push(client);\r\n    }\r\n    else {\r\n        clients = clients.filter(function (c) { return c != client; });\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.unsubscribe(\"bunyan\", subscriber);\r\n        }\r\n    }\r\n}\r\nexports.enable = enable;\r\nfunction dispose() {\r\n    diagnostic_channel_1.channel.unsubscribe(\"bunyan\", subscriber);\r\n    clients = [];\r\n}\r\nexports.dispose = dispose;\r\n//# sourceMappingURL=bunyan.sub.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Contracts_1 = require(\"../../Declarations/Contracts\");\r\nvar diagnostic_channel_1 = require(\"diagnostic-channel\");\r\nvar clients = [];\r\nvar subscriber = function (event) {\r\n    var message = event.data.message;\r\n    clients.forEach(function (client) {\r\n        if (message instanceof Error) {\r\n            client.trackException({ exception: message });\r\n        }\r\n        else {\r\n            // Message can have a trailing newline\r\n            if (message.lastIndexOf(\"\\n\") == message.length - 1) {\r\n                message = message.substring(0, message.length - 1);\r\n            }\r\n            client.trackTrace({ message: message, severity: (event.data.stderr ? Contracts_1.SeverityLevel.Warning : Contracts_1.SeverityLevel.Information) });\r\n        }\r\n    });\r\n};\r\nfunction enable(enabled, client) {\r\n    if (enabled) {\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.subscribe(\"console\", subscriber);\r\n        }\r\n        ;\r\n        clients.push(client);\r\n    }\r\n    else {\r\n        clients = clients.filter(function (c) { return c != client; });\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.unsubscribe(\"console\", subscriber);\r\n        }\r\n    }\r\n}\r\nexports.enable = enable;\r\nfunction dispose() {\r\n    diagnostic_channel_1.channel.unsubscribe(\"console\", subscriber);\r\n    clients = [];\r\n}\r\nexports.dispose = dispose;\r\n//# sourceMappingURL=console.sub.js.map","\"use strict\";\r\n// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license. See LICENSE file in the project root for details.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar AsyncHooksScopeManager_1 = require(\"../AsyncHooksScopeManager\");\r\nvar Logging = require(\"../../Library/Logging\");\r\nexports.IsInitialized = !process.env[\"APPLICATION_INSIGHTS_NO_DIAGNOSTIC_CHANNEL\"];\r\nvar TAG = \"DiagnosticChannel\";\r\nif (exports.IsInitialized) {\r\n    var publishers = require(\"diagnostic-channel-publishers\");\r\n    var individualOptOuts = process.env[\"APPLICATION_INSIGHTS_NO_PATCH_MODULES\"] || \"\";\r\n    var unpatchedModules = individualOptOuts.split(\",\");\r\n    var modules = {\r\n        bunyan: publishers.bunyan,\r\n        console: publishers.console,\r\n        mongodb: publishers.mongodb,\r\n        mongodbCore: publishers.mongodbCore,\r\n        mysql: publishers.mysql,\r\n        redis: publishers.redis,\r\n        pg: publishers.pg,\r\n        pgPool: publishers.pgPool,\r\n        winston: publishers.winston,\r\n        azuresdk: publishers.azuresdk\r\n    };\r\n    for (var mod in modules) {\r\n        if (unpatchedModules.indexOf(mod) === -1) {\r\n            modules[mod].enable();\r\n            Logging.info(TAG, \"Subscribed to \" + mod + \" events\");\r\n        }\r\n    }\r\n    if (unpatchedModules.length > 0) {\r\n        Logging.info(TAG, \"Some modules will not be patched\", unpatchedModules);\r\n    }\r\n}\r\nelse {\r\n    Logging.info(TAG, \"Not subscribing to dependency autocollection because APPLICATION_INSIGHTS_NO_DIAGNOSTIC_CHANNEL was set\");\r\n}\r\nfunction registerContextPreservation(cb) {\r\n    if (!exports.IsInitialized) {\r\n        return;\r\n    }\r\n    var diagChannel = require(\"diagnostic-channel\");\r\n    diagChannel.channel.addContextPreservation(cb);\r\n    diagChannel.channel.spanContextPropagator = AsyncHooksScopeManager_1.AsyncScopeManager;\r\n}\r\nexports.registerContextPreservation = registerContextPreservation;\r\n//# sourceMappingURL=initialization.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar diagnostic_channel_1 = require(\"diagnostic-channel\");\r\nvar clients = [];\r\nexports.subscriber = function (event) {\r\n    if (event.data.event.commandName === \"ismaster\") {\r\n        // suppress noisy ismaster commands\r\n        return;\r\n    }\r\n    clients.forEach(function (client) {\r\n        var dbName = (event.data.startedData && event.data.startedData.databaseName) || \"Unknown database\";\r\n        client.trackDependency({\r\n            target: dbName,\r\n            data: event.data.event.commandName,\r\n            name: event.data.event.commandName,\r\n            duration: event.data.event.duration,\r\n            success: event.data.succeeded,\r\n            /* TODO: transmit result code from mongo */\r\n            resultCode: event.data.succeeded ? \"0\" : \"1\",\r\n            time: event.data.startedData.time,\r\n            dependencyTypeName: 'mongodb'\r\n        });\r\n    });\r\n};\r\nfunction enable(enabled, client) {\r\n    if (enabled) {\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.subscribe(\"mongodb\", exports.subscriber);\r\n        }\r\n        ;\r\n        clients.push(client);\r\n    }\r\n    else {\r\n        clients = clients.filter(function (c) { return c != client; });\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.unsubscribe(\"mongodb\", exports.subscriber);\r\n        }\r\n    }\r\n}\r\nexports.enable = enable;\r\n//# sourceMappingURL=mongodb.sub.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar diagnostic_channel_1 = require(\"diagnostic-channel\");\r\nvar clients = [];\r\nexports.subscriber = function (event) {\r\n    clients.forEach(function (client) {\r\n        var queryObj = event.data.query || {};\r\n        var sqlString = queryObj.sql || \"Unknown query\";\r\n        var success = !event.data.err;\r\n        var connection = queryObj._connection || {};\r\n        var connectionConfig = connection.config || {};\r\n        var dbName = connectionConfig.socketPath ? connectionConfig.socketPath : (connectionConfig.host || \"localhost\") + \":\" + connectionConfig.port;\r\n        client.trackDependency({\r\n            target: dbName,\r\n            data: sqlString,\r\n            name: sqlString,\r\n            duration: event.data.duration,\r\n            success: success,\r\n            /* TODO: transmit result code from mysql */\r\n            resultCode: success ? \"0\" : \"1\",\r\n            time: event.data.time,\r\n            dependencyTypeName: \"mysql\"\r\n        });\r\n    });\r\n};\r\nfunction enable(enabled, client) {\r\n    if (enabled) {\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.subscribe(\"mysql\", exports.subscriber);\r\n        }\r\n        ;\r\n        clients.push(client);\r\n    }\r\n    else {\r\n        clients = clients.filter(function (c) { return c != client; });\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.unsubscribe(\"mysql\", exports.subscriber);\r\n        }\r\n    }\r\n}\r\nexports.enable = enable;\r\n//# sourceMappingURL=mysql.sub.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar diagnostic_channel_1 = require(\"diagnostic-channel\");\r\nvar clients = [];\r\nexports.subscriber = function (event) {\r\n    clients.forEach(function (client) {\r\n        var q = event.data.query;\r\n        var sql = (q.preparable && q.preparable.text) || q.plan || q.text || \"unknown query\";\r\n        var success = !event.data.error;\r\n        var conn = event.data.database.host + \":\" + event.data.database.port;\r\n        client.trackDependency({\r\n            target: conn,\r\n            data: sql,\r\n            name: sql,\r\n            duration: event.data.duration,\r\n            success: success,\r\n            resultCode: success ? \"0\" : \"1\",\r\n            time: event.data.time,\r\n            dependencyTypeName: \"postgres\"\r\n        });\r\n    });\r\n};\r\nfunction enable(enabled, client) {\r\n    if (enabled) {\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.subscribe(\"postgres\", exports.subscriber);\r\n        }\r\n        ;\r\n        clients.push(client);\r\n    }\r\n    else {\r\n        clients = clients.filter(function (c) { return c != client; });\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.unsubscribe(\"postgres\", exports.subscriber);\r\n        }\r\n    }\r\n}\r\nexports.enable = enable;\r\n//# sourceMappingURL=postgres.sub.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar diagnostic_channel_1 = require(\"diagnostic-channel\");\r\nvar clients = [];\r\nexports.subscriber = function (event) {\r\n    clients.forEach(function (client) {\r\n        if (event.data.commandObj.command === \"info\") {\r\n            // We don't want to report 'info', it's irrelevant\r\n            return;\r\n        }\r\n        client.trackDependency({\r\n            target: event.data.address,\r\n            name: event.data.commandObj.command,\r\n            data: event.data.commandObj.command,\r\n            duration: event.data.duration,\r\n            success: !event.data.err,\r\n            /* TODO: transmit result code from redis */\r\n            resultCode: event.data.err ? \"1\" : \"0\",\r\n            time: event.data.time,\r\n            dependencyTypeName: \"redis\"\r\n        });\r\n    });\r\n};\r\nfunction enable(enabled, client) {\r\n    if (enabled) {\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.subscribe(\"redis\", exports.subscriber);\r\n        }\r\n        ;\r\n        clients.push(client);\r\n    }\r\n    else {\r\n        clients = clients.filter(function (c) { return c != client; });\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.unsubscribe(\"redis\", exports.subscriber);\r\n        }\r\n    }\r\n}\r\nexports.enable = enable;\r\n//# sourceMappingURL=redis.sub.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Contracts_1 = require(\"../../Declarations/Contracts\");\r\nvar diagnostic_channel_1 = require(\"diagnostic-channel\");\r\nvar clients = [];\r\nvar winstonToAILevelMap = {\r\n    syslog: function (og) {\r\n        var map = {\r\n            emerg: Contracts_1.SeverityLevel.Critical,\r\n            alert: Contracts_1.SeverityLevel.Critical,\r\n            crit: Contracts_1.SeverityLevel.Critical,\r\n            error: Contracts_1.SeverityLevel.Error,\r\n            warning: Contracts_1.SeverityLevel.Warning,\r\n            notice: Contracts_1.SeverityLevel.Information,\r\n            info: Contracts_1.SeverityLevel.Information,\r\n            debug: Contracts_1.SeverityLevel.Verbose\r\n        };\r\n        return map[og] === undefined ? Contracts_1.SeverityLevel.Information : map[og];\r\n    },\r\n    npm: function (og) {\r\n        var map = {\r\n            error: Contracts_1.SeverityLevel.Error,\r\n            warn: Contracts_1.SeverityLevel.Warning,\r\n            info: Contracts_1.SeverityLevel.Information,\r\n            verbose: Contracts_1.SeverityLevel.Verbose,\r\n            debug: Contracts_1.SeverityLevel.Verbose,\r\n            silly: Contracts_1.SeverityLevel.Verbose\r\n        };\r\n        return map[og] === undefined ? Contracts_1.SeverityLevel.Information : map[og];\r\n    },\r\n    unknown: function (og) {\r\n        return Contracts_1.SeverityLevel.Information;\r\n    }\r\n};\r\nvar subscriber = function (event) {\r\n    var message = event.data.message;\r\n    clients.forEach(function (client) {\r\n        if (message instanceof Error) {\r\n            client.trackException({\r\n                exception: message,\r\n                properties: event.data.meta\r\n            });\r\n        }\r\n        else {\r\n            var AIlevel = winstonToAILevelMap[event.data.levelKind](event.data.level);\r\n            client.trackTrace({\r\n                message: message,\r\n                severity: AIlevel,\r\n                properties: event.data.meta\r\n            });\r\n        }\r\n    });\r\n};\r\nfunction enable(enabled, client) {\r\n    if (enabled) {\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.subscribe(\"winston\", subscriber);\r\n        }\r\n        ;\r\n        clients.push(client);\r\n    }\r\n    else {\r\n        clients = clients.filter(function (c) { return c != client; });\r\n        if (clients.length === 0) {\r\n            diagnostic_channel_1.channel.unsubscribe(\"winston\", subscriber);\r\n        }\r\n    }\r\n}\r\nexports.enable = enable;\r\nfunction dispose() {\r\n    diagnostic_channel_1.channel.unsubscribe(\"winston\", subscriber);\r\n    clients = [];\r\n}\r\nexports.dispose = dispose;\r\n//# sourceMappingURL=winston.sub.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.DEFAULT_BREEZE_ENDPOINT = \"https://dc.services.visualstudio.com\";\r\nexports.DEFAULT_LIVEMETRICS_ENDPOINT = \"https://rt.services.visualstudio.com\";\r\nexports.DEFAULT_LIVEMETRICS_HOST = \"rt.services.visualstudio.com\";\r\nvar QuickPulseCounter;\r\n(function (QuickPulseCounter) {\r\n    // Memory\r\n    QuickPulseCounter[\"COMMITTED_BYTES\"] = \"\\\\Memory\\\\Committed Bytes\";\r\n    // CPU\r\n    QuickPulseCounter[\"PROCESSOR_TIME\"] = \"\\\\Processor(_Total)\\\\% Processor Time\";\r\n    // Request\r\n    QuickPulseCounter[\"REQUEST_RATE\"] = \"\\\\ApplicationInsights\\\\Requests/Sec\";\r\n    QuickPulseCounter[\"REQUEST_FAILURE_RATE\"] = \"\\\\ApplicationInsights\\\\Requests Failed/Sec\";\r\n    QuickPulseCounter[\"REQUEST_DURATION\"] = \"\\\\ApplicationInsights\\\\Request Duration\";\r\n    // Dependency\r\n    QuickPulseCounter[\"DEPENDENCY_RATE\"] = \"\\\\ApplicationInsights\\\\Dependency Calls/Sec\";\r\n    QuickPulseCounter[\"DEPENDENCY_FAILURE_RATE\"] = \"\\\\ApplicationInsights\\\\Dependency Calls Failed/Sec\";\r\n    QuickPulseCounter[\"DEPENDENCY_DURATION\"] = \"\\\\ApplicationInsights\\\\Dependency Call Duration\";\r\n    // Exception\r\n    QuickPulseCounter[\"EXCEPTION_RATE\"] = \"\\\\ApplicationInsights\\\\Exceptions/Sec\";\r\n})(QuickPulseCounter = exports.QuickPulseCounter || (exports.QuickPulseCounter = {}));\r\nvar PerformanceCounter;\r\n(function (PerformanceCounter) {\r\n    // Memory\r\n    PerformanceCounter[\"PRIVATE_BYTES\"] = \"\\\\Process(??APP_WIN32_PROC??)\\\\Private Bytes\";\r\n    PerformanceCounter[\"AVAILABLE_BYTES\"] = \"\\\\Memory\\\\Available Bytes\";\r\n    // CPU\r\n    PerformanceCounter[\"PROCESSOR_TIME\"] = \"\\\\Processor(_Total)\\\\% Processor Time\";\r\n    PerformanceCounter[\"PROCESS_TIME\"] = \"\\\\Process(??APP_WIN32_PROC??)\\\\% Processor Time\";\r\n    // Requests\r\n    PerformanceCounter[\"REQUEST_RATE\"] = \"\\\\ASP.NET Applications(??APP_W3SVC_PROC??)\\\\Requests/Sec\";\r\n    PerformanceCounter[\"REQUEST_DURATION\"] = \"\\\\ASP.NET Applications(??APP_W3SVC_PROC??)\\\\Request Execution Time\";\r\n})(PerformanceCounter = exports.PerformanceCounter || (exports.PerformanceCounter = {}));\r\n;\r\n/**\r\n * Map a PerformanceCounter/QuickPulseCounter to a QuickPulseCounter. If no mapping exists, mapping is *undefined*\r\n */\r\nexports.PerformanceToQuickPulseCounter = (_a = {},\r\n    _a[PerformanceCounter.PROCESSOR_TIME] = QuickPulseCounter.PROCESSOR_TIME,\r\n    _a[PerformanceCounter.REQUEST_RATE] = QuickPulseCounter.REQUEST_RATE,\r\n    _a[PerformanceCounter.REQUEST_DURATION] = QuickPulseCounter.REQUEST_DURATION,\r\n    // Remap quick pulse only counters\r\n    _a[QuickPulseCounter.COMMITTED_BYTES] = QuickPulseCounter.COMMITTED_BYTES,\r\n    _a[QuickPulseCounter.REQUEST_FAILURE_RATE] = QuickPulseCounter.REQUEST_FAILURE_RATE,\r\n    _a[QuickPulseCounter.DEPENDENCY_RATE] = QuickPulseCounter.DEPENDENCY_RATE,\r\n    _a[QuickPulseCounter.DEPENDENCY_FAILURE_RATE] = QuickPulseCounter.DEPENDENCY_FAILURE_RATE,\r\n    _a[QuickPulseCounter.DEPENDENCY_DURATION] = QuickPulseCounter.DEPENDENCY_DURATION,\r\n    _a[QuickPulseCounter.EXCEPTION_RATE] = QuickPulseCounter.EXCEPTION_RATE,\r\n    _a);\r\nexports.QuickPulseDocumentType = {\r\n    Event: \"Event\",\r\n    Exception: \"Exception\",\r\n    Trace: \"Trace\",\r\n    Metric: \"Metric\",\r\n    Request: \"Request\",\r\n    Dependency: \"RemoteDependency\",\r\n    Availability: \"Availability\",\r\n    PageView: \"PageView\",\r\n};\r\nexports.QuickPulseType = {\r\n    Event: \"EventTelemetryDocument\",\r\n    Exception: \"ExceptionTelemetryDocument\",\r\n    Trace: \"TraceTelemetryDocument\",\r\n    Metric: \"MetricTelemetryDocument\",\r\n    Request: \"RequestTelemetryDocument\",\r\n    Dependency: \"DependencyTelemetryDocument\",\r\n    Availability: \"AvailabilityTelemetryDocument\",\r\n    PageView: \"PageViewTelemetryDocument\",\r\n};\r\nexports.TelemetryTypeStringToQuickPulseType = {\r\n    EventData: exports.QuickPulseType.Event,\r\n    ExceptionData: exports.QuickPulseType.Exception,\r\n    MessageData: exports.QuickPulseType.Trace,\r\n    MetricData: exports.QuickPulseType.Metric,\r\n    RequestData: exports.QuickPulseType.Request,\r\n    RemoteDependencyData: exports.QuickPulseType.Dependency,\r\n    AvailabilityData: exports.QuickPulseType.Availability,\r\n    PageViewData: exports.QuickPulseType.PageView\r\n};\r\nexports.TelemetryTypeStringToQuickPulseDocumentType = {\r\n    EventData: exports.QuickPulseDocumentType.Event,\r\n    ExceptionData: exports.QuickPulseDocumentType.Exception,\r\n    MessageData: exports.QuickPulseDocumentType.Trace,\r\n    MetricData: exports.QuickPulseDocumentType.Metric,\r\n    RequestData: exports.QuickPulseDocumentType.Request,\r\n    RemoteDependencyData: exports.QuickPulseDocumentType.Dependency,\r\n    AvailabilityData: exports.QuickPulseDocumentType.Availability,\r\n    PageViewData: exports.QuickPulseDocumentType.PageView\r\n};\r\n// OpenTelemetry Span Attributes\r\nexports.SpanAttribute = {\r\n    // HTTP\r\n    HttpHost: \"http.host\",\r\n    HttpMethod: \"http.method\",\r\n    HttpPort: \"http.port\",\r\n    HttpStatusCode: \"http.status_code\",\r\n    HttpUrl: \"http.url\",\r\n    HttpUserAgent: \"http.user_agent\",\r\n    // GRPC\r\n    GrpcMethod: \"grpc.method\",\r\n    GrpcService: \"rpc.service\",\r\n};\r\nexports.DependencyTypeName = {\r\n    Grpc: \"GRPC\",\r\n    Http: \"HTTP\",\r\n    InProc: \"InProc\",\r\n};\r\nexports.HeartBeatMetricName = \"HeartBeat\";\r\nvar _a;\r\n//# sourceMappingURL=Constants.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Generated_1 = require(\"./Generated\");\r\nvar RemoteDependencyDataConstants = (function () {\r\n    function RemoteDependencyDataConstants() {\r\n    }\r\n    RemoteDependencyDataConstants.TYPE_HTTP = \"Http\";\r\n    RemoteDependencyDataConstants.TYPE_AI = \"Http (tracked component)\";\r\n    return RemoteDependencyDataConstants;\r\n}());\r\nexports.RemoteDependencyDataConstants = RemoteDependencyDataConstants;\r\nfunction domainSupportsProperties(domain) {\r\n    return \"properties\" in domain ||\r\n        domain instanceof Generated_1.EventData ||\r\n        domain instanceof Generated_1.ExceptionData ||\r\n        domain instanceof Generated_1.MessageData ||\r\n        domain instanceof Generated_1.MetricData ||\r\n        domain instanceof Generated_1.PageViewData ||\r\n        domain instanceof Generated_1.RemoteDependencyData ||\r\n        domain instanceof Generated_1.RequestData;\r\n}\r\nexports.domainSupportsProperties = domainSupportsProperties;\r\n//# sourceMappingURL=Constants.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n// THIS FILE WAS AUTOGENERATED\r\nvar Domain = require(\"./Domain\");\r\n\"use strict\";\r\n/**\r\n * Instances of AvailabilityData represent the result of executing an availability test.\r\n */\r\nvar AvailabilityData = (function (_super) {\r\n    __extends(AvailabilityData, _super);\r\n    function AvailabilityData() {\r\n        var _this = _super.call(this) || this;\r\n        _this.ver = 2;\r\n        _this.properties = {};\r\n        _this.measurements = {};\r\n        return _this;\r\n    }\r\n    return AvailabilityData;\r\n}(Domain));\r\nmodule.exports = AvailabilityData;\r\n//# sourceMappingURL=AvailabilityData.js.map","// THIS FILE WAS AUTOGENERATED\r\n\"use strict\";\r\n/**\r\n * Data struct to contain only C section with custom fields.\r\n */\r\nvar Base = (function () {\r\n    function Base() {\r\n    }\r\n    return Base;\r\n}());\r\nmodule.exports = Base;\r\n//# sourceMappingURL=Base.js.map","// THIS FILE WAS AUTOGENERATED\r\n\"use strict\";\r\nvar ContextTagKeys = (function () {\r\n    function ContextTagKeys() {\r\n        this.applicationVersion = \"ai.application.ver\";\r\n        this.deviceId = \"ai.device.id\";\r\n        this.deviceLocale = \"ai.device.locale\";\r\n        this.deviceModel = \"ai.device.model\";\r\n        this.deviceOEMName = \"ai.device.oemName\";\r\n        this.deviceOSVersion = \"ai.device.osVersion\";\r\n        this.deviceType = \"ai.device.type\";\r\n        this.locationIp = \"ai.location.ip\";\r\n        this.operationId = \"ai.operation.id\";\r\n        this.operationName = \"ai.operation.name\";\r\n        this.operationParentId = \"ai.operation.parentId\";\r\n        this.operationSyntheticSource = \"ai.operation.syntheticSource\";\r\n        this.operationCorrelationVector = \"ai.operation.correlationVector\";\r\n        this.sessionId = \"ai.session.id\";\r\n        this.sessionIsFirst = \"ai.session.isFirst\";\r\n        this.userAccountId = \"ai.user.accountId\";\r\n        this.userId = \"ai.user.id\";\r\n        this.userAuthUserId = \"ai.user.authUserId\";\r\n        this.cloudRole = \"ai.cloud.role\";\r\n        this.cloudRoleInstance = \"ai.cloud.roleInstance\";\r\n        this.internalSdkVersion = \"ai.internal.sdkVersion\";\r\n        this.internalAgentVersion = \"ai.internal.agentVersion\";\r\n        this.internalNodeName = \"ai.internal.nodeName\";\r\n    }\r\n    return ContextTagKeys;\r\n}());\r\nmodule.exports = ContextTagKeys;\r\n//# sourceMappingURL=ContextTagKeys.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n// THIS FILE WAS AUTOGENERATED\r\nvar Base = require(\"./Base\");\r\n\"use strict\";\r\n/**\r\n * Data struct to contain both B and C sections.\r\n */\r\nvar Data = (function (_super) {\r\n    __extends(Data, _super);\r\n    function Data() {\r\n        return _super.call(this) || this;\r\n    }\r\n    return Data;\r\n}(Base));\r\nmodule.exports = Data;\r\n//# sourceMappingURL=Data.js.map","\"use strict\";\r\n// THIS FILE WAS AUTOGENERATED\r\nvar DataPointType = require(\"./DataPointType\");\r\n\"use strict\";\r\n/**\r\n * Metric data single measurement.\r\n */\r\nvar DataPoint = (function () {\r\n    function DataPoint() {\r\n        this.kind = DataPointType.Measurement;\r\n    }\r\n    return DataPoint;\r\n}());\r\nmodule.exports = DataPoint;\r\n//# sourceMappingURL=DataPoint.js.map","// THIS FILE WAS AUTOGENERATED\r\n\"use strict\";\r\n/**\r\n * Type of the metric data measurement.\r\n */\r\nvar DataPointType;\r\n(function (DataPointType) {\r\n    DataPointType[DataPointType[\"Measurement\"] = 0] = \"Measurement\";\r\n    DataPointType[DataPointType[\"Aggregation\"] = 1] = \"Aggregation\";\r\n})(DataPointType || (DataPointType = {}));\r\nmodule.exports = DataPointType;\r\n//# sourceMappingURL=DataPointType.js.map","// THIS FILE WAS AUTOGENERATED\r\n\"use strict\";\r\n/**\r\n * The abstract common base of all domains.\r\n */\r\nvar Domain = (function () {\r\n    function Domain() {\r\n    }\r\n    return Domain;\r\n}());\r\nmodule.exports = Domain;\r\n//# sourceMappingURL=Domain.js.map","\"use strict\";\r\n/**\r\n * System variables for a telemetry item.\r\n */\r\nvar Envelope = (function () {\r\n    function Envelope() {\r\n        this.ver = 1;\r\n        this.sampleRate = 100.0;\r\n        this.tags = {};\r\n    }\r\n    return Envelope;\r\n}());\r\nmodule.exports = Envelope;\r\n//# sourceMappingURL=Envelope.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n// THIS FILE WAS AUTOGENERATED\r\nvar Domain = require(\"./Domain\");\r\n\"use strict\";\r\n/**\r\n * Instances of Event represent structured event records that can be grouped and searched by their properties. Event data item also creates a metric of event count by name.\r\n */\r\nvar EventData = (function (_super) {\r\n    __extends(EventData, _super);\r\n    function EventData() {\r\n        var _this = _super.call(this) || this;\r\n        _this.ver = 2;\r\n        _this.properties = {};\r\n        _this.measurements = {};\r\n        return _this;\r\n    }\r\n    return EventData;\r\n}(Domain));\r\nmodule.exports = EventData;\r\n//# sourceMappingURL=EventData.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n// THIS FILE WAS AUTOGENERATED\r\nvar Domain = require(\"./Domain\");\r\n\"use strict\";\r\n/**\r\n * An instance of Exception represents a handled or unhandled exception that occurred during execution of the monitored application.\r\n */\r\nvar ExceptionData = (function (_super) {\r\n    __extends(ExceptionData, _super);\r\n    function ExceptionData() {\r\n        var _this = _super.call(this) || this;\r\n        _this.ver = 2;\r\n        _this.exceptions = [];\r\n        _this.properties = {};\r\n        _this.measurements = {};\r\n        return _this;\r\n    }\r\n    return ExceptionData;\r\n}(Domain));\r\nmodule.exports = ExceptionData;\r\n//# sourceMappingURL=ExceptionData.js.map","\"use strict\";\r\n/**\r\n * Exception details of the exception in a chain.\r\n */\r\nvar ExceptionDetails = (function () {\r\n    function ExceptionDetails() {\r\n        this.hasFullStack = true;\r\n        this.parsedStack = [];\r\n    }\r\n    return ExceptionDetails;\r\n}());\r\nmodule.exports = ExceptionDetails;\r\n//# sourceMappingURL=ExceptionDetails.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n// THIS FILE WAS AUTOGENERATED\r\nvar Domain = require(\"./Domain\");\r\n\"use strict\";\r\n/**\r\n * Instances of Message represent printf-like trace statements that are text-searched. Log4Net, NLog and other text-based log file entries are translated into intances of this type. The message does not have measurements.\r\n */\r\nvar MessageData = (function (_super) {\r\n    __extends(MessageData, _super);\r\n    function MessageData() {\r\n        var _this = _super.call(this) || this;\r\n        _this.ver = 2;\r\n        _this.properties = {};\r\n        return _this;\r\n    }\r\n    return MessageData;\r\n}(Domain));\r\nmodule.exports = MessageData;\r\n//# sourceMappingURL=MessageData.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n// THIS FILE WAS AUTOGENERATED\r\nvar Domain = require(\"./Domain\");\r\n\"use strict\";\r\n/**\r\n * An instance of the Metric item is a list of measurements (single data points) and/or aggregations.\r\n */\r\nvar MetricData = (function (_super) {\r\n    __extends(MetricData, _super);\r\n    function MetricData() {\r\n        var _this = _super.call(this) || this;\r\n        _this.ver = 2;\r\n        _this.metrics = [];\r\n        _this.properties = {};\r\n        return _this;\r\n    }\r\n    return MetricData;\r\n}(Domain));\r\nmodule.exports = MetricData;\r\n//# sourceMappingURL=MetricData.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n// THIS FILE WAS AUTOGENERATED\r\nvar EventData = require(\"./EventData\");\r\n\"use strict\";\r\n/**\r\n * An instance of PageView represents a generic action on a page like a button click. It is also the base type for PageView.\r\n */\r\nvar PageViewData = (function (_super) {\r\n    __extends(PageViewData, _super);\r\n    function PageViewData() {\r\n        var _this = _super.call(this) || this;\r\n        _this.ver = 2;\r\n        _this.properties = {};\r\n        _this.measurements = {};\r\n        return _this;\r\n    }\r\n    return PageViewData;\r\n}(EventData));\r\nmodule.exports = PageViewData;\r\n//# sourceMappingURL=PageViewData.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n// THIS FILE WAS AUTOGENERATED\r\nvar Domain = require(\"./Domain\");\r\n\"use strict\";\r\n/**\r\n * An instance of Remote Dependency represents an interaction of the monitored component with a remote component/service like SQL or an HTTP endpoint.\r\n */\r\nvar RemoteDependencyData = (function (_super) {\r\n    __extends(RemoteDependencyData, _super);\r\n    function RemoteDependencyData() {\r\n        var _this = _super.call(this) || this;\r\n        _this.ver = 2;\r\n        _this.success = true;\r\n        _this.properties = {};\r\n        _this.measurements = {};\r\n        return _this;\r\n    }\r\n    return RemoteDependencyData;\r\n}(Domain));\r\nmodule.exports = RemoteDependencyData;\r\n//# sourceMappingURL=RemoteDependencyData.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n// THIS FILE WAS AUTOGENERATED\r\nvar Domain = require(\"./Domain\");\r\n\"use strict\";\r\n/**\r\n * An instance of Request represents completion of an external request to the application to do work and contains a summary of that request execution and the results.\r\n */\r\nvar RequestData = (function (_super) {\r\n    __extends(RequestData, _super);\r\n    function RequestData() {\r\n        var _this = _super.call(this) || this;\r\n        _this.ver = 2;\r\n        _this.properties = {};\r\n        _this.measurements = {};\r\n        return _this;\r\n    }\r\n    return RequestData;\r\n}(Domain));\r\nmodule.exports = RequestData;\r\n//# sourceMappingURL=RequestData.js.map","// THIS FILE WAS AUTOGENERATED\r\n\"use strict\";\r\n/**\r\n * Defines the level of severity for the event.\r\n */\r\nvar SeverityLevel;\r\n(function (SeverityLevel) {\r\n    SeverityLevel[SeverityLevel[\"Verbose\"] = 0] = \"Verbose\";\r\n    SeverityLevel[SeverityLevel[\"Information\"] = 1] = \"Information\";\r\n    SeverityLevel[SeverityLevel[\"Warning\"] = 2] = \"Warning\";\r\n    SeverityLevel[SeverityLevel[\"Error\"] = 3] = \"Error\";\r\n    SeverityLevel[SeverityLevel[\"Critical\"] = 4] = \"Critical\";\r\n})(SeverityLevel || (SeverityLevel = {}));\r\nmodule.exports = SeverityLevel;\r\n//# sourceMappingURL=SeverityLevel.js.map","// THIS FILE WAS AUTOGENERATED\r\n\"use strict\";\r\n/**\r\n * Stack frame information.\r\n */\r\nvar StackFrame = (function () {\r\n    function StackFrame() {\r\n    }\r\n    return StackFrame;\r\n}());\r\nmodule.exports = StackFrame;\r\n//# sourceMappingURL=StackFrame.js.map","// THIS FILE WAS AUTOGENERATED\r\n\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.AvailabilityData = require(\"./AvailabilityData\");\r\nexports.Base = require(\"./Base\");\r\nexports.ContextTagKeys = require(\"./ContextTagKeys\");\r\nexports.Data = require(\"./Data\");\r\nexports.DataPoint = require(\"./DataPoint\");\r\nexports.DataPointType = require(\"./DataPointType\");\r\nexports.Domain = require(\"./Domain\");\r\nexports.Envelope = require(\"./Envelope\");\r\nexports.EventData = require(\"./EventData\");\r\nexports.ExceptionData = require(\"./ExceptionData\");\r\nexports.ExceptionDetails = require(\"./ExceptionDetails\");\r\nexports.MessageData = require(\"./MessageData\");\r\nexports.MetricData = require(\"./MetricData\");\r\nexports.PageViewData = require(\"./PageViewData\");\r\nexports.RemoteDependencyData = require(\"./RemoteDependencyData\");\r\nexports.RequestData = require(\"./RequestData\");\r\nexports.SeverityLevel = require(\"./SeverityLevel\");\r\nexports.StackFrame = require(\"./StackFrame\");\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Converts the user-friendly enumeration TelemetryType to the underlying schema baseType value\r\n * @param type Type to convert to BaseData string\r\n */\r\nfunction telemetryTypeToBaseType(type) {\r\n    switch (type) {\r\n        case TelemetryType.Event:\r\n            return \"EventData\";\r\n        case TelemetryType.Exception:\r\n            return \"ExceptionData\";\r\n        case TelemetryType.Trace:\r\n            return \"MessageData\";\r\n        case TelemetryType.Metric:\r\n            return \"MetricData\";\r\n        case TelemetryType.Request:\r\n            return \"RequestData\";\r\n        case TelemetryType.Dependency:\r\n            return \"RemoteDependencyData\";\r\n        case TelemetryType.Availability:\r\n            return \"AvailabilityData\";\r\n        case TelemetryType.PageView:\r\n            return \"PageViewData\";\r\n    }\r\n    return undefined;\r\n}\r\nexports.telemetryTypeToBaseType = telemetryTypeToBaseType;\r\n/**\r\n * Converts the schema baseType value to the user-friendly enumeration TelemetryType\r\n * @param baseType BaseData string to convert to TelemetryType\r\n */\r\nfunction baseTypeToTelemetryType(baseType) {\r\n    switch (baseType) {\r\n        case \"EventData\":\r\n            return TelemetryType.Event;\r\n        case \"ExceptionData\":\r\n            return TelemetryType.Exception;\r\n        case \"MessageData\":\r\n            return TelemetryType.Trace;\r\n        case \"MetricData\":\r\n            return TelemetryType.Metric;\r\n        case \"RequestData\":\r\n            return TelemetryType.Request;\r\n        case \"RemoteDependencyData\":\r\n            return TelemetryType.Dependency;\r\n        case \"AvailabilityData\":\r\n            return TelemetryType.Availability;\r\n        case \"PageViewData\":\r\n            return TelemetryType.PageView;\r\n    }\r\n    return undefined;\r\n}\r\nexports.baseTypeToTelemetryType = baseTypeToTelemetryType;\r\nexports.TelemetryTypeString = {\r\n    Event: \"EventData\",\r\n    Exception: \"ExceptionData\",\r\n    Trace: \"MessageData\",\r\n    Metric: \"MetricData\",\r\n    Request: \"RequestData\",\r\n    Dependency: \"RemoteDependencyData\",\r\n    Availability: \"AvailabilityData\",\r\n    PageView: \"PageViewData\",\r\n};\r\n/**\r\n * Telemetry types supported by this SDK\r\n */\r\nvar TelemetryType;\r\n(function (TelemetryType) {\r\n    TelemetryType[TelemetryType[\"Event\"] = 0] = \"Event\";\r\n    TelemetryType[TelemetryType[\"Exception\"] = 1] = \"Exception\";\r\n    TelemetryType[TelemetryType[\"Trace\"] = 2] = \"Trace\";\r\n    TelemetryType[TelemetryType[\"Metric\"] = 3] = \"Metric\";\r\n    TelemetryType[TelemetryType[\"Request\"] = 4] = \"Request\";\r\n    TelemetryType[TelemetryType[\"Dependency\"] = 5] = \"Dependency\";\r\n    TelemetryType[TelemetryType[\"Availability\"] = 6] = \"Availability\";\r\n    TelemetryType[TelemetryType[\"PageView\"] = 7] = \"PageView\";\r\n})(TelemetryType = exports.TelemetryType || (exports.TelemetryType = {}));\r\n//# sourceMappingURL=TelemetryType.js.map","\"use strict\";\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__export(require(\"./TelemetryType\"));\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__export(require(\"./Constants\"));\r\n__export(require(\"./Generated\"));\r\n__export(require(\"./TelemetryTypes\"));\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nvar Logging = require(\"./Logging\");\r\nvar Channel = (function () {\r\n    function Channel(isDisabled, getBatchSize, getBatchIntervalMs, sender) {\r\n        this._buffer = [];\r\n        this._lastSend = 0;\r\n        this._isDisabled = isDisabled;\r\n        this._getBatchSize = getBatchSize;\r\n        this._getBatchIntervalMs = getBatchIntervalMs;\r\n        this._sender = sender;\r\n    }\r\n    /**\r\n     * Enable or disable disk-backed retry caching to cache events when client is offline (enabled by default)\r\n     * These cached events are stored in your system or user's temporary directory and access restricted to your user when possible.\r\n     * @param value if true events that occurred while client is offline will be cached on disk\r\n     * @param resendInterval The wait interval for resending cached events.\r\n     * @param maxBytesOnDisk The maximum size (in bytes) that the created temporary directory for cache events can grow to, before caching is disabled.\r\n     * @returns {Configuration} this class\r\n     */\r\n    Channel.prototype.setUseDiskRetryCaching = function (value, resendInterval, maxBytesOnDisk) {\r\n        this._sender.setDiskRetryMode(value, resendInterval, maxBytesOnDisk);\r\n    };\r\n    /**\r\n     * Add a telemetry item to the send buffer\r\n     */\r\n    Channel.prototype.send = function (envelope) {\r\n        var _this = this;\r\n        // if master off switch is set, don't send any data\r\n        if (this._isDisabled()) {\r\n            // Do not send/save data\r\n            return;\r\n        }\r\n        // validate input\r\n        if (!envelope) {\r\n            Logging.warn(\"Cannot send null/undefined telemetry\");\r\n            return;\r\n        }\r\n        // check if the incoming payload is too large, truncate if necessary\r\n        var payload = this._stringify(envelope);\r\n        if (typeof payload !== \"string\") {\r\n            return;\r\n        }\r\n        // enqueue the payload\r\n        this._buffer.push(payload);\r\n        // flush if we would exceed the max-size limit by adding this item\r\n        if (this._buffer.length >= this._getBatchSize()) {\r\n            this.triggerSend(false);\r\n            return;\r\n        }\r\n        // ensure an invocation timeout is set if anything is in the buffer\r\n        if (!this._timeoutHandle && this._buffer.length > 0) {\r\n            this._timeoutHandle = setTimeout(function () {\r\n                _this._timeoutHandle = null;\r\n                _this.triggerSend(false);\r\n            }, this._getBatchIntervalMs());\r\n        }\r\n    };\r\n    /**\r\n     * Immediately send buffered data\r\n     */\r\n    Channel.prototype.triggerSend = function (isNodeCrashing, callback) {\r\n        var bufferIsEmpty = this._buffer.length < 1;\r\n        if (!bufferIsEmpty) {\r\n            // compose an array of payloads\r\n            var batch = this._buffer.join(\"\\n\");\r\n            // invoke send\r\n            if (isNodeCrashing) {\r\n                this._sender.saveOnCrash(batch);\r\n                if (typeof callback === \"function\") {\r\n                    callback(\"data saved on crash\");\r\n                }\r\n            }\r\n            else {\r\n                this._sender.send(Buffer.from ? Buffer.from(batch) : new Buffer(batch), callback);\r\n            }\r\n        }\r\n        // update lastSend time to enable throttling\r\n        this._lastSend = +new Date;\r\n        // clear buffer\r\n        this._buffer.length = 0;\r\n        clearTimeout(this._timeoutHandle);\r\n        this._timeoutHandle = null;\r\n        if (bufferIsEmpty && typeof callback === \"function\") {\r\n            callback(\"no data to send\");\r\n        }\r\n    };\r\n    Channel.prototype._stringify = function (envelope) {\r\n        try {\r\n            return JSON.stringify(envelope);\r\n        }\r\n        catch (error) {\r\n            Logging.warn(\"Failed to serialize payload\", error, envelope);\r\n        }\r\n    };\r\n    return Channel;\r\n}());\r\nmodule.exports = Channel;\r\n//# sourceMappingURL=Channel.js.map","\"use strict\";\r\nvar CorrelationIdManager = require(\"./CorrelationIdManager\");\r\nvar ConnectionStringParser = require(\"./ConnectionStringParser\");\r\nvar Logging = require(\"./Logging\");\r\nvar Constants = require(\"../Declarations/Constants\");\r\nvar url = require(\"url\");\r\nvar Config = (function () {\r\n    function Config(setupString) {\r\n        var _this = this;\r\n        this.endpointBase = Constants.DEFAULT_BREEZE_ENDPOINT;\r\n        var connectionStringEnv = process.env[Config.ENV_connectionString];\r\n        var csCode = ConnectionStringParser.parse(setupString);\r\n        var csEnv = ConnectionStringParser.parse(connectionStringEnv);\r\n        var iKeyCode = !csCode.instrumentationkey && Object.keys(csCode).length > 0\r\n            ? null // CS was valid but instrumentation key was not provided, null and grab from env var\r\n            : setupString; // CS was invalid, so it must be an ikey\r\n        this.instrumentationKey = csCode.instrumentationkey || iKeyCode /* === instrumentationKey */ || csEnv.instrumentationkey || Config._getInstrumentationKey();\r\n        // validate ikey. If fails throw a warning\r\n        if (!Config._validateInstrumentationKey(this.instrumentationKey)) {\r\n            Logging.warn(\"An invalid instrumentation key was provided. There may be resulting telemetry loss\", this.instrumentationKey);\r\n        }\r\n        this.endpointUrl = (csCode.ingestionendpoint || csEnv.ingestionendpoint || this.endpointBase) + \"/v2/track\";\r\n        this.maxBatchSize = 250;\r\n        this.maxBatchIntervalMs = 15000;\r\n        this.disableAppInsights = false;\r\n        this.samplingPercentage = 100;\r\n        this.correlationIdRetryIntervalMs = 30 * 1000;\r\n        this.correlationHeaderExcludedDomains = [\r\n            \"*.core.windows.net\",\r\n            \"*.core.chinacloudapi.cn\",\r\n            \"*.core.cloudapi.de\",\r\n            \"*.core.usgovcloudapi.net\",\r\n            \"*.core.microsoft.scloud\",\r\n            \"*.core.eaglex.ic.gov\"\r\n        ];\r\n        this.setCorrelationId = function (correlationId) { return _this.correlationId = correlationId; };\r\n        this.proxyHttpUrl = process.env[Config.ENV_http_proxy] || undefined;\r\n        this.proxyHttpsUrl = process.env[Config.ENV_https_proxy] || undefined;\r\n        this.httpAgent = undefined;\r\n        this.httpsAgent = undefined;\r\n        this.profileQueryEndpoint = csCode.ingestionendpoint || csEnv.ingestionendpoint || process.env[Config.ENV_profileQueryEndpoint] || this.endpointBase;\r\n        this._quickPulseHost = csCode.liveendpoint || csEnv.liveendpoint || process.env[Config.ENV_quickPulseHost] || Constants.DEFAULT_LIVEMETRICS_HOST;\r\n        // Parse quickPulseHost if it starts with http(s)://\r\n        if (this._quickPulseHost.match(/^https?:\\/\\//)) {\r\n            this._quickPulseHost = url.parse(this._quickPulseHost).host;\r\n        }\r\n    }\r\n    Object.defineProperty(Config.prototype, \"profileQueryEndpoint\", {\r\n        get: function () {\r\n            return this._profileQueryEndpoint;\r\n        },\r\n        set: function (endpoint) {\r\n            CorrelationIdManager.cancelCorrelationIdQuery(this, this.setCorrelationId);\r\n            this._profileQueryEndpoint = endpoint;\r\n            this.correlationId = CorrelationIdManager.correlationIdPrefix; // Reset the correlationId while we wait for the new query\r\n            CorrelationIdManager.queryCorrelationId(this, this.setCorrelationId);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Config.prototype, \"quickPulseHost\", {\r\n        get: function () {\r\n            return this._quickPulseHost;\r\n        },\r\n        set: function (host) {\r\n            this._quickPulseHost = host;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Config._getInstrumentationKey = function () {\r\n        // check for both the documented env variable and the azure-prefixed variable\r\n        var iKey = process.env[Config.ENV_iKey]\r\n            || process.env[Config.ENV_azurePrefix + Config.ENV_iKey]\r\n            || process.env[Config.legacy_ENV_iKey]\r\n            || process.env[Config.ENV_azurePrefix + Config.legacy_ENV_iKey];\r\n        if (!iKey || iKey == \"\") {\r\n            throw new Error(\"Instrumentation key not found, pass the key in the config to this method or set the key in the environment variable APPINSIGHTS_INSTRUMENTATIONKEY before starting the server\");\r\n        }\r\n        return iKey;\r\n    };\r\n    /**\r\n    * Validate UUID Format\r\n    * Specs taken from breeze repo\r\n    * The definition of a VALID instrumentation key is as follows:\r\n    * Not none\r\n    * Not empty\r\n    * Every character is a hex character [0-9a-f]\r\n    * 32 characters are separated into 5 sections via 4 dashes\r\n    * First section has 8 characters\r\n    * Second section has 4 characters\r\n    * Third section has 4 characters\r\n    * Fourth section has 4 characters\r\n    * Fifth section has 12 characters\r\n    */\r\n    Config._validateInstrumentationKey = function (iKey) {\r\n        var UUID_Regex = '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$';\r\n        var regexp = new RegExp(UUID_Regex);\r\n        return regexp.test(iKey);\r\n    };\r\n    // Azure adds this prefix to all environment variables\r\n    Config.ENV_azurePrefix = \"APPSETTING_\";\r\n    // This key is provided in the readme\r\n    Config.ENV_iKey = \"APPINSIGHTS_INSTRUMENTATIONKEY\";\r\n    Config.legacy_ENV_iKey = \"APPINSIGHTS_INSTRUMENTATION_KEY\";\r\n    Config.ENV_profileQueryEndpoint = \"APPINSIGHTS_PROFILE_QUERY_ENDPOINT\";\r\n    Config.ENV_quickPulseHost = \"APPINSIGHTS_QUICKPULSE_HOST\";\r\n    // Azure Connection String\r\n    Config.ENV_connectionString = \"APPLICATIONINSIGHTS_CONNECTION_STRING\";\r\n    // Native Metrics Opt Outs\r\n    Config.ENV_nativeMetricsDisablers = \"APPLICATION_INSIGHTS_DISABLE_EXTENDED_METRIC\";\r\n    Config.ENV_nativeMetricsDisableAll = \"APPLICATION_INSIGHTS_DISABLE_ALL_EXTENDED_METRICS\";\r\n    Config.ENV_http_proxy = \"http_proxy\";\r\n    Config.ENV_https_proxy = \"https_proxy\";\r\n    return Config;\r\n}());\r\nmodule.exports = Config;\r\n//# sourceMappingURL=Config.js.map","\"use strict\";\r\nvar Constants = require(\"../Declarations/Constants\");\r\nvar ConnectionStringParser = (function () {\r\n    function ConnectionStringParser() {\r\n    }\r\n    ConnectionStringParser.parse = function (connectionString) {\r\n        if (!connectionString) {\r\n            return {};\r\n        }\r\n        var kvPairs = connectionString.split(ConnectionStringParser._FIELDS_SEPARATOR);\r\n        var result = kvPairs.reduce(function (fields, kv) {\r\n            var kvParts = kv.split(ConnectionStringParser._FIELD_KEY_VALUE_SEPARATOR);\r\n            if (kvParts.length === 2) {\r\n                var key = kvParts[0].toLowerCase();\r\n                var value = kvParts[1];\r\n                fields[key] = value;\r\n            }\r\n            return fields;\r\n        }, {});\r\n        if (Object.keys(result).length > 0) {\r\n            // this is a valid connection string, so parse the results\r\n            if (result.endpointsuffix) {\r\n                // use endpoint suffix where overrides are not provided\r\n                var locationPrefix = result.location ? result.location + \".\" : \"\";\r\n                result.ingestionendpoint = result.ingestionendpoint || (\"https://\" + locationPrefix + \"dc.\" + result.endpointsuffix);\r\n                result.liveendpoint = result.liveendpoint || (\"https://\" + locationPrefix + \"live.\" + result.endpointsuffix);\r\n            }\r\n            // apply the default endpoints\r\n            result.ingestionendpoint = result.ingestionendpoint || Constants.DEFAULT_BREEZE_ENDPOINT;\r\n            result.liveendpoint = result.liveendpoint || Constants.DEFAULT_LIVEMETRICS_ENDPOINT;\r\n        }\r\n        return result;\r\n    };\r\n    ConnectionStringParser._FIELDS_SEPARATOR = \";\";\r\n    ConnectionStringParser._FIELD_KEY_VALUE_SEPARATOR = \"=\";\r\n    return ConnectionStringParser;\r\n}());\r\nmodule.exports = ConnectionStringParser;\r\n//# sourceMappingURL=ConnectionStringParser.js.map","\"use strict\";\r\nvar os = require(\"os\");\r\nvar fs = require(\"fs\");\r\nvar path = require(\"path\");\r\nvar Contracts = require(\"../Declarations/Contracts\");\r\nvar Logging = require(\"./Logging\");\r\nvar Context = (function () {\r\n    function Context(packageJsonPath) {\r\n        this.keys = new Contracts.ContextTagKeys();\r\n        this.tags = {};\r\n        this._loadApplicationContext(packageJsonPath);\r\n        this._loadDeviceContext();\r\n        this._loadInternalContext();\r\n    }\r\n    Context.prototype._loadApplicationContext = function (packageJsonPath) {\r\n        // note: this should return the host package.json\r\n        packageJsonPath = packageJsonPath || path.resolve(__dirname, \"../../../../package.json\");\r\n        if (!Context.appVersion[packageJsonPath]) {\r\n            Context.appVersion[packageJsonPath] = \"unknown\";\r\n            try {\r\n                var packageJson = JSON.parse(fs.readFileSync(packageJsonPath, \"utf8\"));\r\n                if (packageJson && typeof packageJson.version === \"string\") {\r\n                    Context.appVersion[packageJsonPath] = packageJson.version;\r\n                }\r\n            }\r\n            catch (exception) {\r\n                Logging.info(\"unable to read app version: \", exception);\r\n            }\r\n        }\r\n        this.tags[this.keys.applicationVersion] = Context.appVersion[packageJsonPath];\r\n    };\r\n    Context.prototype._loadDeviceContext = function () {\r\n        this.tags[this.keys.deviceId] = \"\";\r\n        this.tags[this.keys.cloudRoleInstance] = os && os.hostname();\r\n        this.tags[this.keys.deviceOSVersion] = os && (os.type() + \" \" + os.release());\r\n        this.tags[this.keys.cloudRole] = Context.DefaultRoleName;\r\n        // not yet supported tags\r\n        this.tags[\"ai.device.osArchitecture\"] = os && os.arch();\r\n        this.tags[\"ai.device.osPlatform\"] = os && os.platform();\r\n    };\r\n    Context.prototype._loadInternalContext = function () {\r\n        // note: this should return the sdk package.json\r\n        var packageJsonPath = path.resolve(__dirname, \"../../package.json\");\r\n        if (!Context.sdkVersion) {\r\n            Context.sdkVersion = \"unknown\";\r\n            try {\r\n                var packageJson = JSON.parse(fs.readFileSync(packageJsonPath, \"utf8\"));\r\n                if (packageJson && typeof packageJson.version === \"string\") {\r\n                    Context.sdkVersion = packageJson.version;\r\n                }\r\n            }\r\n            catch (exception) {\r\n                Logging.info(\"unable to read app version: \", exception);\r\n            }\r\n        }\r\n        this.tags[this.keys.internalSdkVersion] = \"node:\" + Context.sdkVersion;\r\n    };\r\n    Context.DefaultRoleName = \"Web\";\r\n    Context.appVersion = {};\r\n    Context.sdkVersion = null;\r\n    return Context;\r\n}());\r\nmodule.exports = Context;\r\n//# sourceMappingURL=Context.js.map","\"use strict\";\r\nvar Util = require(\"./Util\");\r\nvar Logging = require(\"./Logging\");\r\nvar CorrelationIdManager = (function () {\r\n    function CorrelationIdManager() {\r\n    }\r\n    CorrelationIdManager.queryCorrelationId = function (config, callback) {\r\n        // GET request to `${this.endpointBase}/api/profiles/${this.instrumentationKey}/appId`\r\n        // If it 404s, the iKey is bad and we should give up\r\n        // If it fails otherwise, try again later\r\n        var appIdUrlString = config.profileQueryEndpoint + \"/api/profiles/\" + config.instrumentationKey + \"/appId\";\r\n        if (CorrelationIdManager.completedLookups.hasOwnProperty(appIdUrlString)) {\r\n            callback(CorrelationIdManager.completedLookups[appIdUrlString]);\r\n            return;\r\n        }\r\n        else if (CorrelationIdManager.pendingLookups[appIdUrlString]) {\r\n            CorrelationIdManager.pendingLookups[appIdUrlString].push(callback);\r\n            return;\r\n        }\r\n        CorrelationIdManager.pendingLookups[appIdUrlString] = [callback];\r\n        var fetchAppId = function () {\r\n            if (!CorrelationIdManager.pendingLookups[appIdUrlString]) {\r\n                // This query has been cancelled.\r\n                return;\r\n            }\r\n            var requestOptions = {\r\n                method: 'GET',\r\n                // Ensure this request is not captured by auto-collection.\r\n                // Note: we don't refer to the property in HttpDependencyParser because that would cause a cyclical dependency\r\n                disableAppInsightsAutoCollection: true\r\n            };\r\n            Logging.info(CorrelationIdManager.TAG, requestOptions);\r\n            var req = Util.makeRequest(config, appIdUrlString, requestOptions, function (res) {\r\n                if (res.statusCode === 200) {\r\n                    // Success; extract the appId from the body\r\n                    var appId_1 = \"\";\r\n                    res.setEncoding(\"utf-8\");\r\n                    res.on('data', function (data) {\r\n                        appId_1 += data;\r\n                    });\r\n                    res.on('end', function () {\r\n                        Logging.info(CorrelationIdManager.TAG, appId_1);\r\n                        var result = CorrelationIdManager.correlationIdPrefix + appId_1;\r\n                        CorrelationIdManager.completedLookups[appIdUrlString] = result;\r\n                        if (CorrelationIdManager.pendingLookups[appIdUrlString]) {\r\n                            CorrelationIdManager.pendingLookups[appIdUrlString].forEach(function (cb) { return cb(result); });\r\n                        }\r\n                        delete CorrelationIdManager.pendingLookups[appIdUrlString];\r\n                    });\r\n                }\r\n                else if (res.statusCode >= 400 && res.statusCode < 500) {\r\n                    // Not found, probably a bad key. Do not try again.\r\n                    CorrelationIdManager.completedLookups[appIdUrlString] = undefined;\r\n                    delete CorrelationIdManager.pendingLookups[appIdUrlString];\r\n                }\r\n                else {\r\n                    // Retry after timeout.\r\n                    setTimeout(fetchAppId, config.correlationIdRetryIntervalMs);\r\n                }\r\n            });\r\n            if (req) {\r\n                req.on('error', function (error) {\r\n                    // Unable to contact endpoint.\r\n                    // Do nothing for now.\r\n                    Logging.warn(CorrelationIdManager.TAG, error);\r\n                });\r\n                req.end();\r\n            }\r\n        };\r\n        setTimeout(fetchAppId, 0);\r\n    };\r\n    CorrelationIdManager.cancelCorrelationIdQuery = function (config, callback) {\r\n        var appIdUrlString = config.profileQueryEndpoint + \"/api/profiles/\" + config.instrumentationKey + \"/appId\";\r\n        var pendingLookups = CorrelationIdManager.pendingLookups[appIdUrlString];\r\n        if (pendingLookups) {\r\n            CorrelationIdManager.pendingLookups[appIdUrlString] = pendingLookups.filter(function (cb) { return cb != callback; });\r\n            if (CorrelationIdManager.pendingLookups[appIdUrlString].length == 0) {\r\n                delete CorrelationIdManager.pendingLookups[appIdUrlString];\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Generate a request Id according to https://github.com/lmolkova/correlation/blob/master/hierarchical_request_id.md\r\n     * @param parentId\r\n     */\r\n    CorrelationIdManager.generateRequestId = function (parentId) {\r\n        if (parentId) {\r\n            parentId = parentId[0] == '|' ? parentId : '|' + parentId;\r\n            if (parentId[parentId.length - 1] !== '.') {\r\n                parentId += '.';\r\n            }\r\n            var suffix = (CorrelationIdManager.currentRootId++).toString(16);\r\n            return CorrelationIdManager.appendSuffix(parentId, suffix, '_');\r\n        }\r\n        else {\r\n            return CorrelationIdManager.generateRootId();\r\n        }\r\n    };\r\n    /**\r\n     * Given a hierarchical identifier of the form |X.*\r\n     * return the root identifier X\r\n     * @param id\r\n     */\r\n    CorrelationIdManager.getRootId = function (id) {\r\n        var endIndex = id.indexOf('.');\r\n        if (endIndex < 0) {\r\n            endIndex = id.length;\r\n        }\r\n        var startIndex = id[0] === '|' ? 1 : 0;\r\n        return id.substring(startIndex, endIndex);\r\n    };\r\n    CorrelationIdManager.generateRootId = function () {\r\n        return '|' + Util.w3cTraceId() + '.';\r\n    };\r\n    CorrelationIdManager.appendSuffix = function (parentId, suffix, delimiter) {\r\n        if (parentId.length + suffix.length < CorrelationIdManager.requestIdMaxLength) {\r\n            return parentId + suffix + delimiter;\r\n        }\r\n        // Combined identifier would be too long, so we must truncate it.\r\n        // We need 9 characters of space: 8 for the overflow ID, 1 for the\r\n        // overflow delimiter '#'\r\n        var trimPosition = CorrelationIdManager.requestIdMaxLength - 9;\r\n        if (parentId.length > trimPosition) {\r\n            for (; trimPosition > 1; --trimPosition) {\r\n                var c = parentId[trimPosition - 1];\r\n                if (c === '.' || c === '_') {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (trimPosition <= 1) {\r\n            // parentId is not a valid ID\r\n            return CorrelationIdManager.generateRootId();\r\n        }\r\n        suffix = Util.randomu32().toString(16);\r\n        while (suffix.length < 8) {\r\n            suffix = '0' + suffix;\r\n        }\r\n        return parentId.substring(0, trimPosition) + suffix + '#';\r\n    };\r\n    CorrelationIdManager.TAG = \"CorrelationIdManager\";\r\n    CorrelationIdManager.correlationIdPrefix = \"cid-v1:\";\r\n    CorrelationIdManager.w3cEnabled = true;\r\n    // To avoid extraneous HTTP requests, we maintain a queue of callbacks waiting on a particular appId lookup,\r\n    // as well as a cache of completed lookups so future requests can be resolved immediately.\r\n    CorrelationIdManager.pendingLookups = {};\r\n    CorrelationIdManager.completedLookups = {};\r\n    CorrelationIdManager.requestIdMaxLength = 1024;\r\n    CorrelationIdManager.currentRootId = Util.randomu32();\r\n    return CorrelationIdManager;\r\n}());\r\nmodule.exports = CorrelationIdManager;\r\n//# sourceMappingURL=CorrelationIdManager.js.map","\"use strict\";\r\nvar Contracts = require(\"../Declarations/Contracts\");\r\nvar Util = require(\"./Util\");\r\nvar CorrelationContextManager_1 = require(\"../AutoCollection/CorrelationContextManager\");\r\n/**\r\n * Manages the logic of creating envelopes from Telemetry objects\r\n */\r\nvar EnvelopeFactory = (function () {\r\n    function EnvelopeFactory() {\r\n    }\r\n    /**\r\n     * Creates envelope ready to be sent by Channel\r\n     * @param telemetry Telemetry data\r\n     * @param telemetryType Type of telemetry\r\n     * @param commonProperties Bag of custom common properties to be added to the envelope\r\n     * @param context Client context\r\n     * @param config Client configuration\r\n     */\r\n    EnvelopeFactory.createEnvelope = function (telemetry, telemetryType, commonProperties, context, config) {\r\n        var data = null;\r\n        switch (telemetryType) {\r\n            case Contracts.TelemetryType.Trace:\r\n                data = EnvelopeFactory.createTraceData(telemetry);\r\n                break;\r\n            case Contracts.TelemetryType.Dependency:\r\n                data = EnvelopeFactory.createDependencyData(telemetry);\r\n                break;\r\n            case Contracts.TelemetryType.Event:\r\n                data = EnvelopeFactory.createEventData(telemetry);\r\n                break;\r\n            case Contracts.TelemetryType.Exception:\r\n                data = EnvelopeFactory.createExceptionData(telemetry);\r\n                break;\r\n            case Contracts.TelemetryType.Request:\r\n                data = EnvelopeFactory.createRequestData(telemetry);\r\n                break;\r\n            case Contracts.TelemetryType.Metric:\r\n                data = EnvelopeFactory.createMetricData(telemetry);\r\n                break;\r\n            case Contracts.TelemetryType.Availability:\r\n                data = EnvelopeFactory.createAvailabilityData(telemetry);\r\n                break;\r\n            case Contracts.TelemetryType.PageView:\r\n                data = EnvelopeFactory.createPageViewData(telemetry);\r\n                break;\r\n        }\r\n        if (commonProperties && Contracts.domainSupportsProperties(data.baseData)) {\r\n            if (data && data.baseData) {\r\n                // if no properties are specified just add the common ones\r\n                if (!data.baseData.properties) {\r\n                    data.baseData.properties = commonProperties;\r\n                }\r\n                else {\r\n                    // otherwise, check each of the common ones\r\n                    for (var name in commonProperties) {\r\n                        // only override if the property `name` has not been set on this item\r\n                        if (!data.baseData.properties[name]) {\r\n                            data.baseData.properties[name] = commonProperties[name];\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // sanitize properties\r\n            data.baseData.properties = Util.validateStringMap(data.baseData.properties);\r\n        }\r\n        var iKey = config ? config.instrumentationKey || \"\" : \"\";\r\n        var envelope = new Contracts.Envelope();\r\n        envelope.data = data;\r\n        envelope.iKey = iKey;\r\n        // this is kind of a hack, but the envelope name is always the same as the data name sans the chars \"data\"\r\n        envelope.name =\r\n            \"Microsoft.ApplicationInsights.\" +\r\n                iKey.replace(/-/g, \"\") +\r\n                \".\" +\r\n                data.baseType.substr(0, data.baseType.length - 4);\r\n        envelope.tags = this.getTags(context, telemetry.tagOverrides);\r\n        envelope.time = (new Date()).toISOString();\r\n        envelope.ver = 1;\r\n        envelope.sampleRate = config ? config.samplingPercentage : 100;\r\n        // Exclude metrics from sampling by default\r\n        if (telemetryType === Contracts.TelemetryType.Metric) {\r\n            envelope.sampleRate = 100;\r\n        }\r\n        return envelope;\r\n    };\r\n    EnvelopeFactory.createTraceData = function (telemetry) {\r\n        var trace = new Contracts.MessageData();\r\n        trace.message = telemetry.message;\r\n        trace.properties = telemetry.properties;\r\n        if (!isNaN(telemetry.severity)) {\r\n            trace.severityLevel = telemetry.severity;\r\n        }\r\n        else {\r\n            trace.severityLevel = Contracts.SeverityLevel.Information;\r\n        }\r\n        var data = new Contracts.Data();\r\n        data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Trace);\r\n        data.baseData = trace;\r\n        return data;\r\n    };\r\n    EnvelopeFactory.createDependencyData = function (telemetry) {\r\n        var remoteDependency = new Contracts.RemoteDependencyData();\r\n        if (typeof telemetry.name === \"string\") {\r\n            remoteDependency.name = telemetry.name.length > 1024 ? telemetry.name.slice(0, 1021) + '...' : telemetry.name;\r\n        }\r\n        remoteDependency.data = telemetry.data;\r\n        remoteDependency.target = telemetry.target;\r\n        remoteDependency.duration = Util.msToTimeSpan(telemetry.duration);\r\n        remoteDependency.success = telemetry.success;\r\n        remoteDependency.type = telemetry.dependencyTypeName;\r\n        remoteDependency.properties = telemetry.properties;\r\n        remoteDependency.resultCode = (telemetry.resultCode ? telemetry.resultCode + '' : '');\r\n        if (telemetry.id) {\r\n            remoteDependency.id = telemetry.id;\r\n        }\r\n        else {\r\n            remoteDependency.id = Util.w3cTraceId();\r\n        }\r\n        var data = new Contracts.Data();\r\n        data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Dependency);\r\n        data.baseData = remoteDependency;\r\n        return data;\r\n    };\r\n    EnvelopeFactory.createEventData = function (telemetry) {\r\n        var event = new Contracts.EventData();\r\n        event.name = telemetry.name;\r\n        event.properties = telemetry.properties;\r\n        event.measurements = telemetry.measurements;\r\n        var data = new Contracts.Data();\r\n        data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Event);\r\n        data.baseData = event;\r\n        return data;\r\n    };\r\n    EnvelopeFactory.createExceptionData = function (telemetry) {\r\n        var exception = new Contracts.ExceptionData();\r\n        exception.properties = telemetry.properties;\r\n        if (!isNaN(telemetry.severity)) {\r\n            exception.severityLevel = telemetry.severity;\r\n        }\r\n        else {\r\n            exception.severityLevel = Contracts.SeverityLevel.Error;\r\n        }\r\n        exception.measurements = telemetry.measurements;\r\n        exception.exceptions = [];\r\n        var stack = telemetry.exception[\"stack\"];\r\n        var exceptionDetails = new Contracts.ExceptionDetails();\r\n        exceptionDetails.message = telemetry.exception.message;\r\n        exceptionDetails.typeName = telemetry.exception.name;\r\n        exceptionDetails.parsedStack = this.parseStack(stack);\r\n        exceptionDetails.hasFullStack = Util.isArray(exceptionDetails.parsedStack) && exceptionDetails.parsedStack.length > 0;\r\n        exception.exceptions.push(exceptionDetails);\r\n        var data = new Contracts.Data();\r\n        data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Exception);\r\n        data.baseData = exception;\r\n        return data;\r\n    };\r\n    EnvelopeFactory.createRequestData = function (telemetry) {\r\n        var requestData = new Contracts.RequestData();\r\n        if (telemetry.id) {\r\n            requestData.id = telemetry.id;\r\n        }\r\n        else {\r\n            requestData.id = Util.w3cTraceId();\r\n        }\r\n        requestData.name = telemetry.name;\r\n        requestData.url = telemetry.url;\r\n        requestData.source = telemetry.source;\r\n        requestData.duration = Util.msToTimeSpan(telemetry.duration);\r\n        requestData.responseCode = (telemetry.resultCode ? telemetry.resultCode + '' : '');\r\n        requestData.success = telemetry.success;\r\n        requestData.properties = telemetry.properties;\r\n        var data = new Contracts.Data();\r\n        data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Request);\r\n        data.baseData = requestData;\r\n        return data;\r\n    };\r\n    EnvelopeFactory.createMetricData = function (telemetry) {\r\n        var metrics = new Contracts.MetricData(); // todo: enable client-batching of these\r\n        metrics.metrics = [];\r\n        var metric = new Contracts.DataPoint();\r\n        metric.count = !isNaN(telemetry.count) ? telemetry.count : 1;\r\n        metric.kind = Contracts.DataPointType.Aggregation;\r\n        metric.max = !isNaN(telemetry.max) ? telemetry.max : telemetry.value;\r\n        metric.min = !isNaN(telemetry.min) ? telemetry.min : telemetry.value;\r\n        metric.name = telemetry.name;\r\n        metric.stdDev = !isNaN(telemetry.stdDev) ? telemetry.stdDev : 0;\r\n        metric.value = telemetry.value;\r\n        metrics.metrics.push(metric);\r\n        metrics.properties = telemetry.properties;\r\n        var data = new Contracts.Data();\r\n        data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Metric);\r\n        data.baseData = metrics;\r\n        return data;\r\n    };\r\n    EnvelopeFactory.createAvailabilityData = function (telemetry) {\r\n        var availabilityData = new Contracts.AvailabilityData();\r\n        if (telemetry.id) {\r\n            availabilityData.id = telemetry.id;\r\n        }\r\n        else {\r\n            availabilityData.id = Util.w3cTraceId();\r\n        }\r\n        availabilityData.name = telemetry.name;\r\n        availabilityData.duration = Util.msToTimeSpan(telemetry.duration);\r\n        availabilityData.success = telemetry.success;\r\n        availabilityData.runLocation = telemetry.runLocation;\r\n        availabilityData.message = telemetry.message;\r\n        availabilityData.measurements = telemetry.measurements;\r\n        availabilityData.properties = telemetry.properties;\r\n        var data = new Contracts.Data();\r\n        data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Availability);\r\n        data.baseData = availabilityData;\r\n        return data;\r\n    };\r\n    EnvelopeFactory.createPageViewData = function (telemetry) {\r\n        var pageViewData = new Contracts.PageViewData();\r\n        pageViewData.name = telemetry.name;\r\n        pageViewData.duration = Util.msToTimeSpan(telemetry.duration);\r\n        pageViewData.url = telemetry.url;\r\n        pageViewData.measurements = telemetry.measurements;\r\n        pageViewData.properties = telemetry.properties;\r\n        var data = new Contracts.Data();\r\n        data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.PageView);\r\n        data.baseData = pageViewData;\r\n        return data;\r\n    };\r\n    EnvelopeFactory.getTags = function (context, tagOverrides) {\r\n        var correlationContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();\r\n        // Make a copy of context tags so we don't alter the actual object\r\n        // Also perform tag overriding\r\n        var newTags = {};\r\n        if (context && context.tags) {\r\n            for (var key in context.tags) {\r\n                newTags[key] = context.tags[key];\r\n            }\r\n        }\r\n        if (tagOverrides) {\r\n            for (var key in tagOverrides) {\r\n                newTags[key] = tagOverrides[key];\r\n            }\r\n        }\r\n        // Fill in internally-populated values if not already set\r\n        if (correlationContext) {\r\n            newTags[context.keys.operationId] = newTags[context.keys.operationId] || correlationContext.operation.id;\r\n            newTags[context.keys.operationName] = newTags[context.keys.operationName] || correlationContext.operation.name;\r\n            newTags[context.keys.operationParentId] = newTags[context.keys.operationParentId] || correlationContext.operation.parentId;\r\n        }\r\n        return newTags;\r\n    };\r\n    EnvelopeFactory.parseStack = function (stack) {\r\n        var parsedStack = undefined;\r\n        if (typeof stack === \"string\") {\r\n            var frames = stack.split(\"\\n\");\r\n            parsedStack = [];\r\n            var level = 0;\r\n            var totalSizeInBytes = 0;\r\n            for (var i = 0; i <= frames.length; i++) {\r\n                var frame = frames[i];\r\n                if (_StackFrame.regex.test(frame)) {\r\n                    var parsedFrame = new _StackFrame(frames[i], level++);\r\n                    totalSizeInBytes += parsedFrame.sizeInBytes;\r\n                    parsedStack.push(parsedFrame);\r\n                }\r\n            }\r\n            // DP Constraint - exception parsed stack must be < 32KB\r\n            // remove frames from the middle to meet the threshold\r\n            var exceptionParsedStackThreshold = 32 * 1024;\r\n            if (totalSizeInBytes > exceptionParsedStackThreshold) {\r\n                var left = 0;\r\n                var right = parsedStack.length - 1;\r\n                var size = 0;\r\n                var acceptedLeft = left;\r\n                var acceptedRight = right;\r\n                while (left < right) {\r\n                    // check size\r\n                    var lSize = parsedStack[left].sizeInBytes;\r\n                    var rSize = parsedStack[right].sizeInBytes;\r\n                    size += lSize + rSize;\r\n                    if (size > exceptionParsedStackThreshold) {\r\n                        // remove extra frames from the middle\r\n                        var howMany = acceptedRight - acceptedLeft + 1;\r\n                        parsedStack.splice(acceptedLeft, howMany);\r\n                        break;\r\n                    }\r\n                    // update pointers\r\n                    acceptedLeft = left;\r\n                    acceptedRight = right;\r\n                    left++;\r\n                    right--;\r\n                }\r\n            }\r\n        }\r\n        return parsedStack;\r\n    };\r\n    return EnvelopeFactory;\r\n}());\r\nvar _StackFrame = (function () {\r\n    function _StackFrame(frame, level) {\r\n        this.sizeInBytes = 0;\r\n        this.level = level;\r\n        this.method = \"<no_method>\";\r\n        this.assembly = Util.trim(frame);\r\n        var matches = frame.match(_StackFrame.regex);\r\n        if (matches && matches.length >= 5) {\r\n            this.method = Util.trim(matches[2]) || this.method;\r\n            this.fileName = Util.trim(matches[4]) || \"<no_filename>\";\r\n            this.line = parseInt(matches[5]) || 0;\r\n        }\r\n        this.sizeInBytes += this.method.length;\r\n        this.sizeInBytes += this.fileName.length;\r\n        this.sizeInBytes += this.assembly.length;\r\n        // todo: these might need to be removed depending on how the back-end settles on their size calculation\r\n        this.sizeInBytes += _StackFrame.baseSize;\r\n        this.sizeInBytes += this.level.toString().length;\r\n        this.sizeInBytes += this.line.toString().length;\r\n    }\r\n    // regex to match stack frames from ie/chrome/ff\r\n    // methodName=$2, fileName=$4, lineNo=$5, column=$6\r\n    _StackFrame.regex = /^(\\s+at)?(.*?)(\\@|\\s\\(|\\s)([^\\(\\n]+):(\\d+):(\\d+)(\\)?)$/;\r\n    _StackFrame.baseSize = 58; //'{\"method\":\"\",\"level\":,\"assembly\":\"\",\"fileName\":\"\",\"line\":}'.length\r\n    return _StackFrame;\r\n}());\r\nmodule.exports = EnvelopeFactory;\r\n//# sourceMappingURL=EnvelopeFactory.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n//# sourceMappingURL=Functions.js.map","\"use strict\";\r\nvar Logging = (function () {\r\n    function Logging() {\r\n    }\r\n    Logging.info = function (message) {\r\n        var optionalParams = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            optionalParams[_i - 1] = arguments[_i];\r\n        }\r\n        if (Logging.enableDebug) {\r\n            console.info(Logging.TAG + message, optionalParams);\r\n        }\r\n    };\r\n    Logging.warn = function (message) {\r\n        var optionalParams = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            optionalParams[_i - 1] = arguments[_i];\r\n        }\r\n        if (!Logging.disableWarnings) {\r\n            console.warn(Logging.TAG + message, optionalParams);\r\n        }\r\n    };\r\n    Logging.enableDebug = false;\r\n    Logging.disableWarnings = false;\r\n    Logging.disableErrors = false;\r\n    Logging.TAG = \"ApplicationInsights:\";\r\n    return Logging;\r\n}());\r\nmodule.exports = Logging;\r\n//# sourceMappingURL=Logging.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar TelemetryClient = require(\"./TelemetryClient\");\r\nvar ServerRequestTracking = require(\"../AutoCollection/HttpRequests\");\r\nvar ClientRequestTracking = require(\"../AutoCollection/HttpDependencies\");\r\nvar Logging = require(\"./Logging\");\r\n/**\r\n * Application Insights Telemetry Client for Node.JS. Provides the Application Insights TelemetryClient API\r\n * in addition to Node-specific helper functions.\r\n * Construct a new TelemetryClient to have an instance with a different configuration than the default client.\r\n * In most cases, `appInsights.defaultClient` should be used instead.\r\n */\r\nvar NodeClient = (function (_super) {\r\n    __extends(NodeClient, _super);\r\n    function NodeClient() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Log RequestTelemetry from HTTP request and response. This method will log immediately without waiting for request completion\r\n     * and it requires duration parameter to be specified on NodeHttpRequestTelemetry object.\r\n     * Use trackNodeHttpRequest function to log the telemetry after request completion\r\n     * @param telemetry Object encapsulating incoming request, response and duration information\r\n     */\r\n    NodeClient.prototype.trackNodeHttpRequestSync = function (telemetry) {\r\n        if (telemetry && telemetry.request && telemetry.response && telemetry.duration) {\r\n            ServerRequestTracking.trackRequestSync(this, telemetry);\r\n        }\r\n        else {\r\n            Logging.warn(\"trackNodeHttpRequestSync requires NodeHttpRequestTelemetry object with request, response and duration specified.\");\r\n        }\r\n    };\r\n    /**\r\n     * Log RequestTelemetry from HTTP request and response. This method will `follow` the request to completion.\r\n     * Use trackNodeHttpRequestSync function to log telemetry immediately without waiting for request completion\r\n     * @param telemetry Object encapsulating incoming request and response information\r\n     */\r\n    NodeClient.prototype.trackNodeHttpRequest = function (telemetry) {\r\n        if (telemetry.duration || telemetry.error) {\r\n            Logging.warn(\"trackNodeHttpRequest will ignore supplied duration and error parameters. These values are collected from the request and response objects.\");\r\n        }\r\n        if (telemetry && telemetry.request && telemetry.response) {\r\n            ServerRequestTracking.trackRequest(this, telemetry);\r\n        }\r\n        else {\r\n            Logging.warn(\"trackNodeHttpRequest requires NodeHttpRequestTelemetry object with request and response specified.\");\r\n        }\r\n    };\r\n    /**\r\n     * Log DependencyTelemetry from outgoing HTTP request. This method will instrument the outgoing request and append\r\n     * the specified headers and will log the telemetry when outgoing request is complete\r\n     * @param telemetry Object encapsulating outgoing request information\r\n     */\r\n    NodeClient.prototype.trackNodeHttpDependency = function (telemetry) {\r\n        if (telemetry && telemetry.request) {\r\n            ClientRequestTracking.trackRequest(this, telemetry);\r\n        }\r\n        else {\r\n            Logging.warn(\"trackNodeHttpDependency requires NodeHttpDependencyTelemetry object with request specified.\");\r\n        }\r\n    };\r\n    return NodeClient;\r\n}(TelemetryClient));\r\nmodule.exports = NodeClient;\r\n//# sourceMappingURL=NodeClient.js.map","\"use strict\";\r\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nvar os = require(\"os\");\r\nvar Contracts = require(\"../Declarations/Contracts\");\r\nvar Constants = require(\"../Declarations/Constants\");\r\nvar Util = require(\"./Util\");\r\nvar Logging = require(\"./Logging\");\r\nvar StreamId = Util.w3cTraceId(); // Create a guid\r\nvar QuickPulseEnvelopeFactory = (function () {\r\n    function QuickPulseEnvelopeFactory() {\r\n    }\r\n    QuickPulseEnvelopeFactory.createQuickPulseEnvelope = function (metrics, documents, config, context) {\r\n        var machineName = (os && typeof os.hostname === \"function\"\r\n            && os.hostname()) || \"Unknown\"; // Note: os.hostname() was added in node v0.3.3\r\n        var instance = (context.tags\r\n            && context.keys\r\n            && context.keys.cloudRoleInstance\r\n            && context.tags[context.keys.cloudRoleInstance]) || machineName;\r\n        var envelope = {\r\n            Documents: documents.length > 0 ? documents : null,\r\n            InstrumentationKey: config.instrumentationKey || \"\",\r\n            Metrics: metrics.length > 0 ? metrics : null,\r\n            InvariantVersion: 1,\r\n            Timestamp: \"/Date(\" + Date.now() + \")/\",\r\n            Version: context.tags[context.keys.internalSdkVersion],\r\n            StreamId: StreamId,\r\n            MachineName: machineName,\r\n            Instance: instance\r\n        };\r\n        return envelope;\r\n    };\r\n    QuickPulseEnvelopeFactory.createQuickPulseMetric = function (telemetry) {\r\n        var data;\r\n        data = {\r\n            Name: telemetry.name,\r\n            Value: telemetry.value,\r\n            Weight: telemetry.count || 1\r\n        };\r\n        return data;\r\n    };\r\n    QuickPulseEnvelopeFactory.telemetryEnvelopeToQuickPulseDocument = function (envelope) {\r\n        switch (envelope.data.baseType) {\r\n            case Contracts.TelemetryTypeString.Event:\r\n                return QuickPulseEnvelopeFactory.createQuickPulseEventDocument(envelope);\r\n            case Contracts.TelemetryTypeString.Exception:\r\n                return QuickPulseEnvelopeFactory.createQuickPulseExceptionDocument(envelope);\r\n            case Contracts.TelemetryTypeString.Trace:\r\n                return QuickPulseEnvelopeFactory.createQuickPulseTraceDocument(envelope);\r\n            case Contracts.TelemetryTypeString.Dependency:\r\n                return QuickPulseEnvelopeFactory.createQuickPulseDependencyDocument(envelope);\r\n            case Contracts.TelemetryTypeString.Request:\r\n                return QuickPulseEnvelopeFactory.createQuickPulseRequestDocument(envelope);\r\n        }\r\n        return null;\r\n    };\r\n    QuickPulseEnvelopeFactory.createQuickPulseEventDocument = function (envelope) {\r\n        var document = QuickPulseEnvelopeFactory.createQuickPulseDocument(envelope);\r\n        var name = envelope.data.baseData.name;\r\n        var eventDocument = __assign({}, document, { Name: name });\r\n        return eventDocument;\r\n    };\r\n    QuickPulseEnvelopeFactory.createQuickPulseTraceDocument = function (envelope) {\r\n        var document = QuickPulseEnvelopeFactory.createQuickPulseDocument(envelope);\r\n        var severityLevel = envelope.data.baseData.severityLevel || 0;\r\n        var traceDocument = __assign({}, document, { Message: envelope.data.baseData.message, SeverityLevel: Contracts.SeverityLevel[severityLevel] });\r\n        return traceDocument;\r\n    };\r\n    QuickPulseEnvelopeFactory.createQuickPulseExceptionDocument = function (envelope) {\r\n        var document = QuickPulseEnvelopeFactory.createQuickPulseDocument(envelope);\r\n        var exceptionDetails = envelope.data.baseData.exceptions;\r\n        var exception = '';\r\n        var exceptionMessage = '';\r\n        var exceptionType = '';\r\n        // Try to fill exception information from first error only\r\n        if (exceptionDetails && exceptionDetails.length > 0) {\r\n            // Try to grab the stack from parsedStack or stack\r\n            if (exceptionDetails[0].parsedStack && exceptionDetails[0].parsedStack.length > 0) {\r\n                exceptionDetails[0].parsedStack.forEach(function (err) {\r\n                    exception += err.assembly + \"\\n\";\r\n                });\r\n            }\r\n            else if (exceptionDetails[0].stack && exceptionDetails[0].stack.length > 0) {\r\n                exception = exceptionDetails[0].stack;\r\n            }\r\n            exceptionMessage = exceptionDetails[0].message;\r\n            exceptionType = exceptionDetails[0].typeName;\r\n        }\r\n        var exceptionDocument = __assign({}, document, { Exception: exception, ExceptionMessage: exceptionMessage, ExceptionType: exceptionType });\r\n        return exceptionDocument;\r\n    };\r\n    QuickPulseEnvelopeFactory.createQuickPulseRequestDocument = function (envelope) {\r\n        var document = QuickPulseEnvelopeFactory.createQuickPulseDocument(envelope);\r\n        var baseData = envelope.data.baseData;\r\n        var requestDocument = __assign({}, document, { Name: baseData.name, Success: baseData.success, Duration: baseData.duration, ResponseCode: baseData.responseCode, OperationName: baseData.name // TODO: is this correct?\r\n         });\r\n        return requestDocument;\r\n    };\r\n    QuickPulseEnvelopeFactory.createQuickPulseDependencyDocument = function (envelope) {\r\n        var document = QuickPulseEnvelopeFactory.createQuickPulseDocument(envelope);\r\n        var baseData = envelope.data.baseData;\r\n        var dependencyDocument = __assign({}, document, { Name: baseData.name, Target: baseData.target, Success: baseData.success, Duration: baseData.duration, ResultCode: baseData.resultCode, CommandName: baseData.data, OperationName: document.OperationId, DependencyTypeName: baseData.type });\r\n        return dependencyDocument;\r\n    };\r\n    QuickPulseEnvelopeFactory.createQuickPulseDocument = function (envelope) {\r\n        var documentType;\r\n        var __type;\r\n        var operationId, properties;\r\n        if (envelope.data.baseType) {\r\n            __type = Constants.TelemetryTypeStringToQuickPulseType[envelope.data.baseType];\r\n            documentType = Constants.TelemetryTypeStringToQuickPulseDocumentType[envelope.data.baseType];\r\n        }\r\n        else {\r\n            // Remark: This should never be hit because createQuickPulseDocument is only called within\r\n            // valid baseType values\r\n            Logging.warn(\"Document type invalid; not sending live metric document\", envelope.data.baseType);\r\n        }\r\n        operationId = envelope.tags[QuickPulseEnvelopeFactory.keys.operationId];\r\n        properties = QuickPulseEnvelopeFactory.aggregateProperties(envelope);\r\n        var document = {\r\n            DocumentType: documentType,\r\n            __type: __type,\r\n            OperationId: operationId,\r\n            Version: \"1.0\",\r\n            Properties: properties\r\n        };\r\n        return document;\r\n    };\r\n    QuickPulseEnvelopeFactory.aggregateProperties = function (envelope) {\r\n        var properties = [];\r\n        // Collect measurements\r\n        var meas = (envelope.data.baseData).measurements || {};\r\n        for (var key in meas) {\r\n            if (meas.hasOwnProperty(key)) {\r\n                var value = meas[key];\r\n                var property = { key: key, value: value };\r\n                properties.push(property);\r\n            }\r\n        }\r\n        // Collect properties\r\n        var props = (envelope.data.baseData).properties || {};\r\n        for (var key in props) {\r\n            if (props.hasOwnProperty(key)) {\r\n                var value = props[key];\r\n                var property = { key: key, value: value };\r\n                properties.push(property);\r\n            }\r\n        }\r\n        return properties;\r\n    };\r\n    QuickPulseEnvelopeFactory.keys = new Contracts.ContextTagKeys();\r\n    return QuickPulseEnvelopeFactory;\r\n}());\r\nmodule.exports = QuickPulseEnvelopeFactory;\r\n//# sourceMappingURL=QuickPulseEnvelopeFactory.js.map","\"use strict\";\r\nvar https = require(\"https\");\r\nvar AutoCollectHttpDependencies = require(\"../AutoCollection/HttpDependencies\");\r\nvar Logging = require(\"./Logging\");\r\nvar QuickPulseUtil = require(\"./QuickPulseUtil\");\r\nvar Util = require(\"./Util\");\r\nvar QuickPulseConfig = {\r\n    method: \"POST\",\r\n    time: \"x-ms-qps-transmission-time\",\r\n    subscribed: \"x-ms-qps-subscribed\"\r\n};\r\nvar QuickPulseSender = (function () {\r\n    function QuickPulseSender(config) {\r\n        this._config = config;\r\n        this._consecutiveErrors = 0;\r\n    }\r\n    QuickPulseSender.prototype.ping = function (envelope, done) {\r\n        this._submitData(envelope, done, \"ping\");\r\n    };\r\n    QuickPulseSender.prototype.post = function (envelope, done) {\r\n        // Important: When POSTing data, envelope must be an array\r\n        this._submitData([envelope], done, \"post\");\r\n    };\r\n    QuickPulseSender.prototype._submitData = function (envelope, done, postOrPing) {\r\n        var _this = this;\r\n        var payload = JSON.stringify(envelope);\r\n        var options = (_a = {},\r\n            _a[AutoCollectHttpDependencies.disableCollectionRequestOption] = true,\r\n            _a.host = this._config.quickPulseHost,\r\n            _a.method = QuickPulseConfig.method,\r\n            _a.path = \"/QuickPulseService.svc/\" + postOrPing + \"?ikey=\" + this._config.instrumentationKey,\r\n            _a.headers = (_b = {\r\n                    'Expect': '100-continue'\r\n                },\r\n                _b[QuickPulseConfig.time] = QuickPulseUtil.getTransmissionTime(),\r\n                _b['Content-Type'] = 'application\\/json',\r\n                _b['Content-Length'] = Buffer.byteLength(payload),\r\n                _b),\r\n            _a);\r\n        // HTTPS only\r\n        if (this._config.httpsAgent) {\r\n            options.agent = this._config.httpsAgent;\r\n        }\r\n        else {\r\n            options.agent = Util.tlsRestrictedAgent;\r\n        }\r\n        var req = https.request(options, function (res) {\r\n            var shouldPOSTData = res.headers[QuickPulseConfig.subscribed] === \"true\";\r\n            _this._consecutiveErrors = 0;\r\n            done(shouldPOSTData, res);\r\n        });\r\n        req.on(\"error\", function (error) {\r\n            // Unable to contact qps endpoint.\r\n            // Do nothing for now.\r\n            _this._consecutiveErrors++;\r\n            // LOG every error, but WARN instead when X number of consecutive errors occur\r\n            var notice = \"Transient error connecting to the Live Metrics endpoint. This packet will not appear in your Live Metrics Stream. Error:\";\r\n            if (_this._consecutiveErrors % QuickPulseSender.MAX_QPS_FAILURES_BEFORE_WARN === 0) {\r\n                notice = \"Live Metrics endpoint could not be reached \" + _this._consecutiveErrors + \" consecutive times. Most recent error:\";\r\n                Logging.warn(QuickPulseSender.TAG, notice, error);\r\n            }\r\n            else {\r\n                // Potentially transient error, do not change the ping/post state yet.\r\n                Logging.info(QuickPulseSender.TAG, notice, error);\r\n            }\r\n            done();\r\n        });\r\n        req.write(payload);\r\n        req.end();\r\n        var _a, _b;\r\n    };\r\n    QuickPulseSender.TAG = \"QuickPulseSender\";\r\n    QuickPulseSender.MAX_QPS_FAILURES_BEFORE_WARN = 25;\r\n    return QuickPulseSender;\r\n}());\r\nmodule.exports = QuickPulseSender;\r\n//# sourceMappingURL=QuickPulseSender.js.map","\"use strict\";\r\nvar Logging = require(\"./Logging\");\r\nvar Config = require(\"./Config\");\r\nvar QuickPulseEnvelopeFactory = require(\"./QuickPulseEnvelopeFactory\");\r\nvar QuickPulseSender = require(\"./QuickPulseSender\");\r\nvar Constants = require(\"../Declarations/Constants\");\r\nvar Context = require(\"./Context\");\r\n/** State Container for sending to the QuickPulse Service */\r\nvar QuickPulseStateManager = (function () {\r\n    function QuickPulseStateManager(iKey, context) {\r\n        this._isCollectingData = false;\r\n        this._lastSuccessTime = Date.now();\r\n        this._lastSendSucceeded = true;\r\n        this._metrics = {};\r\n        this._documents = [];\r\n        this._collectors = [];\r\n        this.config = new Config(iKey);\r\n        this.context = context || new Context();\r\n        this._sender = new QuickPulseSender(this.config);\r\n        this._isEnabled = false;\r\n    }\r\n    /**\r\n     *\r\n     * @param collector\r\n     */\r\n    QuickPulseStateManager.prototype.addCollector = function (collector) {\r\n        this._collectors.push(collector);\r\n    };\r\n    /**\r\n     * Override of TelemetryClient.trackMetric\r\n     */\r\n    QuickPulseStateManager.prototype.trackMetric = function (telemetry) {\r\n        this._addMetric(telemetry);\r\n    };\r\n    /**\r\n     * Add a document to the current buffer\r\n     * @param envelope\r\n     */\r\n    QuickPulseStateManager.prototype.addDocument = function (envelope) {\r\n        var document = QuickPulseEnvelopeFactory.telemetryEnvelopeToQuickPulseDocument(envelope);\r\n        if (document) {\r\n            this._documents.push(document);\r\n        }\r\n    };\r\n    /**\r\n     * Enable or disable communication with QuickPulseService\r\n     * @param isEnabled\r\n     */\r\n    QuickPulseStateManager.prototype.enable = function (isEnabled) {\r\n        if (isEnabled && !this._isEnabled) {\r\n            this._isEnabled = true;\r\n            this._goQuickPulse();\r\n        }\r\n        else if (!isEnabled && this._isEnabled) {\r\n            this._isEnabled = false;\r\n            clearTimeout(this._handle);\r\n            this._handle = undefined;\r\n        }\r\n    };\r\n    /**\r\n     * Enable or disable all collectors in this instance\r\n     * @param enable\r\n     */\r\n    QuickPulseStateManager.prototype.enableCollectors = function (enable) {\r\n        this._collectors.forEach(function (collector) {\r\n            collector.enable(enable);\r\n        });\r\n    };\r\n    /**\r\n     * Add the metric to this buffer. If same metric already exists in this buffer, add weight to it\r\n     * @param telemetry\r\n     */\r\n    QuickPulseStateManager.prototype._addMetric = function (telemetry) {\r\n        var value = telemetry.value;\r\n        var count = telemetry.count || 1;\r\n        var name = Constants.PerformanceToQuickPulseCounter[telemetry.name];\r\n        if (name) {\r\n            if (this._metrics[name]) {\r\n                this._metrics[name].Value = (this._metrics[name].Value * this._metrics[name].Weight + value * count) / (this._metrics[name].Weight + count);\r\n                this._metrics[name].Weight += count;\r\n            }\r\n            else {\r\n                this._metrics[name] = QuickPulseEnvelopeFactory.createQuickPulseMetric(telemetry);\r\n                this._metrics[name].Name = name;\r\n                this._metrics[name].Weight = 1;\r\n            }\r\n        }\r\n    };\r\n    QuickPulseStateManager.prototype._resetQuickPulseBuffer = function () {\r\n        delete this._metrics;\r\n        this._metrics = {};\r\n        this._documents.length = 0;\r\n    };\r\n    QuickPulseStateManager.prototype._goQuickPulse = function () {\r\n        var _this = this;\r\n        // Create envelope from Documents and Metrics\r\n        var metrics = Object.keys(this._metrics).map(function (k) { return _this._metrics[k]; });\r\n        var envelope = QuickPulseEnvelopeFactory.createQuickPulseEnvelope(metrics, this._documents.slice(), this.config, this.context);\r\n        // Clear this document, metric buffer\r\n        this._resetQuickPulseBuffer();\r\n        // Send it to QuickPulseService, if collecting\r\n        if (this._isCollectingData) {\r\n            this._post(envelope);\r\n        }\r\n        else {\r\n            this._ping(envelope);\r\n        }\r\n        var currentTimeout = this._isCollectingData ? QuickPulseStateManager.POST_INTERVAL : QuickPulseStateManager.PING_INTERVAL;\r\n        if (this._isCollectingData && Date.now() - this._lastSuccessTime >= QuickPulseStateManager.MAX_POST_WAIT_TIME && !this._lastSendSucceeded) {\r\n            // Haven't posted successfully in 20 seconds, so wait 60 seconds and ping\r\n            this._isCollectingData = false;\r\n            currentTimeout = QuickPulseStateManager.FALLBACK_INTERVAL;\r\n        }\r\n        else if (!this._isCollectingData && Date.now() - this._lastSuccessTime >= QuickPulseStateManager.MAX_PING_WAIT_TIME && !this._lastSendSucceeded) {\r\n            // Haven't pinged successfully in 60 seconds, so wait another 60 seconds\r\n            currentTimeout = QuickPulseStateManager.FALLBACK_INTERVAL;\r\n        }\r\n        this._lastSendSucceeded = null;\r\n        this._handle = setTimeout(this._goQuickPulse.bind(this), currentTimeout);\r\n        this._handle.unref(); // Don't block apps from terminating\r\n    };\r\n    QuickPulseStateManager.prototype._ping = function (envelope) {\r\n        this._sender.ping(envelope, this._quickPulseDone.bind(this));\r\n    };\r\n    QuickPulseStateManager.prototype._post = function (envelope) {\r\n        this._sender.post(envelope, this._quickPulseDone.bind(this));\r\n    };\r\n    /**\r\n     * Change the current QPS send state. (shouldPOST == undefined) --> error, but do not change the state yet.\r\n     */\r\n    QuickPulseStateManager.prototype._quickPulseDone = function (shouldPOST, res) {\r\n        if (shouldPOST != undefined) {\r\n            if (this._isCollectingData !== shouldPOST) {\r\n                Logging.info(\"Live Metrics sending data\", shouldPOST);\r\n                this.enableCollectors(shouldPOST);\r\n            }\r\n            this._isCollectingData = shouldPOST;\r\n            if (res && res.statusCode < 300 && res.statusCode >= 200) {\r\n                this._lastSuccessTime = Date.now();\r\n                this._lastSendSucceeded = true;\r\n            }\r\n            else {\r\n                this._lastSendSucceeded = false;\r\n            }\r\n        }\r\n        else {\r\n            // Received an error, keep the state as is\r\n            this._lastSendSucceeded = false;\r\n        }\r\n    };\r\n    QuickPulseStateManager.MAX_POST_WAIT_TIME = 20000;\r\n    QuickPulseStateManager.MAX_PING_WAIT_TIME = 60000;\r\n    QuickPulseStateManager.FALLBACK_INTERVAL = 60000;\r\n    QuickPulseStateManager.PING_INTERVAL = 5000;\r\n    QuickPulseStateManager.POST_INTERVAL = 1000;\r\n    return QuickPulseStateManager;\r\n}());\r\nmodule.exports = QuickPulseStateManager;\r\n//# sourceMappingURL=QuickPulseStateManager.js.map","\"use strict\";\r\n/**\r\n * @description UTC time the request was made. Expressed as the number of 100-nanosecond intervals that have elapsed since 12:00:00 midnight on January 1, 0001. This is used for clock skew calculations, so the value can never be stale (cached).\r\n *\r\n * @example\r\n * 8/5/2020 10:15:00 PM UTC => 637322625000000000\r\n * 8/5/2020 10:15:01 PM UTC => 637322625010000000\r\n *\r\n * @returns {number}\r\n */\r\nvar getTransmissionTime = function () {\r\n    return (Date.now() + 62135596800000) * 10000;\r\n};\r\nmodule.exports = { getTransmissionTime: getTransmissionTime };\r\n//# sourceMappingURL=QuickPulseUtil.js.map","\"use strict\";\r\nmodule.exports = {\r\n    /**\r\n     * Request-Context header\r\n     */\r\n    requestContextHeader: \"request-context\",\r\n    /**\r\n     * Source instrumentation header that is added by an application while making http\r\n     * requests and retrieved by the other application when processing incoming requests.\r\n     */\r\n    requestContextSourceKey: \"appId\",\r\n    /**\r\n     * Target instrumentation header that is added to the response and retrieved by the\r\n     * calling application when processing incoming responses.\r\n     */\r\n    requestContextTargetKey: \"appId\",\r\n    /**\r\n     * Request-Id header\r\n     */\r\n    requestIdHeader: \"request-id\",\r\n    /**\r\n     * Legacy Header containing the id of the immediate caller\r\n     */\r\n    parentIdHeader: \"x-ms-request-id\",\r\n    /**\r\n     * Legacy Header containing the correlation id that kept the same for every telemetry item\r\n     * across transactions\r\n     */\r\n    rootIdHeader: \"x-ms-request-root-id\",\r\n    /**\r\n     * Correlation-Context header\r\n     *\r\n     * Not currently actively used, but the contents should be passed from incoming to outgoing requests\r\n     */\r\n    correlationContextHeader: \"correlation-context\",\r\n    /**\r\n     * W3C distributed tracing protocol header\r\n     */\r\n    traceparentHeader: \"traceparent\",\r\n    /**\r\n     * W3C distributed tracing protocol state header\r\n     */\r\n    traceStateHeader: \"tracestate\"\r\n};\r\n//# sourceMappingURL=RequestResponseHeaders.js.map","\"use strict\";\r\nvar fs = require(\"fs\");\r\nvar os = require(\"os\");\r\nvar path = require(\"path\");\r\nvar zlib = require(\"zlib\");\r\nvar child_process = require(\"child_process\");\r\nvar Logging = require(\"./Logging\");\r\nvar AutoCollectHttpDependencies = require(\"../AutoCollection/HttpDependencies\");\r\nvar Util = require(\"./Util\");\r\nvar Sender = (function () {\r\n    function Sender(config, onSuccess, onError) {\r\n        this._config = config;\r\n        this._onSuccess = onSuccess;\r\n        this._onError = onError;\r\n        this._enableDiskRetryMode = false;\r\n        this._resendInterval = Sender.WAIT_BETWEEN_RESEND;\r\n        this._maxBytesOnDisk = Sender.MAX_BYTES_ON_DISK;\r\n        this._numConsecutiveFailures = 0;\r\n        this._resendTimer = null;\r\n        if (!Sender.OS_PROVIDES_FILE_PROTECTION) {\r\n            // Node's chmod levels do not appropriately restrict file access on Windows\r\n            // Use the built-in command line tool ICACLS on Windows to properly restrict\r\n            // access to the temporary directory used for disk retry mode.\r\n            if (Sender.USE_ICACLS) {\r\n                // This should be async - but it's currently safer to have this synchronous\r\n                // This guarantees we can immediately fail setDiskRetryMode if we need to\r\n                try {\r\n                    Sender.OS_PROVIDES_FILE_PROTECTION = fs.existsSync(Sender.ICACLS_PATH);\r\n                }\r\n                catch (e) { }\r\n                if (!Sender.OS_PROVIDES_FILE_PROTECTION) {\r\n                    Logging.warn(Sender.TAG, \"Could not find ICACLS in expected location! This is necessary to use disk retry mode on Windows.\");\r\n                }\r\n            }\r\n            else {\r\n                // chmod works everywhere else\r\n                Sender.OS_PROVIDES_FILE_PROTECTION = true;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n    * Enable or disable offline mode\r\n    */\r\n    Sender.prototype.setDiskRetryMode = function (value, resendInterval, maxBytesOnDisk) {\r\n        this._enableDiskRetryMode = Sender.OS_PROVIDES_FILE_PROTECTION && value;\r\n        if (typeof resendInterval === 'number' && resendInterval >= 0) {\r\n            this._resendInterval = Math.floor(resendInterval);\r\n        }\r\n        if (typeof maxBytesOnDisk === 'number' && maxBytesOnDisk >= 0) {\r\n            this._maxBytesOnDisk = Math.floor(maxBytesOnDisk);\r\n        }\r\n        if (value && !Sender.OS_PROVIDES_FILE_PROTECTION) {\r\n            this._enableDiskRetryMode = false;\r\n            Logging.warn(Sender.TAG, \"Ignoring request to enable disk retry mode. Sufficient file protection capabilities were not detected.\");\r\n        }\r\n    };\r\n    Sender.prototype.send = function (payload, callback) {\r\n        var _this = this;\r\n        var endpointUrl = this._config.endpointUrl;\r\n        // todo: investigate specifying an agent here: https://nodejs.org/api/http.html#http_class_http_agent\r\n        var options = {\r\n            method: \"POST\",\r\n            withCredentials: false,\r\n            headers: {\r\n                \"Content-Type\": \"application/x-json-stream\"\r\n            }\r\n        };\r\n        zlib.gzip(payload, function (err, buffer) {\r\n            var dataToSend = buffer;\r\n            if (err) {\r\n                Logging.warn(err);\r\n                dataToSend = payload; // something went wrong so send without gzip\r\n                options.headers[\"Content-Length\"] = payload.length.toString();\r\n            }\r\n            else {\r\n                options.headers[\"Content-Encoding\"] = \"gzip\";\r\n                options.headers[\"Content-Length\"] = buffer.length;\r\n            }\r\n            Logging.info(Sender.TAG, options);\r\n            // Ensure this request is not captured by auto-collection.\r\n            options[AutoCollectHttpDependencies.disableCollectionRequestOption] = true;\r\n            var requestCallback = function (res) {\r\n                res.setEncoding(\"utf-8\");\r\n                //returns empty if the data is accepted\r\n                var responseString = \"\";\r\n                res.on(\"data\", function (data) {\r\n                    responseString += data;\r\n                });\r\n                res.on(\"end\", function () {\r\n                    _this._numConsecutiveFailures = 0;\r\n                    Logging.info(Sender.TAG, responseString);\r\n                    if (typeof _this._onSuccess === \"function\") {\r\n                        _this._onSuccess(responseString);\r\n                    }\r\n                    if (typeof callback === \"function\") {\r\n                        callback(responseString);\r\n                    }\r\n                    if (_this._enableDiskRetryMode) {\r\n                        // try to send any cached events if the user is back online\r\n                        if (res.statusCode === 200) {\r\n                            if (!_this._resendTimer) {\r\n                                _this._resendTimer = setTimeout(function () {\r\n                                    _this._resendTimer = null;\r\n                                    _this._sendFirstFileOnDisk();\r\n                                }, _this._resendInterval);\r\n                                _this._resendTimer.unref();\r\n                            }\r\n                            // store to disk in case of burst throttling\r\n                        }\r\n                        else if (res.statusCode === 408 ||\r\n                            res.statusCode === 429 ||\r\n                            res.statusCode === 439 ||\r\n                            res.statusCode === 500 ||\r\n                            res.statusCode === 503) {\r\n                            // TODO: Do not support partial success (206) until _sendFirstFileOnDisk checks payload age\r\n                            _this._storeToDisk(payload);\r\n                        }\r\n                    }\r\n                });\r\n            };\r\n            var req = Util.makeRequest(_this._config, endpointUrl, options, requestCallback);\r\n            req.on(\"error\", function (error) {\r\n                // todo: handle error codes better (group to recoverable/non-recoverable and persist)\r\n                _this._numConsecutiveFailures++;\r\n                // Only use warn level if retries are disabled or we've had some number of consecutive failures sending data\r\n                // This is because warn level is printed in the console by default, and we don't want to be noisy for transient and self-recovering errors\r\n                // Continue informing on each failure if verbose logging is being used\r\n                if (!_this._enableDiskRetryMode || _this._numConsecutiveFailures > 0 && _this._numConsecutiveFailures % Sender.MAX_CONNECTION_FAILURES_BEFORE_WARN === 0) {\r\n                    var notice = \"Ingestion endpoint could not be reached. This batch of telemetry items has been lost. Use Disk Retry Caching to enable resending of failed telemetry. Error:\";\r\n                    if (_this._enableDiskRetryMode) {\r\n                        notice = \"Ingestion endpoint could not be reached \" + _this._numConsecutiveFailures + \" consecutive times. There may be resulting telemetry loss. Most recent error:\";\r\n                    }\r\n                    Logging.warn(Sender.TAG, notice, error);\r\n                }\r\n                else {\r\n                    var notice = \"Transient failure to reach ingestion endpoint. This batch of telemetry items will be retried. Error:\";\r\n                    Logging.info(Sender.TAG, notice, error);\r\n                }\r\n                _this._onErrorHelper(error);\r\n                if (typeof callback === \"function\") {\r\n                    var errorMessage = \"error sending telemetry\";\r\n                    if (error && (typeof error.toString === \"function\")) {\r\n                        errorMessage = error.toString();\r\n                    }\r\n                    callback(errorMessage);\r\n                }\r\n                if (_this._enableDiskRetryMode) {\r\n                    _this._storeToDisk(payload);\r\n                }\r\n            });\r\n            req.write(dataToSend);\r\n            req.end();\r\n        });\r\n    };\r\n    Sender.prototype.saveOnCrash = function (payload) {\r\n        if (this._enableDiskRetryMode) {\r\n            this._storeToDiskSync(payload);\r\n        }\r\n    };\r\n    Sender.prototype._runICACLS = function (args, callback) {\r\n        var aclProc = child_process.spawn(Sender.ICACLS_PATH, args, { windowsHide: true });\r\n        aclProc.on(\"error\", function (e) { return callback(e); });\r\n        aclProc.on(\"close\", function (code, signal) {\r\n            return callback(code === 0 ? null : new Error(\"Setting ACL restrictions did not succeed (ICACLS returned code \" + code + \")\"));\r\n        });\r\n    };\r\n    Sender.prototype._runICACLSSync = function (args) {\r\n        // Some very old versions of Node (< 0.11) don't have this\r\n        if (child_process.spawnSync) {\r\n            var aclProc = child_process.spawnSync(Sender.ICACLS_PATH, args, { windowsHide: true });\r\n            if (aclProc.error) {\r\n                throw aclProc.error;\r\n            }\r\n            else if (aclProc.status !== 0) {\r\n                throw new Error(\"Setting ACL restrictions did not succeed (ICACLS returned code \" + aclProc.status + \")\");\r\n            }\r\n        }\r\n        else {\r\n            throw new Error(\"Could not synchronously call ICACLS under current version of Node.js\");\r\n        }\r\n    };\r\n    Sender.prototype._getACLIdentity = function (callback) {\r\n        if (Sender.ACL_IDENTITY) {\r\n            return callback(null, Sender.ACL_IDENTITY);\r\n        }\r\n        var psProc = child_process.spawn(Sender.POWERSHELL_PATH, [\"-Command\", \"[System.Security.Principal.WindowsIdentity]::GetCurrent().Name\"], {\r\n            windowsHide: true,\r\n            stdio: ['ignore', 'pipe', 'pipe'] // Needed to prevent hanging on Win 7\r\n        });\r\n        var data = \"\";\r\n        psProc.stdout.on(\"data\", function (d) { return data += d; });\r\n        psProc.on(\"error\", function (e) { return callback(e, null); });\r\n        psProc.on(\"close\", function (code, signal) {\r\n            Sender.ACL_IDENTITY = data && data.trim();\r\n            return callback(code === 0 ? null : new Error(\"Getting ACL identity did not succeed (PS returned code \" + code + \")\"), Sender.ACL_IDENTITY);\r\n        });\r\n    };\r\n    Sender.prototype._getACLIdentitySync = function () {\r\n        if (Sender.ACL_IDENTITY) {\r\n            return Sender.ACL_IDENTITY;\r\n        }\r\n        // Some very old versions of Node (< 0.11) don't have this\r\n        if (child_process.spawnSync) {\r\n            var psProc = child_process.spawnSync(Sender.POWERSHELL_PATH, [\"-Command\", \"[System.Security.Principal.WindowsIdentity]::GetCurrent().Name\"], {\r\n                windowsHide: true,\r\n                stdio: ['ignore', 'pipe', 'pipe'] // Needed to prevent hanging on Win 7\r\n            });\r\n            if (psProc.error) {\r\n                throw psProc.error;\r\n            }\r\n            else if (psProc.status !== 0) {\r\n                throw new Error(\"Getting ACL identity did not succeed (PS returned code \" + psProc.status + \")\");\r\n            }\r\n            Sender.ACL_IDENTITY = psProc.stdout && psProc.stdout.toString().trim();\r\n            return Sender.ACL_IDENTITY;\r\n        }\r\n        else {\r\n            throw new Error(\"Could not synchronously get ACL identity under current version of Node.js\");\r\n        }\r\n    };\r\n    Sender.prototype._getACLArguments = function (directory, identity) {\r\n        return [directory,\r\n            \"/grant\", \"*S-1-5-32-544:(OI)(CI)F\",\r\n            \"/grant\", identity + \":(OI)(CI)F\",\r\n            \"/inheritance:r\"]; // Remove all inherited permissions\r\n    };\r\n    Sender.prototype._applyACLRules = function (directory, callback) {\r\n        var _this = this;\r\n        if (!Sender.USE_ICACLS) {\r\n            return callback(null);\r\n        }\r\n        // For performance, only run ACL rules if we haven't already during this session\r\n        if (Sender.ACLED_DIRECTORIES[directory] === undefined) {\r\n            // Avoid multiple calls race condition by setting ACLED_DIRECTORIES to false for this directory immediately\r\n            // If batches are being failed faster than the processes spawned below return, some data won't be stored to disk\r\n            // This is better than the alternative of potentially infinitely spawned processes\r\n            Sender.ACLED_DIRECTORIES[directory] = false;\r\n            // Restrict this directory to only current user and administrator access\r\n            this._getACLIdentity(function (err, identity) {\r\n                if (err) {\r\n                    Sender.ACLED_DIRECTORIES[directory] = false; // false is used to cache failed (vs undefined which is \"not yet tried\")\r\n                    return callback(err);\r\n                }\r\n                else {\r\n                    _this._runICACLS(_this._getACLArguments(directory, identity), function (err) {\r\n                        Sender.ACLED_DIRECTORIES[directory] = !err;\r\n                        return callback(err);\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            return callback(Sender.ACLED_DIRECTORIES[directory] ? null :\r\n                new Error(\"Setting ACL restrictions did not succeed (cached result)\"));\r\n        }\r\n    };\r\n    Sender.prototype._applyACLRulesSync = function (directory) {\r\n        if (Sender.USE_ICACLS) {\r\n            // For performance, only run ACL rules if we haven't already during this session\r\n            if (Sender.ACLED_DIRECTORIES[directory] === undefined) {\r\n                this._runICACLSSync(this._getACLArguments(directory, this._getACLIdentitySync()));\r\n                Sender.ACLED_DIRECTORIES[directory] = true; // If we get here, it succeeded. _runIACLSSync will throw on failures\r\n                return;\r\n            }\r\n            else if (!Sender.ACLED_DIRECTORIES[directory]) {\r\n                throw new Error(\"Setting ACL restrictions did not succeed (cached result)\");\r\n            }\r\n        }\r\n    };\r\n    Sender.prototype._confirmDirExists = function (directory, callback) {\r\n        var _this = this;\r\n        fs.lstat(directory, function (err, stats) {\r\n            if (err && err.code === 'ENOENT') {\r\n                fs.mkdir(directory, function (err) {\r\n                    if (err && err.code !== 'EEXIST') {\r\n                        callback(err);\r\n                    }\r\n                    else {\r\n                        _this._applyACLRules(directory, callback);\r\n                    }\r\n                });\r\n            }\r\n            else if (!err && stats.isDirectory()) {\r\n                _this._applyACLRules(directory, callback);\r\n            }\r\n            else {\r\n                callback(err || new Error(\"Path existed but was not a directory\"));\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Computes the size (in bytes) of all files in a directory at the root level. Asynchronously.\r\n     */\r\n    Sender.prototype._getShallowDirectorySize = function (directory, callback) {\r\n        // Get the directory listing\r\n        fs.readdir(directory, function (err, files) {\r\n            if (err) {\r\n                return callback(err, -1);\r\n            }\r\n            var error = null;\r\n            var totalSize = 0;\r\n            var count = 0;\r\n            if (files.length === 0) {\r\n                callback(null, 0);\r\n                return;\r\n            }\r\n            // Query all file sizes\r\n            for (var i = 0; i < files.length; i++) {\r\n                fs.stat(path.join(directory, files[i]), function (err, fileStats) {\r\n                    count++;\r\n                    if (err) {\r\n                        error = err;\r\n                    }\r\n                    else {\r\n                        if (fileStats.isFile()) {\r\n                            totalSize += fileStats.size;\r\n                        }\r\n                    }\r\n                    if (count === files.length) {\r\n                        // Did we get an error?\r\n                        if (error) {\r\n                            callback(error, -1);\r\n                        }\r\n                        else {\r\n                            callback(error, totalSize);\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Computes the size (in bytes) of all files in a directory at the root level. Synchronously.\r\n     */\r\n    Sender.prototype._getShallowDirectorySizeSync = function (directory) {\r\n        var files = fs.readdirSync(directory);\r\n        var totalSize = 0;\r\n        for (var i = 0; i < files.length; i++) {\r\n            totalSize += fs.statSync(path.join(directory, files[i])).size;\r\n        }\r\n        return totalSize;\r\n    };\r\n    /**\r\n     * Stores the payload as a json file on disk in the temp directory\r\n     */\r\n    Sender.prototype._storeToDisk = function (payload) {\r\n        var _this = this;\r\n        // tmpdir is /tmp for *nix and USERDIR/AppData/Local/Temp for Windows\r\n        var directory = path.join(os.tmpdir(), Sender.TEMPDIR_PREFIX + this._config.instrumentationKey);\r\n        // This will create the dir if it does not exist\r\n        // Default permissions on *nix are directory listing from other users but no file creations\r\n        Logging.info(Sender.TAG, \"Checking existence of data storage directory: \" + directory);\r\n        this._confirmDirExists(directory, function (error) {\r\n            if (error) {\r\n                Logging.warn(Sender.TAG, \"Error while checking/creating directory: \" + (error && error.message));\r\n                _this._onErrorHelper(error);\r\n                return;\r\n            }\r\n            _this._getShallowDirectorySize(directory, function (err, size) {\r\n                if (err || size < 0) {\r\n                    Logging.warn(Sender.TAG, \"Error while checking directory size: \" + (err && err.message));\r\n                    _this._onErrorHelper(err);\r\n                    return;\r\n                }\r\n                else if (size > _this._maxBytesOnDisk) {\r\n                    Logging.warn(Sender.TAG, \"Not saving data due to max size limit being met. Directory size in bytes is: \" + size);\r\n                    return;\r\n                }\r\n                //create file - file name for now is the timestamp, a better approach would be a UUID but that\r\n                //would require an external dependency\r\n                var fileName = new Date().getTime() + \".ai.json\";\r\n                var fileFullPath = path.join(directory, fileName);\r\n                // Mode 600 is w/r for creator and no read access for others (only applies on *nix)\r\n                // For Windows, ACL rules are applied to the entire directory (see logic in _confirmDirExists and _applyACLRules)\r\n                Logging.info(Sender.TAG, \"saving data to disk at: \" + fileFullPath);\r\n                fs.writeFile(fileFullPath, payload, { mode: 384 }, function (error) { return _this._onErrorHelper(error); });\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Stores the payload as a json file on disk using sync file operations\r\n     * this is used when storing data before crashes\r\n     */\r\n    Sender.prototype._storeToDiskSync = function (payload) {\r\n        // tmpdir is /tmp for *nix and USERDIR/AppData/Local/Temp for Windows\r\n        var directory = path.join(os.tmpdir(), Sender.TEMPDIR_PREFIX + this._config.instrumentationKey);\r\n        try {\r\n            Logging.info(Sender.TAG, \"Checking existence of data storage directory: \" + directory);\r\n            if (!fs.existsSync(directory)) {\r\n                fs.mkdirSync(directory);\r\n            }\r\n            // Make sure permissions are valid\r\n            this._applyACLRulesSync(directory);\r\n            var dirSize = this._getShallowDirectorySizeSync(directory);\r\n            if (dirSize > this._maxBytesOnDisk) {\r\n                Logging.info(Sender.TAG, \"Not saving data due to max size limit being met. Directory size in bytes is: \" + dirSize);\r\n                return;\r\n            }\r\n            //create file - file name for now is the timestamp, a better approach would be a UUID but that\r\n            //would require an external dependency\r\n            var fileName = new Date().getTime() + \".ai.json\";\r\n            var fileFullPath = path.join(directory, fileName);\r\n            // Mode 600 is w/r for creator and no access for anyone else (only applies on *nix)\r\n            Logging.info(Sender.TAG, \"saving data before crash to disk at: \" + fileFullPath);\r\n            fs.writeFileSync(fileFullPath, payload, { mode: 384 });\r\n        }\r\n        catch (error) {\r\n            Logging.warn(Sender.TAG, \"Error while saving data to disk: \" + (error && error.message));\r\n            this._onErrorHelper(error);\r\n        }\r\n    };\r\n    /**\r\n     * Check for temp telemetry files\r\n     * reads the first file if exist, deletes it and tries to send its load\r\n     */\r\n    Sender.prototype._sendFirstFileOnDisk = function () {\r\n        var _this = this;\r\n        var tempDir = path.join(os.tmpdir(), Sender.TEMPDIR_PREFIX + this._config.instrumentationKey);\r\n        fs.exists(tempDir, function (exists) {\r\n            if (exists) {\r\n                fs.readdir(tempDir, function (error, files) {\r\n                    if (!error) {\r\n                        files = files.filter(function (f) { return path.basename(f).indexOf(\".ai.json\") > -1; });\r\n                        if (files.length > 0) {\r\n                            var firstFile = files[0];\r\n                            var filePath = path.join(tempDir, firstFile);\r\n                            fs.readFile(filePath, function (error, payload) {\r\n                                if (!error) {\r\n                                    // delete the file first to prevent double sending\r\n                                    fs.unlink(filePath, function (error) {\r\n                                        if (!error) {\r\n                                            _this.send(payload);\r\n                                        }\r\n                                        else {\r\n                                            _this._onErrorHelper(error);\r\n                                        }\r\n                                    });\r\n                                }\r\n                                else {\r\n                                    _this._onErrorHelper(error);\r\n                                }\r\n                            });\r\n                        }\r\n                    }\r\n                    else {\r\n                        _this._onErrorHelper(error);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n    };\r\n    Sender.prototype._onErrorHelper = function (error) {\r\n        if (typeof this._onError === \"function\") {\r\n            this._onError(error);\r\n        }\r\n    };\r\n    Sender.TAG = \"Sender\";\r\n    Sender.ICACLS_PATH = process.env.systemdrive + \"/windows/system32/icacls.exe\";\r\n    Sender.POWERSHELL_PATH = process.env.systemdrive + \"/windows/system32/windowspowershell/v1.0/powershell.exe\";\r\n    Sender.ACLED_DIRECTORIES = {};\r\n    Sender.ACL_IDENTITY = null;\r\n    // the amount of time the SDK will wait between resending cached data, this buffer is to avoid any throttling from the service side\r\n    Sender.WAIT_BETWEEN_RESEND = 60 * 1000;\r\n    Sender.MAX_BYTES_ON_DISK = 50 * 1000 * 1000;\r\n    Sender.MAX_CONNECTION_FAILURES_BEFORE_WARN = 5;\r\n    Sender.TEMPDIR_PREFIX = \"appInsights-node\";\r\n    Sender.OS_PROVIDES_FILE_PROTECTION = false;\r\n    Sender.USE_ICACLS = os.type() === \"Windows_NT\";\r\n    return Sender;\r\n}());\r\nmodule.exports = Sender;\r\n//# sourceMappingURL=Sender.js.map","\"use strict\";\r\nvar url = require(\"url\");\r\nvar Config = require(\"./Config\");\r\nvar Context = require(\"./Context\");\r\nvar Contracts = require(\"../Declarations/Contracts\");\r\nvar Channel = require(\"./Channel\");\r\nvar TelemetryProcessors = require(\"../TelemetryProcessors\");\r\nvar CorrelationContextManager_1 = require(\"../AutoCollection/CorrelationContextManager\");\r\nvar Sender = require(\"./Sender\");\r\nvar Util = require(\"./Util\");\r\nvar Logging = require(\"./Logging\");\r\nvar EnvelopeFactory = require(\"./EnvelopeFactory\");\r\n/**\r\n * Application Insights telemetry client provides interface to track telemetry items, register telemetry initializers and\r\n * and manually trigger immediate sending (flushing)\r\n */\r\nvar TelemetryClient = (function () {\r\n    /**\r\n     * Constructs a new client of the client\r\n     * @param setupString the Connection String or Instrumentation Key to use (read from environment variable if not specified)\r\n     */\r\n    function TelemetryClient(setupString) {\r\n        this._telemetryProcessors = [];\r\n        var config = new Config(setupString);\r\n        this.config = config;\r\n        this.context = new Context();\r\n        this.commonProperties = {};\r\n        var sender = new Sender(this.config);\r\n        this.channel = new Channel(function () { return config.disableAppInsights; }, function () { return config.maxBatchSize; }, function () { return config.maxBatchIntervalMs; }, sender);\r\n    }\r\n    /**\r\n     * Log information about availability of an application\r\n     * @param telemetry      Object encapsulating tracking options\r\n     */\r\n    TelemetryClient.prototype.trackAvailability = function (telemetry) {\r\n        this.track(telemetry, Contracts.TelemetryType.Availability);\r\n    };\r\n    /**\r\n     * Log a page view\r\n     * @param telemetry      Object encapsulating tracking options\r\n     */\r\n    TelemetryClient.prototype.trackPageView = function (telemetry) {\r\n        this.track(telemetry, Contracts.TelemetryType.PageView);\r\n    };\r\n    /**\r\n     * Log a trace message\r\n     * @param telemetry      Object encapsulating tracking options\r\n     */\r\n    TelemetryClient.prototype.trackTrace = function (telemetry) {\r\n        this.track(telemetry, Contracts.TelemetryType.Trace);\r\n    };\r\n    /**\r\n     * Log a numeric value that is not associated with a specific event. Typically used to send regular reports of performance indicators.\r\n     * To send a single measurement, use just the first two parameters. If you take measurements very frequently, you can reduce the\r\n     * telemetry bandwidth by aggregating multiple measurements and sending the resulting average at intervals.\r\n     * @param telemetry      Object encapsulating tracking options\r\n     */\r\n    TelemetryClient.prototype.trackMetric = function (telemetry) {\r\n        this.track(telemetry, Contracts.TelemetryType.Metric);\r\n    };\r\n    /**\r\n     * Log an exception\r\n     * @param telemetry      Object encapsulating tracking options\r\n     */\r\n    TelemetryClient.prototype.trackException = function (telemetry) {\r\n        if (telemetry && telemetry.exception && !Util.isError(telemetry.exception)) {\r\n            telemetry.exception = new Error(telemetry.exception.toString());\r\n        }\r\n        this.track(telemetry, Contracts.TelemetryType.Exception);\r\n    };\r\n    /**\r\n     * Log a user action or other occurrence.\r\n     * @param telemetry      Object encapsulating tracking options\r\n     */\r\n    TelemetryClient.prototype.trackEvent = function (telemetry) {\r\n        this.track(telemetry, Contracts.TelemetryType.Event);\r\n    };\r\n    /**\r\n     * Log a request. Note that the default client will attempt to collect HTTP requests automatically so only use this for requests\r\n     * that aren't automatically captured or if you've disabled automatic request collection.\r\n     *\r\n     * @param telemetry      Object encapsulating tracking options\r\n     */\r\n    TelemetryClient.prototype.trackRequest = function (telemetry) {\r\n        this.track(telemetry, Contracts.TelemetryType.Request);\r\n    };\r\n    /**\r\n     * Log a dependency. Note that the default client will attempt to collect dependencies automatically so only use this for dependencies\r\n     * that aren't automatically captured or if you've disabled automatic dependency collection.\r\n     *\r\n     * @param telemetry      Object encapsulating tracking option\r\n     * */\r\n    TelemetryClient.prototype.trackDependency = function (telemetry) {\r\n        if (telemetry && !telemetry.target && telemetry.data) {\r\n            // url.parse().host returns null for non-urls,\r\n            // making this essentially a no-op in those cases\r\n            // If this logic is moved, update jsdoc in DependencyTelemetry.target\r\n            telemetry.target = url.parse(telemetry.data).host;\r\n        }\r\n        this.track(telemetry, Contracts.TelemetryType.Dependency);\r\n    };\r\n    /**\r\n     * Immediately send all queued telemetry.\r\n     * @param options Flush options, including indicator whether app is crashing and callback\r\n     */\r\n    TelemetryClient.prototype.flush = function (options) {\r\n        this.channel.triggerSend(options ? !!options.isAppCrashing : false, options ? options.callback : undefined);\r\n    };\r\n    /**\r\n     * Generic track method for all telemetry types\r\n     * @param data the telemetry to send\r\n     * @param telemetryType specify the type of telemetry you are tracking from the list of Contracts.DataTypes\r\n     */\r\n    TelemetryClient.prototype.track = function (telemetry, telemetryType) {\r\n        if (telemetry && Contracts.telemetryTypeToBaseType(telemetryType)) {\r\n            var envelope = EnvelopeFactory.createEnvelope(telemetry, telemetryType, this.commonProperties, this.context, this.config);\r\n            // Set time on the envelope if it was set on the telemetry item\r\n            if (telemetry.time) {\r\n                envelope.time = telemetry.time.toISOString();\r\n            }\r\n            var accepted = this.runTelemetryProcessors(envelope, telemetry.contextObjects);\r\n            // Ideally we would have a central place for \"internal\" telemetry processors and users can configure which ones are in use.\r\n            // This will do for now. Otherwise clearTelemetryProcessors() would be problematic.\r\n            accepted = accepted && TelemetryProcessors.samplingTelemetryProcessor(envelope, { correlationContext: CorrelationContextManager_1.CorrelationContextManager.getCurrentContext() });\r\n            if (accepted) {\r\n                TelemetryProcessors.performanceMetricsTelemetryProcessor(envelope, this.quickPulseClient);\r\n                this.channel.send(envelope);\r\n            }\r\n        }\r\n        else {\r\n            Logging.warn(\"track() requires telemetry object and telemetryType to be specified.\");\r\n        }\r\n    };\r\n    /**\r\n     * Adds telemetry processor to the collection. Telemetry processors will be called one by one\r\n     * before telemetry item is pushed for sending and in the order they were added.\r\n     *\r\n     * @param telemetryProcessor function, takes Envelope, and optional context object and returns boolean\r\n     */\r\n    TelemetryClient.prototype.addTelemetryProcessor = function (telemetryProcessor) {\r\n        this._telemetryProcessors.push(telemetryProcessor);\r\n    };\r\n    /*\r\n     * Removes all telemetry processors\r\n     */\r\n    TelemetryClient.prototype.clearTelemetryProcessors = function () {\r\n        this._telemetryProcessors = [];\r\n    };\r\n    TelemetryClient.prototype.runTelemetryProcessors = function (envelope, contextObjects) {\r\n        var accepted = true;\r\n        var telemetryProcessorsCount = this._telemetryProcessors.length;\r\n        if (telemetryProcessorsCount === 0) {\r\n            return accepted;\r\n        }\r\n        contextObjects = contextObjects || {};\r\n        contextObjects['correlationContext'] = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();\r\n        for (var i = 0; i < telemetryProcessorsCount; ++i) {\r\n            try {\r\n                var processor = this._telemetryProcessors[i];\r\n                if (processor) {\r\n                    if (processor.apply(null, [envelope, contextObjects]) === false) {\r\n                        accepted = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            catch (error) {\r\n                accepted = true;\r\n                Logging.warn(\"One of telemetry processors failed, telemetry item will be sent.\", error, envelope);\r\n            }\r\n        }\r\n        return accepted;\r\n    };\r\n    return TelemetryClient;\r\n}());\r\nmodule.exports = TelemetryClient;\r\n//# sourceMappingURL=TelemetryClient.js.map","\"use strict\";\r\nvar Util = require(\"./Util\");\r\nvar CorrelationIdManager = require(\"./CorrelationIdManager\");\r\n/**\r\n * Helper class to manage parsing and validation of traceparent header. Also handles hierarchical\r\n * back-compatibility headers generated from traceparent. W3C traceparent spec is documented at\r\n * https://www.w3.org/TR/trace-context/#traceparent-field\r\n */\r\nvar Traceparent = (function () {\r\n    function Traceparent(traceparent, parentId) {\r\n        this.traceFlag = Traceparent.DEFAULT_TRACE_FLAG;\r\n        this.version = Traceparent.DEFAULT_VERSION;\r\n        if (traceparent && typeof traceparent === \"string\") {\r\n            // If incoming request contains traceparent: parse it, set operation, parent and telemetry id accordingly. traceparent should be injected into outgoing requests. request-id should be injected in back-compat format |traceId.spanId. so that older SDKs could understand it.\r\n            if (traceparent.split(\",\").length > 1) {\r\n                this.traceId = Util.w3cTraceId();\r\n                this.spanId = Util.w3cTraceId().substr(0, 16);\r\n            }\r\n            else {\r\n                var traceparentArr = traceparent.trim().split(\"-\");\r\n                var len = traceparentArr.length;\r\n                if (len >= 4) {\r\n                    this.version = traceparentArr[0];\r\n                    this.traceId = traceparentArr[1];\r\n                    this.spanId = traceparentArr[2];\r\n                    this.traceFlag = traceparentArr[3];\r\n                }\r\n                else {\r\n                    this.traceId = Util.w3cTraceId();\r\n                    this.spanId = Util.w3cTraceId().substr(0, 16);\r\n                }\r\n                // Version validation\r\n                if (!this.version.match(/^[0-9a-f]{2}$/g)) {\r\n                    this.version = Traceparent.DEFAULT_VERSION;\r\n                    this.traceId = Util.w3cTraceId();\r\n                }\r\n                if (this.version === \"00\" && len !== 4) {\r\n                    this.traceId = Util.w3cTraceId();\r\n                    this.spanId = Util.w3cTraceId().substr(0, 16);\r\n                }\r\n                if (this.version === \"ff\") {\r\n                    this.version = Traceparent.DEFAULT_VERSION;\r\n                    this.traceId = Util.w3cTraceId();\r\n                    this.spanId = Util.w3cTraceId().substr(0, 16);\r\n                }\r\n                if (!this.version.match(/^0[0-9a-f]$/g)) {\r\n                    this.version = Traceparent.DEFAULT_VERSION;\r\n                }\r\n                // TraceFlag validation\r\n                if (!this.traceFlag.match(/^[0-9a-f]{2}$/g)) {\r\n                    this.traceFlag = Traceparent.DEFAULT_TRACE_FLAG;\r\n                    this.traceId = Util.w3cTraceId();\r\n                }\r\n                // Validate TraceId, regenerate new traceid if invalid\r\n                if (!Traceparent.isValidTraceId(this.traceId)) {\r\n                    this.traceId = Util.w3cTraceId();\r\n                }\r\n                // Validate Span Id, discard entire traceparent if invalid\r\n                if (!Traceparent.isValidSpanId(this.spanId)) {\r\n                    this.spanId = Util.w3cTraceId().substr(0, 16);\r\n                    this.traceId = Util.w3cTraceId();\r\n                }\r\n                // Save backCompat parentId\r\n                this.parentId = this.getBackCompatRequestId();\r\n            }\r\n        }\r\n        else if (parentId) {\r\n            // If incoming request contains only request-id, new traceid and spanid should be started, request-id value should be used as a parent. Root part of request-id should be stored in custom dimension on the request telemetry if root part is different from traceid. On the outgoing request side, request-id should be emitted in the |traceId.spanId. format.\r\n            this.parentId = parentId.slice(); // copy\r\n            var operationId = CorrelationIdManager.getRootId(parentId);\r\n            if (!Traceparent.isValidTraceId(operationId)) {\r\n                this.legacyRootId = operationId;\r\n                operationId = Util.w3cTraceId();\r\n            }\r\n            if (parentId.indexOf(\"|\") !== -1) {\r\n                parentId = parentId.substring(1 + parentId.substring(0, parentId.length - 1).lastIndexOf(\".\"), parentId.length - 1);\r\n            }\r\n            this.traceId = operationId;\r\n            this.spanId = parentId;\r\n        }\r\n        else {\r\n            // Fallback default constructor\r\n            // if request does not contain any correlation headers, see case p2\r\n            this.traceId = Util.w3cTraceId();\r\n            this.spanId = Util.w3cTraceId().substr(0, 16);\r\n        }\r\n    }\r\n    Traceparent.isValidTraceId = function (id) {\r\n        return id.match(/^[0-9a-f]{32}$/) && id !== \"00000000000000000000000000000000\";\r\n    };\r\n    Traceparent.isValidSpanId = function (id) {\r\n        return id.match(/^[0-9a-f]{16}$/) && id !== \"0000000000000000\";\r\n    };\r\n    Traceparent.prototype.getBackCompatRequestId = function () {\r\n        return \"|\" + this.traceId + \".\" + this.spanId + \".\";\r\n    };\r\n    Traceparent.prototype.toString = function () {\r\n        return this.version + \"-\" + this.traceId + \"-\" + this.spanId + \"-\" + this.traceFlag;\r\n    };\r\n    Traceparent.prototype.updateSpanId = function () {\r\n        this.spanId = Util.w3cTraceId().substr(0, 16);\r\n    };\r\n    Traceparent.DEFAULT_TRACE_FLAG = \"01\";\r\n    Traceparent.DEFAULT_VERSION = \"00\";\r\n    return Traceparent;\r\n}());\r\nmodule.exports = Traceparent;\r\n//# sourceMappingURL=Traceparent.js.map","\"use strict\";\r\n/**\r\n * Helper class to manage parsing and strict-validation of tracestate header. W3C tracestate spec\r\n * is documented at https://www.w3.org/TR/trace-context/#header-value\r\n * @class Tracestate\r\n */\r\nvar Tracestate = (function () {\r\n    // if true, performs strict tracestate header checking, else just passes it along\r\n    function Tracestate(id) {\r\n        this.fieldmap = [];\r\n        if (!id) {\r\n            return;\r\n        }\r\n        this.fieldmap = this.parseHeader(id);\r\n    }\r\n    Tracestate.prototype.toString = function () {\r\n        var fieldarr = this.fieldmap;\r\n        if (!fieldarr || fieldarr.length == 0) {\r\n            return null;\r\n        }\r\n        return fieldarr.join(\", \");\r\n    };\r\n    Tracestate.validateKeyChars = function (key) {\r\n        var keyParts = key.split(\"@\");\r\n        if (keyParts.length == 2) {\r\n            // Parse for tenant@vendor format\r\n            var tenant = keyParts[0].trim();\r\n            var vendor = keyParts[1].trim();\r\n            var tenantValid = Boolean(tenant.match(/^[\\ ]?[a-z0-9\\*\\-\\_/]{1,241}$/));\r\n            var vendorValid = Boolean(vendor.match(/^[\\ ]?[a-z0-9\\*\\-\\_/]{1,14}$/));\r\n            return tenantValid && vendorValid;\r\n        }\r\n        else if (keyParts.length == 1) {\r\n            // Parse for standard key format\r\n            return Boolean(key.match(/^[\\ ]?[a-z0-9\\*\\-\\_/]{1,256}$/));\r\n        }\r\n        return false;\r\n    };\r\n    Tracestate.prototype.parseHeader = function (id) {\r\n        var res = [];\r\n        var keydeduper = {};\r\n        var parts = id.split(\",\");\r\n        if (parts.length > 32)\r\n            return null;\r\n        for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {\r\n            var rawPart = parts_1[_i];\r\n            var part = rawPart.trim(); // trim out whitespace\r\n            if (part.length === 0) {\r\n                continue; // Discard empty pairs, but keep the rest of this tracestate\r\n            }\r\n            var pair = part.split(\"=\");\r\n            // pair should contain exactly one \"=\"\r\n            if (pair.length !== 2) {\r\n                return null; // invalid pair: discard entire tracestate\r\n            }\r\n            // Validate length and charset of this key\r\n            if (!Tracestate.validateKeyChars(pair[0])) {\r\n                return null;\r\n            }\r\n            // Assert uniqueness of this key\r\n            if (keydeduper[pair[0]]) {\r\n                return null; // duplicate key: discard entire tracestate\r\n            }\r\n            else {\r\n                keydeduper[pair[0]] = true;\r\n            }\r\n            // All checks passed -- add this part\r\n            res.push(part);\r\n        }\r\n        return res;\r\n    };\r\n    Tracestate.strict = true;\r\n    return Tracestate;\r\n}());\r\nmodule.exports = Tracestate;\r\n//# sourceMappingURL=Tracestate.js.map","\"use strict\";\r\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nvar http = require(\"http\");\r\nvar https = require(\"https\");\r\nvar url = require(\"url\");\r\nvar constants = require(\"constants\");\r\nvar Logging = require(\"./Logging\");\r\nvar RequestResponseHeaders = require(\"./RequestResponseHeaders\");\r\nvar Util = (function () {\r\n    function Util() {\r\n    }\r\n    /**\r\n     * helper method to access userId and sessionId cookie\r\n     */\r\n    Util.getCookie = function (name, cookie) {\r\n        var value = \"\";\r\n        if (name && name.length && typeof cookie === \"string\") {\r\n            var cookieName = name + \"=\";\r\n            var cookies = cookie.split(\";\");\r\n            for (var i = 0; i < cookies.length; i++) {\r\n                var cookie = cookies[i];\r\n                cookie = Util.trim(cookie);\r\n                if (cookie && cookie.indexOf(cookieName) === 0) {\r\n                    value = cookie.substring(cookieName.length, cookies[i].length);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return value;\r\n    };\r\n    /**\r\n     * helper method to trim strings (IE8 does not implement String.prototype.trim)\r\n     */\r\n    Util.trim = function (str) {\r\n        if (typeof str === \"string\") {\r\n            return str.replace(/^\\s+|\\s+$/g, \"\");\r\n        }\r\n        else {\r\n            return \"\";\r\n        }\r\n    };\r\n    /**\r\n     * Convert an array of int32 to Base64 (no '==' at the end).\r\n     * MSB first.\r\n     */\r\n    Util.int32ArrayToBase64 = function (array) {\r\n        var toChar = function (v, i) {\r\n            return String.fromCharCode((v >> i) & 0xFF);\r\n        };\r\n        var int32AsString = function (v) {\r\n            return toChar(v, 24) + toChar(v, 16) + toChar(v, 8) + toChar(v, 0);\r\n        };\r\n        var x = array.map(int32AsString).join(\"\");\r\n        var b = Buffer.from ? Buffer.from(x, \"binary\") : new Buffer(x, \"binary\");\r\n        var s = b.toString(\"base64\");\r\n        return s.substr(0, s.indexOf(\"=\"));\r\n    };\r\n    /**\r\n     * generate a random 32bit number (-0x80000000..0x7FFFFFFF).\r\n     */\r\n    Util.random32 = function () {\r\n        return (0x100000000 * Math.random()) | 0;\r\n    };\r\n    /**\r\n     * generate a random 32bit number (0x00000000..0xFFFFFFFF).\r\n     */\r\n    Util.randomu32 = function () {\r\n        return Util.random32() + 0x80000000;\r\n    };\r\n    /**\r\n     * generate W3C-compatible trace id\r\n     * https://github.com/w3c/distributed-tracing/blob/master/trace_context/HTTP_HEADER_FORMAT.md#trace-id\r\n     */\r\n    Util.w3cTraceId = function () {\r\n        var hexValues = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\"];\r\n        // rfc4122 version 4 UUID without dashes and with lowercase letters\r\n        var oct = \"\", tmp;\r\n        for (var a = 0; a < 4; a++) {\r\n            tmp = Util.random32();\r\n            oct +=\r\n                hexValues[tmp & 0xF] +\r\n                    hexValues[tmp >> 4 & 0xF] +\r\n                    hexValues[tmp >> 8 & 0xF] +\r\n                    hexValues[tmp >> 12 & 0xF] +\r\n                    hexValues[tmp >> 16 & 0xF] +\r\n                    hexValues[tmp >> 20 & 0xF] +\r\n                    hexValues[tmp >> 24 & 0xF] +\r\n                    hexValues[tmp >> 28 & 0xF];\r\n        }\r\n        // \"Set the two most significant bits (bits 6 and 7) of the clock_seq_hi_and_reserved to zero and one, respectively\"\r\n        var clockSequenceHi = hexValues[8 + (Math.random() * 4) | 0];\r\n        return oct.substr(0, 8) + oct.substr(9, 4) + \"4\" + oct.substr(13, 3) + clockSequenceHi + oct.substr(16, 3) + oct.substr(19, 12);\r\n    };\r\n    Util.w3cSpanId = function () {\r\n        return Util.w3cTraceId().substring(16);\r\n    };\r\n    Util.isValidW3CId = function (id) {\r\n        return id.length === 32 && id !== \"00000000000000000000000000000000\";\r\n    };\r\n    /**\r\n     * Check if an object is of type Array\r\n     */\r\n    Util.isArray = function (obj) {\r\n        return Object.prototype.toString.call(obj) === \"[object Array]\";\r\n    };\r\n    /**\r\n     * Check if an object is of type Error\r\n     */\r\n    Util.isError = function (obj) {\r\n        return obj instanceof Error;\r\n    };\r\n    Util.isPrimitive = function (input) {\r\n        var propType = typeof input;\r\n        return propType === \"string\" || propType === \"number\" || propType === \"boolean\";\r\n    };\r\n    /**\r\n     * Check if an object is of type Date\r\n     */\r\n    Util.isDate = function (obj) {\r\n        return Object.prototype.toString.call(obj) === \"[object Date]\";\r\n    };\r\n    /**\r\n     * Convert ms to c# time span format\r\n     */\r\n    Util.msToTimeSpan = function (totalms) {\r\n        if (isNaN(totalms) || totalms < 0) {\r\n            totalms = 0;\r\n        }\r\n        var sec = ((totalms / 1000) % 60).toFixed(7).replace(/0{0,4}$/, \"\");\r\n        var min = \"\" + Math.floor(totalms / (1000 * 60)) % 60;\r\n        var hour = \"\" + Math.floor(totalms / (1000 * 60 * 60)) % 24;\r\n        var days = Math.floor(totalms / (1000 * 60 * 60 * 24));\r\n        sec = sec.indexOf(\".\") < 2 ? \"0\" + sec : sec;\r\n        min = min.length < 2 ? \"0\" + min : min;\r\n        hour = hour.length < 2 ? \"0\" + hour : hour;\r\n        var daysText = days > 0 ? days + \".\" : \"\";\r\n        return daysText + hour + \":\" + min + \":\" + sec;\r\n    };\r\n    /**\r\n     * Using JSON.stringify, by default Errors do not serialize to something useful:\r\n     * Simplify a generic Node Error into a simpler map for customDimensions\r\n     * Custom errors can still implement toJSON to override this functionality\r\n     */\r\n    Util.extractError = function (err) {\r\n        // Error is often subclassed so may have code OR id properties:\r\n        // https://nodejs.org/api/errors.html#errors_error_code\r\n        var looseError = err;\r\n        return {\r\n            message: err.message,\r\n            code: looseError.code || looseError.id || \"\",\r\n        };\r\n    };\r\n    /**\r\n     * Manually call toJSON if available to pre-convert the value.\r\n     * If a primitive is returned, then the consumer of this function can skip JSON.stringify.\r\n     * This avoids double escaping of quotes for Date objects, for example.\r\n     */\r\n    Util.extractObject = function (origProperty) {\r\n        if (origProperty instanceof Error) {\r\n            return Util.extractError(origProperty);\r\n        }\r\n        if (typeof origProperty.toJSON === \"function\") {\r\n            return origProperty.toJSON();\r\n        }\r\n        return origProperty;\r\n    };\r\n    /**\r\n     * Validate that an object is of type { [key: string]: string }\r\n     */\r\n    Util.validateStringMap = function (obj) {\r\n        if (typeof obj !== \"object\") {\r\n            Logging.info(\"Invalid properties dropped from payload\");\r\n            return;\r\n        }\r\n        var map = {};\r\n        for (var field in obj) {\r\n            var property = '';\r\n            var origProperty = obj[field];\r\n            var propType = typeof origProperty;\r\n            if (Util.isPrimitive(origProperty)) {\r\n                property = origProperty.toString();\r\n            }\r\n            else if (origProperty === null || propType === \"undefined\") {\r\n                property = \"\";\r\n            }\r\n            else if (propType === \"function\") {\r\n                Logging.info(\"key: \" + field + \" was function; will not serialize\");\r\n                continue;\r\n            }\r\n            else {\r\n                var stringTarget = Util.isArray(origProperty) ? origProperty : Util.extractObject(origProperty);\r\n                try {\r\n                    if (Util.isPrimitive(stringTarget)) {\r\n                        property = stringTarget;\r\n                    }\r\n                    else {\r\n                        property = JSON.stringify(stringTarget);\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    property = origProperty.constructor.name.toString() + \" (Error: \" + e.message + \")\";\r\n                    Logging.info(\"key: \" + field + \", could not be serialized\");\r\n                }\r\n            }\r\n            map[field] = property.substring(0, Util.MAX_PROPERTY_LENGTH);\r\n        }\r\n        return map;\r\n    };\r\n    /**\r\n     * Checks if a request url is not on a excluded domain list\r\n     * and if it is safe to add correlation headers\r\n     */\r\n    Util.canIncludeCorrelationHeader = function (client, requestUrl) {\r\n        var excludedDomains = client && client.config && client.config.correlationHeaderExcludedDomains;\r\n        if (!excludedDomains || excludedDomains.length == 0 || !requestUrl) {\r\n            return true;\r\n        }\r\n        for (var i = 0; i < excludedDomains.length; i++) {\r\n            var regex = new RegExp(excludedDomains[i].replace(/\\./g, \"\\.\").replace(/\\*/g, \".*\"));\r\n            if (regex.test(url.parse(requestUrl).hostname)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    Util.getCorrelationContextTarget = function (response, key) {\r\n        var contextHeaders = response.headers && response.headers[RequestResponseHeaders.requestContextHeader];\r\n        if (contextHeaders) {\r\n            var keyValues = contextHeaders.split(\",\");\r\n            for (var i = 0; i < keyValues.length; ++i) {\r\n                var keyValue = keyValues[i].split(\"=\");\r\n                if (keyValue.length == 2 && keyValue[0] == key) {\r\n                    return keyValue[1];\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Generate request\r\n     *\r\n     * Proxify the request creation to handle proxy http\r\n     *\r\n     * @param {string} requestUrl url endpoint\r\n     * @param {Object} requestOptions Request option\r\n     * @param {Function} requestCallback callback on request\r\n     * @returns {http.ClientRequest} request object\r\n     */\r\n    Util.makeRequest = function (config, requestUrl, requestOptions, requestCallback) {\r\n        if (requestUrl && requestUrl.indexOf('//') === 0) {\r\n            requestUrl = 'https:' + requestUrl;\r\n        }\r\n        var requestUrlParsed = url.parse(requestUrl);\r\n        var options = __assign({}, requestOptions, { host: requestUrlParsed.hostname, port: requestUrlParsed.port, path: requestUrlParsed.pathname });\r\n        var proxyUrl = undefined;\r\n        if (requestUrlParsed.protocol === 'https:') {\r\n            proxyUrl = config.proxyHttpsUrl || undefined;\r\n        }\r\n        if (requestUrlParsed.protocol === 'http:') {\r\n            proxyUrl = config.proxyHttpUrl || undefined;\r\n        }\r\n        if (proxyUrl) {\r\n            if (proxyUrl.indexOf('//') === 0) {\r\n                proxyUrl = 'http:' + proxyUrl;\r\n            }\r\n            var proxyUrlParsed = url.parse(proxyUrl);\r\n            // https is not supported at the moment\r\n            if (proxyUrlParsed.protocol === 'https:') {\r\n                Logging.info(\"Proxies that use HTTPS are not supported\");\r\n                proxyUrl = undefined;\r\n            }\r\n            else {\r\n                options = __assign({}, options, { host: proxyUrlParsed.hostname, port: proxyUrlParsed.port || \"80\", path: requestUrl, headers: __assign({}, options.headers, { Host: requestUrlParsed.hostname }) });\r\n            }\r\n        }\r\n        var isHttps = requestUrlParsed.protocol === 'https:' && !proxyUrl;\r\n        if (isHttps && config.httpsAgent !== undefined) {\r\n            options.agent = config.httpsAgent;\r\n        }\r\n        else if (!isHttps && config.httpAgent !== undefined) {\r\n            options.agent = config.httpAgent;\r\n        }\r\n        else if (isHttps) {\r\n            // HTTPS without a passed in agent. Use one that enforces our TLS rules\r\n            options.agent = Util.tlsRestrictedAgent;\r\n        }\r\n        if (isHttps) {\r\n            return https.request(options, requestCallback);\r\n        }\r\n        else {\r\n            return http.request(options, requestCallback);\r\n        }\r\n    };\r\n    ;\r\n    /**\r\n     * Parse standard <string | string[] | number> request-context header\r\n     */\r\n    Util.safeIncludeCorrelationHeader = function (client, request, correlationHeader) {\r\n        var header; // attempt to cast correlationHeader to string\r\n        if (typeof correlationHeader === \"string\") {\r\n            header = correlationHeader;\r\n        }\r\n        else if (correlationHeader instanceof Array) {\r\n            header = correlationHeader.join(\",\");\r\n        }\r\n        else if (correlationHeader && typeof correlationHeader.toString === \"function\") {\r\n            // best effort attempt: requires well-defined toString\r\n            try {\r\n                header = correlationHeader.toString();\r\n            }\r\n            catch (err) {\r\n                Logging.warn(\"Outgoing request-context header could not be read. Correlation of requests may be lost.\", err, correlationHeader);\r\n            }\r\n        }\r\n        if (header) {\r\n            Util.addCorrelationIdHeaderFromString(client, request, header);\r\n        }\r\n        else {\r\n            request.setHeader(RequestResponseHeaders.requestContextHeader, RequestResponseHeaders.requestContextSourceKey + \"=\" + client.config.correlationId);\r\n        }\r\n    };\r\n    Util.addCorrelationIdHeaderFromString = function (client, response, correlationHeader) {\r\n        var components = correlationHeader.split(\",\");\r\n        var key = RequestResponseHeaders.requestContextSourceKey + \"=\";\r\n        var found = components.some(function (value) { return value.substring(0, key.length) === key; });\r\n        if (!found) {\r\n            response.setHeader(RequestResponseHeaders.requestContextHeader, correlationHeader + \",\" + RequestResponseHeaders.requestContextSourceKey + \"=\" + client.config.correlationId);\r\n        }\r\n    };\r\n    Util.MAX_PROPERTY_LENGTH = 8192;\r\n    Util.tlsRestrictedAgent = new https.Agent({\r\n        secureOptions: constants.SSL_OP_NO_SSLv2 | constants.SSL_OP_NO_SSLv3 |\r\n            constants.SSL_OP_NO_TLSv1 | constants.SSL_OP_NO_TLSv1_1\r\n    });\r\n    return Util;\r\n}());\r\nmodule.exports = Util;\r\n//# sourceMappingURL=Util.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar AutoCollectPerformance = require(\"../AutoCollection/Performance\");\r\nvar TelemetryType = require(\"../Declarations/Contracts\");\r\nfunction performanceMetricsTelemetryProcessor(envelope, client) {\r\n    // If live metrics is enabled, forward all telemetry there\r\n    if (client) {\r\n        client.addDocument(envelope);\r\n    }\r\n    // Increment rate counters (for standard metrics and live metrics)\r\n    switch (envelope.data.baseType) {\r\n        case TelemetryType.TelemetryTypeString.Exception:\r\n            AutoCollectPerformance.countException();\r\n            break;\r\n        case TelemetryType.TelemetryTypeString.Request:\r\n            var requestData = envelope.data.baseData;\r\n            AutoCollectPerformance.countRequest(requestData.duration, requestData.success);\r\n            break;\r\n        case TelemetryType.TelemetryTypeString.Dependency:\r\n            var remoteDependencyData = envelope.data.baseData;\r\n            AutoCollectPerformance.countDependency(remoteDependencyData.duration, remoteDependencyData.success);\r\n            break;\r\n    }\r\n    return true;\r\n}\r\nexports.performanceMetricsTelemetryProcessor = performanceMetricsTelemetryProcessor;\r\n//# sourceMappingURL=PerformanceMetricsTelemetryProcessor.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Contracts = require(\"../Declarations/Contracts\");\r\n/**\r\n *  A telemetry processor that handles sampling.\r\n */\r\nfunction samplingTelemetryProcessor(envelope, contextObjects) {\r\n    var samplingPercentage = envelope.sampleRate; // Set for us in Client.getEnvelope\r\n    var isSampledIn = false;\r\n    if (samplingPercentage === null || samplingPercentage === undefined || samplingPercentage >= 100) {\r\n        return true;\r\n    }\r\n    else if (envelope.data && Contracts.TelemetryType.Metric === Contracts.baseTypeToTelemetryType(envelope.data.baseType)) {\r\n        // Exclude MetricData telemetry from sampling\r\n        return true;\r\n    }\r\n    else if (contextObjects.correlationContext && contextObjects.correlationContext.operation) {\r\n        // If we're using dependency correlation, sampling should retain all telemetry from a given request\r\n        isSampledIn = getSamplingHashCode(contextObjects.correlationContext.operation.id) < samplingPercentage;\r\n    }\r\n    else {\r\n        // If we're not using dependency correlation, sampling should use a random distribution on each item\r\n        isSampledIn = (Math.random() * 100) < samplingPercentage;\r\n    }\r\n    return isSampledIn;\r\n}\r\nexports.samplingTelemetryProcessor = samplingTelemetryProcessor;\r\n/** Ported from AI .NET SDK */\r\nfunction getSamplingHashCode(input) {\r\n    var csharpMin = -2147483648;\r\n    var csharpMax = 2147483647;\r\n    var hash = 5381;\r\n    if (!input) {\r\n        return 0;\r\n    }\r\n    while (input.length < 8) {\r\n        input = input + input;\r\n    }\r\n    for (var i = 0; i < input.length; i++) {\r\n        // JS doesn't respond to integer overflow by wrapping around. Simulate it with bitwise operators ( | 0)\r\n        hash = ((((hash << 5) + hash) | 0) + input.charCodeAt(i) | 0);\r\n    }\r\n    hash = hash <= csharpMin ? csharpMax : Math.abs(hash);\r\n    return (hash / csharpMax) * 100;\r\n}\r\nexports.getSamplingHashCode = getSamplingHashCode;\r\n//# sourceMappingURL=SamplingTelemetryProcessor.js.map","\"use strict\";\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__export(require(\"./SamplingTelemetryProcessor\"));\r\n__export(require(\"./PerformanceMetricsTelemetryProcessor\"));\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar CorrelationContextManager = require(\"./AutoCollection/CorrelationContextManager\"); // Keep this first\r\nvar AutoCollectConsole = require(\"./AutoCollection/Console\");\r\nvar AutoCollectExceptions = require(\"./AutoCollection/Exceptions\");\r\nvar AutoCollectPerformance = require(\"./AutoCollection/Performance\");\r\nvar HeartBeat = require(\"./AutoCollection/HeartBeat\");\r\nvar AutoCollectHttpDependencies = require(\"./AutoCollection/HttpDependencies\");\r\nvar AutoCollectHttpRequests = require(\"./AutoCollection/HttpRequests\");\r\nvar CorrelationIdManager = require(\"./Library/CorrelationIdManager\");\r\nvar Logging = require(\"./Library/Logging\");\r\nvar QuickPulseClient = require(\"./Library/QuickPulseStateManager\");\r\nvar NativePerformance_1 = require(\"./AutoCollection/NativePerformance\");\r\n// We export these imports so that SDK users may use these classes directly.\r\n// They're exposed using \"export import\" so that types are passed along as expected\r\nexports.TelemetryClient = require(\"./Library/NodeClient\");\r\nexports.Contracts = require(\"./Declarations/Contracts\");\r\nexports.azureFunctionsTypes = require(\"./Library/Functions\");\r\nvar DistributedTracingModes;\r\n(function (DistributedTracingModes) {\r\n    /**\r\n     * (Default) Send Application Insights correlation headers\r\n     */\r\n    DistributedTracingModes[DistributedTracingModes[\"AI\"] = 0] = \"AI\";\r\n    /**\r\n     * Send both W3C Trace Context headers and back-compatibility Application Insights headers\r\n     */\r\n    DistributedTracingModes[DistributedTracingModes[\"AI_AND_W3C\"] = 1] = \"AI_AND_W3C\";\r\n})(DistributedTracingModes = exports.DistributedTracingModes || (exports.DistributedTracingModes = {}));\r\n// Default autocollection configuration\r\nvar _isConsole = true;\r\nvar _isConsoleLog = false;\r\nvar _isExceptions = true;\r\nvar _isPerformance = true;\r\nvar _isHeartBeat = false; // off by default for now\r\nvar _isRequests = true;\r\nvar _isDependencies = true;\r\nvar _isDiskRetry = true;\r\nvar _isCorrelating = true;\r\nvar _forceClsHooked;\r\nvar _isSendingLiveMetrics = false; // Off by default\r\nvar _isNativePerformance = true;\r\nvar _disabledExtendedMetrics;\r\nvar _diskRetryInterval = undefined;\r\nvar _diskRetryMaxBytes = undefined;\r\nvar _console;\r\nvar _exceptions;\r\nvar _performance;\r\nvar _heartbeat;\r\nvar _nativePerformance;\r\nvar _serverRequests;\r\nvar _clientRequests;\r\nvar _isStarted = false;\r\nvar _performanceLiveMetrics;\r\n/**\r\n * Initializes the default client. Should be called after setting\r\n * configuration options.\r\n *\r\n * @param setupString the Connection String or Instrumentation Key to use. Optional, if\r\n * this is not specified, the value will be read from the environment\r\n * variable APPLICATIONINSIGHTS_CONNECTION_STRING or APPINSIGHTS_INSTRUMENTATIONKEY.\r\n * @returns {Configuration} the configuration class to initialize\r\n * and start the SDK.\r\n */\r\nfunction setup(setupString) {\r\n    if (!exports.defaultClient) {\r\n        exports.defaultClient = new exports.TelemetryClient(setupString);\r\n        _console = new AutoCollectConsole(exports.defaultClient);\r\n        _exceptions = new AutoCollectExceptions(exports.defaultClient);\r\n        _performance = new AutoCollectPerformance(exports.defaultClient);\r\n        _heartbeat = new HeartBeat(exports.defaultClient);\r\n        _serverRequests = new AutoCollectHttpRequests(exports.defaultClient);\r\n        _clientRequests = new AutoCollectHttpDependencies(exports.defaultClient);\r\n        if (!_nativePerformance) {\r\n            _nativePerformance = new NativePerformance_1.AutoCollectNativePerformance(exports.defaultClient);\r\n        }\r\n    }\r\n    else {\r\n        Logging.info(\"The default client is already setup\");\r\n    }\r\n    if (exports.defaultClient && exports.defaultClient.channel) {\r\n        exports.defaultClient.channel.setUseDiskRetryCaching(_isDiskRetry, _diskRetryInterval, _diskRetryMaxBytes);\r\n    }\r\n    return Configuration;\r\n}\r\nexports.setup = setup;\r\n/**\r\n * Starts automatic collection of telemetry. Prior to calling start no\r\n * telemetry will be *automatically* collected, though manual collection\r\n * is enabled.\r\n * @returns {ApplicationInsights} this class\r\n */\r\nfunction start() {\r\n    if (!!exports.defaultClient) {\r\n        _isStarted = true;\r\n        _console.enable(_isConsole, _isConsoleLog);\r\n        _exceptions.enable(_isExceptions);\r\n        _performance.enable(_isPerformance);\r\n        _heartbeat.enable(_isHeartBeat, exports.defaultClient.config);\r\n        _nativePerformance.enable(_isNativePerformance, _disabledExtendedMetrics);\r\n        _serverRequests.useAutoCorrelation(_isCorrelating, _forceClsHooked);\r\n        _serverRequests.enable(_isRequests);\r\n        _clientRequests.enable(_isDependencies);\r\n        if (exports.liveMetricsClient && _isSendingLiveMetrics) {\r\n            exports.liveMetricsClient.enable(_isSendingLiveMetrics);\r\n        }\r\n    }\r\n    else {\r\n        Logging.warn(\"Start cannot be called before setup\");\r\n    }\r\n    return Configuration;\r\n}\r\nexports.start = start;\r\n/**\r\n * Returns an object that is shared across all code handling a given request.\r\n * This can be used similarly to thread-local storage in other languages.\r\n * Properties set on this object will be available to telemetry processors.\r\n *\r\n * Do not store sensitive information here.\r\n * Custom properties set on this object can be exposed in a future SDK\r\n * release via outgoing HTTP headers.\r\n * This is to allow for correlating data cross-component.\r\n *\r\n * This method will return null if automatic dependency correlation is disabled.\r\n * @returns A plain object for request storage or null if automatic dependency correlation is disabled.\r\n */\r\nfunction getCorrelationContext() {\r\n    if (_isCorrelating) {\r\n        return CorrelationContextManager.CorrelationContextManager.getCurrentContext();\r\n    }\r\n    return null;\r\n}\r\nexports.getCorrelationContext = getCorrelationContext;\r\nfunction startOperation(context, request) {\r\n    return CorrelationContextManager.CorrelationContextManager.startOperation(context, request);\r\n}\r\nexports.startOperation = startOperation;\r\n/**\r\n * Returns a function that will get the same correlation context within its\r\n * function body as the code executing this function.\r\n * Use this method if automatic dependency correlation is not propagating\r\n * correctly to an asynchronous callback.\r\n */\r\nfunction wrapWithCorrelationContext(fn, context) {\r\n    return CorrelationContextManager.CorrelationContextManager.wrapCallback(fn, context);\r\n}\r\nexports.wrapWithCorrelationContext = wrapWithCorrelationContext;\r\n/**\r\n * The active configuration for global SDK behaviors, such as autocollection.\r\n */\r\nvar Configuration = (function () {\r\n    function Configuration() {\r\n    }\r\n    /**\r\n     * Sets the distributed tracing modes. If W3C mode is enabled, W3C trace context\r\n     * headers (traceparent/tracestate) will be parsed in all incoming requests, and included in outgoing\r\n     * requests. In W3C mode, existing back-compatibility AI headers will also be parsed and included.\r\n     * Enabling W3C mode will not break existing correlation with other Application Insights instrumented\r\n     * services. Default=AI\r\n    */\r\n    Configuration.setDistributedTracingMode = function (value) {\r\n        CorrelationIdManager.w3cEnabled = value === DistributedTracingModes.AI_AND_W3C;\r\n        return Configuration;\r\n    };\r\n    /**\r\n     * Sets the state of console and logger tracking (enabled by default for third-party loggers only)\r\n     * @param value if true logger activity will be sent to Application Insights\r\n     * @param collectConsoleLog if true, logger autocollection will include console.log calls (default false)\r\n     * @returns {Configuration} this class\r\n     */\r\n    Configuration.setAutoCollectConsole = function (value, collectConsoleLog) {\r\n        if (collectConsoleLog === void 0) { collectConsoleLog = false; }\r\n        _isConsole = value;\r\n        _isConsoleLog = collectConsoleLog;\r\n        if (_isStarted) {\r\n            _console.enable(value, collectConsoleLog);\r\n        }\r\n        return Configuration;\r\n    };\r\n    /**\r\n     * Sets the state of exception tracking (enabled by default)\r\n     * @param value if true uncaught exceptions will be sent to Application Insights\r\n     * @returns {Configuration} this class\r\n     */\r\n    Configuration.setAutoCollectExceptions = function (value) {\r\n        _isExceptions = value;\r\n        if (_isStarted) {\r\n            _exceptions.enable(value);\r\n        }\r\n        return Configuration;\r\n    };\r\n    /**\r\n     * Sets the state of performance tracking (enabled by default)\r\n     * @param value if true performance counters will be collected every second and sent to Application Insights\r\n     * @param collectExtendedMetrics if true, extended metrics counters will be collected every minute and sent to Application Insights\r\n     * @returns {Configuration} this class\r\n     */\r\n    Configuration.setAutoCollectPerformance = function (value, collectExtendedMetrics) {\r\n        if (collectExtendedMetrics === void 0) { collectExtendedMetrics = true; }\r\n        _isPerformance = value;\r\n        var extendedMetricsConfig = NativePerformance_1.AutoCollectNativePerformance.parseEnabled(collectExtendedMetrics);\r\n        _isNativePerformance = extendedMetricsConfig.isEnabled;\r\n        _disabledExtendedMetrics = extendedMetricsConfig.disabledMetrics;\r\n        if (_isStarted) {\r\n            _performance.enable(value);\r\n            _nativePerformance.enable(extendedMetricsConfig.isEnabled, extendedMetricsConfig.disabledMetrics);\r\n        }\r\n        return Configuration;\r\n    };\r\n    /**\r\n     * Sets the state of request tracking (enabled by default)\r\n     * @param value if true HeartBeat metric data will be collected every 15 mintues and sent to Application Insights\r\n     * @returns {Configuration} this class\r\n     */\r\n    Configuration.setAutoCollectHeartbeat = function (value) {\r\n        _isHeartBeat = value;\r\n        if (_isStarted) {\r\n            _heartbeat.enable(value, exports.defaultClient.config);\r\n        }\r\n        return Configuration;\r\n    };\r\n    /**\r\n     * Sets the state of request tracking (enabled by default)\r\n     * @param value if true requests will be sent to Application Insights\r\n     * @returns {Configuration} this class\r\n     */\r\n    Configuration.setAutoCollectRequests = function (value) {\r\n        _isRequests = value;\r\n        if (_isStarted) {\r\n            _serverRequests.enable(value);\r\n        }\r\n        return Configuration;\r\n    };\r\n    /**\r\n     * Sets the state of dependency tracking (enabled by default)\r\n     * @param value if true dependencies will be sent to Application Insights\r\n     * @returns {Configuration} this class\r\n     */\r\n    Configuration.setAutoCollectDependencies = function (value) {\r\n        _isDependencies = value;\r\n        if (_isStarted) {\r\n            _clientRequests.enable(value);\r\n        }\r\n        return Configuration;\r\n    };\r\n    /**\r\n     * Sets the state of automatic dependency correlation (enabled by default)\r\n     * @param value if true dependencies will be correlated with requests\r\n     * @param useAsyncHooks if true, forces use of experimental async_hooks module to provide correlation. If false, instead uses only patching-based techniques. If left blank, the best option is chosen for you based on your version of Node.js.\r\n     * @returns {Configuration} this class\r\n     */\r\n    Configuration.setAutoDependencyCorrelation = function (value, useAsyncHooks) {\r\n        _isCorrelating = value;\r\n        _forceClsHooked = useAsyncHooks;\r\n        if (_isStarted) {\r\n            _serverRequests.useAutoCorrelation(value, useAsyncHooks);\r\n        }\r\n        return Configuration;\r\n    };\r\n    /**\r\n     * Enable or disable disk-backed retry caching to cache events when client is offline (enabled by default)\r\n     * Note that this method only applies to the default client. Disk-backed retry caching is disabled by default for additional clients.\r\n     * For enable for additional clients, use client.channel.setUseDiskRetryCaching(true).\r\n     * These cached events are stored in your system or user's temporary directory and access restricted to your user when possible.\r\n     * @param value if true events that occured while client is offline will be cached on disk\r\n     * @param resendInterval The wait interval for resending cached events.\r\n     * @param maxBytesOnDisk The maximum size (in bytes) that the created temporary directory for cache events can grow to, before caching is disabled.\r\n     * @returns {Configuration} this class\r\n     */\r\n    Configuration.setUseDiskRetryCaching = function (value, resendInterval, maxBytesOnDisk) {\r\n        _isDiskRetry = value;\r\n        _diskRetryInterval = resendInterval;\r\n        _diskRetryMaxBytes = maxBytesOnDisk;\r\n        if (exports.defaultClient && exports.defaultClient.channel) {\r\n            exports.defaultClient.channel.setUseDiskRetryCaching(value, resendInterval, maxBytesOnDisk);\r\n        }\r\n        return Configuration;\r\n    };\r\n    /**\r\n     * Enables debug and warning logging for AppInsights itself.\r\n     * @param enableDebugLogging if true, enables debug logging\r\n     * @param enableWarningLogging if true, enables warning logging\r\n     * @returns {Configuration} this class\r\n     */\r\n    Configuration.setInternalLogging = function (enableDebugLogging, enableWarningLogging) {\r\n        if (enableDebugLogging === void 0) { enableDebugLogging = false; }\r\n        if (enableWarningLogging === void 0) { enableWarningLogging = true; }\r\n        Logging.enableDebug = enableDebugLogging;\r\n        Logging.disableWarnings = !enableWarningLogging;\r\n        return Configuration;\r\n    };\r\n    /**\r\n     * Enables communication with Application Insights Live Metrics.\r\n     * @param enable if true, enables communication with the live metrics service\r\n     */\r\n    Configuration.setSendLiveMetrics = function (enable) {\r\n        if (enable === void 0) { enable = false; }\r\n        if (!exports.defaultClient) {\r\n            // Need a defaultClient so that we can add the QPS telemetry processor to it\r\n            Logging.warn(\"Live metrics client cannot be setup without the default client\");\r\n            return Configuration;\r\n        }\r\n        if (!exports.liveMetricsClient && enable) {\r\n            // No qps client exists. Create one and prepare it to be enabled at .start()\r\n            exports.liveMetricsClient = new QuickPulseClient(exports.defaultClient.config.instrumentationKey);\r\n            _performanceLiveMetrics = new AutoCollectPerformance(exports.liveMetricsClient, 1000, true);\r\n            exports.liveMetricsClient.addCollector(_performanceLiveMetrics);\r\n            exports.defaultClient.quickPulseClient = exports.liveMetricsClient; // Need this so we can forward all manual tracks to live metrics via PerformanceMetricsTelemetryProcessor\r\n        }\r\n        else if (exports.liveMetricsClient) {\r\n            // qps client already exists; enable/disable it\r\n            exports.liveMetricsClient.enable(enable);\r\n        }\r\n        _isSendingLiveMetrics = enable;\r\n        return Configuration;\r\n    };\r\n    // Convenience shortcut to ApplicationInsights.start\r\n    Configuration.start = start;\r\n    return Configuration;\r\n}());\r\nexports.Configuration = Configuration;\r\n/**\r\n * Disposes the default client and all the auto collectors so they can be reinitialized with different configuration\r\n*/\r\nfunction dispose() {\r\n    CorrelationIdManager.w3cEnabled = true; // reset to default\r\n    exports.defaultClient = null;\r\n    _isStarted = false;\r\n    if (_console) {\r\n        _console.dispose();\r\n    }\r\n    if (_exceptions) {\r\n        _exceptions.dispose();\r\n    }\r\n    if (_performance) {\r\n        _performance.dispose();\r\n    }\r\n    if (_heartbeat) {\r\n        _heartbeat.dispose();\r\n    }\r\n    if (_nativePerformance) {\r\n        _nativePerformance.dispose();\r\n    }\r\n    if (_serverRequests) {\r\n        _serverRequests.dispose();\r\n    }\r\n    if (_clientRequests) {\r\n        _clientRequests.dispose();\r\n    }\r\n    if (exports.liveMetricsClient) {\r\n        exports.liveMetricsClient.enable(false);\r\n        _isSendingLiveMetrics = false;\r\n        exports.liveMetricsClient = undefined;\r\n    }\r\n}\r\nexports.dispose = dispose;\r\n//# sourceMappingURL=applicationinsights.js.map","// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\n\nmodule.exports = {\n\n  newInvalidAsn1Error: function (msg) {\n    var e = new Error();\n    e.name = 'InvalidAsn1Error';\n    e.message = msg || '';\n    return e;\n  }\n\n};\n","// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\nvar errors = require('./errors');\nvar types = require('./types');\n\nvar Reader = require('./reader');\nvar Writer = require('./writer');\n\n\n// --- Exports\n\nmodule.exports = {\n\n  Reader: Reader,\n\n  Writer: Writer\n\n};\n\nfor (var t in types) {\n  if (types.hasOwnProperty(t))\n    module.exports[t] = types[t];\n}\nfor (var e in errors) {\n  if (errors.hasOwnProperty(e))\n    module.exports[e] = errors[e];\n}\n","// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\nvar assert = require('assert');\nvar Buffer = require('safer-buffer').Buffer;\n\nvar ASN1 = require('./types');\nvar errors = require('./errors');\n\n\n// --- Globals\n\nvar newInvalidAsn1Error = errors.newInvalidAsn1Error;\n\n\n\n// --- API\n\nfunction Reader(data) {\n  if (!data || !Buffer.isBuffer(data))\n    throw new TypeError('data must be a node Buffer');\n\n  this._buf = data;\n  this._size = data.length;\n\n  // These hold the \"current\" state\n  this._len = 0;\n  this._offset = 0;\n}\n\nObject.defineProperty(Reader.prototype, 'length', {\n  enumerable: true,\n  get: function () { return (this._len); }\n});\n\nObject.defineProperty(Reader.prototype, 'offset', {\n  enumerable: true,\n  get: function () { return (this._offset); }\n});\n\nObject.defineProperty(Reader.prototype, 'remain', {\n  get: function () { return (this._size - this._offset); }\n});\n\nObject.defineProperty(Reader.prototype, 'buffer', {\n  get: function () { return (this._buf.slice(this._offset)); }\n});\n\n\n/**\n * Reads a single byte and advances offset; you can pass in `true` to make this\n * a \"peek\" operation (i.e., get the byte, but don't advance the offset).\n *\n * @param {Boolean} peek true means don't move offset.\n * @return {Number} the next byte, null if not enough data.\n */\nReader.prototype.readByte = function (peek) {\n  if (this._size - this._offset < 1)\n    return null;\n\n  var b = this._buf[this._offset] & 0xff;\n\n  if (!peek)\n    this._offset += 1;\n\n  return b;\n};\n\n\nReader.prototype.peek = function () {\n  return this.readByte(true);\n};\n\n\n/**\n * Reads a (potentially) variable length off the BER buffer.  This call is\n * not really meant to be called directly, as callers have to manipulate\n * the internal buffer afterwards.\n *\n * As a result of this call, you can call `Reader.length`, until the\n * next thing called that does a readLength.\n *\n * @return {Number} the amount of offset to advance the buffer.\n * @throws {InvalidAsn1Error} on bad ASN.1\n */\nReader.prototype.readLength = function (offset) {\n  if (offset === undefined)\n    offset = this._offset;\n\n  if (offset >= this._size)\n    return null;\n\n  var lenB = this._buf[offset++] & 0xff;\n  if (lenB === null)\n    return null;\n\n  if ((lenB & 0x80) === 0x80) {\n    lenB &= 0x7f;\n\n    if (lenB === 0)\n      throw newInvalidAsn1Error('Indefinite length not supported');\n\n    if (lenB > 4)\n      throw newInvalidAsn1Error('encoding too long');\n\n    if (this._size - offset < lenB)\n      return null;\n\n    this._len = 0;\n    for (var i = 0; i < lenB; i++)\n      this._len = (this._len << 8) + (this._buf[offset++] & 0xff);\n\n  } else {\n    // Wasn't a variable length\n    this._len = lenB;\n  }\n\n  return offset;\n};\n\n\n/**\n * Parses the next sequence in this BER buffer.\n *\n * To get the length of the sequence, call `Reader.length`.\n *\n * @return {Number} the sequence's tag.\n */\nReader.prototype.readSequence = function (tag) {\n  var seq = this.peek();\n  if (seq === null)\n    return null;\n  if (tag !== undefined && tag !== seq)\n    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +\n                              ': got 0x' + seq.toString(16));\n\n  var o = this.readLength(this._offset + 1); // stored in `length`\n  if (o === null)\n    return null;\n\n  this._offset = o;\n  return seq;\n};\n\n\nReader.prototype.readInt = function () {\n  return this._readTag(ASN1.Integer);\n};\n\n\nReader.prototype.readBoolean = function () {\n  return (this._readTag(ASN1.Boolean) === 0 ? false : true);\n};\n\n\nReader.prototype.readEnumeration = function () {\n  return this._readTag(ASN1.Enumeration);\n};\n\n\nReader.prototype.readString = function (tag, retbuf) {\n  if (!tag)\n    tag = ASN1.OctetString;\n\n  var b = this.peek();\n  if (b === null)\n    return null;\n\n  if (b !== tag)\n    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +\n                              ': got 0x' + b.toString(16));\n\n  var o = this.readLength(this._offset + 1); // stored in `length`\n\n  if (o === null)\n    return null;\n\n  if (this.length > this._size - o)\n    return null;\n\n  this._offset = o;\n\n  if (this.length === 0)\n    return retbuf ? Buffer.alloc(0) : '';\n\n  var str = this._buf.slice(this._offset, this._offset + this.length);\n  this._offset += this.length;\n\n  return retbuf ? str : str.toString('utf8');\n};\n\nReader.prototype.readOID = function (tag) {\n  if (!tag)\n    tag = ASN1.OID;\n\n  var b = this.readString(tag, true);\n  if (b === null)\n    return null;\n\n  var values = [];\n  var value = 0;\n\n  for (var i = 0; i < b.length; i++) {\n    var byte = b[i] & 0xff;\n\n    value <<= 7;\n    value += byte & 0x7f;\n    if ((byte & 0x80) === 0) {\n      values.push(value);\n      value = 0;\n    }\n  }\n\n  value = values.shift();\n  values.unshift(value % 40);\n  values.unshift((value / 40) >> 0);\n\n  return values.join('.');\n};\n\n\nReader.prototype._readTag = function (tag) {\n  assert.ok(tag !== undefined);\n\n  var b = this.peek();\n\n  if (b === null)\n    return null;\n\n  if (b !== tag)\n    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +\n                              ': got 0x' + b.toString(16));\n\n  var o = this.readLength(this._offset + 1); // stored in `length`\n  if (o === null)\n    return null;\n\n  if (this.length > 4)\n    throw newInvalidAsn1Error('Integer too long: ' + this.length);\n\n  if (this.length > this._size - o)\n    return null;\n  this._offset = o;\n\n  var fb = this._buf[this._offset];\n  var value = 0;\n\n  for (var i = 0; i < this.length; i++) {\n    value <<= 8;\n    value |= (this._buf[this._offset++] & 0xff);\n  }\n\n  if ((fb & 0x80) === 0x80 && i !== 4)\n    value -= (1 << (i * 8));\n\n  return value >> 0;\n};\n\n\n\n// --- Exported API\n\nmodule.exports = Reader;\n","// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\n\nmodule.exports = {\n  EOC: 0,\n  Boolean: 1,\n  Integer: 2,\n  BitString: 3,\n  OctetString: 4,\n  Null: 5,\n  OID: 6,\n  ObjectDescriptor: 7,\n  External: 8,\n  Real: 9, // float\n  Enumeration: 10,\n  PDV: 11,\n  Utf8String: 12,\n  RelativeOID: 13,\n  Sequence: 16,\n  Set: 17,\n  NumericString: 18,\n  PrintableString: 19,\n  T61String: 20,\n  VideotexString: 21,\n  IA5String: 22,\n  UTCTime: 23,\n  GeneralizedTime: 24,\n  GraphicString: 25,\n  VisibleString: 26,\n  GeneralString: 28,\n  UniversalString: 29,\n  CharacterString: 30,\n  BMPString: 31,\n  Constructor: 32,\n  Context: 128\n};\n","// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\nvar assert = require('assert');\nvar Buffer = require('safer-buffer').Buffer;\nvar ASN1 = require('./types');\nvar errors = require('./errors');\n\n\n// --- Globals\n\nvar newInvalidAsn1Error = errors.newInvalidAsn1Error;\n\nvar DEFAULT_OPTS = {\n  size: 1024,\n  growthFactor: 8\n};\n\n\n// --- Helpers\n\nfunction merge(from, to) {\n  assert.ok(from);\n  assert.equal(typeof (from), 'object');\n  assert.ok(to);\n  assert.equal(typeof (to), 'object');\n\n  var keys = Object.getOwnPropertyNames(from);\n  keys.forEach(function (key) {\n    if (to[key])\n      return;\n\n    var value = Object.getOwnPropertyDescriptor(from, key);\n    Object.defineProperty(to, key, value);\n  });\n\n  return to;\n}\n\n\n\n// --- API\n\nfunction Writer(options) {\n  options = merge(DEFAULT_OPTS, options || {});\n\n  this._buf = Buffer.alloc(options.size || 1024);\n  this._size = this._buf.length;\n  this._offset = 0;\n  this._options = options;\n\n  // A list of offsets in the buffer where we need to insert\n  // sequence tag/len pairs.\n  this._seq = [];\n}\n\nObject.defineProperty(Writer.prototype, 'buffer', {\n  get: function () {\n    if (this._seq.length)\n      throw newInvalidAsn1Error(this._seq.length + ' unended sequence(s)');\n\n    return (this._buf.slice(0, this._offset));\n  }\n});\n\nWriter.prototype.writeByte = function (b) {\n  if (typeof (b) !== 'number')\n    throw new TypeError('argument must be a Number');\n\n  this._ensure(1);\n  this._buf[this._offset++] = b;\n};\n\n\nWriter.prototype.writeInt = function (i, tag) {\n  if (typeof (i) !== 'number')\n    throw new TypeError('argument must be a Number');\n  if (typeof (tag) !== 'number')\n    tag = ASN1.Integer;\n\n  var sz = 4;\n\n  while ((((i & 0xff800000) === 0) || ((i & 0xff800000) === 0xff800000 >> 0)) &&\n        (sz > 1)) {\n    sz--;\n    i <<= 8;\n  }\n\n  if (sz > 4)\n    throw newInvalidAsn1Error('BER ints cannot be > 0xffffffff');\n\n  this._ensure(2 + sz);\n  this._buf[this._offset++] = tag;\n  this._buf[this._offset++] = sz;\n\n  while (sz-- > 0) {\n    this._buf[this._offset++] = ((i & 0xff000000) >>> 24);\n    i <<= 8;\n  }\n\n};\n\n\nWriter.prototype.writeNull = function () {\n  this.writeByte(ASN1.Null);\n  this.writeByte(0x00);\n};\n\n\nWriter.prototype.writeEnumeration = function (i, tag) {\n  if (typeof (i) !== 'number')\n    throw new TypeError('argument must be a Number');\n  if (typeof (tag) !== 'number')\n    tag = ASN1.Enumeration;\n\n  return this.writeInt(i, tag);\n};\n\n\nWriter.prototype.writeBoolean = function (b, tag) {\n  if (typeof (b) !== 'boolean')\n    throw new TypeError('argument must be a Boolean');\n  if (typeof (tag) !== 'number')\n    tag = ASN1.Boolean;\n\n  this._ensure(3);\n  this._buf[this._offset++] = tag;\n  this._buf[this._offset++] = 0x01;\n  this._buf[this._offset++] = b ? 0xff : 0x00;\n};\n\n\nWriter.prototype.writeString = function (s, tag) {\n  if (typeof (s) !== 'string')\n    throw new TypeError('argument must be a string (was: ' + typeof (s) + ')');\n  if (typeof (tag) !== 'number')\n    tag = ASN1.OctetString;\n\n  var len = Buffer.byteLength(s);\n  this.writeByte(tag);\n  this.writeLength(len);\n  if (len) {\n    this._ensure(len);\n    this._buf.write(s, this._offset);\n    this._offset += len;\n  }\n};\n\n\nWriter.prototype.writeBuffer = function (buf, tag) {\n  if (typeof (tag) !== 'number')\n    throw new TypeError('tag must be a number');\n  if (!Buffer.isBuffer(buf))\n    throw new TypeError('argument must be a buffer');\n\n  this.writeByte(tag);\n  this.writeLength(buf.length);\n  this._ensure(buf.length);\n  buf.copy(this._buf, this._offset, 0, buf.length);\n  this._offset += buf.length;\n};\n\n\nWriter.prototype.writeStringArray = function (strings) {\n  if ((!strings instanceof Array))\n    throw new TypeError('argument must be an Array[String]');\n\n  var self = this;\n  strings.forEach(function (s) {\n    self.writeString(s);\n  });\n};\n\n// This is really to solve DER cases, but whatever for now\nWriter.prototype.writeOID = function (s, tag) {\n  if (typeof (s) !== 'string')\n    throw new TypeError('argument must be a string');\n  if (typeof (tag) !== 'number')\n    tag = ASN1.OID;\n\n  if (!/^([0-9]+\\.){3,}[0-9]+$/.test(s))\n    throw new Error('argument is not a valid OID string');\n\n  function encodeOctet(bytes, octet) {\n    if (octet < 128) {\n        bytes.push(octet);\n    } else if (octet < 16384) {\n        bytes.push((octet >>> 7) | 0x80);\n        bytes.push(octet & 0x7F);\n    } else if (octet < 2097152) {\n      bytes.push((octet >>> 14) | 0x80);\n      bytes.push(((octet >>> 7) | 0x80) & 0xFF);\n      bytes.push(octet & 0x7F);\n    } else if (octet < 268435456) {\n      bytes.push((octet >>> 21) | 0x80);\n      bytes.push(((octet >>> 14) | 0x80) & 0xFF);\n      bytes.push(((octet >>> 7) | 0x80) & 0xFF);\n      bytes.push(octet & 0x7F);\n    } else {\n      bytes.push(((octet >>> 28) | 0x80) & 0xFF);\n      bytes.push(((octet >>> 21) | 0x80) & 0xFF);\n      bytes.push(((octet >>> 14) | 0x80) & 0xFF);\n      bytes.push(((octet >>> 7) | 0x80) & 0xFF);\n      bytes.push(octet & 0x7F);\n    }\n  }\n\n  var tmp = s.split('.');\n  var bytes = [];\n  bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));\n  tmp.slice(2).forEach(function (b) {\n    encodeOctet(bytes, parseInt(b, 10));\n  });\n\n  var self = this;\n  this._ensure(2 + bytes.length);\n  this.writeByte(tag);\n  this.writeLength(bytes.length);\n  bytes.forEach(function (b) {\n    self.writeByte(b);\n  });\n};\n\n\nWriter.prototype.writeLength = function (len) {\n  if (typeof (len) !== 'number')\n    throw new TypeError('argument must be a Number');\n\n  this._ensure(4);\n\n  if (len <= 0x7f) {\n    this._buf[this._offset++] = len;\n  } else if (len <= 0xff) {\n    this._buf[this._offset++] = 0x81;\n    this._buf[this._offset++] = len;\n  } else if (len <= 0xffff) {\n    this._buf[this._offset++] = 0x82;\n    this._buf[this._offset++] = len >> 8;\n    this._buf[this._offset++] = len;\n  } else if (len <= 0xffffff) {\n    this._buf[this._offset++] = 0x83;\n    this._buf[this._offset++] = len >> 16;\n    this._buf[this._offset++] = len >> 8;\n    this._buf[this._offset++] = len;\n  } else {\n    throw newInvalidAsn1Error('Length too long (> 4 bytes)');\n  }\n};\n\nWriter.prototype.startSequence = function (tag) {\n  if (typeof (tag) !== 'number')\n    tag = ASN1.Sequence | ASN1.Constructor;\n\n  this.writeByte(tag);\n  this._seq.push(this._offset);\n  this._ensure(3);\n  this._offset += 3;\n};\n\n\nWriter.prototype.endSequence = function () {\n  var seq = this._seq.pop();\n  var start = seq + 3;\n  var len = this._offset - start;\n\n  if (len <= 0x7f) {\n    this._shift(start, len, -2);\n    this._buf[seq] = len;\n  } else if (len <= 0xff) {\n    this._shift(start, len, -1);\n    this._buf[seq] = 0x81;\n    this._buf[seq + 1] = len;\n  } else if (len <= 0xffff) {\n    this._buf[seq] = 0x82;\n    this._buf[seq + 1] = len >> 8;\n    this._buf[seq + 2] = len;\n  } else if (len <= 0xffffff) {\n    this._shift(start, len, 1);\n    this._buf[seq] = 0x83;\n    this._buf[seq + 1] = len >> 16;\n    this._buf[seq + 2] = len >> 8;\n    this._buf[seq + 3] = len;\n  } else {\n    throw newInvalidAsn1Error('Sequence too long');\n  }\n};\n\n\nWriter.prototype._shift = function (start, len, shift) {\n  assert.ok(start !== undefined);\n  assert.ok(len !== undefined);\n  assert.ok(shift);\n\n  this._buf.copy(this._buf, start + shift, start, start + len);\n  this._offset += shift;\n};\n\nWriter.prototype._ensure = function (len) {\n  assert.ok(len);\n\n  if (this._size - this._offset < len) {\n    var sz = this._size * this._options.growthFactor;\n    if (sz - this._offset < len)\n      sz += len;\n\n    var buf = Buffer.alloc(sz);\n\n    this._buf.copy(buf, 0, 0, this._offset);\n    this._buf = buf;\n    this._size = sz;\n  }\n};\n\n\n\n// --- Exported API\n\nmodule.exports = Writer;\n","// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\n// If you have no idea what ASN.1 or BER is, see this:\n// ftp://ftp.rsa.com/pub/pkcs/ascii/layman.asc\n\nvar Ber = require('./ber/index');\n\n\n\n// --- Exported API\n\nmodule.exports = {\n\n  Ber: Ber,\n\n  BerReader: Ber.Reader,\n\n  BerWriter: Ber.Writer\n\n};\n","'use strict';\n\nconst asyncWrap = process.binding('async_wrap');\nconst TIMERWRAP = asyncWrap.Providers.TIMERWRAP;\n\nconst patchs = {\n  'nextTick': require('./patches/next-tick.js'),\n  'promise': require('./patches/promise.js'),\n  'timers': require('./patches/timers.js')\n};\n\nconst ignoreUIDs = new Set();\n\nfunction State() {\n  this.enabled = false;\n  this.counter = 0;\n}\n\nfunction Hooks() {\n  const initFns = this.initFns = [];\n  const preFns = this.preFns = [];\n  const postFns = this.postFns = [];\n  const destroyFns = this.destroyFns = [];\n\n  this.init = function (uid, provider, parentUid, parentHandle) {\n    // Ignore TIMERWRAP, since setTimeout etc. is monkey patched\n    if (provider === TIMERWRAP) {\n      ignoreUIDs.add(uid);\n      return;\n    }\n\n    // call hooks\n    for (const hook of initFns) {\n      hook(uid, this, provider, parentUid, parentHandle);\n    }\n  };\n\n  this.pre = function (uid) {\n    if (ignoreUIDs.has(uid)) return;\n\n    // call hooks\n    for (const hook of preFns) {\n      hook(uid, this);\n    }\n  };\n\n  this.post = function (uid, didThrow) {\n    if (ignoreUIDs.has(uid)) return;\n\n    // call hooks\n    for (const hook of postFns) {\n      hook(uid, this, didThrow);\n    }\n  };\n\n  this.destroy = function (uid) {\n    // Cleanup the ignore list if this uid should be ignored\n    if (ignoreUIDs.has(uid)) {\n      ignoreUIDs.delete(uid);\n      return;\n    }\n\n    // call hooks\n    for (const hook of destroyFns) {\n      hook(uid);\n    }\n  };\n}\n\nHooks.prototype.add = function (hooks) {\n  if (hooks.init) this.initFns.push(hooks.init);\n  if (hooks.pre) this.preFns.push(hooks.pre);\n  if (hooks.post) this.postFns.push(hooks.post);\n  if (hooks.destroy) this.destroyFns.push(hooks.destroy);\n};\n\nfunction removeElement(array, item) {\n  const index = array.indexOf(item);\n  if (index === -1) return;\n  array.splice(index, 1);\n}\n\nHooks.prototype.remove = function (hooks) {\n  if (hooks.init) removeElement(this.initFns, hooks.init);\n  if (hooks.pre) removeElement(this.preFns, hooks.pre);\n  if (hooks.post) removeElement(this.postFns, hooks.post);\n  if (hooks.destroy) removeElement(this.destroyFns, hooks.destroy);\n};\n\nfunction AsyncHook() {\n  this._state = new State();\n  this._hooks = new Hooks();\n\n  // expose version for conflict detection\n  this.version = require('./package.json').version;\n\n  // expose the Providers map\n  this.providers = asyncWrap.Providers;\n\n  // apply patches\n  for (const key of Object.keys(patchs)) {\n    patchs[key].call(this);\n  }\n\n  // setup async wrap\n  if (process.env.hasOwnProperty('NODE_ASYNC_HOOK_WARNING')) {\n    console.warn('warning: you are using async-hook-jl which is unstable.');\n  }\n  asyncWrap.setupHooks({\n    init: this._hooks.init,\n    pre: this._hooks.pre,\n    post: this._hooks.post,\n    destroy: this._hooks.destroy\n  });\n}\nmodule.exports = AsyncHook;\n\nAsyncHook.prototype.addHooks = function (hooks) {\n  this._hooks.add(hooks);\n};\n\nAsyncHook.prototype.removeHooks = function (hooks) {\n  this._hooks.remove(hooks);\n};\n\nAsyncHook.prototype.enable = function () {\n  this._state.enabled = true;\n  asyncWrap.enable();\n};\n\nAsyncHook.prototype.disable = function () {\n  this._state.enabled = false;\n  asyncWrap.disable();\n};","'use strict';\n\nconst AsyncHook = require('./async-hook.js');\n\n// If a another copy (same version or not) of stack-chain exists it will result\n// in wrong stack traces (most likely dublicate callSites).\nif (global._asyncHook) {\n  // In case the version match, we can simply return the first initialized copy\n  if (global._asyncHook.version === require('./package.json').version) {\n    module.exports = global._asyncHook;\n  }\n  // The version don't match, this is really bad. Lets just throw\n  else {\n    throw new Error('Conflicting version of async-hook-jl found');\n  }\n} else {\n  const stackChain = require('stack-chain');\n\n  // Remove callSites from this module. AsyncWrap doesn't have any callSites\n  // and the hooks are expected to be completely transparent.\n  stackChain.filter.attach(function (error, frames) {\n    return frames.filter(function (callSite) {\n      const filename = callSite.getFileName();\n      // filename is not always a string, for example in case of eval it is\n      // undefined. So check if the filename is defined.\n      return !(filename && filename.slice(0, __dirname.length) === __dirname);\n    });\n  });\n\n  module.exports = global._asyncHook = new AsyncHook();\n}","'use strict';\n\nfunction NextTickWrap() {}\n\nmodule.exports = function patch() {\n  const hooks = this._hooks;\n  const state = this._state;\n\n  const oldNextTick = process.nextTick;\n  process.nextTick = function () {\n    if (!state.enabled) return oldNextTick.apply(process, arguments);\n\n    const args = new Array(arguments.length);\n    for (let i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n    const callback = args[0];\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('callback is not a function');\n    }\n\n    const handle = new NextTickWrap();\n    const uid = --state.counter;\n\n    // call the init hook\n    hooks.init.call(handle, uid, 0, null, null);\n\n    // overwrite callback\n    args[0] = function () {\n      // call the pre hook\n      hooks.pre.call(handle, uid);\n\n      let didThrow = true;\n      try {\n        callback.apply(this, arguments);\n        didThrow = false;\n      } finally {\n        // If `callback` threw and there is an uncaughtException handler\n        // then call the `post` and `destroy` hook after the uncaughtException\n        // user handlers have been invoked.\n        if(didThrow && process.listenerCount('uncaughtException') > 0) {\n          process.once('uncaughtException', function () {\n            hooks.post.call(handle, uid, true);\n            hooks.destroy.call(null, uid);\n          });\n        }\n      }\n\n      // callback done successfully\n      hooks.post.call(handle, uid, false);\n      hooks.destroy.call(null, uid);\n    };\n\n    return oldNextTick.apply(process, args);\n  };\n}\n","'use strict';\n\nfunction PromiseWrap() {}\n\nmodule.exports = function patchPromise() {\n  const hooks = this._hooks;\n  const state = this._state;\n\n  const Promise = global.Promise;\n\n  /* As per ECMAScript 2015, .catch must be implemented by calling .then, as\n   * such we need needn't patch .catch as well. see:\n   * http://www.ecma-international.org/ecma-262/6.0/#sec-promise.prototype.catch\n   */\n  const oldThen = Promise.prototype.then;\n  Promise.prototype.then = wrappedThen;\n\n  function makeWrappedHandler(fn, handle, uid, isOnFulfilled) {\n    if ('function' !== typeof fn) {\n      return isOnFulfilled\n        ? makeUnhandledResolutionHandler(uid)\n        : makeUnhandledRejectionHandler(uid);\n    }\n\n    return function wrappedHandler() {\n      hooks.pre.call(handle, uid);\n      try {\n        return fn.apply(this, arguments);\n      } finally {\n        hooks.post.call(handle, uid, false);\n        hooks.destroy.call(null, uid);\n      }\n    };\n  }\n\n  function makeUnhandledResolutionHandler(uid) {\n    return function unhandledResolutionHandler(val) {\n      hooks.destroy.call(null, uid);\n      return val;\n    };\n  }\n\n  function makeUnhandledRejectionHandler(uid) {\n    return function unhandledRejectedHandler(val) {\n      hooks.destroy.call(null, uid);\n      throw val;\n    };\n  }\n\n  function wrappedThen(onFulfilled, onRejected) {\n    if (!state.enabled) return oldThen.call(this, onFulfilled, onRejected);\n\n    const handle = new PromiseWrap();\n    const uid = --state.counter;\n\n    hooks.init.call(handle, uid, 0, null, null);\n\n    return oldThen.call(\n      this,\n      makeWrappedHandler(onFulfilled, handle, uid, true),\n      makeWrappedHandler(onRejected, handle, uid, false)\n    );\n  }\n};\n","'use strict';\n\nconst timers = require('timers');\n\nfunction TimeoutWrap() {}\nfunction IntervalWrap() {}\nfunction ImmediateWrap() {}\n\nconst timeoutMap = new Map();\nconst intervalMap = new Map();\nconst ImmediateMap = new Map();\n\nlet activeCallback = null;\nlet clearedInCallback = false;\n\nmodule.exports = function patch() {\n  patchTimer(this._hooks, this._state, 'setTimeout', 'clearTimeout', TimeoutWrap, timeoutMap, true);\n  patchTimer(this._hooks, this._state, 'setInterval', 'clearInterval', IntervalWrap, intervalMap, false);\n  patchTimer(this._hooks, this._state, 'setImmediate', 'clearImmediate', ImmediateWrap, ImmediateMap, true);\n\n  global.setTimeout = timers.setTimeout;\n  global.setInterval = timers.setInterval;\n  global.setImmediate = timers.setImmediate;\n\n  global.clearTimeout = timers.clearTimeout;\n  global.clearInterval = timers.clearInterval;\n  global.clearImmediate = timers.clearImmediate;\n};\n\nfunction patchTimer(hooks, state, setFn, clearFn, Handle, timerMap, singleCall) {\n  const oldSetFn = timers[setFn];\n  const oldClearFn = timers[clearFn];\n\n  // overwrite set[Timeout]\n  timers[setFn] = function () {\n    if (!state.enabled) return oldSetFn.apply(timers, arguments);\n\n    const args = new Array(arguments.length);\n    for (let i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n    const callback = args[0];\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('\"callback\" argument must be a function');\n    }\n\n    const handle = new Handle();\n    const uid = --state.counter;\n    let timerId = undefined;\n\n    // call the init hook\n    hooks.init.call(handle, uid, 0, null, null);\n\n    // overwrite callback\n    args[0] = function () {\n      // call the pre hook\n      activeCallback = timerId;\n      hooks.pre.call(handle, uid);\n\n      let didThrow = true;\n      try {\n        callback.apply(this, arguments);\n        didThrow = false;\n      } finally {\n        // If `callback` threw and there is an uncaughtException handler\n        // then call the `post` and `destroy` hook after the uncaughtException\n        // user handlers have been invoked.\n        if (didThrow && process.listenerCount('uncaughtException') > 0) {\n          process.once('uncaughtException', function () {\n            // call the post hook\n            hooks.post.call(handle, uid, true);\n            // setInterval won't continue\n            timerMap.delete(timerId);\n            hooks.destroy.call(null, uid);\n          });\n        }\n      }\n\n      // callback done successfully\n      hooks.post.call(handle, uid, false);\n      activeCallback = null;\n\n      // call the destroy hook if the callback will only be called once\n      if (singleCall || clearedInCallback) {\n        clearedInCallback = false;\n        timerMap.delete(timerId);\n        hooks.destroy.call(null, uid);\n      }\n    };\n\n    timerId = oldSetFn.apply(timers, args);\n    // Bind the timerId and uid for later use, in case the clear* function is\n    // called.\n    timerMap.set(timerId, uid);\n\n    return timerId;\n  };\n\n  // overwrite clear[Timeout]\n  timers[clearFn] = function (timerId) {\n    // If clear* was called within the timer callback, then delay the destroy\n    // event to after the post event has been called.\n    if (activeCallback === timerId && timerId !== null) {\n      clearedInCallback = true;\n    }\n    // clear should call the destroy hook. Note if timerId doesn't exists\n    // it is because asyncWrap wasn't enabled at the time.\n    else if (timerMap.has(timerId)) {\n      const uid = timerMap.get(timerId);\n      timerMap.delete(timerId);\n      hooks.destroy.call(null, uid);\n    }\n\n    oldClearFn.apply(timers, arguments);\n  };\n}\n","'use strict';\n\nmodule.exports = (Promise, ensureAslWrapper) => {\n  // Updates to this class should also be applied to the the ES3 version\n  // in index.js.\n  return class WrappedPromise extends Promise {\n    constructor(executor) {\n      var context, args;\n      super(wrappedExecutor);\n      var promise = this;\n\n      try {\n        executor.apply(context, args);\n      } catch (err) {\n        args[1](err);\n      }\n\n      return promise;\n      function wrappedExecutor(resolve, reject) {\n        context = this;\n        args = [wrappedResolve, wrappedReject];\n\n        // These wrappers create a function that can be passed a function and an argument to\n        // call as a continuation from the resolve or reject.\n        function wrappedResolve(val) {\n          ensureAslWrapper(promise, false);\n          return resolve(val);\n        }\n\n        function wrappedReject(val) {\n          ensureAslWrapper(promise, false);\n          return reject(val);\n        }\n      }\n    }\n  }\n};\n","var wrap = require('shimmer').wrap;\n\n/*\n *\n * CONSTANTS\n *\n */\nvar HAS_CREATE_AL = 1 << 0;\nvar HAS_BEFORE_AL = 1 << 1;\nvar HAS_AFTER_AL = 1 << 2;\nvar HAS_ERROR_AL = 1 << 3;\n\n/**\n * There is one list of currently active listeners that is mutated in place by\n * addAsyncListener and removeAsyncListener. This complicates error-handling,\n * for reasons that are discussed below.\n */\nvar listeners = [];\n\n/**\n * There can be multiple listeners with the same properties, so disambiguate\n * them by assigning them an ID at creation time.\n */\nvar uid = 0;\n\n/**\n * Ensure that errors coming from within listeners are handed off to domains,\n * process._fatalException, or uncaughtException without being treated like\n * user errors.\n */\nvar inAsyncTick = false;\n\n/**\n * Because asynchronous contexts can be nested, and errors can come from anywhere\n * in the stack, a little extra work is required to keep track of where in the\n * nesting we are. Because JS arrays are frequently mutated in place\n */\nvar listenerStack = [];\n\n/**\n * The error handler on a listener can capture errors thrown during synchronous\n * execution immediately after the listener is added. To capture both\n * synchronous and asynchronous errors, the error handler just uses the\n * \"global\" list of active listeners, and the rest of the code ensures that the\n * listener list is correct by using a stack of listener lists during\n * asynchronous execution.\n */\nvar asyncCatcher;\n\n/**\n * The guts of the system -- called each time an asynchronous event happens\n * while one or more listeners are active.\n */\nvar asyncWrap;\n\n/**\n * Simple helper function that's probably faster than using Array\n * filter methods and can be inlined.\n */\nfunction union(dest, added) {\n  var destLength = dest.length;\n  var addedLength = added.length;\n  var returned = [];\n\n  if (destLength === 0 && addedLength === 0) return returned;\n\n  for (var j  = 0; j < destLength; j++) returned[j] = dest[j];\n\n  if (addedLength === 0) return returned;\n\n  for (var i = 0; i < addedLength; i++) {\n    var missing = true;\n    for (j = 0; j < destLength; j++) {\n      if (dest[j].uid === added[i].uid) {\n        missing = false;\n        break;\n      }\n    }\n    if (missing) returned.push(added[i]);\n  }\n\n  return returned;\n}\n\n/*\n * For performance, split error-handlers and asyncCatcher up into two separate\n * code paths.\n */\n\n// 0.9+\nif (process._fatalException) {\n  /**\n   * Error handlers on listeners can throw, the catcher needs to be able to\n   * discriminate between exceptions thrown by user code, and exceptions coming\n   * from within the catcher itself. Use a global to keep track of which state\n   * the catcher is currently in.\n   */\n  var inErrorTick = false;\n\n  /**\n   * Throwing always happens synchronously. If the current array of values for\n   * the current list of asyncListeners is put in a module-scoped variable right\n   * before a call that can throw, it will always be correct when the error\n   * handlers are run.\n   */\n  var errorValues;\n\n  asyncCatcher = function asyncCatcher(er) {\n    var length = listeners.length;\n    if (inErrorTick || length === 0) return false;\n\n    var handled = false;\n\n    /*\n     * error handlers\n     */\n    inErrorTick = true;\n    for (var i = 0; i < length; ++i) {\n      var listener = listeners[i];\n      if ((listener.flags & HAS_ERROR_AL) === 0) continue;\n\n      var value = errorValues && errorValues[listener.uid];\n      handled = listener.error(value, er) || handled;\n    }\n    inErrorTick = false;\n\n    /* Test whether there are any listener arrays on the stack. In the case of\n     * synchronous throws when the listener is active, there may have been\n     * none pushed yet.\n     */\n    if (listenerStack.length > 0) listeners = listenerStack.pop();\n    errorValues = undefined;\n\n    return handled && !inAsyncTick;\n  };\n\n  asyncWrap = function asyncWrap(original, list, length) {\n    var values = [];\n\n    /*\n     * listeners\n     */\n    inAsyncTick = true;\n    for (var i = 0; i < length; ++i) {\n      var listener = list[i];\n      values[listener.uid] = listener.data;\n\n      if ((listener.flags & HAS_CREATE_AL) === 0) continue;\n\n      var value = listener.create(listener.data);\n      if (value !== undefined) values[listener.uid] = value;\n    }\n    inAsyncTick = false;\n\n    /* One of the main differences between this polyfill and the core\n     * asyncListener support is that core avoids creating closures by putting a\n     * lot of the state managemnt on the C++ side of Node (and of course also it\n     * bakes support for async listeners into the Node C++ API through the\n     * AsyncWrap class, which means that it doesn't monkeypatch basically every\n     * async method like this does).\n     */\n    return function () {\n      // put the current values where the catcher can see them\n      errorValues = values;\n\n      /* More than one listener can end up inside these closures, so save the\n       * current listeners on a stack.\n       */\n      listenerStack.push(listeners);\n\n      /* Activate both the listeners that were active when the closure was\n       * created and the listeners that were previously active.\n       */\n      listeners = union(list, listeners);\n\n      /*\n       * before handlers\n       */\n      inAsyncTick = true;\n      for (var i = 0; i < length; ++i) {\n        if ((list[i].flags & HAS_BEFORE_AL) > 0) {\n          list[i].before(this, values[list[i].uid]);\n        }\n      }\n      inAsyncTick = false;\n\n      // save the return value to pass to the after callbacks\n      var returned = original.apply(this, arguments);\n\n      /*\n       * after handlers (not run if original throws)\n       */\n      inAsyncTick = true;\n      for (i = 0; i < length; ++i) {\n        if ((list[i].flags & HAS_AFTER_AL) > 0) {\n          list[i].after(this, values[list[i].uid]);\n        }\n      }\n      inAsyncTick = false;\n\n      // back to the previous listener list on the stack\n      listeners = listenerStack.pop();\n      errorValues = undefined;\n\n      return returned;\n    };\n  };\n\n  wrap(process, '_fatalException', function (_fatalException) {\n    return function _asyncFatalException(er) {\n      return asyncCatcher(er) || _fatalException(er);\n    };\n  });\n}\n// 0.8 and below\nelse {\n  /**\n   * If an error handler in asyncWrap throws, the process must die. Under 0.8\n   * and earlier the only way to put a bullet through the head of the process\n   * is to rethrow from inside the exception handler, so rethrow and set\n   * errorThrew to tell the uncaughtHandler what to do.\n   */\n  var errorThrew = false;\n\n  /**\n   * Under Node 0.8, this handler *only* handles synchronously thrown errors.\n   * This simplifies it, which almost but not quite makes up for the hit taken\n   * by putting everything in a try-catch.\n   */\n  asyncCatcher = function uncaughtCatcher(er) {\n    // going down hard\n    if (errorThrew) throw er;\n\n    var handled = false;\n\n    /*\n     * error handlers\n     */\n    var length = listeners.length;\n    for (var i = 0; i < length; ++i) {\n      var listener = listeners[i];\n      if ((listener.flags & HAS_ERROR_AL) === 0) continue;\n      handled = listener.error(null, er) || handled;\n    }\n\n    /* Rethrow if one of the before / after handlers fire, which will bring the\n     * process down immediately.\n     */\n    if (!handled && inAsyncTick) throw er;\n  };\n\n  asyncWrap = function asyncWrap(original, list, length) {\n    var values = [];\n\n    /*\n     * listeners\n     */\n    inAsyncTick = true;\n    for (var i = 0; i < length; ++i) {\n      var listener = list[i];\n      values[listener.uid] = listener.data;\n\n      if ((listener.flags & HAS_CREATE_AL) === 0) continue;\n\n      var value = listener.create(listener.data);\n      if (value !== undefined) values[listener.uid] = value;\n    }\n    inAsyncTick = false;\n\n    /* One of the main differences between this polyfill and the core\n     * asyncListener support is that core avoids creating closures by putting a\n     * lot of the state managemnt on the C++ side of Node (and of course also it\n     * bakes support for async listeners into the Node C++ API through the\n     * AsyncWrap class, which means that it doesn't monkeypatch basically every\n     * async method like this does).\n     */\n    return function () {\n      /*jshint maxdepth:4*/\n\n      // after() handlers don't run if threw\n      var threw = false;\n\n      // ...unless the error is handled\n      var handled = false;\n\n      /* More than one listener can end up inside these closures, so save the\n       * current listeners on a stack.\n       */\n      listenerStack.push(listeners);\n\n      /* Activate both the listeners that were active when the closure was\n       * created and the listeners that were previously active.\n       */\n      listeners = union(list, listeners);\n\n      /*\n       * before handlers\n       */\n      inAsyncTick = true;\n      for (var i = 0; i < length; ++i) {\n        if ((list[i].flags & HAS_BEFORE_AL) > 0) {\n          list[i].before(this, values[list[i].uid]);\n        }\n      }\n      inAsyncTick = false;\n\n      // save the return value to pass to the after callbacks\n      var returned;\n      try {\n        returned = original.apply(this, arguments);\n      }\n      catch (er) {\n        threw = true;\n        for (var i = 0; i < length; ++i) {\n          if ((listeners[i].flags & HAS_ERROR_AL) == 0) continue;\n          try {\n            handled = listeners[i].error(values[list[i].uid], er) || handled;\n          }\n          catch (x) {\n            errorThrew = true;\n            throw x;\n          }\n        }\n\n        if (!handled) {\n          // having an uncaughtException handler here alters crash semantics\n          process.removeListener('uncaughtException', asyncCatcher);\n          process._originalNextTick(function () {\n            process.addListener('uncaughtException', asyncCatcher);\n          });\n\n          throw er;\n        }\n      }\n      finally {\n        /*\n         * after handlers (not run if original throws)\n         */\n        if (!threw || handled) {\n          inAsyncTick = true;\n          for (i = 0; i < length; ++i) {\n            if ((list[i].flags & HAS_AFTER_AL) > 0) {\n              list[i].after(this, values[list[i].uid]);\n            }\n          }\n          inAsyncTick = false;\n        }\n\n        // back to the previous listener list on the stack\n        listeners = listenerStack.pop();\n      }\n\n\n      return returned;\n    };\n  };\n\n  // will be the first to fire if async-listener is the first module loaded\n  process.addListener('uncaughtException', asyncCatcher);\n}\n\n// for performance in the case where there are no handlers, just the listener\nfunction simpleWrap(original, list, length) {\n  inAsyncTick = true;\n  for (var i = 0; i < length; ++i) {\n    var listener = list[i];\n    if (listener.create) listener.create(listener.data);\n  }\n  inAsyncTick = false;\n\n  // still need to make sure nested async calls are made in the context\n  // of the listeners active at their creation\n  return function () {\n    listenerStack.push(listeners);\n    listeners = union(list, listeners);\n\n    var returned = original.apply(this, arguments);\n\n    listeners = listenerStack.pop();\n\n    return returned;\n  };\n}\n\n/**\n * Called each time an asynchronous function that's been monkeypatched in\n * index.js is called. If there are no listeners, return the function\n * unwrapped.  If there are any asyncListeners and any of them have callbacks,\n * pass them off to asyncWrap for later use, otherwise just call the listener.\n */\nfunction wrapCallback(original) {\n  var length = listeners.length;\n\n  // no context to capture, so avoid closure creation\n  if (length === 0) return original;\n\n  // capture the active listeners as of when the wrapped function was called\n  var list = listeners.slice();\n\n  for (var i = 0; i < length; ++i) {\n    if (list[i].flags > 0) return asyncWrap(original, list, length);\n  }\n\n  return simpleWrap(original, list, length);\n}\n\nfunction AsyncListener(callbacks, data) {\n  if (typeof callbacks.create === 'function') {\n    this.create = callbacks.create;\n    this.flags |= HAS_CREATE_AL;\n  }\n\n  if (typeof callbacks.before === 'function') {\n    this.before = callbacks.before;\n    this.flags |= HAS_BEFORE_AL;\n  }\n\n  if (typeof callbacks.after === 'function') {\n    this.after = callbacks.after;\n    this.flags |= HAS_AFTER_AL;\n  }\n\n  if (typeof callbacks.error === 'function') {\n    this.error = callbacks.error;\n    this.flags |= HAS_ERROR_AL;\n  }\n\n  this.uid = ++uid;\n  this.data = data === undefined ? null : data;\n}\nAsyncListener.prototype.create = undefined;\nAsyncListener.prototype.before = undefined;\nAsyncListener.prototype.after  = undefined;\nAsyncListener.prototype.error  = undefined;\nAsyncListener.prototype.data   = undefined;\nAsyncListener.prototype.uid    = 0;\nAsyncListener.prototype.flags  = 0;\n\nfunction createAsyncListener(callbacks, data) {\n  if (typeof callbacks !== 'object' || !callbacks) {\n    throw new TypeError('callbacks argument must be an object');\n  }\n\n  if (callbacks instanceof AsyncListener) {\n    return callbacks;\n  }\n  else {\n    return new AsyncListener(callbacks, data);\n  }\n}\n\nfunction addAsyncListener(callbacks, data) {\n  var listener;\n  if (!(callbacks instanceof AsyncListener)) {\n    listener = createAsyncListener(callbacks, data);\n  }\n  else {\n    listener = callbacks;\n  }\n\n  // Make sure the listener isn't already in the list.\n  var registered = false;\n  for (var i = 0; i < listeners.length; i++) {\n    if (listener === listeners[i]) {\n      registered = true;\n      break;\n    }\n  }\n\n  if (!registered) listeners.push(listener);\n\n  return listener;\n}\n\nfunction removeAsyncListener(listener) {\n  for (var i = 0; i < listeners.length; i++) {\n    if (listener === listeners[i]) {\n      listeners.splice(i, 1);\n      break;\n    }\n  }\n}\n\nprocess.createAsyncListener = createAsyncListener;\nprocess.addAsyncListener    = addAsyncListener;\nprocess.removeAsyncListener = removeAsyncListener;\n\nmodule.exports = wrapCallback;\n","'use strict';\n\nif (process.addAsyncListener) throw new Error(\"Don't require polyfill unless needed\");\n\nvar shimmer      = require('shimmer')\n  , semver       = require('semver')\n  , wrap         = shimmer.wrap\n  , massWrap     = shimmer.massWrap\n  , wrapCallback = require('./glue.js')\n  , util         = require('util')\n  ;\n\nvar v6plus = semver.gte(process.version, '6.0.0');\nvar v7plus = semver.gte(process.version, '7.0.0');\nvar v8plus = semver.gte(process.version, '8.0.0');\nvar v11plus = semver.gte(process.version, '11.0.0');\n\nvar net = require('net');\n\n// From Node.js v7.0.0, net._normalizeConnectArgs have been renamed net._normalizeArgs\nif (v7plus && !net._normalizeArgs) {\n  // a polyfill in our polyfill etc so forth -- taken from node master on 2017/03/09\n  net._normalizeArgs = function (args) {\n    if (args.length === 0) {\n      return [{}, null];\n    }\n\n    var arg0 = args[0];\n    var options = {};\n    if (typeof arg0 === 'object' && arg0 !== null) {\n      // (options[...][, cb])\n      options = arg0;\n    } else if (isPipeName(arg0)) {\n      // (path[...][, cb])\n      options.path = arg0;\n    } else {\n      // ([port][, host][...][, cb])\n      options.port = arg0;\n      if (args.length > 1 && typeof args[1] === 'string') {\n        options.host = args[1];\n      }\n    }\n\n    var cb = args[args.length - 1];\n    if (typeof cb !== 'function')\n      return [options, null];\n    else\n      return [options, cb];\n  }\n} else if (!v7plus && !net._normalizeConnectArgs) {\n  // a polyfill in our polyfill etc so forth -- taken from node master on 2013/10/30\n  net._normalizeConnectArgs = function (args) {\n    var options = {};\n\n    function toNumber(x) { return (x = Number(x)) >= 0 ? x : false; }\n\n    if (typeof args[0] === 'object' && args[0] !== null) {\n      // connect(options, [cb])\n      options = args[0];\n    }\n    else if (typeof args[0] === 'string' && toNumber(args[0]) === false) {\n      // connect(path, [cb]);\n      options.path = args[0];\n    }\n    else {\n      // connect(port, [host], [cb])\n      options.port = args[0];\n      if (typeof args[1] === 'string') {\n        options.host = args[1];\n      }\n    }\n\n    var cb = args[args.length - 1];\n    return typeof cb === 'function' ? [options, cb] : [options];\n  };\n}\n\n// In https://github.com/nodejs/node/pull/11796 `_listen2` was renamed\n// `_setUpListenHandle`. It's still aliased as `_listen2`, and currently the\n// Node internals still call the alias - but who knows for how long. So better\n// make sure we use the new name instead if available.\nif ('_setUpListenHandle' in net.Server.prototype) {\n  wrap(net.Server.prototype, '_setUpListenHandle', wrapSetUpListenHandle);\n} else {\n  wrap(net.Server.prototype, '_listen2', wrapSetUpListenHandle);\n}\n\nfunction wrapSetUpListenHandle(original) {\n  return function () {\n    this.on('connection', function (socket) {\n      if (socket._handle) {\n        socket._handle.onread = wrapCallback(socket._handle.onread);\n      }\n    });\n\n    try {\n      return original.apply(this, arguments);\n    }\n    finally {\n      // the handle will only not be set in cases where there has been an error\n      if (this._handle && this._handle.onconnection) {\n        this._handle.onconnection = wrapCallback(this._handle.onconnection);\n      }\n    }\n  };\n}\n\nfunction patchOnRead(ctx) {\n  if (ctx && ctx._handle) {\n    var handle = ctx._handle;\n    if (!handle._originalOnread) {\n      handle._originalOnread = handle.onread;\n    }\n    handle.onread = wrapCallback(handle._originalOnread);\n  }\n}\n\nwrap(net.Socket.prototype, 'connect', function (original) {\n  return function () {\n    var args;\n    // Node core uses an internal Symbol here to guard against the edge-case\n    // where the user accidentally passes in an array. As we don't have access\n    // to this Symbol we resort to this hack where we just detect if there is a\n    // symbol or not. Checking for the number of Symbols is by no means a fool\n    // proof solution, but it catches the most basic cases.\n    if (v8plus &&\n        Array.isArray(arguments[0]) &&\n        Object.getOwnPropertySymbols(arguments[0]).length > 0) {\n      // already normalized\n      args = arguments[0];\n    } else {\n      // From Node.js v7.0.0, net._normalizeConnectArgs have been renamed net._normalizeArgs\n      args = v7plus\n        ? net._normalizeArgs(arguments)\n        : net._normalizeConnectArgs(arguments);\n    }\n    if (args[1]) args[1] = wrapCallback(args[1]);\n    var result = original.apply(this, args);\n    patchOnRead(this);\n    return result;\n  };\n});\n\nvar http = require('http');\n\n// NOTE: A rewrite occurred in 0.11 that changed the addRequest signature\n// from (req, host, port, localAddress) to (req, options)\n// Here, I use the longer signature to maintain 0.10 support, even though\n// the rest of the arguments aren't actually used\nwrap(http.Agent.prototype, 'addRequest', function (original) {\n  return function (req) {\n    var onSocket = req.onSocket;\n    req.onSocket = wrapCallback(function (socket) {\n      patchOnRead(socket);\n      return onSocket.apply(this, arguments);\n    });\n    return original.apply(this, arguments);\n  };\n});\n\nvar childProcess = require('child_process');\n\nfunction wrapChildProcess(child) {\n  if (Array.isArray(child.stdio)) {\n    child.stdio.forEach(function (socket) {\n      if (socket && socket._handle) {\n        socket._handle.onread = wrapCallback(socket._handle.onread);\n        wrap(socket._handle, 'close', activatorFirst);\n      }\n    });\n  }\n\n  if (child._handle) {\n    child._handle.onexit = wrapCallback(child._handle.onexit);\n  }\n}\n\n// iojs v2.0.0+\nif (childProcess.ChildProcess) {\n  wrap(childProcess.ChildProcess.prototype, 'spawn', function (original) {\n    return function () {\n      var result = original.apply(this, arguments);\n      wrapChildProcess(this);\n      return result;\n    };\n  });\n} else {\n  massWrap(childProcess, [\n    'execFile', // exec is implemented in terms of execFile\n    'fork',\n    'spawn'\n  ], function (original) {\n    return function () {\n      var result = original.apply(this, arguments);\n      wrapChildProcess(result);\n      return result;\n    };\n  });\n}\n\n// need unwrapped nextTick for use within < 0.9 async error handling\nif (!process._fatalException) {\n  process._originalNextTick = process.nextTick;\n}\n\nvar processors = [];\nif (process._nextDomainTick) processors.push('_nextDomainTick');\nif (process._tickDomainCallback) processors.push('_tickDomainCallback');\n\nmassWrap(\n  process,\n  processors,\n  activator\n);\nwrap(process, 'nextTick', activatorFirst);\n\nvar asynchronizers = [\n  'setTimeout',\n  'setInterval'\n];\nif (global.setImmediate) asynchronizers.push('setImmediate');\n\nvar timers = require('timers');\nvar patchGlobalTimers = global.setTimeout === timers.setTimeout;\n\nmassWrap(\n  timers,\n  asynchronizers,\n  activatorFirst\n);\n\nif (patchGlobalTimers) {\n  massWrap(\n    global,\n    asynchronizers,\n    activatorFirst\n  );\n}\n\nvar dns = require('dns');\nmassWrap(\n  dns,\n  [\n    'lookup',\n    'resolve',\n    'resolve4',\n    'resolve6',\n    'resolveCname',\n    'resolveMx',\n    'resolveNs',\n    'resolveTxt',\n    'resolveSrv',\n    'reverse'\n  ],\n  activator\n);\n\nif (dns.resolveNaptr) wrap(dns, 'resolveNaptr', activator);\n\nvar fs = require('fs');\nmassWrap(\n  fs,\n  [\n    'watch',\n    'rename',\n    'truncate',\n    'chown',\n    'fchown',\n    'chmod',\n    'fchmod',\n    'stat',\n    'lstat',\n    'fstat',\n    'link',\n    'symlink',\n    'readlink',\n    'realpath',\n    'unlink',\n    'rmdir',\n    'mkdir',\n    'readdir',\n    'close',\n    'open',\n    'utimes',\n    'futimes',\n    'fsync',\n    'write',\n    'read',\n    'readFile',\n    'writeFile',\n    'appendFile',\n    'watchFile',\n    'unwatchFile',\n    \"exists\",\n  ],\n  activator\n);\n\n// only wrap lchown and lchmod on systems that have them.\nif (fs.lchown) wrap(fs, 'lchown', activator);\nif (fs.lchmod) wrap(fs, 'lchmod', activator);\n\n// only wrap ftruncate in versions of node that have it\nif (fs.ftruncate) wrap(fs, 'ftruncate', activator);\n\n// Wrap zlib streams\nvar zlib;\ntry { zlib = require('zlib'); } catch (err) { }\nif (zlib && zlib.Deflate && zlib.Deflate.prototype) {\n  var proto = Object.getPrototypeOf(zlib.Deflate.prototype);\n  if (proto._transform) {\n    // streams2\n    wrap(proto, \"_transform\", activator);\n  }\n  else if (proto.write && proto.flush && proto.end) {\n    // plain ol' streams\n    massWrap(\n      proto,\n      [\n        'write',\n        'flush',\n        'end'\n      ],\n      activator\n    );\n  }\n}\n\n// Wrap Crypto\nvar crypto;\ntry { crypto = require('crypto'); } catch (err) { }\nif (crypto) {\n\n  var toWrap = [\n      'pbkdf2',\n      'randomBytes',\n  ];\n  if (!v11plus) {\n    toWrap.push('pseudoRandomBytes');\n  }\n\n  massWrap(crypto, toWrap, activator);\n}\n\n// It is unlikely that any userspace promise implementations have a native\n// implementation of both Promise and Promise.toString.\nvar instrumentPromise = !!global.Promise &&\n    Promise.toString() === 'function Promise() { [native code] }' &&\n    Promise.toString.toString() === 'function toString() { [native code] }';\n\n// Check that global Promise is native\nif (instrumentPromise) {\n  // shoult not use any methods that have already been wrapped\n  var promiseListener = process.addAsyncListener({\n    create: function create() {\n      instrumentPromise = false;\n    }\n  });\n\n  // should not resolve synchronously\n  global.Promise.resolve(true).then(function notSync() {\n    instrumentPromise = false;\n  });\n\n  process.removeAsyncListener(promiseListener);\n}\n\n/*\n * Native promises use the microtask queue to make all callbacks run\n * asynchronously to avoid Zalgo issues. Since the microtask queue is not\n * exposed externally, promises need to be modified in a fairly invasive and\n * complex way.\n *\n * The async boundary in promises that must be patched is between the\n * fulfillment of the promise and the execution of any callback that is waiting\n * for that fulfillment to happen. This means that we need to trigger a create\n * when resolve or reject is called and trigger before, after and error handlers\n * around the callback execution. There may be multiple callbacks for each\n * fulfilled promise, so handlers will behave similar to setInterval where\n * there may be multiple before after and error calls for each create call.\n *\n * async-listener monkeypatching has one basic entry point: `wrapCallback`.\n * `wrapCallback` should be called when create should be triggered and be\n * passed a function to wrap, which will execute the body of the async work.\n * The resolve and reject calls can be modified fairly easily to call\n * `wrapCallback`, but at the time of resolve and reject all the work to be done\n * on fulfillment may not be defined, since a call to then, chain or fetch can\n * be made even after the promise has been fulfilled. To get around this, we\n * create a placeholder function which will call a function passed into it,\n * since the call to the main work is being made from within the wrapped\n * function, async-listener will work correctly.\n *\n * There is another complication with monkeypatching Promises. Calls to then,\n * chain and catch each create new Promises that are fulfilled internally in\n * different ways depending on the return value of the callback. When the\n * callback return a Promise, the new Promise is resolved asynchronously after\n * the returned Promise has been also been resolved. When something other than\n * a promise is resolved the resolve call for the new Promise is put in the\n * microtask queue and asynchronously resolved.\n *\n * Then must be wrapped so that its returned promise has a wrapper that can be\n * used to invoke further continuations. This wrapper cannot be created until\n * after the callback has run, since the callback may return either a promise\n * or another value. Fortunately we already have a wrapper function around the\n * callback we can use (the wrapper created by resolve or reject).\n *\n * By adding an additional argument to this wrapper, we can pass in the\n * returned promise so it can have its own wrapper appended. the wrapper\n * function can the call the callback, and take action based on the return\n * value. If a promise is returned, the new Promise can proxy the returned\n * Promise's wrapper (this wrapper may not exist yet, but will by the time the\n * wrapper needs to be invoked). Otherwise, a new wrapper can be create the\n * same way as in resolve and reject. Since this wrapper is created\n * synchronously within another wrapper, it will properly appear as a\n * continuation from within the callback.\n */\n\nif (instrumentPromise) {\n  wrapPromise();\n}\n\nfunction wrapPromise() {\n  var Promise = global.Promise;\n\n  // Updates to this class should also be applied to the the ES6 version\n  // in es6-wrapped-promise.js.\n  function wrappedPromise(executor) {\n    if (!(this instanceof wrappedPromise)) {\n      return Promise(executor);\n    }\n\n    if (typeof executor !== 'function') {\n      return new Promise(executor);\n    }\n\n    var context, args;\n    var promise = new Promise(wrappedExecutor);\n    promise.__proto__ = wrappedPromise.prototype;\n\n    try {\n      executor.apply(context, args);\n    } catch (err) {\n      args[1](err);\n    }\n\n    return promise;\n\n    function wrappedExecutor(resolve, reject) {\n      context = this;\n      args = [wrappedResolve, wrappedReject];\n\n      // These wrappers create a function that can be passed a function and an argument to\n      // call as a continuation from the resolve or reject.\n      function wrappedResolve(val) {\n        ensureAslWrapper(promise, false);\n        return resolve(val);\n      }\n\n      function wrappedReject(val) {\n        ensureAslWrapper(promise, false);\n        return reject(val);\n      }\n    }\n  }\n\n  util.inherits(wrappedPromise, Promise);\n\n  wrap(Promise.prototype, 'then', wrapThen);\n  // Node.js <v7 only, alias for .then\n  if (Promise.prototype.chain) {\n    wrap(Promise.prototype, 'chain', wrapThen);\n  }\n\n  if (v6plus) {\n    global.Promise = require('./es6-wrapped-promise.js')(Promise, ensureAslWrapper);\n  } else {\n    var PromiseFunctions = [\n      'all',\n      'race',\n      'reject',\n      'resolve',\n      'accept',  // Node.js <v7 only\n      'defer'    // Node.js <v7 only\n    ];\n\n    PromiseFunctions.forEach(function(key) {\n      // don't break `in` by creating a key for undefined entries\n      if (typeof Promise[key] === 'function') {\n        wrappedPromise[key] = Promise[key];\n      }\n    });\n    global.Promise = wrappedPromise\n  }\n\n  function ensureAslWrapper(promise, overwrite) {\n    if (!promise.__asl_wrapper || overwrite) {\n      promise.__asl_wrapper = wrapCallback(propagateAslWrapper);\n    }\n  }\n\n  function propagateAslWrapper(ctx, fn, result, next) {\n    var nextResult;\n    try {\n      nextResult = fn.call(ctx, result);\n      return {returnVal: nextResult, error: false}\n    } catch (err) {\n      return {errorVal: err, error: true}\n    } finally {\n      // Wrap any resulting futures as continuations.\n      if (nextResult instanceof Promise) {\n        next.__asl_wrapper = function proxyWrapper() {\n          var aslWrapper = nextResult.__asl_wrapper || propagateAslWrapper;\n          return aslWrapper.apply(this, arguments);\n        }\n      } else {\n        ensureAslWrapper(next, true);\n      }\n    }\n  }\n\n  function wrapThen(original) {\n    return function wrappedThen() {\n      var promise = this;\n      var next = original.apply(promise, Array.prototype.map.call(arguments, bind));\n\n      next.__asl_wrapper = function proxyWrapper(ctx, fn, val, last) {\n        if (promise.__asl_wrapper) {\n          promise.__asl_wrapper(ctx, function () {}, null, next);\n          return next.__asl_wrapper(ctx, fn, val, last);\n        }\n        return propagateAslWrapper(ctx, fn, val, last);\n      }\n\n      return next;\n\n      // wrap callbacks (success, error) so that the callbacks will be called as a\n      // continuations of the resolve or reject call using the __asl_wrapper created above.\n      function bind(fn) {\n        if (typeof fn !== 'function') return fn;\n        return wrapCallback(function (val) {\n          var result = (promise.__asl_wrapper || propagateAslWrapper)(this, fn, val, next);\n          if (result.error) {\n            throw result.errorVal\n          } else {\n            return result.returnVal\n          }\n        });\n      }\n    }\n  }\n}\n\n// Shim activator for functions that have callback last\nfunction activator(fn) {\n  var fallback = function () {\n    var args;\n    var cbIdx = arguments.length - 1;\n    if (typeof arguments[cbIdx] === \"function\") {\n      args = Array(arguments.length)\n      for (var i = 0; i < arguments.length - 1; i++) {\n        args[i] = arguments[i];\n      }\n      args[cbIdx] = wrapCallback(arguments[cbIdx]);\n    }\n    return fn.apply(this, args || arguments);\n  };\n  // Preserve function length for small arg count functions.\n  switch (fn.length) {\n    case 1:\n      return function (cb) {\n        if (arguments.length !== 1) return fallback.apply(this, arguments);\n        if (typeof cb === \"function\") cb = wrapCallback(cb);\n        return fn.call(this, cb);\n      };\n    case 2:\n      return function (a, cb) {\n        if (arguments.length !== 2) return fallback.apply(this, arguments);\n        if (typeof cb === \"function\") cb = wrapCallback(cb);\n        return fn.call(this, a, cb);\n      };\n    case 3:\n      return function (a, b, cb) {\n        if (arguments.length !== 3) return fallback.apply(this, arguments);\n        if (typeof cb === \"function\") cb = wrapCallback(cb);\n        return fn.call(this, a, b, cb);\n      };\n    case 4:\n      return function (a, b, c, cb) {\n        if (arguments.length !== 4) return fallback.apply(this, arguments);\n        if (typeof cb === \"function\") cb = wrapCallback(cb);\n        return fn.call(this, a, b, c, cb);\n      };\n    case 5:\n      return function (a, b, c, d, cb) {\n        if (arguments.length !== 5) return fallback.apply(this, arguments);\n        if (typeof cb === \"function\") cb = wrapCallback(cb);\n        return fn.call(this, a, b, c, d, cb);\n      };\n    case 6:\n      return function (a, b, c, d, e, cb) {\n        if (arguments.length !== 6) return fallback.apply(this, arguments);\n        if (typeof cb === \"function\") cb = wrapCallback(cb);\n        return fn.call(this, a, b, c, d, e, cb);\n      };\n    default:\n      return fallback;\n  }\n}\n\n// Shim activator for functions that have callback first\nfunction activatorFirst(fn) {\n  var fallback = function () {\n    var args;\n    if (typeof arguments[0] === \"function\") {\n      args = Array(arguments.length)\n      args[0] = wrapCallback(arguments[0]);\n      for (var i = 1; i < arguments.length; i++) {\n        args[i] = arguments[i];\n      }\n    }\n    return fn.apply(this, args || arguments);\n  };\n  // Preserve function length for small arg count functions.\n  switch (fn.length) {\n    case 1:\n      return function (cb) {\n        if (arguments.length !== 1) return fallback.apply(this, arguments);\n        if (typeof cb === \"function\") cb = wrapCallback(cb);\n        return fn.call(this, cb);\n      };\n    case 2:\n      return function (cb, a) {\n        if (arguments.length !== 2) return fallback.apply(this, arguments);\n        if (typeof cb === \"function\") cb = wrapCallback(cb);\n        return fn.call(this, cb, a);\n      };\n    case 3:\n      return function (cb, a, b) {\n        if (arguments.length !== 3) return fallback.apply(this, arguments);\n        if (typeof cb === \"function\") cb = wrapCallback(cb);\n        return fn.call(this, cb, a, b);\n      };\n    case 4:\n      return function (cb, a, b, c) {\n        if (arguments.length !== 4) return fallback.apply(this, arguments);\n        if (typeof cb === \"function\") cb = wrapCallback(cb);\n        return fn.call(this, cb, a, b, c);\n      };\n    case 5:\n      return function (cb, a, b, c, d) {\n        if (arguments.length !== 5) return fallback.apply(this, arguments);\n        if (typeof cb === \"function\") cb = wrapCallback(cb);\n        return fn.call(this, cb, a, b, c, d);\n      };\n    case 6:\n      return function (cb, a, b, c, d, e) {\n        if (arguments.length !== 6) return fallback.apply(this, arguments);\n        if (typeof cb === \"function\") cb = wrapCallback(cb);\n        return fn.call(this, cb, a, b, c, d, e);\n      };\n    default:\n      return fallback;\n  }\n}\n\n// taken from node master on 2017/03/09\nfunction toNumber(x) {\n  return (x = Number(x)) >= 0 ? x : false;\n}\n\n// taken from node master on 2017/03/09\nfunction isPipeName(s) {\n  return typeof s === 'string' && toNumber(s) === false;\n}\n","'use strict';\n\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */\nconst mask = (source, mask, output, offset, length) => {\n  for (var i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask[i & 3];\n  }\n};\n\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */\nconst unmask = (buffer, mask) => {\n  // Required until https://github.com/nodejs/node/issues/9006 is resolved.\n  const length = buffer.length;\n  for (var i = 0; i < length; i++) {\n    buffer[i] ^= mask[i & 3];\n  }\n};\n\nmodule.exports = { mask, unmask };\n","'use strict';\n\ntry {\n  module.exports = require('node-gyp-build')(__dirname);\n} catch (e) {\n  module.exports = require('./fallback');\n}\n","'use strict';\n\nconst util = require('util');\nconst assert = require('assert');\nconst wrapEmitter = require('emitter-listener');\nconst asyncHook = require('async-hook-jl');\n\nconst CONTEXTS_SYMBOL = 'cls@contexts';\nconst ERROR_SYMBOL = 'error@context';\n\n//const trace = [];\n\nconst invertedProviders = [];\nfor (let key in asyncHook.providers) {\n  invertedProviders[asyncHook.providers[key]] = key;\n}\n\nconst DEBUG_CLS_HOOKED = process.env.DEBUG_CLS_HOOKED;\n\nlet currentUid = -1;\n\nmodule.exports = {\n  getNamespace: getNamespace,\n  createNamespace: createNamespace,\n  destroyNamespace: destroyNamespace,\n  reset: reset,\n  //trace: trace,\n  ERROR_SYMBOL: ERROR_SYMBOL\n};\n\nfunction Namespace(name) {\n  this.name = name;\n  // changed in 2.7: no default context\n  this.active = null;\n  this._set = [];\n  this.id = null;\n  this._contexts = new Map();\n}\n\nNamespace.prototype.set = function set(key, value) {\n  if (!this.active) {\n    throw new Error('No context available. ns.run() or ns.bind() must be called first.');\n  }\n\n  if (DEBUG_CLS_HOOKED) {\n    debug2('    SETTING KEY:' + key + '=' + value + ' in ns:' + this.name + ' uid:' + currentUid + ' active:' +\n      util.inspect(this.active, true));\n  }\n  this.active[key] = value;\n  return value;\n};\n\nNamespace.prototype.get = function get(key) {\n  if (!this.active) {\n    if (DEBUG_CLS_HOOKED) {\n      debug2('    GETTING KEY:' + key + '=undefined' + ' ' + this.name + ' uid:' + currentUid + ' active:' +\n        util.inspect(this.active, true));\n    }\n    return undefined;\n  }\n  if (DEBUG_CLS_HOOKED) {\n    debug2('    GETTING KEY:' + key + '=' + this.active[key] + ' ' + this.name + ' uid:' + currentUid + ' active:' +\n      util.inspect(this.active, true));\n  }\n  return this.active[key];\n};\n\nNamespace.prototype.createContext = function createContext() {\n  if (DEBUG_CLS_HOOKED) {\n    debug2('   CREATING Context: ' + this.name + ' uid:' + currentUid + ' len:' + this._set.length + ' ' + ' active:' +\n      util.inspect(this.active, true, 2, true));\n  }\n\n  let context = Object.create(this.active ? this.active : Object.prototype);\n  context._ns_name = this.name;\n  context.id = currentUid;\n\n  if (DEBUG_CLS_HOOKED) {\n    debug2('   CREATED Context: ' + this.name + ' uid:' + currentUid + ' len:' + this._set.length + ' ' + ' context:' +\n      util.inspect(context, true, 2, true));\n  }\n\n  return context;\n};\n\nNamespace.prototype.run = function run(fn) {\n  let context = this.createContext();\n  this.enter(context);\n  try {\n    if (DEBUG_CLS_HOOKED) {\n      debug2(' BEFORE RUN: ' + this.name + ' uid:' + currentUid + ' len:' + this._set.length + ' ' +\n        util.inspect(context));\n    }\n    fn(context);\n    return context;\n  }\n  catch (exception) {\n    if (exception) {\n      exception[ERROR_SYMBOL] = context;\n    }\n    throw exception;\n  }\n  finally {\n    if (DEBUG_CLS_HOOKED) {\n      debug2(' AFTER RUN: ' + this.name + ' uid:' + currentUid + ' len:' + this._set.length + ' ' +\n        util.inspect(context));\n    }\n    this.exit(context);\n  }\n};\n\nNamespace.prototype.runAndReturn = function runAndReturn(fn) {\n  var value;\n  this.run(function (context) {\n    value = fn(context);\n  });\n  return value;\n};\n\n/**\n * Uses global Promise and assumes Promise is cls friendly or wrapped already.\n * @param {function} fn\n * @returns {*}\n */\nNamespace.prototype.runPromise = function runPromise(fn) {\n  let context = this.createContext();\n  this.enter(context);\n\n  let promise = fn(context);\n  if (!promise || !promise.then || !promise.catch) {\n    throw new Error('fn must return a promise.');\n  }\n\n  if (DEBUG_CLS_HOOKED) {\n    debug2(' BEFORE runPromise: ' + this.name + ' uid:' + currentUid + ' len:' + this._set.length + ' ' +\n      util.inspect(context));\n  }\n\n  return promise\n    .then(result => {\n      if (DEBUG_CLS_HOOKED) {\n        debug2(' AFTER runPromise: ' + this.name + ' uid:' + currentUid + ' len:' + this._set.length + ' ' +\n          util.inspect(context));\n      }\n      this.exit(context);\n      return result;\n    })\n    .catch(err => {\n      err[ERROR_SYMBOL] = context;\n      if (DEBUG_CLS_HOOKED) {\n        debug2(' AFTER runPromise: ' + this.name + ' uid:' + currentUid + ' len:' + this._set.length + ' ' +\n          util.inspect(context));\n      }\n      this.exit(context);\n      throw err;\n    });\n};\n\nNamespace.prototype.bind = function bindFactory(fn, context) {\n  if (!context) {\n    if (!this.active) {\n      context = this.createContext();\n    }\n    else {\n      context = this.active;\n    }\n  }\n\n  let self = this;\n  return function clsBind() {\n    self.enter(context);\n    try {\n      return fn.apply(this, arguments);\n    }\n    catch (exception) {\n      if (exception) {\n        exception[ERROR_SYMBOL] = context;\n      }\n      throw exception;\n    }\n    finally {\n      self.exit(context);\n    }\n  };\n};\n\nNamespace.prototype.enter = function enter(context) {\n  assert.ok(context, 'context must be provided for entering');\n  if (DEBUG_CLS_HOOKED) {\n    debug2('  ENTER ' + this.name + ' uid:' + currentUid + ' len:' + this._set.length + ' context: ' +\n      util.inspect(context));\n  }\n\n  this._set.push(this.active);\n  this.active = context;\n};\n\nNamespace.prototype.exit = function exit(context) {\n  assert.ok(context, 'context must be provided for exiting');\n  if (DEBUG_CLS_HOOKED) {\n    debug2('  EXIT ' + this.name + ' uid:' + currentUid + ' len:' + this._set.length + ' context: ' +\n      util.inspect(context));\n  }\n\n  // Fast path for most exits that are at the top of the stack\n  if (this.active === context) {\n    assert.ok(this._set.length, 'can\\'t remove top context');\n    this.active = this._set.pop();\n    return;\n  }\n\n  // Fast search in the stack using lastIndexOf\n  let index = this._set.lastIndexOf(context);\n\n  if (index < 0) {\n    if (DEBUG_CLS_HOOKED) {\n      debug2('??ERROR?? context exiting but not entered - ignoring: ' + util.inspect(context));\n    }\n    assert.ok(index >= 0, 'context not currently entered; can\\'t exit. \\n' + util.inspect(this) + '\\n' +\n      util.inspect(context));\n  } else {\n    assert.ok(index, 'can\\'t remove top context');\n    this._set.splice(index, 1);\n  }\n};\n\nNamespace.prototype.bindEmitter = function bindEmitter(emitter) {\n  assert.ok(emitter.on && emitter.addListener && emitter.emit, 'can only bind real EEs');\n\n  let namespace = this;\n  let thisSymbol = 'context@' + this.name;\n\n  // Capture the context active at the time the emitter is bound.\n  function attach(listener) {\n    if (!listener) {\n      return;\n    }\n    if (!listener[CONTEXTS_SYMBOL]) {\n      listener[CONTEXTS_SYMBOL] = Object.create(null);\n    }\n\n    listener[CONTEXTS_SYMBOL][thisSymbol] = {\n      namespace: namespace,\n      context: namespace.active\n    };\n  }\n\n  // At emit time, bind the listener within the correct context.\n  function bind(unwrapped) {\n    if (!(unwrapped && unwrapped[CONTEXTS_SYMBOL])) {\n      return unwrapped;\n    }\n\n    let wrapped = unwrapped;\n    let unwrappedContexts = unwrapped[CONTEXTS_SYMBOL];\n    Object.keys(unwrappedContexts).forEach(function (name) {\n      let thunk = unwrappedContexts[name];\n      wrapped = thunk.namespace.bind(wrapped, thunk.context);\n    });\n    return wrapped;\n  }\n\n  wrapEmitter(emitter, attach, bind);\n};\n\n/**\n * If an error comes out of a namespace, it will have a context attached to it.\n * This function knows how to find it.\n *\n * @param {Error} exception Possibly annotated error.\n */\nNamespace.prototype.fromException = function fromException(exception) {\n  return exception[ERROR_SYMBOL];\n};\n\nfunction getNamespace(name) {\n  return process.namespaces[name];\n}\n\nfunction createNamespace(name) {\n  assert.ok(name, 'namespace must be given a name.');\n\n  if (DEBUG_CLS_HOOKED) {\n    debug2('CREATING NAMESPACE ' + name);\n  }\n  let namespace = new Namespace(name);\n  namespace.id = currentUid;\n\n  asyncHook.addHooks({\n    init(uid, handle, provider, parentUid, parentHandle) {\n      //parentUid = parentUid || currentUid;  // Suggested usage but appears to work better for tracing modules.\n      currentUid = uid;\n\n      //CHAIN Parent's Context onto child if none exists. This is needed to pass net-events.spec\n      if (parentUid) {\n        namespace._contexts.set(uid, namespace._contexts.get(parentUid));\n        if (DEBUG_CLS_HOOKED) {\n          debug2('PARENTID: ' + name + ' uid:' + uid + ' parent:' + parentUid + ' provider:' + provider);\n        }\n      } else {\n        namespace._contexts.set(currentUid, namespace.active);\n      }\n\n      if (DEBUG_CLS_HOOKED) {\n        debug2('INIT ' + name + ' uid:' + uid + ' parent:' + parentUid + ' provider:' + invertedProviders[provider]\n          + ' active:' + util.inspect(namespace.active, true));\n      }\n\n    },\n    pre(uid, handle) {\n      currentUid = uid;\n      let context = namespace._contexts.get(uid);\n      if (context) {\n        if (DEBUG_CLS_HOOKED) {\n          debug2(' PRE ' + name + ' uid:' + uid + ' handle:' + getFunctionName(handle) + ' context:' +\n            util.inspect(context));\n        }\n\n        namespace.enter(context);\n      } else {\n        if (DEBUG_CLS_HOOKED) {\n          debug2(' PRE MISSING CONTEXT ' + name + ' uid:' + uid + ' handle:' + getFunctionName(handle));\n        }\n      }\n    },\n    post(uid, handle) {\n      currentUid = uid;\n      let context = namespace._contexts.get(uid);\n      if (context) {\n        if (DEBUG_CLS_HOOKED) {\n          debug2(' POST ' + name + ' uid:' + uid + ' handle:' + getFunctionName(handle) + ' context:' +\n            util.inspect(context));\n        }\n\n        namespace.exit(context);\n      } else {\n        if (DEBUG_CLS_HOOKED) {\n          debug2(' POST MISSING CONTEXT ' + name + ' uid:' + uid + ' handle:' + getFunctionName(handle));\n        }\n      }\n    },\n    destroy(uid) {\n      currentUid = uid;\n\n      if (DEBUG_CLS_HOOKED) {\n        debug2('DESTROY ' + name + ' uid:' + uid + ' context:' + util.inspect(namespace._contexts.get(currentUid))\n          + ' active:' + util.inspect(namespace.active, true));\n      }\n\n      namespace._contexts.delete(uid);\n    }\n  });\n\n  process.namespaces[name] = namespace;\n  return namespace;\n}\n\nfunction destroyNamespace(name) {\n  let namespace = getNamespace(name);\n\n  assert.ok(namespace, 'can\\'t delete nonexistent namespace! \"' + name + '\"');\n  assert.ok(namespace.id, 'don\\'t assign to process.namespaces directly! ' + util.inspect(namespace));\n\n  process.namespaces[name] = null;\n}\n\nfunction reset() {\n  // must unregister async listeners\n  if (process.namespaces) {\n    Object.keys(process.namespaces).forEach(function (name) {\n      destroyNamespace(name);\n    });\n  }\n  process.namespaces = Object.create(null);\n}\n\nprocess.namespaces = {};\n\nif (asyncHook._state && !asyncHook._state.enabled) {\n  asyncHook.enable();\n}\n\nfunction debug2(msg) {\n  if (process.env.DEBUG) {\n    process._rawDebug(msg);\n  }\n}\n\n\n/*function debug(from, ns) {\n process._rawDebug('DEBUG: ' + util.inspect({\n from: from,\n currentUid: currentUid,\n context: ns ? ns._contexts.get(currentUid) : 'no ns'\n }, true, 2, true));\n }*/\n\n\nfunction getFunctionName(fn) {\n  if (!fn) {\n    return fn;\n  }\n  if (typeof fn === 'function') {\n    if (fn.name) {\n      return fn.name;\n    }\n    return (fn.toString().trim().match(/^function\\s*([^\\s(]+)/) || [])[1];\n  } else if (fn.constructor && fn.constructor.name) {\n    return fn.constructor.name;\n  }\n}\n\n\n// Add back to callstack\nif (DEBUG_CLS_HOOKED) {\n  var stackChain = require('stack-chain');\n  for (var modifier in stackChain.filter._modifiers) {\n    stackChain.filter.deattach(modifier);\n  }\n}\n","/* eslint-disable max-len */\n'use strict';\n\nconst util = require('util');\nconst assert = require('assert');\nconst wrapEmitter = require('emitter-listener');\nconst async_hooks = require('async_hooks');\n\nconst CONTEXTS_SYMBOL = 'cls@contexts';\nconst ERROR_SYMBOL = 'error@context';\n\nconst DEBUG_CLS_HOOKED = process.env.DEBUG_CLS_HOOKED;\n\nlet currentUid = -1;\n\nmodule.exports = {\n  getNamespace: getNamespace,\n  createNamespace: createNamespace,\n  destroyNamespace: destroyNamespace,\n  reset: reset,\n  ERROR_SYMBOL: ERROR_SYMBOL\n};\n\nfunction Namespace(name) {\n  this.name = name;\n  // changed in 2.7: no default context\n  this.active = null;\n  this._set = [];\n  this.id = null;\n  this._contexts = new Map();\n  this._indent = 0;\n}\n\nNamespace.prototype.set = function set(key, value) {\n  if (!this.active) {\n    throw new Error('No context available. ns.run() or ns.bind() must be called first.');\n  }\n\n  this.active[key] = value;\n\n  if (DEBUG_CLS_HOOKED) {\n    const indentStr = ' '.repeat(this._indent < 0 ? 0 : this._indent);\n    debug2(indentStr + 'CONTEXT-SET KEY:' + key + '=' + value + ' in ns:' + this.name + ' currentUid:' + currentUid + ' active:' + util.inspect(this.active, {showHidden:true, depth:2, colors:true}));\n  }\n\n  return value;\n};\n\nNamespace.prototype.get = function get(key) {\n  if (!this.active) {\n    if (DEBUG_CLS_HOOKED) {\n      const asyncHooksCurrentId = async_hooks.currentId();\n      const triggerId = async_hooks.triggerAsyncId();\n      const indentStr = ' '.repeat(this._indent < 0 ? 0 : this._indent);\n      //debug2(indentStr + 'CONTEXT-GETTING KEY NO ACTIVE NS:' + key + '=undefined' + ' (' + this.name + ') currentUid:' + currentUid + ' active:' + util.inspect(this.active, {showHidden:true, depth:2, colors:true}));\n      debug2(`${indentStr}CONTEXT-GETTING KEY NO ACTIVE NS: (${this.name}) ${key}=undefined currentUid:${currentUid} asyncHooksCurrentId:${asyncHooksCurrentId} triggerId:${triggerId} len:${this._set.length}`);\n    }\n    return undefined;\n  }\n  if (DEBUG_CLS_HOOKED) {\n    const asyncHooksCurrentId = async_hooks.executionAsyncId();\n    const triggerId = async_hooks.triggerAsyncId();\n    const indentStr = ' '.repeat(this._indent < 0 ? 0 : this._indent);\n    debug2(indentStr + 'CONTEXT-GETTING KEY:' + key + '=' + this.active[key] + ' (' + this.name + ') currentUid:' + currentUid + ' active:' + util.inspect(this.active, {showHidden:true, depth:2, colors:true}));\n    debug2(`${indentStr}CONTEXT-GETTING KEY: (${this.name}) ${key}=${this.active[key]} currentUid:${currentUid} asyncHooksCurrentId:${asyncHooksCurrentId} triggerId:${triggerId} len:${this._set.length} active:${util.inspect(this.active)}`);\n  }\n  return this.active[key];\n};\n\nNamespace.prototype.createContext = function createContext() {\n  // Prototype inherit existing context if created a new child context within existing context.\n  let context = Object.create(this.active ? this.active : Object.prototype);\n  context._ns_name = this.name;\n  context.id = currentUid;\n\n  if (DEBUG_CLS_HOOKED) {\n    const asyncHooksCurrentId = async_hooks.executionAsyncId();\n    const triggerId = async_hooks.triggerAsyncId();\n    const indentStr = ' '.repeat(this._indent < 0 ? 0 : this._indent);\n    debug2(`${indentStr}CONTEXT-CREATED Context: (${this.name}) currentUid:${currentUid} asyncHooksCurrentId:${asyncHooksCurrentId} triggerId:${triggerId} len:${this._set.length} context:${util.inspect(context, {showHidden:true, depth:2, colors:true})}`);\n  }\n\n  return context;\n};\n\nNamespace.prototype.run = function run(fn) {\n  let context = this.createContext();\n  this.enter(context);\n\n  try {\n    if (DEBUG_CLS_HOOKED) {\n      const triggerId = async_hooks.triggerAsyncId();\n      const asyncHooksCurrentId = async_hooks.executionAsyncId();\n      const indentStr = ' '.repeat(this._indent < 0 ? 0 : this._indent);\n      debug2(`${indentStr}CONTEXT-RUN BEGIN: (${this.name}) currentUid:${currentUid} triggerId:${triggerId} asyncHooksCurrentId:${asyncHooksCurrentId} len:${this._set.length} context:${util.inspect(context)}`);\n    }\n    fn(context);\n    return context;\n  } catch (exception) {\n    if (exception) {\n      exception[ERROR_SYMBOL] = context;\n    }\n    throw exception;\n  } finally {\n    if (DEBUG_CLS_HOOKED) {\n      const triggerId = async_hooks.triggerAsyncId();\n      const asyncHooksCurrentId = async_hooks.executionAsyncId();\n      const indentStr = ' '.repeat(this._indent < 0 ? 0 : this._indent);\n      debug2(`${indentStr}CONTEXT-RUN END: (${this.name}) currentUid:${currentUid} triggerId:${triggerId} asyncHooksCurrentId:${asyncHooksCurrentId} len:${this._set.length} ${util.inspect(context)}`);\n    }\n    this.exit(context);\n  }\n};\n\nNamespace.prototype.runAndReturn = function runAndReturn(fn) {\n  let value;\n  this.run(function (context) {\n    value = fn(context);\n  });\n  return value;\n};\n\n/**\n * Uses global Promise and assumes Promise is cls friendly or wrapped already.\n * @param {function} fn\n * @returns {*}\n */\nNamespace.prototype.runPromise = function runPromise(fn) {\n  let context = this.createContext();\n  this.enter(context);\n\n  let promise = fn(context);\n  if (!promise || !promise.then || !promise.catch) {\n    throw new Error('fn must return a promise.');\n  }\n\n  if (DEBUG_CLS_HOOKED) {\n    debug2('CONTEXT-runPromise BEFORE: (' + this.name + ') currentUid:' + currentUid + ' len:' + this._set.length + ' ' + util.inspect(context));\n  }\n\n  return promise\n    .then(result => {\n      if (DEBUG_CLS_HOOKED) {\n        debug2('CONTEXT-runPromise AFTER then: (' + this.name + ') currentUid:' + currentUid + ' len:' + this._set.length + ' ' + util.inspect(context));\n      }\n      this.exit(context);\n      return result;\n    })\n    .catch(err => {\n      err[ERROR_SYMBOL] = context;\n      if (DEBUG_CLS_HOOKED) {\n        debug2('CONTEXT-runPromise AFTER catch: (' + this.name + ') currentUid:' + currentUid + ' len:' + this._set.length + ' ' + util.inspect(context));\n      }\n      this.exit(context);\n      throw err;\n    });\n};\n\nNamespace.prototype.bind = function bindFactory(fn, context) {\n  if (!context) {\n    if (!this.active) {\n      context = this.createContext();\n    } else {\n      context = this.active;\n    }\n  }\n\n  let self = this;\n  return function clsBind() {\n    self.enter(context);\n    try {\n      return fn.apply(this, arguments);\n    } catch (exception) {\n      if (exception) {\n        exception[ERROR_SYMBOL] = context;\n      }\n      throw exception;\n    } finally {\n      self.exit(context);\n    }\n  };\n};\n\nNamespace.prototype.enter = function enter(context) {\n  assert.ok(context, 'context must be provided for entering');\n  if (DEBUG_CLS_HOOKED) {\n    const asyncHooksCurrentId = async_hooks.executionAsyncId();\n    const triggerId = async_hooks.triggerAsyncId();\n    const indentStr = ' '.repeat(this._indent < 0 ? 0 : this._indent);\n    debug2(`${indentStr}CONTEXT-ENTER: (${this.name}) currentUid:${currentUid} triggerId:${triggerId} asyncHooksCurrentId:${asyncHooksCurrentId} len:${this._set.length} ${util.inspect(context)}`);\n  }\n\n  this._set.push(this.active);\n  this.active = context;\n};\n\nNamespace.prototype.exit = function exit(context) {\n  assert.ok(context, 'context must be provided for exiting');\n  if (DEBUG_CLS_HOOKED) {\n    const asyncHooksCurrentId = async_hooks.executionAsyncId();\n    const triggerId = async_hooks.triggerAsyncId();\n    const indentStr = ' '.repeat(this._indent < 0 ? 0 : this._indent);\n    debug2(`${indentStr}CONTEXT-EXIT: (${this.name}) currentUid:${currentUid} triggerId:${triggerId} asyncHooksCurrentId:${asyncHooksCurrentId} len:${this._set.length} ${util.inspect(context)}`);\n  }\n\n  // Fast path for most exits that are at the top of the stack\n  if (this.active === context) {\n    assert.ok(this._set.length, 'can\\'t remove top context');\n    this.active = this._set.pop();\n    return;\n  }\n\n  // Fast search in the stack using lastIndexOf\n  let index = this._set.lastIndexOf(context);\n\n  if (index < 0) {\n    if (DEBUG_CLS_HOOKED) {\n      debug2('??ERROR?? context exiting but not entered - ignoring: ' + util.inspect(context));\n    }\n    assert.ok(index >= 0, 'context not currently entered; can\\'t exit. \\n' + util.inspect(this) + '\\n' + util.inspect(context));\n  } else {\n    assert.ok(index, 'can\\'t remove top context');\n    this._set.splice(index, 1);\n  }\n};\n\nNamespace.prototype.bindEmitter = function bindEmitter(emitter) {\n  assert.ok(emitter.on && emitter.addListener && emitter.emit, 'can only bind real EEs');\n\n  let namespace = this;\n  let thisSymbol = 'context@' + this.name;\n\n  // Capture the context active at the time the emitter is bound.\n  function attach(listener) {\n    if (!listener) {\n      return;\n    }\n    if (!listener[CONTEXTS_SYMBOL]) {\n      listener[CONTEXTS_SYMBOL] = Object.create(null);\n    }\n\n    listener[CONTEXTS_SYMBOL][thisSymbol] = {\n      namespace: namespace,\n      context: namespace.active\n    };\n  }\n\n  // At emit time, bind the listener within the correct context.\n  function bind(unwrapped) {\n    if (!(unwrapped && unwrapped[CONTEXTS_SYMBOL])) {\n      return unwrapped;\n    }\n\n    let wrapped = unwrapped;\n    let unwrappedContexts = unwrapped[CONTEXTS_SYMBOL];\n    Object.keys(unwrappedContexts).forEach(function (name) {\n      let thunk = unwrappedContexts[name];\n      wrapped = thunk.namespace.bind(wrapped, thunk.context);\n    });\n    return wrapped;\n  }\n\n  wrapEmitter(emitter, attach, bind);\n};\n\n/**\n * If an error comes out of a namespace, it will have a context attached to it.\n * This function knows how to find it.\n *\n * @param {Error} exception Possibly annotated error.\n */\nNamespace.prototype.fromException = function fromException(exception) {\n  return exception[ERROR_SYMBOL];\n};\n\nfunction getNamespace(name) {\n  return process.namespaces[name];\n}\n\nfunction createNamespace(name) {\n  assert.ok(name, 'namespace must be given a name.');\n\n  if (DEBUG_CLS_HOOKED) {\n    debug2(`NS-CREATING NAMESPACE (${name})`);\n  }\n  let namespace = new Namespace(name);\n  namespace.id = currentUid;\n\n  const hook = async_hooks.createHook({\n    init(asyncId, type, triggerId, resource) {\n      currentUid = async_hooks.executionAsyncId();\n\n      //CHAIN Parent's Context onto child if none exists. This is needed to pass net-events.spec\n      // let initContext = namespace.active;\n      // if(!initContext && triggerId) {\n      //   let parentContext = namespace._contexts.get(triggerId);\n      //   if (parentContext) {\n      //     namespace.active = parentContext;\n      //     namespace._contexts.set(currentUid, parentContext);\n      //     if (DEBUG_CLS_HOOKED) {\n      //       const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);\n      //       debug2(`${indentStr}INIT [${type}] (${name}) WITH PARENT CONTEXT asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, true)} resource:${resource}`);\n      //     }\n      //   } else if (DEBUG_CLS_HOOKED) {\n      //       const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);\n      //       debug2(`${indentStr}INIT [${type}] (${name}) MISSING CONTEXT asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, true)} resource:${resource}`);\n      //     }\n      // }else {\n      //   namespace._contexts.set(currentUid, namespace.active);\n      //   if (DEBUG_CLS_HOOKED) {\n      //     const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);\n      //     debug2(`${indentStr}INIT [${type}] (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, true)} resource:${resource}`);\n      //   }\n      // }\n      if(namespace.active) {\n        namespace._contexts.set(asyncId, namespace.active);\n\n        if (DEBUG_CLS_HOOKED) {\n          const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);\n          debug2(`${indentStr}INIT [${type}] (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, {showHidden:true, depth:2, colors:true})} resource:${resource}`);\n        }\n      }else if(currentUid === 0){\n        // CurrentId will be 0 when triggered from C++. Promise events\n        // https://github.com/nodejs/node/blob/master/doc/api/async_hooks.md#triggerid\n        const triggerId = async_hooks.triggerAsyncId();\n        const triggerIdContext = namespace._contexts.get(triggerId);\n        if (triggerIdContext) {\n          namespace._contexts.set(asyncId, triggerIdContext);\n          if (DEBUG_CLS_HOOKED) {\n            const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);\n            debug2(`${indentStr}INIT USING CONTEXT FROM TRIGGERID [${type}] (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, { showHidden: true, depth: 2, colors: true })} resource:${resource}`);\n          }\n        } else if (DEBUG_CLS_HOOKED) {\n          const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);\n          debug2(`${indentStr}INIT MISSING CONTEXT [${type}] (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, { showHidden: true, depth: 2, colors: true })} resource:${resource}`);\n        }\n      }\n\n\n      if(DEBUG_CLS_HOOKED && type === 'PROMISE'){\n        debug2(util.inspect(resource, {showHidden: true}));\n        const parentId = resource.parentId;\n        const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);\n        debug2(`${indentStr}INIT RESOURCE-PROMISE [${type}] (${name}) parentId:${parentId} asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, {showHidden:true, depth:2, colors:true})} resource:${resource}`);\n      }\n\n    },\n    before(asyncId) {\n      currentUid = async_hooks.executionAsyncId();\n      let context;\n\n      /*\n      if(currentUid === 0){\n        // CurrentId will be 0 when triggered from C++. Promise events\n        // https://github.com/nodejs/node/blob/master/doc/api/async_hooks.md#triggerid\n        //const triggerId = async_hooks.triggerAsyncId();\n        context = namespace._contexts.get(asyncId); // || namespace._contexts.get(triggerId);\n      }else{\n        context = namespace._contexts.get(currentUid);\n      }\n      */\n\n      //HACK to work with promises until they are fixed in node > 8.1.1\n      context = namespace._contexts.get(asyncId) || namespace._contexts.get(currentUid);\n\n      if (context) {\n        if (DEBUG_CLS_HOOKED) {\n          const triggerId = async_hooks.triggerAsyncId();\n          const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);\n          debug2(`${indentStr}BEFORE (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, {showHidden:true, depth:2, colors:true})} context:${util.inspect(context)}`);\n          namespace._indent += 2;\n        }\n\n        namespace.enter(context);\n\n      } else if (DEBUG_CLS_HOOKED) {\n        const triggerId = async_hooks.triggerAsyncId();\n        const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);\n        debug2(`${indentStr}BEFORE MISSING CONTEXT (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, {showHidden:true, depth:2, colors:true})} namespace._contexts:${util.inspect(namespace._contexts, {showHidden:true, depth:2, colors:true})}`);\n        namespace._indent += 2;\n      }\n    },\n    after(asyncId) {\n      currentUid = async_hooks.executionAsyncId();\n      let context; // = namespace._contexts.get(currentUid);\n      /*\n      if(currentUid === 0){\n        // CurrentId will be 0 when triggered from C++. Promise events\n        // https://github.com/nodejs/node/blob/master/doc/api/async_hooks.md#triggerid\n        //const triggerId = async_hooks.triggerAsyncId();\n        context = namespace._contexts.get(asyncId); // || namespace._contexts.get(triggerId);\n      }else{\n        context = namespace._contexts.get(currentUid);\n      }\n      */\n      //HACK to work with promises until they are fixed in node > 8.1.1\n      context = namespace._contexts.get(asyncId) || namespace._contexts.get(currentUid);\n\n      if (context) {\n        if (DEBUG_CLS_HOOKED) {\n          const triggerId = async_hooks.triggerAsyncId();\n          namespace._indent -= 2;\n          const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);\n          debug2(`${indentStr}AFTER (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, {showHidden:true, depth:2, colors:true})} context:${util.inspect(context)}`);\n        }\n\n        namespace.exit(context);\n\n      } else if (DEBUG_CLS_HOOKED) {\n        const triggerId = async_hooks.triggerAsyncId();\n        namespace._indent -= 2;\n        const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);\n        debug2(`${indentStr}AFTER MISSING CONTEXT (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, {showHidden:true, depth:2, colors:true})} context:${util.inspect(context)}`);\n      }\n    },\n    destroy(asyncId) {\n      currentUid = async_hooks.executionAsyncId();\n      if (DEBUG_CLS_HOOKED) {\n        const triggerId = async_hooks.triggerAsyncId();\n        const indentStr = ' '.repeat(namespace._indent < 0 ? 0 : namespace._indent);\n        debug2(`${indentStr}DESTROY (${name}) currentUid:${currentUid} asyncId:${asyncId} triggerId:${triggerId} active:${util.inspect(namespace.active, {showHidden:true, depth:2, colors:true})} context:${util.inspect(namespace._contexts.get(currentUid))}`);\n      }\n\n      namespace._contexts.delete(asyncId);\n    }\n  });\n\n  hook.enable();\n\n  process.namespaces[name] = namespace;\n  return namespace;\n}\n\nfunction destroyNamespace(name) {\n  let namespace = getNamespace(name);\n\n  assert.ok(namespace, 'can\\'t delete nonexistent namespace! \"' + name + '\"');\n  assert.ok(namespace.id, 'don\\'t assign to process.namespaces directly! ' + util.inspect(namespace));\n\n  process.namespaces[name] = null;\n}\n\nfunction reset() {\n  // must unregister async listeners\n  if (process.namespaces) {\n    Object.keys(process.namespaces).forEach(function (name) {\n      destroyNamespace(name);\n    });\n  }\n  process.namespaces = Object.create(null);\n}\n\nprocess.namespaces = {};\n\n//const fs = require('fs');\nfunction debug2(...args) {\n  if (DEBUG_CLS_HOOKED) {\n    //fs.writeSync(1, `${util.format(...args)}\\n`);\n    process._rawDebug(`${util.format(...args)}`);\n  }\n}\n\n/*function getFunctionName(fn) {\n  if (!fn) {\n    return fn;\n  }\n  if (typeof fn === 'function') {\n    if (fn.name) {\n      return fn.name;\n    }\n    return (fn.toString().trim().match(/^function\\s*([^\\s(]+)/) || [])[1];\n  } else if (fn.constructor && fn.constructor.name) {\n    return fn.constructor.name;\n  }\n}*/\n\n\n","'use strict';\n\nconst semver = require('semver');\n\n/**\n * In order to increase node version support, this loads the version of context\n * that is appropriate for the version of on nodejs that is running.\n * Node < v8 - uses AsyncWrap and async-hooks-jl\n * Node >= v8 - uses native async-hooks\n */\nif(process && semver.gte(process.versions.node, '8.0.0')){\n  module.exports = require('./context');\n}else{\n  module.exports = require('./context-legacy');\n}\n","/* MIT license */\nvar cssKeywords = require('color-name');\n\n// NOTE: conversions should only return primitive values (i.e. arrays, or\n//       values that give correct `typeof` results).\n//       do not use box values types (i.e. Number(), String(), etc.)\n\nvar reverseKeywords = {};\nfor (var key in cssKeywords) {\n\tif (cssKeywords.hasOwnProperty(key)) {\n\t\treverseKeywords[cssKeywords[key]] = key;\n\t}\n}\n\nvar convert = module.exports = {\n\trgb: {channels: 3, labels: 'rgb'},\n\thsl: {channels: 3, labels: 'hsl'},\n\thsv: {channels: 3, labels: 'hsv'},\n\thwb: {channels: 3, labels: 'hwb'},\n\tcmyk: {channels: 4, labels: 'cmyk'},\n\txyz: {channels: 3, labels: 'xyz'},\n\tlab: {channels: 3, labels: 'lab'},\n\tlch: {channels: 3, labels: 'lch'},\n\thex: {channels: 1, labels: ['hex']},\n\tkeyword: {channels: 1, labels: ['keyword']},\n\tansi16: {channels: 1, labels: ['ansi16']},\n\tansi256: {channels: 1, labels: ['ansi256']},\n\thcg: {channels: 3, labels: ['h', 'c', 'g']},\n\tapple: {channels: 3, labels: ['r16', 'g16', 'b16']},\n\tgray: {channels: 1, labels: ['gray']}\n};\n\n// hide .channels and .labels properties\nfor (var model in convert) {\n\tif (convert.hasOwnProperty(model)) {\n\t\tif (!('channels' in convert[model])) {\n\t\t\tthrow new Error('missing channels property: ' + model);\n\t\t}\n\n\t\tif (!('labels' in convert[model])) {\n\t\t\tthrow new Error('missing channel labels property: ' + model);\n\t\t}\n\n\t\tif (convert[model].labels.length !== convert[model].channels) {\n\t\t\tthrow new Error('channel and label counts mismatch: ' + model);\n\t\t}\n\n\t\tvar channels = convert[model].channels;\n\t\tvar labels = convert[model].labels;\n\t\tdelete convert[model].channels;\n\t\tdelete convert[model].labels;\n\t\tObject.defineProperty(convert[model], 'channels', {value: channels});\n\t\tObject.defineProperty(convert[model], 'labels', {value: labels});\n\t}\n}\n\nconvert.rgb.hsl = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tvar min = Math.min(r, g, b);\n\tvar max = Math.max(r, g, b);\n\tvar delta = max - min;\n\tvar h;\n\tvar s;\n\tvar l;\n\n\tif (max === min) {\n\t\th = 0;\n\t} else if (r === max) {\n\t\th = (g - b) / delta;\n\t} else if (g === max) {\n\t\th = 2 + (b - r) / delta;\n\t} else if (b === max) {\n\t\th = 4 + (r - g) / delta;\n\t}\n\n\th = Math.min(h * 60, 360);\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tl = (min + max) / 2;\n\n\tif (max === min) {\n\t\ts = 0;\n\t} else if (l <= 0.5) {\n\t\ts = delta / (max + min);\n\t} else {\n\t\ts = delta / (2 - max - min);\n\t}\n\n\treturn [h, s * 100, l * 100];\n};\n\nconvert.rgb.hsv = function (rgb) {\n\tvar rdif;\n\tvar gdif;\n\tvar bdif;\n\tvar h;\n\tvar s;\n\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tvar v = Math.max(r, g, b);\n\tvar diff = v - Math.min(r, g, b);\n\tvar diffc = function (c) {\n\t\treturn (v - c) / 6 / diff + 1 / 2;\n\t};\n\n\tif (diff === 0) {\n\t\th = s = 0;\n\t} else {\n\t\ts = diff / v;\n\t\trdif = diffc(r);\n\t\tgdif = diffc(g);\n\t\tbdif = diffc(b);\n\n\t\tif (r === v) {\n\t\t\th = bdif - gdif;\n\t\t} else if (g === v) {\n\t\t\th = (1 / 3) + rdif - bdif;\n\t\t} else if (b === v) {\n\t\t\th = (2 / 3) + gdif - rdif;\n\t\t}\n\t\tif (h < 0) {\n\t\t\th += 1;\n\t\t} else if (h > 1) {\n\t\t\th -= 1;\n\t\t}\n\t}\n\n\treturn [\n\t\th * 360,\n\t\ts * 100,\n\t\tv * 100\n\t];\n};\n\nconvert.rgb.hwb = function (rgb) {\n\tvar r = rgb[0];\n\tvar g = rgb[1];\n\tvar b = rgb[2];\n\tvar h = convert.rgb.hsl(rgb)[0];\n\tvar w = 1 / 255 * Math.min(r, Math.min(g, b));\n\n\tb = 1 - 1 / 255 * Math.max(r, Math.max(g, b));\n\n\treturn [h, w * 100, b * 100];\n};\n\nconvert.rgb.cmyk = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tvar c;\n\tvar m;\n\tvar y;\n\tvar k;\n\n\tk = Math.min(1 - r, 1 - g, 1 - b);\n\tc = (1 - r - k) / (1 - k) || 0;\n\tm = (1 - g - k) / (1 - k) || 0;\n\ty = (1 - b - k) / (1 - k) || 0;\n\n\treturn [c * 100, m * 100, y * 100, k * 100];\n};\n\n/**\n * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance\n * */\nfunction comparativeDistance(x, y) {\n\treturn (\n\t\tMath.pow(x[0] - y[0], 2) +\n\t\tMath.pow(x[1] - y[1], 2) +\n\t\tMath.pow(x[2] - y[2], 2)\n\t);\n}\n\nconvert.rgb.keyword = function (rgb) {\n\tvar reversed = reverseKeywords[rgb];\n\tif (reversed) {\n\t\treturn reversed;\n\t}\n\n\tvar currentClosestDistance = Infinity;\n\tvar currentClosestKeyword;\n\n\tfor (var keyword in cssKeywords) {\n\t\tif (cssKeywords.hasOwnProperty(keyword)) {\n\t\t\tvar value = cssKeywords[keyword];\n\n\t\t\t// Compute comparative distance\n\t\t\tvar distance = comparativeDistance(rgb, value);\n\n\t\t\t// Check if its less, if so set as closest\n\t\t\tif (distance < currentClosestDistance) {\n\t\t\t\tcurrentClosestDistance = distance;\n\t\t\t\tcurrentClosestKeyword = keyword;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn currentClosestKeyword;\n};\n\nconvert.keyword.rgb = function (keyword) {\n\treturn cssKeywords[keyword];\n};\n\nconvert.rgb.xyz = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\n\t// assume sRGB\n\tr = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);\n\tg = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);\n\tb = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);\n\n\tvar x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);\n\tvar y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\n\tvar z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\n\n\treturn [x * 100, y * 100, z * 100];\n};\n\nconvert.rgb.lab = function (rgb) {\n\tvar xyz = convert.rgb.xyz(rgb);\n\tvar x = xyz[0];\n\tvar y = xyz[1];\n\tvar z = xyz[2];\n\tvar l;\n\tvar a;\n\tvar b;\n\n\tx /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);\n\tz = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);\n\n\tl = (116 * y) - 16;\n\ta = 500 * (x - y);\n\tb = 200 * (y - z);\n\n\treturn [l, a, b];\n};\n\nconvert.hsl.rgb = function (hsl) {\n\tvar h = hsl[0] / 360;\n\tvar s = hsl[1] / 100;\n\tvar l = hsl[2] / 100;\n\tvar t1;\n\tvar t2;\n\tvar t3;\n\tvar rgb;\n\tvar val;\n\n\tif (s === 0) {\n\t\tval = l * 255;\n\t\treturn [val, val, val];\n\t}\n\n\tif (l < 0.5) {\n\t\tt2 = l * (1 + s);\n\t} else {\n\t\tt2 = l + s - l * s;\n\t}\n\n\tt1 = 2 * l - t2;\n\n\trgb = [0, 0, 0];\n\tfor (var i = 0; i < 3; i++) {\n\t\tt3 = h + 1 / 3 * -(i - 1);\n\t\tif (t3 < 0) {\n\t\t\tt3++;\n\t\t}\n\t\tif (t3 > 1) {\n\t\t\tt3--;\n\t\t}\n\n\t\tif (6 * t3 < 1) {\n\t\t\tval = t1 + (t2 - t1) * 6 * t3;\n\t\t} else if (2 * t3 < 1) {\n\t\t\tval = t2;\n\t\t} else if (3 * t3 < 2) {\n\t\t\tval = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n\t\t} else {\n\t\t\tval = t1;\n\t\t}\n\n\t\trgb[i] = val * 255;\n\t}\n\n\treturn rgb;\n};\n\nconvert.hsl.hsv = function (hsl) {\n\tvar h = hsl[0];\n\tvar s = hsl[1] / 100;\n\tvar l = hsl[2] / 100;\n\tvar smin = s;\n\tvar lmin = Math.max(l, 0.01);\n\tvar sv;\n\tvar v;\n\n\tl *= 2;\n\ts *= (l <= 1) ? l : 2 - l;\n\tsmin *= lmin <= 1 ? lmin : 2 - lmin;\n\tv = (l + s) / 2;\n\tsv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);\n\n\treturn [h, sv * 100, v * 100];\n};\n\nconvert.hsv.rgb = function (hsv) {\n\tvar h = hsv[0] / 60;\n\tvar s = hsv[1] / 100;\n\tvar v = hsv[2] / 100;\n\tvar hi = Math.floor(h) % 6;\n\n\tvar f = h - Math.floor(h);\n\tvar p = 255 * v * (1 - s);\n\tvar q = 255 * v * (1 - (s * f));\n\tvar t = 255 * v * (1 - (s * (1 - f)));\n\tv *= 255;\n\n\tswitch (hi) {\n\t\tcase 0:\n\t\t\treturn [v, t, p];\n\t\tcase 1:\n\t\t\treturn [q, v, p];\n\t\tcase 2:\n\t\t\treturn [p, v, t];\n\t\tcase 3:\n\t\t\treturn [p, q, v];\n\t\tcase 4:\n\t\t\treturn [t, p, v];\n\t\tcase 5:\n\t\t\treturn [v, p, q];\n\t}\n};\n\nconvert.hsv.hsl = function (hsv) {\n\tvar h = hsv[0];\n\tvar s = hsv[1] / 100;\n\tvar v = hsv[2] / 100;\n\tvar vmin = Math.max(v, 0.01);\n\tvar lmin;\n\tvar sl;\n\tvar l;\n\n\tl = (2 - s) * v;\n\tlmin = (2 - s) * vmin;\n\tsl = s * vmin;\n\tsl /= (lmin <= 1) ? lmin : 2 - lmin;\n\tsl = sl || 0;\n\tl /= 2;\n\n\treturn [h, sl * 100, l * 100];\n};\n\n// http://dev.w3.org/csswg/css-color/#hwb-to-rgb\nconvert.hwb.rgb = function (hwb) {\n\tvar h = hwb[0] / 360;\n\tvar wh = hwb[1] / 100;\n\tvar bl = hwb[2] / 100;\n\tvar ratio = wh + bl;\n\tvar i;\n\tvar v;\n\tvar f;\n\tvar n;\n\n\t// wh + bl cant be > 1\n\tif (ratio > 1) {\n\t\twh /= ratio;\n\t\tbl /= ratio;\n\t}\n\n\ti = Math.floor(6 * h);\n\tv = 1 - bl;\n\tf = 6 * h - i;\n\n\tif ((i & 0x01) !== 0) {\n\t\tf = 1 - f;\n\t}\n\n\tn = wh + f * (v - wh); // linear interpolation\n\n\tvar r;\n\tvar g;\n\tvar b;\n\tswitch (i) {\n\t\tdefault:\n\t\tcase 6:\n\t\tcase 0: r = v; g = n; b = wh; break;\n\t\tcase 1: r = n; g = v; b = wh; break;\n\t\tcase 2: r = wh; g = v; b = n; break;\n\t\tcase 3: r = wh; g = n; b = v; break;\n\t\tcase 4: r = n; g = wh; b = v; break;\n\t\tcase 5: r = v; g = wh; b = n; break;\n\t}\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.cmyk.rgb = function (cmyk) {\n\tvar c = cmyk[0] / 100;\n\tvar m = cmyk[1] / 100;\n\tvar y = cmyk[2] / 100;\n\tvar k = cmyk[3] / 100;\n\tvar r;\n\tvar g;\n\tvar b;\n\n\tr = 1 - Math.min(1, c * (1 - k) + k);\n\tg = 1 - Math.min(1, m * (1 - k) + k);\n\tb = 1 - Math.min(1, y * (1 - k) + k);\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.rgb = function (xyz) {\n\tvar x = xyz[0] / 100;\n\tvar y = xyz[1] / 100;\n\tvar z = xyz[2] / 100;\n\tvar r;\n\tvar g;\n\tvar b;\n\n\tr = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n\tg = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n\tb = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n\t// assume sRGB\n\tr = r > 0.0031308\n\t\t? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)\n\t\t: r * 12.92;\n\n\tg = g > 0.0031308\n\t\t? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)\n\t\t: g * 12.92;\n\n\tb = b > 0.0031308\n\t\t? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)\n\t\t: b * 12.92;\n\n\tr = Math.min(Math.max(0, r), 1);\n\tg = Math.min(Math.max(0, g), 1);\n\tb = Math.min(Math.max(0, b), 1);\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.lab = function (xyz) {\n\tvar x = xyz[0];\n\tvar y = xyz[1];\n\tvar z = xyz[2];\n\tvar l;\n\tvar a;\n\tvar b;\n\n\tx /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);\n\tz = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);\n\n\tl = (116 * y) - 16;\n\ta = 500 * (x - y);\n\tb = 200 * (y - z);\n\n\treturn [l, a, b];\n};\n\nconvert.lab.xyz = function (lab) {\n\tvar l = lab[0];\n\tvar a = lab[1];\n\tvar b = lab[2];\n\tvar x;\n\tvar y;\n\tvar z;\n\n\ty = (l + 16) / 116;\n\tx = a / 500 + y;\n\tz = y - b / 200;\n\n\tvar y2 = Math.pow(y, 3);\n\tvar x2 = Math.pow(x, 3);\n\tvar z2 = Math.pow(z, 3);\n\ty = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;\n\tx = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;\n\tz = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;\n\n\tx *= 95.047;\n\ty *= 100;\n\tz *= 108.883;\n\n\treturn [x, y, z];\n};\n\nconvert.lab.lch = function (lab) {\n\tvar l = lab[0];\n\tvar a = lab[1];\n\tvar b = lab[2];\n\tvar hr;\n\tvar h;\n\tvar c;\n\n\thr = Math.atan2(b, a);\n\th = hr * 360 / 2 / Math.PI;\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tc = Math.sqrt(a * a + b * b);\n\n\treturn [l, c, h];\n};\n\nconvert.lch.lab = function (lch) {\n\tvar l = lch[0];\n\tvar c = lch[1];\n\tvar h = lch[2];\n\tvar a;\n\tvar b;\n\tvar hr;\n\n\thr = h / 360 * 2 * Math.PI;\n\ta = c * Math.cos(hr);\n\tb = c * Math.sin(hr);\n\n\treturn [l, a, b];\n};\n\nconvert.rgb.ansi16 = function (args) {\n\tvar r = args[0];\n\tvar g = args[1];\n\tvar b = args[2];\n\tvar value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization\n\n\tvalue = Math.round(value / 50);\n\n\tif (value === 0) {\n\t\treturn 30;\n\t}\n\n\tvar ansi = 30\n\t\t+ ((Math.round(b / 255) << 2)\n\t\t| (Math.round(g / 255) << 1)\n\t\t| Math.round(r / 255));\n\n\tif (value === 2) {\n\t\tansi += 60;\n\t}\n\n\treturn ansi;\n};\n\nconvert.hsv.ansi16 = function (args) {\n\t// optimization here; we already know the value and don't need to get\n\t// it converted for us.\n\treturn convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);\n};\n\nconvert.rgb.ansi256 = function (args) {\n\tvar r = args[0];\n\tvar g = args[1];\n\tvar b = args[2];\n\n\t// we use the extended greyscale palette here, with the exception of\n\t// black and white. normal palette only has 4 greyscale shades.\n\tif (r === g && g === b) {\n\t\tif (r < 8) {\n\t\t\treturn 16;\n\t\t}\n\n\t\tif (r > 248) {\n\t\t\treturn 231;\n\t\t}\n\n\t\treturn Math.round(((r - 8) / 247) * 24) + 232;\n\t}\n\n\tvar ansi = 16\n\t\t+ (36 * Math.round(r / 255 * 5))\n\t\t+ (6 * Math.round(g / 255 * 5))\n\t\t+ Math.round(b / 255 * 5);\n\n\treturn ansi;\n};\n\nconvert.ansi16.rgb = function (args) {\n\tvar color = args % 10;\n\n\t// handle greyscale\n\tif (color === 0 || color === 7) {\n\t\tif (args > 50) {\n\t\t\tcolor += 3.5;\n\t\t}\n\n\t\tcolor = color / 10.5 * 255;\n\n\t\treturn [color, color, color];\n\t}\n\n\tvar mult = (~~(args > 50) + 1) * 0.5;\n\tvar r = ((color & 1) * mult) * 255;\n\tvar g = (((color >> 1) & 1) * mult) * 255;\n\tvar b = (((color >> 2) & 1) * mult) * 255;\n\n\treturn [r, g, b];\n};\n\nconvert.ansi256.rgb = function (args) {\n\t// handle greyscale\n\tif (args >= 232) {\n\t\tvar c = (args - 232) * 10 + 8;\n\t\treturn [c, c, c];\n\t}\n\n\targs -= 16;\n\n\tvar rem;\n\tvar r = Math.floor(args / 36) / 5 * 255;\n\tvar g = Math.floor((rem = args % 36) / 6) / 5 * 255;\n\tvar b = (rem % 6) / 5 * 255;\n\n\treturn [r, g, b];\n};\n\nconvert.rgb.hex = function (args) {\n\tvar integer = ((Math.round(args[0]) & 0xFF) << 16)\n\t\t+ ((Math.round(args[1]) & 0xFF) << 8)\n\t\t+ (Math.round(args[2]) & 0xFF);\n\n\tvar string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length) + string;\n};\n\nconvert.hex.rgb = function (args) {\n\tvar match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);\n\tif (!match) {\n\t\treturn [0, 0, 0];\n\t}\n\n\tvar colorString = match[0];\n\n\tif (match[0].length === 3) {\n\t\tcolorString = colorString.split('').map(function (char) {\n\t\t\treturn char + char;\n\t\t}).join('');\n\t}\n\n\tvar integer = parseInt(colorString, 16);\n\tvar r = (integer >> 16) & 0xFF;\n\tvar g = (integer >> 8) & 0xFF;\n\tvar b = integer & 0xFF;\n\n\treturn [r, g, b];\n};\n\nconvert.rgb.hcg = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tvar max = Math.max(Math.max(r, g), b);\n\tvar min = Math.min(Math.min(r, g), b);\n\tvar chroma = (max - min);\n\tvar grayscale;\n\tvar hue;\n\n\tif (chroma < 1) {\n\t\tgrayscale = min / (1 - chroma);\n\t} else {\n\t\tgrayscale = 0;\n\t}\n\n\tif (chroma <= 0) {\n\t\thue = 0;\n\t} else\n\tif (max === r) {\n\t\thue = ((g - b) / chroma) % 6;\n\t} else\n\tif (max === g) {\n\t\thue = 2 + (b - r) / chroma;\n\t} else {\n\t\thue = 4 + (r - g) / chroma + 4;\n\t}\n\n\thue /= 6;\n\thue %= 1;\n\n\treturn [hue * 360, chroma * 100, grayscale * 100];\n};\n\nconvert.hsl.hcg = function (hsl) {\n\tvar s = hsl[1] / 100;\n\tvar l = hsl[2] / 100;\n\tvar c = 1;\n\tvar f = 0;\n\n\tif (l < 0.5) {\n\t\tc = 2.0 * s * l;\n\t} else {\n\t\tc = 2.0 * s * (1.0 - l);\n\t}\n\n\tif (c < 1.0) {\n\t\tf = (l - 0.5 * c) / (1.0 - c);\n\t}\n\n\treturn [hsl[0], c * 100, f * 100];\n};\n\nconvert.hsv.hcg = function (hsv) {\n\tvar s = hsv[1] / 100;\n\tvar v = hsv[2] / 100;\n\n\tvar c = s * v;\n\tvar f = 0;\n\n\tif (c < 1.0) {\n\t\tf = (v - c) / (1 - c);\n\t}\n\n\treturn [hsv[0], c * 100, f * 100];\n};\n\nconvert.hcg.rgb = function (hcg) {\n\tvar h = hcg[0] / 360;\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\n\tif (c === 0.0) {\n\t\treturn [g * 255, g * 255, g * 255];\n\t}\n\n\tvar pure = [0, 0, 0];\n\tvar hi = (h % 1) * 6;\n\tvar v = hi % 1;\n\tvar w = 1 - v;\n\tvar mg = 0;\n\n\tswitch (Math.floor(hi)) {\n\t\tcase 0:\n\t\t\tpure[0] = 1; pure[1] = v; pure[2] = 0; break;\n\t\tcase 1:\n\t\t\tpure[0] = w; pure[1] = 1; pure[2] = 0; break;\n\t\tcase 2:\n\t\t\tpure[0] = 0; pure[1] = 1; pure[2] = v; break;\n\t\tcase 3:\n\t\t\tpure[0] = 0; pure[1] = w; pure[2] = 1; break;\n\t\tcase 4:\n\t\t\tpure[0] = v; pure[1] = 0; pure[2] = 1; break;\n\t\tdefault:\n\t\t\tpure[0] = 1; pure[1] = 0; pure[2] = w;\n\t}\n\n\tmg = (1.0 - c) * g;\n\n\treturn [\n\t\t(c * pure[0] + mg) * 255,\n\t\t(c * pure[1] + mg) * 255,\n\t\t(c * pure[2] + mg) * 255\n\t];\n};\n\nconvert.hcg.hsv = function (hcg) {\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\n\tvar v = c + g * (1.0 - c);\n\tvar f = 0;\n\n\tif (v > 0.0) {\n\t\tf = c / v;\n\t}\n\n\treturn [hcg[0], f * 100, v * 100];\n};\n\nconvert.hcg.hsl = function (hcg) {\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\n\tvar l = g * (1.0 - c) + 0.5 * c;\n\tvar s = 0;\n\n\tif (l > 0.0 && l < 0.5) {\n\t\ts = c / (2 * l);\n\t} else\n\tif (l >= 0.5 && l < 1.0) {\n\t\ts = c / (2 * (1 - l));\n\t}\n\n\treturn [hcg[0], s * 100, l * 100];\n};\n\nconvert.hcg.hwb = function (hcg) {\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\tvar v = c + g * (1.0 - c);\n\treturn [hcg[0], (v - c) * 100, (1 - v) * 100];\n};\n\nconvert.hwb.hcg = function (hwb) {\n\tvar w = hwb[1] / 100;\n\tvar b = hwb[2] / 100;\n\tvar v = 1 - b;\n\tvar c = v - w;\n\tvar g = 0;\n\n\tif (c < 1) {\n\t\tg = (v - c) / (1 - c);\n\t}\n\n\treturn [hwb[0], c * 100, g * 100];\n};\n\nconvert.apple.rgb = function (apple) {\n\treturn [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];\n};\n\nconvert.rgb.apple = function (rgb) {\n\treturn [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];\n};\n\nconvert.gray.rgb = function (args) {\n\treturn [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];\n};\n\nconvert.gray.hsl = convert.gray.hsv = function (args) {\n\treturn [0, 0, args[0]];\n};\n\nconvert.gray.hwb = function (gray) {\n\treturn [0, 100, gray[0]];\n};\n\nconvert.gray.cmyk = function (gray) {\n\treturn [0, 0, 0, gray[0]];\n};\n\nconvert.gray.lab = function (gray) {\n\treturn [gray[0], 0, 0];\n};\n\nconvert.gray.hex = function (gray) {\n\tvar val = Math.round(gray[0] / 100 * 255) & 0xFF;\n\tvar integer = (val << 16) + (val << 8) + val;\n\n\tvar string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length) + string;\n};\n\nconvert.rgb.gray = function (rgb) {\n\tvar val = (rgb[0] + rgb[1] + rgb[2]) / 3;\n\treturn [val / 255 * 100];\n};\n","var conversions = require('./conversions');\nvar route = require('./route');\n\nvar convert = {};\n\nvar models = Object.keys(conversions);\n\nfunction wrapRaw(fn) {\n\tvar wrappedFn = function (args) {\n\t\tif (args === undefined || args === null) {\n\t\t\treturn args;\n\t\t}\n\n\t\tif (arguments.length > 1) {\n\t\t\targs = Array.prototype.slice.call(arguments);\n\t\t}\n\n\t\treturn fn(args);\n\t};\n\n\t// preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nfunction wrapRounded(fn) {\n\tvar wrappedFn = function (args) {\n\t\tif (args === undefined || args === null) {\n\t\t\treturn args;\n\t\t}\n\n\t\tif (arguments.length > 1) {\n\t\t\targs = Array.prototype.slice.call(arguments);\n\t\t}\n\n\t\tvar result = fn(args);\n\n\t\t// we're assuming the result is an array here.\n\t\t// see notice in conversions.js; don't use box types\n\t\t// in conversion functions.\n\t\tif (typeof result === 'object') {\n\t\t\tfor (var len = result.length, i = 0; i < len; i++) {\n\t\t\t\tresult[i] = Math.round(result[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t// preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nmodels.forEach(function (fromModel) {\n\tconvert[fromModel] = {};\n\n\tObject.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});\n\tObject.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});\n\n\tvar routes = route(fromModel);\n\tvar routeModels = Object.keys(routes);\n\n\trouteModels.forEach(function (toModel) {\n\t\tvar fn = routes[toModel];\n\n\t\tconvert[fromModel][toModel] = wrapRounded(fn);\n\t\tconvert[fromModel][toModel].raw = wrapRaw(fn);\n\t});\n});\n\nmodule.exports = convert;\n","'use strict'\r\n\r\nmodule.exports = {\r\n\t\"aliceblue\": [240, 248, 255],\r\n\t\"antiquewhite\": [250, 235, 215],\r\n\t\"aqua\": [0, 255, 255],\r\n\t\"aquamarine\": [127, 255, 212],\r\n\t\"azure\": [240, 255, 255],\r\n\t\"beige\": [245, 245, 220],\r\n\t\"bisque\": [255, 228, 196],\r\n\t\"black\": [0, 0, 0],\r\n\t\"blanchedalmond\": [255, 235, 205],\r\n\t\"blue\": [0, 0, 255],\r\n\t\"blueviolet\": [138, 43, 226],\r\n\t\"brown\": [165, 42, 42],\r\n\t\"burlywood\": [222, 184, 135],\r\n\t\"cadetblue\": [95, 158, 160],\r\n\t\"chartreuse\": [127, 255, 0],\r\n\t\"chocolate\": [210, 105, 30],\r\n\t\"coral\": [255, 127, 80],\r\n\t\"cornflowerblue\": [100, 149, 237],\r\n\t\"cornsilk\": [255, 248, 220],\r\n\t\"crimson\": [220, 20, 60],\r\n\t\"cyan\": [0, 255, 255],\r\n\t\"darkblue\": [0, 0, 139],\r\n\t\"darkcyan\": [0, 139, 139],\r\n\t\"darkgoldenrod\": [184, 134, 11],\r\n\t\"darkgray\": [169, 169, 169],\r\n\t\"darkgreen\": [0, 100, 0],\r\n\t\"darkgrey\": [169, 169, 169],\r\n\t\"darkkhaki\": [189, 183, 107],\r\n\t\"darkmagenta\": [139, 0, 139],\r\n\t\"darkolivegreen\": [85, 107, 47],\r\n\t\"darkorange\": [255, 140, 0],\r\n\t\"darkorchid\": [153, 50, 204],\r\n\t\"darkred\": [139, 0, 0],\r\n\t\"darksalmon\": [233, 150, 122],\r\n\t\"darkseagreen\": [143, 188, 143],\r\n\t\"darkslateblue\": [72, 61, 139],\r\n\t\"darkslategray\": [47, 79, 79],\r\n\t\"darkslategrey\": [47, 79, 79],\r\n\t\"darkturquoise\": [0, 206, 209],\r\n\t\"darkviolet\": [148, 0, 211],\r\n\t\"deeppink\": [255, 20, 147],\r\n\t\"deepskyblue\": [0, 191, 255],\r\n\t\"dimgray\": [105, 105, 105],\r\n\t\"dimgrey\": [105, 105, 105],\r\n\t\"dodgerblue\": [30, 144, 255],\r\n\t\"firebrick\": [178, 34, 34],\r\n\t\"floralwhite\": [255, 250, 240],\r\n\t\"forestgreen\": [34, 139, 34],\r\n\t\"fuchsia\": [255, 0, 255],\r\n\t\"gainsboro\": [220, 220, 220],\r\n\t\"ghostwhite\": [248, 248, 255],\r\n\t\"gold\": [255, 215, 0],\r\n\t\"goldenrod\": [218, 165, 32],\r\n\t\"gray\": [128, 128, 128],\r\n\t\"green\": [0, 128, 0],\r\n\t\"greenyellow\": [173, 255, 47],\r\n\t\"grey\": [128, 128, 128],\r\n\t\"honeydew\": [240, 255, 240],\r\n\t\"hotpink\": [255, 105, 180],\r\n\t\"indianred\": [205, 92, 92],\r\n\t\"indigo\": [75, 0, 130],\r\n\t\"ivory\": [255, 255, 240],\r\n\t\"khaki\": [240, 230, 140],\r\n\t\"lavender\": [230, 230, 250],\r\n\t\"lavenderblush\": [255, 240, 245],\r\n\t\"lawngreen\": [124, 252, 0],\r\n\t\"lemonchiffon\": [255, 250, 205],\r\n\t\"lightblue\": [173, 216, 230],\r\n\t\"lightcoral\": [240, 128, 128],\r\n\t\"lightcyan\": [224, 255, 255],\r\n\t\"lightgoldenrodyellow\": [250, 250, 210],\r\n\t\"lightgray\": [211, 211, 211],\r\n\t\"lightgreen\": [144, 238, 144],\r\n\t\"lightgrey\": [211, 211, 211],\r\n\t\"lightpink\": [255, 182, 193],\r\n\t\"lightsalmon\": [255, 160, 122],\r\n\t\"lightseagreen\": [32, 178, 170],\r\n\t\"lightskyblue\": [135, 206, 250],\r\n\t\"lightslategray\": [119, 136, 153],\r\n\t\"lightslategrey\": [119, 136, 153],\r\n\t\"lightsteelblue\": [176, 196, 222],\r\n\t\"lightyellow\": [255, 255, 224],\r\n\t\"lime\": [0, 255, 0],\r\n\t\"limegreen\": [50, 205, 50],\r\n\t\"linen\": [250, 240, 230],\r\n\t\"magenta\": [255, 0, 255],\r\n\t\"maroon\": [128, 0, 0],\r\n\t\"mediumaquamarine\": [102, 205, 170],\r\n\t\"mediumblue\": [0, 0, 205],\r\n\t\"mediumorchid\": [186, 85, 211],\r\n\t\"mediumpurple\": [147, 112, 219],\r\n\t\"mediumseagreen\": [60, 179, 113],\r\n\t\"mediumslateblue\": [123, 104, 238],\r\n\t\"mediumspringgreen\": [0, 250, 154],\r\n\t\"mediumturquoise\": [72, 209, 204],\r\n\t\"mediumvioletred\": [199, 21, 133],\r\n\t\"midnightblue\": [25, 25, 112],\r\n\t\"mintcream\": [245, 255, 250],\r\n\t\"mistyrose\": [255, 228, 225],\r\n\t\"moccasin\": [255, 228, 181],\r\n\t\"navajowhite\": [255, 222, 173],\r\n\t\"navy\": [0, 0, 128],\r\n\t\"oldlace\": [253, 245, 230],\r\n\t\"olive\": [128, 128, 0],\r\n\t\"olivedrab\": [107, 142, 35],\r\n\t\"orange\": [255, 165, 0],\r\n\t\"orangered\": [255, 69, 0],\r\n\t\"orchid\": [218, 112, 214],\r\n\t\"palegoldenrod\": [238, 232, 170],\r\n\t\"palegreen\": [152, 251, 152],\r\n\t\"paleturquoise\": [175, 238, 238],\r\n\t\"palevioletred\": [219, 112, 147],\r\n\t\"papayawhip\": [255, 239, 213],\r\n\t\"peachpuff\": [255, 218, 185],\r\n\t\"peru\": [205, 133, 63],\r\n\t\"pink\": [255, 192, 203],\r\n\t\"plum\": [221, 160, 221],\r\n\t\"powderblue\": [176, 224, 230],\r\n\t\"purple\": [128, 0, 128],\r\n\t\"rebeccapurple\": [102, 51, 153],\r\n\t\"red\": [255, 0, 0],\r\n\t\"rosybrown\": [188, 143, 143],\r\n\t\"royalblue\": [65, 105, 225],\r\n\t\"saddlebrown\": [139, 69, 19],\r\n\t\"salmon\": [250, 128, 114],\r\n\t\"sandybrown\": [244, 164, 96],\r\n\t\"seagreen\": [46, 139, 87],\r\n\t\"seashell\": [255, 245, 238],\r\n\t\"sienna\": [160, 82, 45],\r\n\t\"silver\": [192, 192, 192],\r\n\t\"skyblue\": [135, 206, 235],\r\n\t\"slateblue\": [106, 90, 205],\r\n\t\"slategray\": [112, 128, 144],\r\n\t\"slategrey\": [112, 128, 144],\r\n\t\"snow\": [255, 250, 250],\r\n\t\"springgreen\": [0, 255, 127],\r\n\t\"steelblue\": [70, 130, 180],\r\n\t\"tan\": [210, 180, 140],\r\n\t\"teal\": [0, 128, 128],\r\n\t\"thistle\": [216, 191, 216],\r\n\t\"tomato\": [255, 99, 71],\r\n\t\"turquoise\": [64, 224, 208],\r\n\t\"violet\": [238, 130, 238],\r\n\t\"wheat\": [245, 222, 179],\r\n\t\"white\": [255, 255, 255],\r\n\t\"whitesmoke\": [245, 245, 245],\r\n\t\"yellow\": [255, 255, 0],\r\n\t\"yellowgreen\": [154, 205, 50]\r\n};\r\n","var conversions = require('./conversions');\n\n/*\n\tthis function routes a model to all other models.\n\n\tall functions that are routed have a property `.conversion` attached\n\tto the returned synthetic function. This property is an array\n\tof strings, each with the steps in between the 'from' and 'to'\n\tcolor models (inclusive).\n\n\tconversions that are not possible simply are not included.\n*/\n\nfunction buildGraph() {\n\tvar graph = {};\n\t// https://jsperf.com/object-keys-vs-for-in-with-closure/3\n\tvar models = Object.keys(conversions);\n\n\tfor (var len = models.length, i = 0; i < len; i++) {\n\t\tgraph[models[i]] = {\n\t\t\t// http://jsperf.com/1-vs-infinity\n\t\t\t// micro-opt, but this is simple.\n\t\t\tdistance: -1,\n\t\t\tparent: null\n\t\t};\n\t}\n\n\treturn graph;\n}\n\n// https://en.wikipedia.org/wiki/Breadth-first_search\nfunction deriveBFS(fromModel) {\n\tvar graph = buildGraph();\n\tvar queue = [fromModel]; // unshift -> queue -> pop\n\n\tgraph[fromModel].distance = 0;\n\n\twhile (queue.length) {\n\t\tvar current = queue.pop();\n\t\tvar adjacents = Object.keys(conversions[current]);\n\n\t\tfor (var len = adjacents.length, i = 0; i < len; i++) {\n\t\t\tvar adjacent = adjacents[i];\n\t\t\tvar node = graph[adjacent];\n\n\t\t\tif (node.distance === -1) {\n\t\t\t\tnode.distance = graph[current].distance + 1;\n\t\t\t\tnode.parent = current;\n\t\t\t\tqueue.unshift(adjacent);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn graph;\n}\n\nfunction link(from, to) {\n\treturn function (args) {\n\t\treturn to(from(args));\n\t};\n}\n\nfunction wrapConversion(toModel, graph) {\n\tvar path = [graph[toModel].parent, toModel];\n\tvar fn = conversions[graph[toModel].parent][toModel];\n\n\tvar cur = graph[toModel].parent;\n\twhile (graph[cur].parent) {\n\t\tpath.unshift(graph[cur].parent);\n\t\tfn = link(conversions[graph[cur].parent][cur], fn);\n\t\tcur = graph[cur].parent;\n\t}\n\n\tfn.conversion = path;\n\treturn fn;\n}\n\nmodule.exports = function (fromModel) {\n\tvar graph = deriveBFS(fromModel);\n\tvar conversion = {};\n\n\tvar models = Object.keys(graph);\n\tfor (var len = models.length, i = 0; i < len; i++) {\n\t\tvar toModel = models[i];\n\t\tvar node = graph[toModel];\n\n\t\tif (node.parent === null) {\n\t\t\t// no possible conversion, or this node is the source model.\n\t\t\tcontinue;\n\t\t}\n\n\t\tconversion[toModel] = wrapConversion(toModel, graph);\n\t}\n\n\treturn conversion;\n};\n\n","'use strict';\n\nvar assert      = require('assert');\nvar wrapEmitter = require('emitter-listener');\n\n/*\n *\n * CONSTANTS\n *\n */\nvar CONTEXTS_SYMBOL = 'cls@contexts';\nvar ERROR_SYMBOL = 'error@context';\n\n// load polyfill if native support is unavailable\nif (!process.addAsyncListener) require('async-listener');\n\nfunction Namespace(name) {\n  this.name   = name;\n  // changed in 2.7: no default context\n  this.active = null;\n  this._set   = [];\n  this.id     = null;\n}\n\nNamespace.prototype.set = function (key, value) {\n  if (!this.active) {\n    throw new Error(\"No context available. ns.run() or ns.bind() must be called first.\");\n  }\n\n  this.active[key] = value;\n  return value;\n};\n\nNamespace.prototype.get = function (key) {\n  if (!this.active) return undefined;\n\n  return this.active[key];\n};\n\nNamespace.prototype.createContext = function () {\n  return Object.create(this.active);\n};\n\nNamespace.prototype.run = function (fn) {\n  var context = this.createContext();\n  this.enter(context);\n  try {\n    fn(context);\n    return context;\n  }\n  catch (exception) {\n    if (exception) {\n      exception[ERROR_SYMBOL] = context;\n    }\n    throw exception;\n  }\n  finally {\n    this.exit(context);\n  }\n};\n\nNamespace.prototype.runAndReturn = function (fn) {\n  var value;\n  this.run(function (context) {\n    value = fn(context);\n  });\n  return value;\n};\n\nNamespace.prototype.bind = function (fn, context) {\n  if (!context) {\n    if (!this.active) {\n      context = this.createContext();\n    }\n    else {\n      context = this.active;\n    }\n  }\n\n  var self = this;\n  return function () {\n    self.enter(context);\n    try {\n      return fn.apply(this, arguments);\n    }\n    catch (exception) {\n      if (exception) {\n        exception[ERROR_SYMBOL] = context;\n      }\n      throw exception;\n    }\n    finally {\n      self.exit(context);\n    }\n  };\n};\n\nNamespace.prototype.enter = function (context) {\n  assert.ok(context, \"context must be provided for entering\");\n\n  this._set.push(this.active);\n  this.active = context;\n};\n\nNamespace.prototype.exit = function (context) {\n  assert.ok(context, \"context must be provided for exiting\");\n\n  // Fast path for most exits that are at the top of the stack\n  if (this.active === context) {\n    assert.ok(this._set.length, \"can't remove top context\");\n    this.active = this._set.pop();\n    return;\n  }\n\n  // Fast search in the stack using lastIndexOf\n  var index = this._set.lastIndexOf(context);\n\n  assert.ok(index >= 0, \"context not currently entered; can't exit\");\n  assert.ok(index,      \"can't remove top context\");\n\n  this._set.splice(index, 1);\n};\n\nNamespace.prototype.bindEmitter = function (emitter) {\n  assert.ok(emitter.on && emitter.addListener && emitter.emit, \"can only bind real EEs\");\n\n  var namespace  = this;\n  var thisSymbol = 'context@' + this.name;\n\n  // Capture the context active at the time the emitter is bound.\n  function attach(listener) {\n    if (!listener) return;\n    if (!listener[CONTEXTS_SYMBOL]) listener[CONTEXTS_SYMBOL] = Object.create(null);\n\n    listener[CONTEXTS_SYMBOL][thisSymbol] = {\n      namespace : namespace,\n      context   : namespace.active\n    };\n  }\n\n  // At emit time, bind the listener within the correct context.\n  function bind(unwrapped) {\n    if (!(unwrapped && unwrapped[CONTEXTS_SYMBOL])) return unwrapped;\n\n    var wrapped  = unwrapped;\n    var contexts = unwrapped[CONTEXTS_SYMBOL];\n    Object.keys(contexts).forEach(function (name) {\n      var thunk = contexts[name];\n      wrapped = thunk.namespace.bind(wrapped, thunk.context);\n    });\n    return wrapped;\n  }\n\n  wrapEmitter(emitter, attach, bind);\n};\n\n/**\n * If an error comes out of a namespace, it will have a context attached to it.\n * This function knows how to find it.\n *\n * @param {Error} exception Possibly annotated error.\n */\nNamespace.prototype.fromException = function (exception) {\n  return exception[ERROR_SYMBOL];\n};\n\nfunction get(name) {\n  return process.namespaces[name];\n}\n\nfunction create(name) {\n  assert.ok(name, \"namespace must be given a name!\");\n\n  var namespace = new Namespace(name);\n  namespace.id = process.addAsyncListener({\n    create : function () { return namespace.active; },\n    before : function (context, storage) { if (storage) namespace.enter(storage); },\n    after  : function (context, storage) { if (storage) namespace.exit(storage); },\n    error  : function (storage) { if (storage) namespace.exit(storage); }\n  });\n\n  process.namespaces[name] = namespace;\n  return namespace;\n}\n\nfunction destroy(name) {\n  var namespace = get(name);\n\n  assert.ok(namespace,    \"can't delete nonexistent namespace!\");\n  assert.ok(namespace.id, \"don't assign to process.namespaces directly!\");\n\n  process.removeAsyncListener(namespace.id);\n  process.namespaces[name] = null;\n}\n\nfunction reset() {\n  // must unregister async listeners\n  if (process.namespaces) {\n    Object.keys(process.namespaces).forEach(function (name) {\n      destroy(name);\n    });\n  }\n  process.namespaces = Object.create(null);\n}\nif (!process.namespaces) reset(); // call immediately to set up\n\nmodule.exports = {\n  getNamespace     : get,\n  createNamespace  : create,\n  destroyNamespace : destroy,\n  reset            : reset\n};\n","/*\n * Date Format 1.2.3\n * (c) 2007-2009 Steven Levithan <stevenlevithan.com>\n * MIT license\n *\n * Includes enhancements by Scott Trenda <scott.trenda.net>\n * and Kris Kowal <cixar.com/~kris.kowal/>\n *\n * Accepts a date, a mask, or a date and a mask.\n * Returns a formatted version of the given date.\n * The date defaults to the current date/time.\n * The mask defaults to dateFormat.masks.default.\n */\n\n(function(global) {\n  'use strict';\n\n  var dateFormat = (function() {\n      var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\\1?|[LloSZWN]|\"[^\"]*\"|'[^']*'/g;\n      var timezone = /\\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\\d{4})?)\\b/g;\n      var timezoneClip = /[^-+\\dA-Z]/g;\n  \n      // Regexes and supporting functions are cached through closure\n      return function (date, mask, utc, gmt) {\n  \n        // You can't provide utc if you skip other args (use the 'UTC:' mask prefix)\n        if (arguments.length === 1 && kindOf(date) === 'string' && !/\\d/.test(date)) {\n          mask = date;\n          date = undefined;\n        }\n  \n        date = date || new Date;\n  \n        if(!(date instanceof Date)) {\n          date = new Date(date);\n        }\n  \n        if (isNaN(date)) {\n          throw TypeError('Invalid date');\n        }\n  \n        mask = String(dateFormat.masks[mask] || mask || dateFormat.masks['default']);\n  \n        // Allow setting the utc/gmt argument via the mask\n        var maskSlice = mask.slice(0, 4);\n        if (maskSlice === 'UTC:' || maskSlice === 'GMT:') {\n          mask = mask.slice(4);\n          utc = true;\n          if (maskSlice === 'GMT:') {\n            gmt = true;\n          }\n        }\n  \n        var _ = utc ? 'getUTC' : 'get';\n        var d = date[_ + 'Date']();\n        var D = date[_ + 'Day']();\n        var m = date[_ + 'Month']();\n        var y = date[_ + 'FullYear']();\n        var H = date[_ + 'Hours']();\n        var M = date[_ + 'Minutes']();\n        var s = date[_ + 'Seconds']();\n        var L = date[_ + 'Milliseconds']();\n        var o = utc ? 0 : date.getTimezoneOffset();\n        var W = getWeek(date);\n        var N = getDayOfWeek(date);\n        var flags = {\n          d:    d,\n          dd:   pad(d),\n          ddd:  dateFormat.i18n.dayNames[D],\n          dddd: dateFormat.i18n.dayNames[D + 7],\n          m:    m + 1,\n          mm:   pad(m + 1),\n          mmm:  dateFormat.i18n.monthNames[m],\n          mmmm: dateFormat.i18n.monthNames[m + 12],\n          yy:   String(y).slice(2),\n          yyyy: y,\n          h:    H % 12 || 12,\n          hh:   pad(H % 12 || 12),\n          H:    H,\n          HH:   pad(H),\n          M:    M,\n          MM:   pad(M),\n          s:    s,\n          ss:   pad(s),\n          l:    pad(L, 3),\n          L:    pad(Math.round(L / 10)),\n          t:    H < 12 ? dateFormat.i18n.timeNames[0] : dateFormat.i18n.timeNames[1],\n          tt:   H < 12 ? dateFormat.i18n.timeNames[2] : dateFormat.i18n.timeNames[3],\n          T:    H < 12 ? dateFormat.i18n.timeNames[4] : dateFormat.i18n.timeNames[5],\n          TT:   H < 12 ? dateFormat.i18n.timeNames[6] : dateFormat.i18n.timeNames[7],\n          Z:    gmt ? 'GMT' : utc ? 'UTC' : (String(date).match(timezone) || ['']).pop().replace(timezoneClip, ''),\n          o:    (o > 0 ? '-' : '+') + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),\n          S:    ['th', 'st', 'nd', 'rd'][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10],\n          W:    W,\n          N:    N\n        };\n  \n        return mask.replace(token, function (match) {\n          if (match in flags) {\n            return flags[match];\n          }\n          return match.slice(1, match.length - 1);\n        });\n      };\n    })();\n\n  dateFormat.masks = {\n    'default':               'ddd mmm dd yyyy HH:MM:ss',\n    'shortDate':             'm/d/yy',\n    'mediumDate':            'mmm d, yyyy',\n    'longDate':              'mmmm d, yyyy',\n    'fullDate':              'dddd, mmmm d, yyyy',\n    'shortTime':             'h:MM TT',\n    'mediumTime':            'h:MM:ss TT',\n    'longTime':              'h:MM:ss TT Z',\n    'isoDate':               'yyyy-mm-dd',\n    'isoTime':               'HH:MM:ss',\n    'isoDateTime':           'yyyy-mm-dd\\'T\\'HH:MM:sso',\n    'isoUtcDateTime':        'UTC:yyyy-mm-dd\\'T\\'HH:MM:ss\\'Z\\'',\n    'expiresHeaderFormat':   'ddd, dd mmm yyyy HH:MM:ss Z'\n  };\n\n  // Internationalization strings\n  dateFormat.i18n = {\n    dayNames: [\n      'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat',\n      'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'\n    ],\n    monthNames: [\n      'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec',\n      'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'\n    ],\n    timeNames: [\n      'a', 'p', 'am', 'pm', 'A', 'P', 'AM', 'PM'\n    ]\n  };\n\nfunction pad(val, len) {\n  val = String(val);\n  len = len || 2;\n  while (val.length < len) {\n    val = '0' + val;\n  }\n  return val;\n}\n\n/**\n * Get the ISO 8601 week number\n * Based on comments from\n * http://techblog.procurios.nl/k/n618/news/view/33796/14863/Calculate-ISO-8601-week-and-year-in-javascript.html\n *\n * @param  {Object} `date`\n * @return {Number}\n */\nfunction getWeek(date) {\n  // Remove time components of date\n  var targetThursday = new Date(date.getFullYear(), date.getMonth(), date.getDate());\n\n  // Change date to Thursday same week\n  targetThursday.setDate(targetThursday.getDate() - ((targetThursday.getDay() + 6) % 7) + 3);\n\n  // Take January 4th as it is always in week 1 (see ISO 8601)\n  var firstThursday = new Date(targetThursday.getFullYear(), 0, 4);\n\n  // Change date to Thursday same week\n  firstThursday.setDate(firstThursday.getDate() - ((firstThursday.getDay() + 6) % 7) + 3);\n\n  // Check if daylight-saving-time-switch occurred and correct for it\n  var ds = targetThursday.getTimezoneOffset() - firstThursday.getTimezoneOffset();\n  targetThursday.setHours(targetThursday.getHours() - ds);\n\n  // Number of weeks between target Thursday and first Thursday\n  var weekDiff = (targetThursday - firstThursday) / (86400000*7);\n  return 1 + Math.floor(weekDiff);\n}\n\n/**\n * Get ISO-8601 numeric representation of the day of the week\n * 1 (for Monday) through 7 (for Sunday)\n * \n * @param  {Object} `date`\n * @return {Number}\n */\nfunction getDayOfWeek(date) {\n  var dow = date.getDay();\n  if(dow === 0) {\n    dow = 7;\n  }\n  return dow;\n}\n\n/**\n * kind-of shortcut\n * @param  {*} val\n * @return {String}\n */\nfunction kindOf(val) {\n  if (val === null) {\n    return 'null';\n  }\n\n  if (val === undefined) {\n    return 'undefined';\n  }\n\n  if (typeof val !== 'object') {\n    return typeof val;\n  }\n\n  if (Array.isArray(val)) {\n    return 'array';\n  }\n\n  return {}.toString.call(val)\n    .slice(8, -1).toLowerCase();\n};\n\n\n\n  if (typeof define === 'function' && define.amd) {\n    define(function () {\n      return dateFormat;\n    });\n  } else if (typeof exports === 'object') {\n    module.exports = dateFormat;\n  } else {\n    global.dateFormat = dateFormat;\n  }\n})(this);\n","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\nfunction log(...args) {\n\t// This hackery is required for IE8/9, where\n\t// the `console.log` function doesn't have 'apply'\n\treturn typeof console === 'object' &&\n\t\tconsole.log &&\n\t\tconsole.log(...args);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* Active `debug` instances.\n\t*/\n\tcreateDebug.instances = [];\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.enabled = createDebug.enabled(namespace);\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = selectColor(namespace);\n\t\tdebug.destroy = destroy;\n\t\tdebug.extend = extend;\n\t\t// Debug.formatArgs = formatArgs;\n\t\t// debug.rawLog = rawLog;\n\n\t\t// env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\tcreateDebug.instances.push(debug);\n\n\t\treturn debug;\n\t}\n\n\tfunction destroy() {\n\t\tconst index = createDebug.instances.indexOf(this);\n\t\tif (index !== -1) {\n\t\t\tcreateDebug.instances.splice(index, 1);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < createDebug.instances.length; i++) {\n\t\t\tconst instance = createDebug.instances[i];\n\t\t\tinstance.enabled = createDebug.enabled(instance.namespace);\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n","/**\n * Detect Electron renderer / nwjs process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {\n\tmodule.exports = require('./browser.js');\n} else {\n\tmodule.exports = require('./node.js');\n}\n","/**\n * Module dependencies.\n */\n\nconst tty = require('tty');\nconst util = require('util');\n\n/**\n * This is the Node.js implementation of `debug()`.\n */\n\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\ntry {\n\t// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)\n\t// eslint-disable-next-line import/no-extraneous-dependencies\n\tconst supportsColor = require('supports-color');\n\n\tif (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n\t\texports.colors = [\n\t\t\t20,\n\t\t\t21,\n\t\t\t26,\n\t\t\t27,\n\t\t\t32,\n\t\t\t33,\n\t\t\t38,\n\t\t\t39,\n\t\t\t40,\n\t\t\t41,\n\t\t\t42,\n\t\t\t43,\n\t\t\t44,\n\t\t\t45,\n\t\t\t56,\n\t\t\t57,\n\t\t\t62,\n\t\t\t63,\n\t\t\t68,\n\t\t\t69,\n\t\t\t74,\n\t\t\t75,\n\t\t\t76,\n\t\t\t77,\n\t\t\t78,\n\t\t\t79,\n\t\t\t80,\n\t\t\t81,\n\t\t\t92,\n\t\t\t93,\n\t\t\t98,\n\t\t\t99,\n\t\t\t112,\n\t\t\t113,\n\t\t\t128,\n\t\t\t129,\n\t\t\t134,\n\t\t\t135,\n\t\t\t148,\n\t\t\t149,\n\t\t\t160,\n\t\t\t161,\n\t\t\t162,\n\t\t\t163,\n\t\t\t164,\n\t\t\t165,\n\t\t\t166,\n\t\t\t167,\n\t\t\t168,\n\t\t\t169,\n\t\t\t170,\n\t\t\t171,\n\t\t\t172,\n\t\t\t173,\n\t\t\t178,\n\t\t\t179,\n\t\t\t184,\n\t\t\t185,\n\t\t\t196,\n\t\t\t197,\n\t\t\t198,\n\t\t\t199,\n\t\t\t200,\n\t\t\t201,\n\t\t\t202,\n\t\t\t203,\n\t\t\t204,\n\t\t\t205,\n\t\t\t206,\n\t\t\t207,\n\t\t\t208,\n\t\t\t209,\n\t\t\t214,\n\t\t\t215,\n\t\t\t220,\n\t\t\t221\n\t\t];\n\t}\n} catch (error) {\n\t// Swallow - we only care if `supports-color` is available; it doesn't have to be.\n}\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(key => {\n\treturn /^debug_/i.test(key);\n}).reduce((obj, key) => {\n\t// Camel-case\n\tconst prop = key\n\t\t.substring(6)\n\t\t.toLowerCase()\n\t\t.replace(/_([a-z])/g, (_, k) => {\n\t\t\treturn k.toUpperCase();\n\t\t});\n\n\t// Coerce string value into JS value\n\tlet val = process.env[key];\n\tif (/^(yes|on|true|enabled)$/i.test(val)) {\n\t\tval = true;\n\t} else if (/^(no|off|false|disabled)$/i.test(val)) {\n\t\tval = false;\n\t} else if (val === 'null') {\n\t\tval = null;\n\t} else {\n\t\tval = Number(val);\n\t}\n\n\tobj[prop] = val;\n\treturn obj;\n}, {});\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n\treturn 'colors' in exports.inspectOpts ?\n\t\tBoolean(exports.inspectOpts.colors) :\n\t\ttty.isatty(process.stderr.fd);\n}\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\tconst {namespace: name, useColors} = this;\n\n\tif (useColors) {\n\t\tconst c = this.color;\n\t\tconst colorCode = '\\u001B[3' + (c < 8 ? c : '8;5;' + c);\n\t\tconst prefix = `  ${colorCode};1m${name} \\u001B[0m`;\n\n\t\targs[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n\t\targs.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\\u001B[0m');\n\t} else {\n\t\targs[0] = getDate() + name + ' ' + args[0];\n\t}\n}\n\nfunction getDate() {\n\tif (exports.inspectOpts.hideDate) {\n\t\treturn '';\n\t}\n\treturn new Date().toISOString() + ' ';\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to stderr.\n */\n\nfunction log(...args) {\n\treturn process.stderr.write(util.format(...args) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\tif (namespaces) {\n\t\tprocess.env.DEBUG = namespaces;\n\t} else {\n\t\t// If you set a process.env field to null or undefined, it gets cast to the\n\t\t// string 'null' or 'undefined'. Just delete instead.\n\t\tdelete process.env.DEBUG;\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n\treturn process.env.DEBUG;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init(debug) {\n\tdebug.inspectOpts = {};\n\n\tconst keys = Object.keys(exports.inspectOpts);\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tdebug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nformatters.o = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts)\n\t\t.replace(/\\s*\\n\\s*/g, ' ');\n};\n\n/**\n * Map %O to `util.inspect()`, allowing multiple lines if needed.\n */\n\nformatters.O = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts);\n};\n","'use strict';\nmodule.exports = function (str, sep) {\n\tif (typeof str !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\tsep = typeof sep === 'undefined' ? '_' : sep;\n\n\treturn str\n\t\t.replace(/([a-z\\d])([A-Z])/g, '$1' + sep + '$2')\n\t\t.replace(/([A-Z]+)([A-Z][a-z\\d]+)/g, '$1' + sep + '$2')\n\t\t.toLowerCase();\n};\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = \"../../node_modules/diagnostic-channel-publishers/dist/src sync recursive ^.*\\\\/lib\\\\/Connection$\";","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = \"../../node_modules/diagnostic-channel-publishers/dist/src sync recursive ^.*\\\\/lib\\\\/Pool$\";","\"use strict\";\r\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar diagnostic_channel_1 = require(\"diagnostic-channel\");\r\nexports.AzureMonitorSymbol = \"Azure_Monitor_Tracer\";\r\nvar isPatched = false;\r\n/**\r\n * By default, @azure/core-tracing default tracer is a NoopTracer.\r\n * This patching changes the default tracer to a patched BasicTracer\r\n * which emits ended spans as diag-channel events.\r\n *\r\n * The @opentelemetry/tracing package must be installed to use these patches\r\n * https://www.npmjs.com/package/@opentelemetry/tracing\r\n * @param coreTracing\r\n */\r\nvar azureCoreTracingPatchFunction = function (coreTracing) {\r\n    if (isPatched) {\r\n        // tracer is already cached -- noop\r\n        return coreTracing;\r\n    }\r\n    try {\r\n        var tracing = require(\"@opentelemetry/tracing\");\r\n        var opentelemetry = require(\"@opentelemetry/api\");\r\n        var tracerConfig = diagnostic_channel_1.channel.spanContextPropagator\r\n            ? { contextManager: diagnostic_channel_1.channel.spanContextPropagator }\r\n            : undefined;\r\n        new tracing.BasicTracerProvider().register(tracerConfig);\r\n        var tracer_1 = opentelemetry.trace.getTracer(\"applicationinsights tracer\");\r\n        // Patch startSpan instead of using spanProcessor.onStart because parentSpan must be\r\n        // set while the span is constructed\r\n        var startSpanOriginal_1 = tracer_1.startSpan;\r\n        tracer_1.startSpan = function (name, options) {\r\n            // if no parent span was provided, apply the current context\r\n            if (!options || !options.parent) {\r\n                var parentOperation = tracer_1.getCurrentSpan();\r\n                if (parentOperation && parentOperation.operation && parentOperation.operation.traceparent) {\r\n                    options = __assign({}, options, { parent: {\r\n                            traceId: parentOperation.operation.traceparent.traceId,\r\n                            spanId: parentOperation.operation.traceparent.spanId,\r\n                            traceFlags: 1,\r\n                        } });\r\n                }\r\n            }\r\n            var span = startSpanOriginal_1.call(this, name, options);\r\n            var originalEnd = span.end;\r\n            span.end = function () {\r\n                var result = originalEnd.apply(this, arguments);\r\n                diagnostic_channel_1.channel.publish(\"azure-coretracing\", span);\r\n                return result;\r\n            };\r\n            return span;\r\n        };\r\n        tracer_1.getCurrentSpan(); // seed OpenTelemetryScopeManagerWrapper with \"active\" symbol\r\n        tracer_1[exports.AzureMonitorSymbol] = true;\r\n        coreTracing.setTracer(tracer_1); // recordSpanData is not present on BasicTracer - cast to any\r\n        isPatched = true;\r\n    }\r\n    catch (e) { /* squash errors */ }\r\n    return coreTracing;\r\n};\r\nexports.azureCoreTracing = {\r\n    versionSpecifier: \">= 1.0.0 < 2.0.0\",\r\n    patch: azureCoreTracingPatchFunction,\r\n};\r\nfunction enable() {\r\n    diagnostic_channel_1.channel.registerMonkeyPatch(\"@azure/core-tracing\", exports.azureCoreTracing);\r\n}\r\nexports.enable = enable;\r\n//# sourceMappingURL=azure-coretracing.pub.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license. See LICENSE file in the project root for details.\r\nvar diagnostic_channel_1 = require(\"diagnostic-channel\");\r\nvar bunyanPatchFunction = function (originalBunyan) {\r\n    var originalEmit = originalBunyan.prototype._emit;\r\n    originalBunyan.prototype._emit = function (rec, noemit) {\r\n        var ret = originalEmit.apply(this, arguments);\r\n        if (!noemit) {\r\n            var str = ret;\r\n            if (!str) {\r\n                str = originalEmit.call(this, rec, true);\r\n            }\r\n            diagnostic_channel_1.channel.publish(\"bunyan\", { level: rec.level, result: str });\r\n        }\r\n        return ret;\r\n    };\r\n    return originalBunyan;\r\n};\r\nexports.bunyan = {\r\n    versionSpecifier: \">= 1.0.0 < 2.0.0\",\r\n    patch: bunyanPatchFunction,\r\n};\r\nfunction enable() {\r\n    diagnostic_channel_1.channel.registerMonkeyPatch(\"bunyan\", exports.bunyan);\r\n}\r\nexports.enable = enable;\r\n//# sourceMappingURL=bunyan.pub.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license. See LICENSE file in the project root for details.\r\nvar diagnostic_channel_1 = require(\"diagnostic-channel\");\r\nvar stream_1 = require(\"stream\");\r\nvar consolePatchFunction = function (originalConsole) {\r\n    var aiLoggingOutStream = new stream_1.Writable();\r\n    var aiLoggingErrStream = new stream_1.Writable();\r\n    // Default console is roughly equivalent to `new Console(process.stdout, process.stderr)`\r\n    // We create a version which publishes to the channel and also to stdout/stderr\r\n    aiLoggingOutStream.write = function (chunk) {\r\n        if (!chunk) {\r\n            return true;\r\n        }\r\n        var message = chunk.toString();\r\n        diagnostic_channel_1.channel.publish(\"console\", { message: message });\r\n        return true;\r\n    };\r\n    aiLoggingErrStream.write = function (chunk) {\r\n        if (!chunk) {\r\n            return true;\r\n        }\r\n        var message = chunk.toString();\r\n        diagnostic_channel_1.channel.publish(\"console\", { message: message, stderr: true });\r\n        return true;\r\n    };\r\n    var aiLoggingConsole = new originalConsole.Console(aiLoggingOutStream, aiLoggingErrStream);\r\n    var consoleMethods = [\"log\", \"info\", \"warn\", \"error\", \"dir\", \"time\", \"timeEnd\", \"trace\", \"assert\"];\r\n    var _loop_1 = function (method) {\r\n        var originalMethod = originalConsole[method];\r\n        if (originalMethod) {\r\n            originalConsole[method] = function () {\r\n                if (aiLoggingConsole[method]) {\r\n                    try {\r\n                        aiLoggingConsole[method].apply(aiLoggingConsole, arguments);\r\n                    }\r\n                    catch (e) {\r\n                        // Ignore errors; allow the original method to throw if necessary\r\n                    }\r\n                }\r\n                return originalMethod.apply(originalConsole, arguments);\r\n            };\r\n        }\r\n    };\r\n    for (var _i = 0, consoleMethods_1 = consoleMethods; _i < consoleMethods_1.length; _i++) {\r\n        var method = consoleMethods_1[_i];\r\n        _loop_1(method);\r\n    }\r\n    return originalConsole;\r\n};\r\nexports.console = {\r\n    versionSpecifier: \">= 4.0.0\",\r\n    patch: consolePatchFunction,\r\n};\r\nfunction enable() {\r\n    diagnostic_channel_1.channel.registerMonkeyPatch(\"console\", exports.console);\r\n    // Force patching of console\r\n    /* tslint:disable-next-line:no-var-requires */\r\n    require(\"console\");\r\n}\r\nexports.enable = enable;\r\n//# sourceMappingURL=console.pub.js.map","\"use strict\";\r\n// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license. See LICENSE file in the project root for details.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar azuresdk = require(\"./azure-coretracing.pub\");\r\nexports.azuresdk = azuresdk;\r\nvar bunyan = require(\"./bunyan.pub\");\r\nexports.bunyan = bunyan;\r\nvar consolePub = require(\"./console.pub\");\r\nexports.console = consolePub;\r\nvar mongodbCore = require(\"./mongodb-core.pub\");\r\nexports.mongodbCore = mongodbCore;\r\nvar mongodb = require(\"./mongodb.pub\");\r\nexports.mongodb = mongodb;\r\nvar mysql = require(\"./mysql.pub\");\r\nexports.mysql = mysql;\r\nvar pgPool = require(\"./pg-pool.pub\");\r\nexports.pgPool = pgPool;\r\nvar pg = require(\"./pg.pub\");\r\nexports.pg = pg;\r\nvar redis = require(\"./redis.pub\");\r\nexports.redis = redis;\r\nvar tedious = require(\"./tedious.pub\");\r\nexports.tedious = tedious;\r\nvar winston = require(\"./winston.pub\");\r\nexports.winston = winston;\r\nfunction enable() {\r\n    bunyan.enable();\r\n    consolePub.enable();\r\n    mongodbCore.enable();\r\n    mongodb.enable();\r\n    mysql.enable();\r\n    pg.enable();\r\n    pgPool.enable();\r\n    redis.enable();\r\n    winston.enable();\r\n    azuresdk.enable();\r\n    tedious.enable();\r\n}\r\nexports.enable = enable;\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license. See LICENSE file in the project root for details.\r\nvar diagnostic_channel_1 = require(\"diagnostic-channel\");\r\nvar mongodbcorePatchFunction = function (originalMongoCore) {\r\n    var originalConnect = originalMongoCore.Server.prototype.connect;\r\n    originalMongoCore.Server.prototype.connect = function contextPreservingConnect() {\r\n        var ret = originalConnect.apply(this, arguments);\r\n        // Messages sent to mongo progress through a pool\r\n        // This can result in context getting mixed between different responses\r\n        // so we wrap the callbacks to restore appropriate state\r\n        var originalWrite = this.s.pool.write;\r\n        this.s.pool.write = function contextPreservingWrite() {\r\n            var cbidx = typeof arguments[1] === \"function\" ? 1 : 2;\r\n            if (typeof arguments[cbidx] === \"function\") {\r\n                arguments[cbidx] = diagnostic_channel_1.channel.bindToContext(arguments[cbidx]);\r\n            }\r\n            return originalWrite.apply(this, arguments);\r\n        };\r\n        // Logout is a special case, it doesn't call the write function but instead\r\n        // directly calls into connection.write\r\n        var originalLogout = this.s.pool.logout;\r\n        this.s.pool.logout = function contextPreservingLogout() {\r\n            if (typeof arguments[1] === \"function\") {\r\n                arguments[1] = diagnostic_channel_1.channel.bindToContext(arguments[1]);\r\n            }\r\n            return originalLogout.apply(this, arguments);\r\n        };\r\n        return ret;\r\n    };\r\n    return originalMongoCore;\r\n};\r\nexports.mongoCore = {\r\n    versionSpecifier: \">= 2.0.0 < 4.0.0\",\r\n    patch: mongodbcorePatchFunction,\r\n};\r\nfunction enable() {\r\n    diagnostic_channel_1.channel.registerMonkeyPatch(\"mongodb-core\", exports.mongoCore);\r\n}\r\nexports.enable = enable;\r\n//# sourceMappingURL=mongodb-core.pub.js.map","\"use strict\";\r\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license. See LICENSE file in the project root for details.\r\nvar diagnostic_channel_1 = require(\"diagnostic-channel\");\r\nvar mongodbPatchFunction = function (originalMongo) {\r\n    var listener = originalMongo.instrument({\r\n        operationIdGenerator: {\r\n            next: function () {\r\n                return diagnostic_channel_1.channel.bindToContext(function (cb) { return cb(); });\r\n            },\r\n        },\r\n    });\r\n    var eventMap = {};\r\n    listener.on(\"started\", function (event) {\r\n        if (eventMap[event.requestId]) {\r\n            // Note: Mongo can generate 2 completely separate requests\r\n            // which share the same requestId, if a certain race condition is triggered.\r\n            // For now, we accept that this can happen and potentially miss or mislabel some events.\r\n            return;\r\n        }\r\n        eventMap[event.requestId] = __assign({}, event, { time: new Date() });\r\n    });\r\n    listener.on(\"succeeded\", function (event) {\r\n        var startedData = eventMap[event.requestId];\r\n        if (startedData) {\r\n            delete eventMap[event.requestId];\r\n        }\r\n        if (typeof event.operationId === \"function\") {\r\n            event.operationId(function () { return diagnostic_channel_1.channel.publish(\"mongodb\", { startedData: startedData, event: event, succeeded: true }); });\r\n        }\r\n        else {\r\n            // fallback -- correlation will not work here\r\n            diagnostic_channel_1.channel.publish(\"mongodb\", { startedData: startedData, event: event, succeeded: true });\r\n        }\r\n    });\r\n    listener.on(\"failed\", function (event) {\r\n        var startedData = eventMap[event.requestId];\r\n        if (startedData) {\r\n            delete eventMap[event.requestId];\r\n        }\r\n        if (typeof event.operationId === \"function\") {\r\n            event.operationId(function () { return diagnostic_channel_1.channel.publish(\"mongodb\", { startedData: startedData, event: event, succeeded: false }); });\r\n        }\r\n        else {\r\n            // fallback -- correlation will not work here\r\n            diagnostic_channel_1.channel.publish(\"mongodb\", { startedData: startedData, event: event, succeeded: false });\r\n        }\r\n    });\r\n    return originalMongo;\r\n};\r\nvar mongodb3PatchFunction = function (originalMongo) {\r\n    var listener = originalMongo.instrument();\r\n    var eventMap = {};\r\n    var contextMap = {};\r\n    listener.on(\"started\", function (event) {\r\n        if (eventMap[event.requestId]) {\r\n            // Note: Mongo can generate 2 completely separate requests\r\n            // which share the same requestId, if a certain race condition is triggered.\r\n            // For now, we accept that this can happen and potentially miss or mislabel some events.\r\n            return;\r\n        }\r\n        contextMap[event.requestId] = diagnostic_channel_1.channel.bindToContext(function (cb) { return cb(); });\r\n        eventMap[event.requestId] = __assign({}, event, { time: new Date() });\r\n    });\r\n    listener.on(\"succeeded\", function (event) {\r\n        var startedData = eventMap[event.requestId];\r\n        if (startedData) {\r\n            delete eventMap[event.requestId];\r\n        }\r\n        if (typeof event === \"object\" && typeof contextMap[event.requestId] === \"function\") {\r\n            contextMap[event.requestId](function () { return diagnostic_channel_1.channel.publish(\"mongodb\", { startedData: startedData, event: event, succeeded: true }); });\r\n            delete contextMap[event.requestId];\r\n        }\r\n    });\r\n    listener.on(\"failed\", function (event) {\r\n        var startedData = eventMap[event.requestId];\r\n        if (startedData) {\r\n            delete eventMap[event.requestId];\r\n        }\r\n        if (typeof event === \"object\" && typeof contextMap[event.requestId] === \"function\") {\r\n            contextMap[event.requestId](function () { return diagnostic_channel_1.channel.publish(\"mongodb\", { startedData: startedData, event: event, succeeded: false }); });\r\n            delete contextMap[event.requestId];\r\n        }\r\n    });\r\n    return originalMongo;\r\n};\r\n// In mongodb 3.3.0, mongodb-core was merged into mongodb, so the same patching\r\n// can be used here. this.s.pool was changed to this.s.coreTopology.s.pool\r\nvar mongodbcorePatchFunction = function (originalMongo) {\r\n    var originalConnect = originalMongo.Server.prototype.connect;\r\n    originalMongo.Server.prototype.connect = function contextPreservingConnect() {\r\n        var ret = originalConnect.apply(this, arguments);\r\n        // Messages sent to mongo progress through a pool\r\n        // This can result in context getting mixed between different responses\r\n        // so we wrap the callbacks to restore appropriate state\r\n        var originalWrite = this.s.coreTopology.s.pool.write;\r\n        this.s.coreTopology.s.pool.write = function contextPreservingWrite() {\r\n            var cbidx = typeof arguments[1] === \"function\" ? 1 : 2;\r\n            if (typeof arguments[cbidx] === \"function\") {\r\n                arguments[cbidx] = diagnostic_channel_1.channel.bindToContext(arguments[cbidx]);\r\n            }\r\n            return originalWrite.apply(this, arguments);\r\n        };\r\n        // Logout is a special case, it doesn't call the write function but instead\r\n        // directly calls into connection.write\r\n        var originalLogout = this.s.coreTopology.s.pool.logout;\r\n        this.s.coreTopology.s.pool.logout = function contextPreservingLogout() {\r\n            if (typeof arguments[1] === \"function\") {\r\n                arguments[1] = diagnostic_channel_1.channel.bindToContext(arguments[1]);\r\n            }\r\n            return originalLogout.apply(this, arguments);\r\n        };\r\n        return ret;\r\n    };\r\n    return originalMongo;\r\n};\r\nvar mongodb330PatchFunction = function (originalMongo) {\r\n    mongodbcorePatchFunction(originalMongo); // apply mongodb-core patches\r\n    var listener = originalMongo.instrument();\r\n    var eventMap = {};\r\n    var contextMap = {};\r\n    listener.on(\"started\", function (event) {\r\n        if (eventMap[event.requestId]) {\r\n            // Note: Mongo can generate 2 completely separate requests\r\n            // which share the same requestId, if a certain race condition is triggered.\r\n            // For now, we accept that this can happen and potentially miss or mislabel some events.\r\n            return;\r\n        }\r\n        contextMap[event.requestId] = diagnostic_channel_1.channel.bindToContext(function (cb) { return cb(); });\r\n        eventMap[event.requestId] = event;\r\n    });\r\n    listener.on(\"succeeded\", function (event) {\r\n        var startedData = eventMap[event.requestId];\r\n        if (startedData) {\r\n            delete eventMap[event.requestId];\r\n        }\r\n        if (typeof event === \"object\" && typeof contextMap[event.requestId] === \"function\") {\r\n            contextMap[event.requestId](function () { return diagnostic_channel_1.channel.publish(\"mongodb\", { startedData: startedData, event: event, succeeded: true }); });\r\n            delete contextMap[event.requestId];\r\n        }\r\n    });\r\n    listener.on(\"failed\", function (event) {\r\n        var startedData = eventMap[event.requestId];\r\n        if (startedData) {\r\n            delete eventMap[event.requestId];\r\n        }\r\n        if (typeof event === \"object\" && typeof contextMap[event.requestId] === \"function\") {\r\n            contextMap[event.requestId](function () { return diagnostic_channel_1.channel.publish(\"mongodb\", { startedData: startedData, event: event, succeeded: false }); });\r\n            delete contextMap[event.requestId];\r\n        }\r\n    });\r\n    return originalMongo;\r\n};\r\nexports.mongo2 = {\r\n    versionSpecifier: \">= 2.0.0 <= 3.0.5\",\r\n    patch: mongodbPatchFunction,\r\n};\r\nexports.mongo3 = {\r\n    versionSpecifier: \"> 3.0.5 < 3.3.0\",\r\n    patch: mongodb3PatchFunction,\r\n};\r\nexports.mongo330 = {\r\n    versionSpecifier: \">= 3.3.0 < 4.0.0\",\r\n    patch: mongodb330PatchFunction,\r\n};\r\nfunction enable() {\r\n    diagnostic_channel_1.channel.registerMonkeyPatch(\"mongodb\", exports.mongo2);\r\n    diagnostic_channel_1.channel.registerMonkeyPatch(\"mongodb\", exports.mongo3);\r\n    diagnostic_channel_1.channel.registerMonkeyPatch(\"mongodb\", exports.mongo330);\r\n}\r\nexports.enable = enable;\r\n//# sourceMappingURL=mongodb.pub.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license. See LICENSE file in the project root for details.\r\nvar diagnostic_channel_1 = require(\"diagnostic-channel\");\r\nvar path = require(\"path\");\r\nvar mysqlPatchFunction = function (originalMysql, originalMysqlPath) {\r\n    // The `name` passed in here is for debugging purposes,\r\n    // to help distinguish which object is being patched.\r\n    var patchObjectFunction = function (obj, name) {\r\n        return function (func, cbWrapper) {\r\n            var originalFunc = obj[func];\r\n            if (originalFunc) {\r\n                obj[func] = function mysqlContextPreserver() {\r\n                    // Find the callback, if there is one\r\n                    var cbidx = arguments.length - 1;\r\n                    for (var i = arguments.length - 1; i >= 0; --i) {\r\n                        if (typeof arguments[i] === \"function\") {\r\n                            cbidx = i;\r\n                            break;\r\n                        }\r\n                        else if (typeof arguments[i] !== \"undefined\") {\r\n                            break;\r\n                        }\r\n                    }\r\n                    var cb = arguments[cbidx];\r\n                    var resultContainer = { result: null, startTime: null, startDate: null };\r\n                    if (typeof cb === \"function\") {\r\n                        // Preserve context on the callback.\r\n                        // If this is one of the functions that we want to track,\r\n                        // then wrap the callback with the tracking wrapper\r\n                        if (cbWrapper) {\r\n                            resultContainer.startTime = process.hrtime();\r\n                            resultContainer.startDate = new Date();\r\n                            arguments[cbidx] = diagnostic_channel_1.channel.bindToContext(cbWrapper(resultContainer, cb));\r\n                        }\r\n                        else {\r\n                            arguments[cbidx] = diagnostic_channel_1.channel.bindToContext(cb);\r\n                        }\r\n                    }\r\n                    var result = originalFunc.apply(this, arguments);\r\n                    resultContainer.result = result;\r\n                    return result;\r\n                };\r\n            }\r\n        };\r\n    };\r\n    var patchClassMemberFunction = function (classObject, name) {\r\n        return patchObjectFunction(classObject.prototype, name + \".prototype\");\r\n    };\r\n    var connectionCallbackFunctions = [\r\n        \"connect\", \"changeUser\",\r\n        \"ping\", \"statistics\", \"end\",\r\n    ];\r\n    var connectionClass = require(path.dirname(originalMysqlPath) + \"/lib/Connection\");\r\n    connectionCallbackFunctions.forEach(function (value) { return patchClassMemberFunction(connectionClass, \"Connection\")(value); });\r\n    // Connection.createQuery is a static method\r\n    patchObjectFunction(connectionClass, \"Connection\")(\"createQuery\", function (resultContainer, cb) {\r\n        return function (err) {\r\n            var hrDuration = process.hrtime(resultContainer.startTime);\r\n            /* tslint:disable-next-line:no-bitwise */\r\n            var duration = (hrDuration[0] * 1e3 + hrDuration[1] / 1e6) | 0;\r\n            diagnostic_channel_1.channel.publish(\"mysql\", { query: resultContainer.result, callbackArgs: arguments, err: err, duration: duration, time: resultContainer.startDate });\r\n            cb.apply(this, arguments);\r\n        };\r\n    });\r\n    var poolCallbackFunctions = [\r\n        \"_enqueueCallback\",\r\n    ];\r\n    var poolClass = require(path.dirname(originalMysqlPath) + \"/lib/Pool\");\r\n    poolCallbackFunctions.forEach(function (value) { return patchClassMemberFunction(poolClass, \"Pool\")(value); });\r\n    return originalMysql;\r\n};\r\nexports.mysql = {\r\n    versionSpecifier: \">= 2.0.0 < 3.0.0\",\r\n    patch: mysqlPatchFunction,\r\n};\r\nfunction enable() {\r\n    diagnostic_channel_1.channel.registerMonkeyPatch(\"mysql\", exports.mysql);\r\n}\r\nexports.enable = enable;\r\n//# sourceMappingURL=mysql.pub.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license. See LICENSE file in the project root for details.\r\nvar diagnostic_channel_1 = require(\"diagnostic-channel\");\r\nfunction postgresPool1PatchFunction(originalPgPool) {\r\n    var originalConnect = originalPgPool.prototype.connect;\r\n    originalPgPool.prototype.connect = function connect(callback) {\r\n        if (callback) {\r\n            arguments[0] = diagnostic_channel_1.channel.bindToContext(callback);\r\n        }\r\n        return originalConnect.apply(this, arguments);\r\n    };\r\n    return originalPgPool;\r\n}\r\nexports.postgresPool1 = {\r\n    versionSpecifier: \">= 1.0.0 < 3.0.0\",\r\n    patch: postgresPool1PatchFunction,\r\n};\r\nfunction enable() {\r\n    diagnostic_channel_1.channel.registerMonkeyPatch(\"pg-pool\", exports.postgresPool1);\r\n}\r\nexports.enable = enable;\r\n//# sourceMappingURL=pg-pool.pub.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license. See LICENSE file in the project root for details.\r\nvar diagnostic_channel_1 = require(\"diagnostic-channel\");\r\nvar events_1 = require(\"events\");\r\nfunction postgres6PatchFunction(originalPg, originalPgPath) {\r\n    var originalClientQuery = originalPg.Client.prototype.query;\r\n    var diagnosticOriginalFunc = \"__diagnosticOriginalFunc\";\r\n    // wherever the callback is passed, find it, save it, and remove it from the call\r\n    // to the the original .query() function\r\n    originalPg.Client.prototype.query = function query(config, values, callback) {\r\n        var data = {\r\n            query: {},\r\n            database: {\r\n                host: this.connectionParameters.host,\r\n                port: this.connectionParameters.port,\r\n            },\r\n            result: null,\r\n            error: null,\r\n            duration: 0,\r\n            time: new Date(),\r\n        };\r\n        var start = process.hrtime();\r\n        var queryResult;\r\n        function patchCallback(cb) {\r\n            if (cb && cb[diagnosticOriginalFunc]) {\r\n                cb = cb[diagnosticOriginalFunc];\r\n            }\r\n            var trackingCallback = diagnostic_channel_1.channel.bindToContext(function (err, res) {\r\n                var end = process.hrtime(start);\r\n                data.result = res && { rowCount: res.rowCount, command: res.command };\r\n                data.error = err;\r\n                data.duration = Math.ceil((end[0] * 1e3) + (end[1] / 1e6));\r\n                diagnostic_channel_1.channel.publish(\"postgres\", data);\r\n                // emulate weird internal behavior in pg@6\r\n                // on success, the callback is called *before* query events are emitted\r\n                // on failure, the callback is called *instead of* the query emitting events\r\n                // with no events, that means no promises (since the promise is resolved/rejected in an event handler)\r\n                // since we are always inserting ourselves as a callback, we have to restore the original\r\n                // behavior if the user didn't provide one themselves\r\n                if (err) {\r\n                    if (cb) {\r\n                        return cb.apply(this, arguments);\r\n                    }\r\n                    else if (queryResult && queryResult instanceof events_1.EventEmitter) {\r\n                        queryResult.emit(\"error\", err);\r\n                    }\r\n                }\r\n                else if (cb) {\r\n                    cb.apply(this, arguments);\r\n                }\r\n            });\r\n            try {\r\n                Object.defineProperty(trackingCallback, diagnosticOriginalFunc, { value: cb });\r\n                return trackingCallback;\r\n            }\r\n            catch (e) {\r\n                // this should never happen, but bailout in case it does\r\n                return cb;\r\n            }\r\n        }\r\n        // this function takes too many variations of arguments.\r\n        // this patches any provided callback or creates a new callback if one wasn't provided.\r\n        // since the callback is always called (if provided) in addition to always having a Promisified\r\n        // EventEmitter returned (well, sometimes -- see above), its safe to insert a callback if none was given\r\n        try {\r\n            if (typeof config === \"string\") {\r\n                if (values instanceof Array) {\r\n                    data.query.preparable = {\r\n                        text: config,\r\n                        args: values,\r\n                    };\r\n                    callback = patchCallback(callback);\r\n                }\r\n                else {\r\n                    data.query.text = config;\r\n                    // pg v6 will, for some reason, accept both\r\n                    // client.query(\"...\", undefined, () => {...})\r\n                    // **and**\r\n                    // client.query(\"...\", () => {...});\r\n                    // Internally, precedence is given to the callback argument\r\n                    if (callback) {\r\n                        callback = patchCallback(callback);\r\n                    }\r\n                    else {\r\n                        values = patchCallback(values);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (typeof config.name === \"string\") {\r\n                    data.query.plan = config.name;\r\n                }\r\n                else if (config.values instanceof Array) {\r\n                    data.query.preparable = {\r\n                        text: config.text,\r\n                        args: config.values,\r\n                    };\r\n                }\r\n                else {\r\n                    data.query.text = config.text;\r\n                }\r\n                if (callback) {\r\n                    callback = patchCallback(callback);\r\n                }\r\n                else if (values) {\r\n                    values = patchCallback(values);\r\n                }\r\n                else {\r\n                    config.callback = patchCallback(config.callback);\r\n                }\r\n            }\r\n        }\r\n        catch (e) {\r\n            // if our logic here throws, bail out and just let pg do its thing\r\n            return originalClientQuery.apply(this, arguments);\r\n        }\r\n        arguments[0] = config;\r\n        arguments[1] = values;\r\n        arguments[2] = callback;\r\n        arguments.length = (arguments.length > 3) ? arguments.length : 3;\r\n        queryResult = originalClientQuery.apply(this, arguments);\r\n        return queryResult;\r\n    };\r\n    return originalPg;\r\n}\r\nfunction postgres7PatchFunction(originalPg, originalPgPath) {\r\n    var originalClientQuery = originalPg.Client.prototype.query;\r\n    var diagnosticOriginalFunc = \"__diagnosticOriginalFunc\";\r\n    // wherever the callback is passed, find it, save it, and remove it from the call\r\n    // to the the original .query() function\r\n    originalPg.Client.prototype.query = function query(config, values, callback) {\r\n        var _this = this;\r\n        var callbackProvided = !!callback; // Starting in pg@7.x+, Promise is returned only if !callbackProvided\r\n        var data = {\r\n            query: {},\r\n            database: {\r\n                host: this.connectionParameters.host,\r\n                port: this.connectionParameters.port,\r\n            },\r\n            result: null,\r\n            error: null,\r\n            duration: 0,\r\n            time: new Date(),\r\n        };\r\n        var start = process.hrtime();\r\n        var queryResult;\r\n        function patchCallback(cb) {\r\n            if (cb && cb[diagnosticOriginalFunc]) {\r\n                cb = cb[diagnosticOriginalFunc];\r\n            }\r\n            var trackingCallback = diagnostic_channel_1.channel.bindToContext(function (err, res) {\r\n                var end = process.hrtime(start);\r\n                data.result = res && { rowCount: res.rowCount, command: res.command };\r\n                data.error = err;\r\n                data.duration = Math.ceil((end[0] * 1e3) + (end[1] / 1e6));\r\n                diagnostic_channel_1.channel.publish(\"postgres\", data);\r\n                if (err) {\r\n                    if (cb) {\r\n                        return cb.apply(this, arguments);\r\n                    }\r\n                    else if (queryResult && queryResult instanceof events_1.EventEmitter) {\r\n                        queryResult.emit(\"error\", err);\r\n                    }\r\n                }\r\n                else if (cb) {\r\n                    cb.apply(this, arguments);\r\n                }\r\n            });\r\n            try {\r\n                Object.defineProperty(trackingCallback, diagnosticOriginalFunc, { value: cb });\r\n                return trackingCallback;\r\n            }\r\n            catch (e) {\r\n                // this should never happen, but bailout in case it does\r\n                return cb;\r\n            }\r\n        }\r\n        // Only try to wrap the callback if it is a function. We want to keep the same\r\n        // behavior of returning a promise only if no callback is provided. Wrapping\r\n        // a nonfunction makes it a function and pg will interpret it as a callback\r\n        try {\r\n            if (typeof config === \"string\") {\r\n                if (values instanceof Array) {\r\n                    data.query.preparable = {\r\n                        text: config,\r\n                        args: values,\r\n                    };\r\n                    callbackProvided = typeof callback === \"function\";\r\n                    callback = callbackProvided ? patchCallback(callback) : callback;\r\n                }\r\n                else {\r\n                    data.query.text = config;\r\n                    if (callback) {\r\n                        callbackProvided = typeof callback === \"function\";\r\n                        callback = callbackProvided ? patchCallback(callback) : callback;\r\n                    }\r\n                    else {\r\n                        callbackProvided = typeof values === \"function\";\r\n                        values = callbackProvided ? patchCallback(values) : values;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (typeof config.name === \"string\") {\r\n                    data.query.plan = config.name;\r\n                }\r\n                else if (config.values instanceof Array) {\r\n                    data.query.preparable = {\r\n                        text: config.text,\r\n                        args: config.values,\r\n                    };\r\n                }\r\n                else {\r\n                    data.query.text = config.text;\r\n                }\r\n                if (callback) {\r\n                    callbackProvided = typeof callback === \"function\";\r\n                    callback = patchCallback(callback);\r\n                }\r\n                else if (values) {\r\n                    callbackProvided = typeof values === \"function\";\r\n                    values = callbackProvided ? patchCallback(values) : values;\r\n                }\r\n                else {\r\n                    callbackProvided = typeof config.callback === \"function\";\r\n                    config.callback = callbackProvided ? patchCallback(config.callback) : config.callback;\r\n                }\r\n            }\r\n        }\r\n        catch (e) {\r\n            // if our logic here throws, bail out and just let pg do its thing\r\n            return originalClientQuery.apply(this, arguments);\r\n        }\r\n        arguments[0] = config;\r\n        arguments[1] = values;\r\n        arguments[2] = callback;\r\n        arguments.length = (arguments.length > 3) ? arguments.length : 3;\r\n        queryResult = originalClientQuery.apply(this, arguments);\r\n        if (!callbackProvided) {\r\n            // no callback, so create a pass along promise\r\n            return queryResult\r\n                // pass resolved promise after publishing the event\r\n                .then(function (result) {\r\n                patchCallback()(undefined, result);\r\n                return new _this._Promise(function (resolve, reject) {\r\n                    resolve(result);\r\n                });\r\n            })\r\n                // pass along rejected promise after publishing the error\r\n                .catch(function (error) {\r\n                patchCallback()(error, undefined);\r\n                return new _this._Promise(function (resolve, reject) {\r\n                    reject(error);\r\n                });\r\n            });\r\n        }\r\n        return queryResult;\r\n    };\r\n    return originalPg;\r\n}\r\nexports.postgres6 = {\r\n    versionSpecifier: \"6.*\",\r\n    patch: postgres6PatchFunction,\r\n};\r\nexports.postgres7 = {\r\n    versionSpecifier: \">=7.* <=8.*\",\r\n    patch: postgres7PatchFunction,\r\n};\r\nfunction enable() {\r\n    diagnostic_channel_1.channel.registerMonkeyPatch(\"pg\", exports.postgres6);\r\n    diagnostic_channel_1.channel.registerMonkeyPatch(\"pg\", exports.postgres7);\r\n}\r\nexports.enable = enable;\r\n//# sourceMappingURL=pg.pub.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license. See LICENSE file in the project root for details.\r\nvar diagnostic_channel_1 = require(\"diagnostic-channel\");\r\nvar redisPatchFunction = function (originalRedis) {\r\n    var originalSend = originalRedis.RedisClient.prototype.internal_send_command;\r\n    // Note: This is mixing together both context tracking and dependency tracking\r\n    originalRedis.RedisClient.prototype.internal_send_command = function (commandObj) {\r\n        if (commandObj) {\r\n            var cb_1 = commandObj.callback;\r\n            if (!cb_1 || !cb_1.pubsubBound) {\r\n                var address_1 = this.address;\r\n                var startTime_1 = process.hrtime();\r\n                var startDate_1 = new Date();\r\n                // Note: augmenting the callback on internal_send_command is correct for context\r\n                // tracking, but may be too low-level for dependency tracking. There are some 'errors'\r\n                // which higher levels expect in some cases\r\n                // However, the only other option is to intercept every individual command.\r\n                commandObj.callback = diagnostic_channel_1.channel.bindToContext(function (err, result) {\r\n                    var hrDuration = process.hrtime(startTime_1);\r\n                    /* tslint:disable-next-line:no-bitwise */\r\n                    var duration = (hrDuration[0] * 1e3 + hrDuration[1] / 1e6) | 0;\r\n                    diagnostic_channel_1.channel.publish(\"redis\", { duration: duration, address: address_1, commandObj: commandObj, err: err, result: result, time: startDate_1 });\r\n                    if (typeof cb_1 === \"function\") {\r\n                        cb_1.apply(this, arguments);\r\n                    }\r\n                });\r\n                commandObj.callback.pubsubBound = true;\r\n            }\r\n        }\r\n        return originalSend.call(this, commandObj);\r\n    };\r\n    return originalRedis;\r\n};\r\nexports.redis = {\r\n    versionSpecifier: \">= 2.0.0 < 4.0.0\",\r\n    patch: redisPatchFunction,\r\n};\r\nfunction enable() {\r\n    diagnostic_channel_1.channel.registerMonkeyPatch(\"redis\", exports.redis);\r\n}\r\nexports.enable = enable;\r\n//# sourceMappingURL=redis.pub.js.map","\"use strict\";\r\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n            t[p] = s[p];\r\n    }\r\n    return t;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license. See LICENSE file in the project root for details.\r\nvar diagnostic_channel_1 = require(\"diagnostic-channel\");\r\nvar tediousPatchFunction = function (originalTedious) {\r\n    var originalMakeRequest = originalTedious.Connection.prototype.makeRequest;\r\n    originalTedious.Connection.prototype.makeRequest = function makeRequest() {\r\n        function getPatchedCallback(origCallback) {\r\n            var start = process.hrtime();\r\n            var data = {\r\n                query: {},\r\n                database: {\r\n                    host: null,\r\n                    port: null,\r\n                },\r\n                result: null,\r\n                error: null,\r\n                duration: 0,\r\n            };\r\n            return diagnostic_channel_1.channel.bindToContext(function (err, rowCount, rows) {\r\n                var end = process.hrtime(start);\r\n                data = __assign({}, data, { database: {\r\n                        host: this.connection.config.server,\r\n                        port: this.connection.config.options.port,\r\n                    }, result: !err && { rowCount: rowCount, rows: rows }, query: {\r\n                        text: this.parametersByName.statement.value,\r\n                    }, error: err, duration: Math.ceil((end[0] * 1e3) + (end[1] / 1e6)) });\r\n                diagnostic_channel_1.channel.publish(\"tedious\", data);\r\n                origCallback.call(this, err, rowCount, rows);\r\n            });\r\n        }\r\n        var request = arguments[0];\r\n        arguments[0].callback = getPatchedCallback(request.callback);\r\n        originalMakeRequest.apply(this, arguments);\r\n    };\r\n    return originalTedious;\r\n};\r\nexports.tedious = {\r\n    versionSpecifier: \">= 6.0.0 < 9.0.0\",\r\n    patch: tediousPatchFunction,\r\n};\r\nfunction enable() {\r\n    diagnostic_channel_1.channel.registerMonkeyPatch(\"tedious\", exports.tedious);\r\n}\r\nexports.enable = enable;\r\n//# sourceMappingURL=tedious.pub.js.map","\"use strict\";\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __rest = (this && this.__rest) || function (s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license. See LICENSE file in the project root for details.\r\nvar diagnostic_channel_1 = require(\"diagnostic-channel\");\r\n// register a \"filter\" with each logger that publishes the data about to be logged\r\nvar winston2PatchFunction = function (originalWinston) {\r\n    var originalLog = originalWinston.Logger.prototype.log;\r\n    var curLevels;\r\n    var loggingFilter = function (level, message, meta) {\r\n        var levelKind;\r\n        if (curLevels === originalWinston.config.npm.levels) {\r\n            levelKind = \"npm\";\r\n        }\r\n        else if (curLevels === originalWinston.config.syslog.levels) {\r\n            levelKind = \"syslog\";\r\n        }\r\n        else {\r\n            levelKind = \"unknown\";\r\n        }\r\n        diagnostic_channel_1.channel.publish(\"winston\", { level: level, message: message, meta: meta, levelKind: levelKind });\r\n        return message;\r\n    };\r\n    // whenever someone logs, ensure our filter comes last\r\n    originalWinston.Logger.prototype.log = function log() {\r\n        curLevels = this.levels;\r\n        if (!this.filters || this.filters.length === 0) {\r\n            this.filters = [loggingFilter];\r\n        }\r\n        else if (this.filters[this.filters.length - 1] !== loggingFilter) {\r\n            this.filters = this.filters.filter(function (f) { return f !== loggingFilter; });\r\n            this.filters.push(loggingFilter);\r\n        }\r\n        return originalLog.apply(this, arguments);\r\n    };\r\n    return originalWinston;\r\n};\r\nvar winston3PatchFunction = function (originalWinston) {\r\n    var mapLevelToKind = function (winston, level) {\r\n        var levelKind;\r\n        if (winston.config.npm.levels[level] != null) {\r\n            levelKind = \"npm\";\r\n        }\r\n        else if (winston.config.syslog.levels[level] != null) {\r\n            levelKind = \"syslog\";\r\n        }\r\n        else {\r\n            levelKind = \"unknown\";\r\n        }\r\n        return levelKind;\r\n    };\r\n    var AppInsightsTransport = /** @class */ (function (_super) {\r\n        __extends(AppInsightsTransport, _super);\r\n        function AppInsightsTransport(winston, opts) {\r\n            var _this = _super.call(this, opts) || this;\r\n            _this.winston = winston;\r\n            return _this;\r\n        }\r\n        AppInsightsTransport.prototype.log = function (info, callback) {\r\n            // tslint:disable-next-line:prefer-const - try to obtain level from Symbol(level) afterwards\r\n            var message = info.message, level = info.level, meta = info.meta, splat = __rest(info, [\"message\", \"level\", \"meta\"]);\r\n            level = typeof Symbol[\"for\"] === \"function\" ? info[Symbol[\"for\"](\"level\")] : level; // Symbol(level) is uncolorized, so prefer getting it from here\r\n            message = info instanceof Error ? info : message; // Winston places Errors at info, strings at info.message\r\n            var levelKind = mapLevelToKind(this.winston, level);\r\n            meta = meta || {}; // Winston _somtimes_ puts metadata inside meta, so start from here\r\n            for (var key in splat) {\r\n                if (splat.hasOwnProperty(key)) {\r\n                    meta[key] = splat[key];\r\n                }\r\n            }\r\n            diagnostic_channel_1.channel.publish(\"winston\", { message: message, level: level, levelKind: levelKind, meta: meta });\r\n            callback();\r\n        };\r\n        return AppInsightsTransport;\r\n    }(originalWinston.Transport));\r\n    // Patch this function\r\n    function patchedConfigure() {\r\n        // Grab highest sev logging level in case of custom logging levels\r\n        var levels = arguments[0].levels || originalWinston.config.npm.levels;\r\n        var lastLevel;\r\n        for (var level in levels) {\r\n            if (levels.hasOwnProperty(level)) {\r\n                lastLevel = lastLevel === undefined || levels[level] > levels[lastLevel] ? level : lastLevel;\r\n            }\r\n        }\r\n        this.add(new AppInsightsTransport(originalWinston, { level: lastLevel }));\r\n    }\r\n    var origCreate = originalWinston.createLogger;\r\n    originalWinston.createLogger = function patchedCreate() {\r\n        // Grab highest sev logging level in case of custom logging levels\r\n        var levels = arguments[0].levels || originalWinston.config.npm.levels;\r\n        var lastLevel;\r\n        for (var level in levels) {\r\n            if (levels.hasOwnProperty(level)) {\r\n                lastLevel = lastLevel === undefined || levels[level] > levels[lastLevel] ? level : lastLevel;\r\n            }\r\n        }\r\n        // Add custom app insights transport to the end\r\n        // Remark: Configure is not available until after createLogger()\r\n        // and the Logger prototype is not exported in winston 3.x, so\r\n        // patch both createLogger and configure. Could also call configure\r\n        // again after createLogger, but that would cause configure to be called\r\n        // twice per create.\r\n        var result = origCreate.apply(this, arguments);\r\n        result.add(new AppInsightsTransport(originalWinston, { level: lastLevel }));\r\n        var origConfigure = result.configure;\r\n        result.configure = function () {\r\n            origConfigure.apply(this, arguments);\r\n            patchedConfigure.apply(this, arguments);\r\n        };\r\n        return result;\r\n    };\r\n    var origRootConfigure = originalWinston.configure;\r\n    originalWinston.configure = function () {\r\n        origRootConfigure.apply(this, arguments);\r\n        patchedConfigure.apply(this, arguments);\r\n    };\r\n    originalWinston.add(new AppInsightsTransport(originalWinston));\r\n    return originalWinston;\r\n};\r\nexports.winston3 = {\r\n    versionSpecifier: \"3.x\",\r\n    patch: winston3PatchFunction,\r\n};\r\nexports.winston2 = {\r\n    versionSpecifier: \"2.x\",\r\n    patch: winston2PatchFunction,\r\n};\r\nfunction enable() {\r\n    diagnostic_channel_1.channel.registerMonkeyPatch(\"winston\", exports.winston2);\r\n    diagnostic_channel_1.channel.registerMonkeyPatch(\"winston\", exports.winston3);\r\n}\r\nexports.enable = enable;\r\n//# sourceMappingURL=winston.pub.js.map","\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for details.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar patchRequire_1 = require(\"./patchRequire\");\nvar patchRequire_2 = require(\"./patchRequire\");\nexports.makePatchingRequire = patchRequire_2.makePatchingRequire;\nvar trueFilter = function (publishing) { return true; };\nvar ContextPreservingEventEmitter = /** @class */ (function () {\n    function ContextPreservingEventEmitter() {\n        this.version = require(\"./../../package.json\").version; // Allow for future versions to replace things?\n        this.subscribers = {};\n        this.contextPreservationFunction = function (cb) { return cb; };\n        this.knownPatches = {};\n        this.currentlyPublishing = false;\n    }\n    ContextPreservingEventEmitter.prototype.shouldPublish = function (name) {\n        var listeners = this.subscribers[name];\n        if (listeners) {\n            return listeners.some(function (_a) {\n                var filter = _a.filter;\n                return !filter || filter(false);\n            });\n        }\n        return false;\n    };\n    ContextPreservingEventEmitter.prototype.publish = function (name, event) {\n        if (this.currentlyPublishing) {\n            return; // Avoid reentrancy\n        }\n        var listeners = this.subscribers[name];\n        // Note: Listeners called synchronously to preserve context\n        if (listeners) {\n            var standardEvent_1 = {\n                timestamp: Date.now(),\n                data: event,\n            };\n            this.currentlyPublishing = true;\n            listeners.forEach(function (_a) {\n                var listener = _a.listener, filter = _a.filter;\n                try {\n                    if (filter && filter(true)) {\n                        listener(standardEvent_1);\n                    }\n                }\n                catch (e) {\n                    // Subscriber threw an error\n                }\n            });\n            this.currentlyPublishing = false;\n        }\n    };\n    ContextPreservingEventEmitter.prototype.subscribe = function (name, listener, filter) {\n        if (filter === void 0) { filter = trueFilter; }\n        if (!this.subscribers[name]) {\n            this.subscribers[name] = [];\n        }\n        this.subscribers[name].push({ listener: listener, filter: filter });\n    };\n    ContextPreservingEventEmitter.prototype.unsubscribe = function (name, listener, filter) {\n        if (filter === void 0) { filter = trueFilter; }\n        var listeners = this.subscribers[name];\n        if (listeners) {\n            for (var index = 0; index < listeners.length; ++index) {\n                if (listeners[index].listener === listener && listeners[index].filter === filter) {\n                    listeners.splice(index, 1);\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n    // Used for tests\n    ContextPreservingEventEmitter.prototype.reset = function () {\n        var _this = this;\n        this.subscribers = {};\n        this.contextPreservationFunction = function (cb) { return cb; };\n        // Modify the knownPatches object rather than replace, since a reference will be used in the require patcher\n        Object.getOwnPropertyNames(this.knownPatches).forEach(function (prop) { return delete _this.knownPatches[prop]; });\n    };\n    ContextPreservingEventEmitter.prototype.bindToContext = function (cb) {\n        return this.contextPreservationFunction(cb);\n    };\n    ContextPreservingEventEmitter.prototype.addContextPreservation = function (preserver) {\n        var previousPreservationStack = this.contextPreservationFunction;\n        this.contextPreservationFunction = (function (cb) { return preserver(previousPreservationStack(cb)); });\n    };\n    ContextPreservingEventEmitter.prototype.registerMonkeyPatch = function (packageName, patcher) {\n        if (!this.knownPatches[packageName]) {\n            this.knownPatches[packageName] = [];\n        }\n        this.knownPatches[packageName].push(patcher);\n    };\n    ContextPreservingEventEmitter.prototype.getPatchesObject = function () {\n        return this.knownPatches;\n    };\n    return ContextPreservingEventEmitter;\n}());\nif (!global.diagnosticsSource) {\n    global.diagnosticsSource = new ContextPreservingEventEmitter();\n    // TODO: should this only patch require after at least one monkey patch is registered?\n    /* tslint:disable-next-line:no-var-requires */\n    var moduleModule = require(\"module\");\n    // Note: We pass in the object now before any patches are registered, but the object is passed by reference\n    // so any updates made to the object will be visible in the patcher.\n    moduleModule.prototype.require = patchRequire_1.makePatchingRequire(global.diagnosticsSource.getPatchesObject());\n}\nexports.channel = global.diagnosticsSource;\n//# sourceMappingURL=channel.js.map","\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for details.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar path = require(\"path\");\nvar semver = require(\"semver\");\n/* tslint:disable-next-line:no-var-requires */\nvar moduleModule = require(\"module\");\nvar nativeModules = Object.keys(process.binding(\"natives\"));\nvar originalRequire = moduleModule.prototype.require;\nfunction makePatchingRequire(knownPatches) {\n    var patchedModules = {};\n    return function patchedRequire(moduleId) {\n        var originalModule = originalRequire.apply(this, arguments);\n        if (knownPatches[moduleId]) {\n            // Fetch the specific path of the module\n            var modulePath = moduleModule._resolveFilename(moduleId, this);\n            if (patchedModules.hasOwnProperty(modulePath)) {\n                // This module has already been patched, no need to reapply\n                return patchedModules[modulePath];\n            }\n            var moduleVersion = void 0;\n            if (nativeModules.indexOf(moduleId) < 0) {\n                try {\n                    moduleVersion = originalRequire.call(this, path.join(moduleId, \"package.json\")).version;\n                }\n                catch (e) {\n                    // This should only happen if moduleId is actually a path rather than a module\n                    // This is not a supported scenario\n                    return originalModule;\n                }\n            }\n            else {\n                // This module is implemented natively so we cannot find a package.json\n                // Instead, take the version of node itself\n                moduleVersion = process.version.substring(1);\n            }\n            var prereleaseTagIndex = moduleVersion.indexOf(\"-\");\n            if (prereleaseTagIndex >= 0) {\n                // We ignore prerelease tags to avoid impossible to fix gaps in support\n                // e.g. supporting console in >= 4.0.0 would otherwise not include\n                // 8.0.0-pre\n                moduleVersion = moduleVersion.substring(0, prereleaseTagIndex);\n            }\n            var modifiedModule = originalModule;\n            for (var _i = 0, _a = knownPatches[moduleId]; _i < _a.length; _i++) {\n                var modulePatcher = _a[_i];\n                if (semver.satisfies(moduleVersion, modulePatcher.versionSpecifier)) {\n                    modifiedModule = modulePatcher.patch(modifiedModule, modulePath);\n                }\n            }\n            return patchedModules[modulePath] = modifiedModule;\n        }\n        return originalModule;\n    };\n}\nexports.makePatchingRequire = makePatchingRequire;\n//# sourceMappingURL=patchRequire.js.map","var crypto = require('crypto')\n\n// getDiffieHellman\nexports.DiffieHellmanGroup = crypto.DiffieHellmanGroup\nexports.createDiffieHellmanGroup = crypto.createDiffieHellmanGroup\nexports.getDiffieHellman = crypto.getDiffieHellman\n\n// createDiffieHellman\nexports.createDiffieHellman = crypto.createDiffieHellman\nexports.DiffieHellman = crypto.DiffieHellman\n","'use strict';\n\nvar shimmer = require('shimmer');\nvar wrap    = shimmer.wrap;\nvar unwrap  = shimmer.unwrap;\n\n// Default to complaining loudly when things don't go according to plan.\n// dunderscores are boring\nvar SYMBOL = 'wrap@before';\n\n// Sets a property on an object, preserving its enumerability.\n// This function assumes that the property is already writable.\nfunction defineProperty(obj, name, value) {\n  var enumerable = !!obj[name] && obj.propertyIsEnumerable(name);\n  Object.defineProperty(obj, name, {\n    configurable: true,\n    enumerable: enumerable,\n    writable: true,\n    value: value\n  });\n}\n\nfunction _process(self, listeners) {\n  var l = listeners.length;\n  for (var p = 0; p < l; p++) {\n    var listener = listeners[p];\n    // set up the listener so that onEmit can do whatever it needs\n    var before = self[SYMBOL];\n    if (typeof before === 'function') {\n      before(listener);\n    }\n    else if (Array.isArray(before)) {\n      var length = before.length;\n      for (var i = 0; i < length; i++) before[i](listener);\n    }\n  }\n}\n\nfunction _listeners(self, event) {\n  var listeners;\n  listeners = self._events && self._events[event];\n  if (!Array.isArray(listeners)) {\n    if (listeners) {\n      listeners = [listeners];\n    }\n    else {\n      listeners = [];\n    }\n  }\n\n  return listeners;\n}\n\nfunction _findAndProcess(self, event, before) {\n  var after = _listeners(self, event);\n  var unprocessed = after.filter(function(fn) { return before.indexOf(fn) === -1; });\n  if (unprocessed.length > 0) _process(self, unprocessed);\n}\n\nfunction _wrap(unwrapped, visit) {\n  if (!unwrapped) return;\n\n  var wrapped = unwrapped;\n  if (typeof unwrapped === 'function') {\n    wrapped = visit(unwrapped);\n  }\n  else if (Array.isArray(unwrapped)) {\n    wrapped = [];\n    for (var i = 0; i < unwrapped.length; i++) {\n      wrapped[i] = visit(unwrapped[i]);\n    }\n  }\n  return wrapped;\n}\n\nmodule.exports = function wrapEmitter(emitter, onAddListener, onEmit) {\n  if (!emitter || !emitter.on || !emitter.addListener ||\n      !emitter.removeListener || !emitter.emit) {\n    throw new Error(\"can only wrap real EEs\");\n  }\n\n  if (!onAddListener) throw new Error(\"must have function to run on listener addition\");\n  if (!onEmit) throw new Error(\"must have function to wrap listeners when emitting\");\n\n  /* Attach a context to a listener, and make sure that this hook stays\n   * attached to the emitter forevermore.\n   */\n  function adding(on) {\n    return function added(event, listener) {\n      var existing = _listeners(this, event).slice();\n\n      try {\n        var returned = on.call(this, event, listener);\n        _findAndProcess(this, event, existing);\n        return returned;\n      }\n      finally {\n        // old-style streaming overwrites .on and .addListener, so rewrap\n        if (!this.on.__wrapped) wrap(this, 'on', adding);\n        if (!this.addListener.__wrapped) wrap(this, 'addListener', adding);\n      }\n    };\n  }\n\n  function emitting(emit) {\n    return function emitted(event) {\n      if (!this._events || !this._events[event]) return emit.apply(this, arguments);\n\n      var unwrapped = this._events[event];\n\n      /* Ensure that if removeListener gets called, it's working with the\n       * unwrapped listeners.\n       */\n      function remover(removeListener) {\n        return function removed() {\n          this._events[event] = unwrapped;\n          try {\n            return removeListener.apply(this, arguments);\n          }\n          finally {\n            unwrapped = this._events[event];\n            this._events[event] = _wrap(unwrapped, onEmit);\n          }\n        };\n      }\n      wrap(this, 'removeListener', remover);\n\n      try {\n        /* At emit time, ensure that whatever else is going on, removeListener will\n         * still work while at the same time running whatever hooks are necessary to\n         * make sure the listener is run in the correct context.\n         */\n        this._events[event] = _wrap(unwrapped, onEmit);\n        return emit.apply(this, arguments);\n      }\n      finally {\n        /* Ensure that regardless of what happens when preparing and running the\n         * listeners, the status quo ante is restored before continuing.\n         */\n        unwrap(this, 'removeListener');\n        this._events[event] = unwrapped;\n      }\n    };\n  }\n\n  // support multiple onAddListeners\n  if (!emitter[SYMBOL]) {\n    defineProperty(emitter, SYMBOL, onAddListener);\n  }\n  else if (typeof emitter[SYMBOL] === 'function') {\n    defineProperty(emitter, SYMBOL, [emitter[SYMBOL], onAddListener]);\n  }\n  else if (Array.isArray(emitter[SYMBOL])) {\n    emitter[SYMBOL].push(onAddListener);\n  }\n\n  // only wrap the core functions once\n  if (!emitter.__wrapped) {\n    wrap(emitter, 'addListener', adding);\n    wrap(emitter, 'on',          adding);\n    wrap(emitter, 'emit',        emitting);\n\n    defineProperty(emitter, '__unwrap', function () {\n      unwrap(emitter, 'addListener');\n      unwrap(emitter, 'on');\n      unwrap(emitter, 'emit');\n      delete emitter[SYMBOL];\n      delete emitter.__wrapped;\n    });\n    defineProperty(emitter, '__wrapped', true);\n  }\n};\n","\"use strict\";\n\nmodule.exports = function () {\n  // https://mths.be/emoji\n  return /\\uD83C\\uDFF4(?:\\uDB40\\uDC67\\uDB40\\uDC62(?:\\uDB40\\uDC65\\uDB40\\uDC6E\\uDB40\\uDC67|\\uDB40\\uDC77\\uDB40\\uDC6C\\uDB40\\uDC73|\\uDB40\\uDC73\\uDB40\\uDC63\\uDB40\\uDC74)\\uDB40\\uDC7F|\\u200D\\u2620\\uFE0F)|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|\\uD83D\\uDC68(?:\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83D\\uDC68|(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDB0-\\uDDB3])|(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDB0-\\uDDB3]))|\\uD83D\\uDC69\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDB0-\\uDDB3])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|(?:\\uD83D\\uDC41\\uFE0F\\u200D\\uD83D\\uDDE8|\\uD83D\\uDC69(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2695\\u2696\\u2708]|\\uD83D\\uDC68(?:(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])|(?:(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)\\uFE0F|\\uD83D\\uDC6F|\\uD83E[\\uDD3C\\uDDDE\\uDDDF])\\u200D[\\u2640\\u2642]|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDD6-\\uDDDD])(?:(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]|\\u200D[\\u2640\\u2642])|\\uD83D\\uDC69\\u200D[\\u2695\\u2696\\u2708])\\uFE0F|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83D\\uDC68(?:\\u200D(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83D[\\uDC66\\uDC67])|\\uD83C[\\uDFFB-\\uDFFF])|\\uD83C\\uDFF3\\uFE0F\\u200D\\uD83C\\uDF08|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67|\\uD83D\\uDC69(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDB0-\\uDDB3])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66|\\uD83C\\uDDF6\\uD83C\\uDDE6|\\uD83C\\uDDFD\\uD83C\\uDDF0|\\uD83C\\uDDF4\\uD83C\\uDDF2|\\uD83D\\uDC69(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83C\\uDDED(?:\\uD83C[\\uDDF0\\uDDF2\\uDDF3\\uDDF7\\uDDF9\\uDDFA])|\\uD83C\\uDDEC(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEE\\uDDF1-\\uDDF3\\uDDF5-\\uDDFA\\uDDFC\\uDDFE])|\\uD83C\\uDDEA(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDED\\uDDF7-\\uDDFA])|\\uD83C\\uDDE8(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDEE\\uDDF0-\\uDDF5\\uDDF7\\uDDFA-\\uDDFF])|\\uD83C\\uDDF2(?:\\uD83C[\\uDDE6\\uDDE8-\\uDDED\\uDDF0-\\uDDFF])|\\uD83C\\uDDF3(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA-\\uDDEC\\uDDEE\\uDDF1\\uDDF4\\uDDF5\\uDDF7\\uDDFA\\uDDFF])|\\uD83C\\uDDFC(?:\\uD83C[\\uDDEB\\uDDF8])|\\uD83C\\uDDFA(?:\\uD83C[\\uDDE6\\uDDEC\\uDDF2\\uDDF3\\uDDF8\\uDDFE\\uDDFF])|\\uD83C\\uDDF0(?:\\uD83C[\\uDDEA\\uDDEC-\\uDDEE\\uDDF2\\uDDF3\\uDDF5\\uDDF7\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDEF(?:\\uD83C[\\uDDEA\\uDDF2\\uDDF4\\uDDF5])|\\uD83C\\uDDF8(?:\\uD83C[\\uDDE6-\\uDDEA\\uDDEC-\\uDDF4\\uDDF7-\\uDDF9\\uDDFB\\uDDFD-\\uDDFF])|\\uD83C\\uDDEE(?:\\uD83C[\\uDDE8-\\uDDEA\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9])|\\uD83C\\uDDFF(?:\\uD83C[\\uDDE6\\uDDF2\\uDDFC])|\\uD83C\\uDDEB(?:\\uD83C[\\uDDEE-\\uDDF0\\uDDF2\\uDDF4\\uDDF7])|\\uD83C\\uDDF5(?:\\uD83C[\\uDDE6\\uDDEA-\\uDDED\\uDDF0-\\uDDF3\\uDDF7-\\uDDF9\\uDDFC\\uDDFE])|\\uD83C\\uDDE9(?:\\uD83C[\\uDDEA\\uDDEC\\uDDEF\\uDDF0\\uDDF2\\uDDF4\\uDDFF])|\\uD83C\\uDDF9(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDED\\uDDEF-\\uDDF4\\uDDF7\\uDDF9\\uDDFB\\uDDFC\\uDDFF])|\\uD83C\\uDDE7(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEF\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9\\uDDFB\\uDDFC\\uDDFE\\uDDFF])|[#\\*0-9]\\uFE0F\\u20E3|\\uD83C\\uDDF1(?:\\uD83C[\\uDDE6-\\uDDE8\\uDDEE\\uDDF0\\uDDF7-\\uDDFB\\uDDFE])|\\uD83C\\uDDE6(?:\\uD83C[\\uDDE8-\\uDDEC\\uDDEE\\uDDF1\\uDDF2\\uDDF4\\uDDF6-\\uDDFA\\uDDFC\\uDDFD\\uDDFF])|\\uD83C\\uDDF7(?:\\uD83C[\\uDDEA\\uDDF4\\uDDF8\\uDDFA\\uDDFC])|\\uD83C\\uDDFB(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDEE\\uDDF3\\uDDFA])|\\uD83C\\uDDFE(?:\\uD83C[\\uDDEA\\uDDF9])|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u261D\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC70\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDCAA\\uDD74\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD36\\uDDB5\\uDDB6\\uDDD1-\\uDDD5])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u270A\\u270B\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF93\\uDFA0-\\uDFCA\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF4\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC3E\\uDC40\\uDC42-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDD7A\\uDD95\\uDD96\\uDDA4\\uDDFB-\\uDE4F\\uDE80-\\uDEC5\\uDECC\\uDED0-\\uDED2\\uDEEB\\uDEEC\\uDEF4-\\uDEF9]|\\uD83E[\\uDD10-\\uDD3A\\uDD3C-\\uDD3E\\uDD40-\\uDD45\\uDD47-\\uDD70\\uDD73-\\uDD76\\uDD7A\\uDD7C-\\uDDA2\\uDDB0-\\uDDB9\\uDDC0-\\uDDC2\\uDDD0-\\uDDFF])|(?:[#\\*0-9\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u261D\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u267F\\u2692-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A1\\u26AA\\u26AB\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C5\\u26C8\\u26CE\\u26CF\\u26D1\\u26D3\\u26D4\\u26E9\\u26EA\\u26F0-\\u26F5\\u26F7-\\u26FA\\u26FD\\u2702\\u2705\\u2708-\\u270D\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763\\u2764\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC04\\uDCCF\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE02\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF21\\uDF24-\\uDF93\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E-\\uDFF0\\uDFF3-\\uDFF5\\uDFF7-\\uDFFF]|\\uD83D[\\uDC00-\\uDCFD\\uDCFF-\\uDD3D\\uDD49-\\uDD4E\\uDD50-\\uDD67\\uDD6F\\uDD70\\uDD73-\\uDD7A\\uDD87\\uDD8A-\\uDD8D\\uDD90\\uDD95\\uDD96\\uDDA4\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA-\\uDE4F\\uDE80-\\uDEC5\\uDECB-\\uDED2\\uDEE0-\\uDEE5\\uDEE9\\uDEEB\\uDEEC\\uDEF0\\uDEF3-\\uDEF9]|\\uD83E[\\uDD10-\\uDD3A\\uDD3C-\\uDD3E\\uDD40-\\uDD45\\uDD47-\\uDD70\\uDD73-\\uDD76\\uDD7A\\uDD7C-\\uDDA2\\uDDB0-\\uDDB9\\uDDC0-\\uDDC2\\uDDD0-\\uDDFF])\\uFE0F|(?:[\\u261D\\u26F9\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2-\\uDFC4\\uDFC7\\uDFCA-\\uDFCC]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66-\\uDC69\\uDC6E\\uDC70-\\uDC78\\uDC7C\\uDC81-\\uDC83\\uDC85-\\uDC87\\uDCAA\\uDD74\\uDD75\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE45-\\uDE47\\uDE4B-\\uDE4F\\uDEA3\\uDEB4-\\uDEB6\\uDEC0\\uDECC]|\\uD83E[\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD26\\uDD30-\\uDD39\\uDD3D\\uDD3E\\uDDB5\\uDDB6\\uDDB8\\uDDB9\\uDDD1-\\uDDDD])/g;\n};\n","/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n * @copyright 2015 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/**\n * @typedef {object} PrivateData\n * @property {EventTarget} eventTarget The event target.\n * @property {{type:string}} event The original event object.\n * @property {number} eventPhase The current event phase.\n * @property {EventTarget|null} currentTarget The current event target.\n * @property {boolean} canceled The flag to prevent default.\n * @property {boolean} stopped The flag to stop propagation.\n * @property {boolean} immediateStopped The flag to stop propagation immediately.\n * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.\n * @property {number} timeStamp The unix time.\n * @private\n */\n\n/**\n * Private data for event wrappers.\n * @type {WeakMap<Event, PrivateData>}\n * @private\n */\nconst privateData = new WeakMap();\n\n/**\n * Cache for wrapper classes.\n * @type {WeakMap<Object, Function>}\n * @private\n */\nconst wrappers = new WeakMap();\n\n/**\n * Get private data.\n * @param {Event} event The event object to get private data.\n * @returns {PrivateData} The private data of the event.\n * @private\n */\nfunction pd(event) {\n    const retv = privateData.get(event);\n    console.assert(\n        retv != null,\n        \"'this' is expected an Event object, but got\",\n        event\n    );\n    return retv\n}\n\n/**\n * https://dom.spec.whatwg.org/#set-the-canceled-flag\n * @param data {PrivateData} private data.\n */\nfunction setCancelFlag(data) {\n    if (data.passiveListener != null) {\n        if (\n            typeof console !== \"undefined\" &&\n            typeof console.error === \"function\"\n        ) {\n            console.error(\n                \"Unable to preventDefault inside passive event listener invocation.\",\n                data.passiveListener\n            );\n        }\n        return\n    }\n    if (!data.event.cancelable) {\n        return\n    }\n\n    data.canceled = true;\n    if (typeof data.event.preventDefault === \"function\") {\n        data.event.preventDefault();\n    }\n}\n\n/**\n * @see https://dom.spec.whatwg.org/#interface-event\n * @private\n */\n/**\n * The event wrapper.\n * @constructor\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Event|{type:string}} event The original event to wrap.\n */\nfunction Event(eventTarget, event) {\n    privateData.set(this, {\n        eventTarget,\n        event,\n        eventPhase: 2,\n        currentTarget: eventTarget,\n        canceled: false,\n        stopped: false,\n        immediateStopped: false,\n        passiveListener: null,\n        timeStamp: event.timeStamp || Date.now(),\n    });\n\n    // https://heycam.github.io/webidl/#Unforgeable\n    Object.defineProperty(this, \"isTrusted\", { value: false, enumerable: true });\n\n    // Define accessors\n    const keys = Object.keys(event);\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        if (!(key in this)) {\n            Object.defineProperty(this, key, defineRedirectDescriptor(key));\n        }\n    }\n}\n\n// Should be enumerable, but class methods are not enumerable.\nEvent.prototype = {\n    /**\n     * The type of this event.\n     * @type {string}\n     */\n    get type() {\n        return pd(this).event.type\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */\n    get target() {\n        return pd(this).eventTarget\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */\n    get currentTarget() {\n        return pd(this).currentTarget\n    },\n\n    /**\n     * @returns {EventTarget[]} The composed path of this event.\n     */\n    composedPath() {\n        const currentTarget = pd(this).currentTarget;\n        if (currentTarget == null) {\n            return []\n        }\n        return [currentTarget]\n    },\n\n    /**\n     * Constant of NONE.\n     * @type {number}\n     */\n    get NONE() {\n        return 0\n    },\n\n    /**\n     * Constant of CAPTURING_PHASE.\n     * @type {number}\n     */\n    get CAPTURING_PHASE() {\n        return 1\n    },\n\n    /**\n     * Constant of AT_TARGET.\n     * @type {number}\n     */\n    get AT_TARGET() {\n        return 2\n    },\n\n    /**\n     * Constant of BUBBLING_PHASE.\n     * @type {number}\n     */\n    get BUBBLING_PHASE() {\n        return 3\n    },\n\n    /**\n     * The target of this event.\n     * @type {number}\n     */\n    get eventPhase() {\n        return pd(this).eventPhase\n    },\n\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */\n    stopPropagation() {\n        const data = pd(this);\n\n        data.stopped = true;\n        if (typeof data.event.stopPropagation === \"function\") {\n            data.event.stopPropagation();\n        }\n    },\n\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */\n    stopImmediatePropagation() {\n        const data = pd(this);\n\n        data.stopped = true;\n        data.immediateStopped = true;\n        if (typeof data.event.stopImmediatePropagation === \"function\") {\n            data.event.stopImmediatePropagation();\n        }\n    },\n\n    /**\n     * The flag to be bubbling.\n     * @type {boolean}\n     */\n    get bubbles() {\n        return Boolean(pd(this).event.bubbles)\n    },\n\n    /**\n     * The flag to be cancelable.\n     * @type {boolean}\n     */\n    get cancelable() {\n        return Boolean(pd(this).event.cancelable)\n    },\n\n    /**\n     * Cancel this event.\n     * @returns {void}\n     */\n    preventDefault() {\n        setCancelFlag(pd(this));\n    },\n\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     */\n    get defaultPrevented() {\n        return pd(this).canceled\n    },\n\n    /**\n     * The flag to be composed.\n     * @type {boolean}\n     */\n    get composed() {\n        return Boolean(pd(this).event.composed)\n    },\n\n    /**\n     * The unix time of this event.\n     * @type {number}\n     */\n    get timeStamp() {\n        return pd(this).timeStamp\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     * @deprecated\n     */\n    get srcElement() {\n        return pd(this).eventTarget\n    },\n\n    /**\n     * The flag to stop event bubbling.\n     * @type {boolean}\n     * @deprecated\n     */\n    get cancelBubble() {\n        return pd(this).stopped\n    },\n    set cancelBubble(value) {\n        if (!value) {\n            return\n        }\n        const data = pd(this);\n\n        data.stopped = true;\n        if (typeof data.event.cancelBubble === \"boolean\") {\n            data.event.cancelBubble = true;\n        }\n    },\n\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     * @deprecated\n     */\n    get returnValue() {\n        return !pd(this).canceled\n    },\n    set returnValue(value) {\n        if (!value) {\n            setCancelFlag(pd(this));\n        }\n    },\n\n    /**\n     * Initialize this event object. But do nothing under event dispatching.\n     * @param {string} type The event type.\n     * @param {boolean} [bubbles=false] The flag to be possible to bubble up.\n     * @param {boolean} [cancelable=false] The flag to be possible to cancel.\n     * @deprecated\n     */\n    initEvent() {\n        // Do nothing.\n    },\n};\n\n// `constructor` is not enumerable.\nObject.defineProperty(Event.prototype, \"constructor\", {\n    value: Event,\n    configurable: true,\n    writable: true,\n});\n\n// Ensure `event instanceof window.Event` is `true`.\nif (typeof window !== \"undefined\" && typeof window.Event !== \"undefined\") {\n    Object.setPrototypeOf(Event.prototype, window.Event.prototype);\n\n    // Make association for wrappers.\n    wrappers.set(window.Event.prototype, Event);\n}\n\n/**\n * Get the property descriptor to redirect a given property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to redirect the property.\n * @private\n */\nfunction defineRedirectDescriptor(key) {\n    return {\n        get() {\n            return pd(this).event[key]\n        },\n        set(value) {\n            pd(this).event[key] = value;\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Get the property descriptor to call a given method property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to call the method property.\n * @private\n */\nfunction defineCallDescriptor(key) {\n    return {\n        value() {\n            const event = pd(this).event;\n            return event[key].apply(event, arguments)\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Define new wrapper class.\n * @param {Function} BaseEvent The base wrapper class.\n * @param {Object} proto The prototype of the original event.\n * @returns {Function} The defined wrapper class.\n * @private\n */\nfunction defineWrapper(BaseEvent, proto) {\n    const keys = Object.keys(proto);\n    if (keys.length === 0) {\n        return BaseEvent\n    }\n\n    /** CustomEvent */\n    function CustomEvent(eventTarget, event) {\n        BaseEvent.call(this, eventTarget, event);\n    }\n\n    CustomEvent.prototype = Object.create(BaseEvent.prototype, {\n        constructor: { value: CustomEvent, configurable: true, writable: true },\n    });\n\n    // Define accessors.\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        if (!(key in BaseEvent.prototype)) {\n            const descriptor = Object.getOwnPropertyDescriptor(proto, key);\n            const isFunc = typeof descriptor.value === \"function\";\n            Object.defineProperty(\n                CustomEvent.prototype,\n                key,\n                isFunc\n                    ? defineCallDescriptor(key)\n                    : defineRedirectDescriptor(key)\n            );\n        }\n    }\n\n    return CustomEvent\n}\n\n/**\n * Get the wrapper class of a given prototype.\n * @param {Object} proto The prototype of the original event to get its wrapper.\n * @returns {Function} The wrapper class.\n * @private\n */\nfunction getWrapper(proto) {\n    if (proto == null || proto === Object.prototype) {\n        return Event\n    }\n\n    let wrapper = wrappers.get(proto);\n    if (wrapper == null) {\n        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);\n        wrappers.set(proto, wrapper);\n    }\n    return wrapper\n}\n\n/**\n * Wrap a given event to management a dispatching.\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Object} event The event to wrap.\n * @returns {Event} The wrapper instance.\n * @private\n */\nfunction wrapEvent(eventTarget, event) {\n    const Wrapper = getWrapper(Object.getPrototypeOf(event));\n    return new Wrapper(eventTarget, event)\n}\n\n/**\n * Get the immediateStopped flag of a given event.\n * @param {Event} event The event to get.\n * @returns {boolean} The flag to stop propagation immediately.\n * @private\n */\nfunction isStopped(event) {\n    return pd(event).immediateStopped\n}\n\n/**\n * Set the current event phase of a given event.\n * @param {Event} event The event to set current target.\n * @param {number} eventPhase New event phase.\n * @returns {void}\n * @private\n */\nfunction setEventPhase(event, eventPhase) {\n    pd(event).eventPhase = eventPhase;\n}\n\n/**\n * Set the current target of a given event.\n * @param {Event} event The event to set current target.\n * @param {EventTarget|null} currentTarget New current target.\n * @returns {void}\n * @private\n */\nfunction setCurrentTarget(event, currentTarget) {\n    pd(event).currentTarget = currentTarget;\n}\n\n/**\n * Set a passive listener of a given event.\n * @param {Event} event The event to set current target.\n * @param {Function|null} passiveListener New passive listener.\n * @returns {void}\n * @private\n */\nfunction setPassiveListener(event, passiveListener) {\n    pd(event).passiveListener = passiveListener;\n}\n\n/**\n * @typedef {object} ListenerNode\n * @property {Function} listener\n * @property {1|2|3} listenerType\n * @property {boolean} passive\n * @property {boolean} once\n * @property {ListenerNode|null} next\n * @private\n */\n\n/**\n * @type {WeakMap<object, Map<string, ListenerNode>>}\n * @private\n */\nconst listenersMap = new WeakMap();\n\n// Listener types\nconst CAPTURE = 1;\nconst BUBBLE = 2;\nconst ATTRIBUTE = 3;\n\n/**\n * Check whether a given value is an object or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if the value is an object.\n */\nfunction isObject(x) {\n    return x !== null && typeof x === \"object\" //eslint-disable-line no-restricted-syntax\n}\n\n/**\n * Get listeners.\n * @param {EventTarget} eventTarget The event target to get.\n * @returns {Map<string, ListenerNode>} The listeners.\n * @private\n */\nfunction getListeners(eventTarget) {\n    const listeners = listenersMap.get(eventTarget);\n    if (listeners == null) {\n        throw new TypeError(\n            \"'this' is expected an EventTarget object, but got another value.\"\n        )\n    }\n    return listeners\n}\n\n/**\n * Get the property descriptor for the event attribute of a given event.\n * @param {string} eventName The event name to get property descriptor.\n * @returns {PropertyDescriptor} The property descriptor.\n * @private\n */\nfunction defineEventAttributeDescriptor(eventName) {\n    return {\n        get() {\n            const listeners = getListeners(this);\n            let node = listeners.get(eventName);\n            while (node != null) {\n                if (node.listenerType === ATTRIBUTE) {\n                    return node.listener\n                }\n                node = node.next;\n            }\n            return null\n        },\n\n        set(listener) {\n            if (typeof listener !== \"function\" && !isObject(listener)) {\n                listener = null; // eslint-disable-line no-param-reassign\n            }\n            const listeners = getListeners(this);\n\n            // Traverse to the tail while removing old value.\n            let prev = null;\n            let node = listeners.get(eventName);\n            while (node != null) {\n                if (node.listenerType === ATTRIBUTE) {\n                    // Remove old value.\n                    if (prev !== null) {\n                        prev.next = node.next;\n                    } else if (node.next !== null) {\n                        listeners.set(eventName, node.next);\n                    } else {\n                        listeners.delete(eventName);\n                    }\n                } else {\n                    prev = node;\n                }\n\n                node = node.next;\n            }\n\n            // Add new value.\n            if (listener !== null) {\n                const newNode = {\n                    listener,\n                    listenerType: ATTRIBUTE,\n                    passive: false,\n                    once: false,\n                    next: null,\n                };\n                if (prev === null) {\n                    listeners.set(eventName, newNode);\n                } else {\n                    prev.next = newNode;\n                }\n            }\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Define an event attribute (e.g. `eventTarget.onclick`).\n * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.\n * @param {string} eventName The event name to define.\n * @returns {void}\n */\nfunction defineEventAttribute(eventTargetPrototype, eventName) {\n    Object.defineProperty(\n        eventTargetPrototype,\n        `on${eventName}`,\n        defineEventAttributeDescriptor(eventName)\n    );\n}\n\n/**\n * Define a custom EventTarget with event attributes.\n * @param {string[]} eventNames Event names for event attributes.\n * @returns {EventTarget} The custom EventTarget.\n * @private\n */\nfunction defineCustomEventTarget(eventNames) {\n    /** CustomEventTarget */\n    function CustomEventTarget() {\n        EventTarget.call(this);\n    }\n\n    CustomEventTarget.prototype = Object.create(EventTarget.prototype, {\n        constructor: {\n            value: CustomEventTarget,\n            configurable: true,\n            writable: true,\n        },\n    });\n\n    for (let i = 0; i < eventNames.length; ++i) {\n        defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);\n    }\n\n    return CustomEventTarget\n}\n\n/**\n * EventTarget.\n *\n * - This is constructor if no arguments.\n * - This is a function which returns a CustomEventTarget constructor if there are arguments.\n *\n * For example:\n *\n *     class A extends EventTarget {}\n *     class B extends EventTarget(\"message\") {}\n *     class C extends EventTarget(\"message\", \"error\") {}\n *     class D extends EventTarget([\"message\", \"error\"]) {}\n */\nfunction EventTarget() {\n    /*eslint-disable consistent-return */\n    if (this instanceof EventTarget) {\n        listenersMap.set(this, new Map());\n        return\n    }\n    if (arguments.length === 1 && Array.isArray(arguments[0])) {\n        return defineCustomEventTarget(arguments[0])\n    }\n    if (arguments.length > 0) {\n        const types = new Array(arguments.length);\n        for (let i = 0; i < arguments.length; ++i) {\n            types[i] = arguments[i];\n        }\n        return defineCustomEventTarget(types)\n    }\n    throw new TypeError(\"Cannot call a class as a function\")\n    /*eslint-enable consistent-return */\n}\n\n// Should be enumerable, but class methods are not enumerable.\nEventTarget.prototype = {\n    /**\n     * Add a given listener to this event target.\n     * @param {string} eventName The event name to add.\n     * @param {Function} listener The listener to add.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */\n    addEventListener(eventName, listener, options) {\n        if (listener == null) {\n            return\n        }\n        if (typeof listener !== \"function\" && !isObject(listener)) {\n            throw new TypeError(\"'listener' should be a function or an object.\")\n        }\n\n        const listeners = getListeners(this);\n        const optionsIsObj = isObject(options);\n        const capture = optionsIsObj\n            ? Boolean(options.capture)\n            : Boolean(options);\n        const listenerType = capture ? CAPTURE : BUBBLE;\n        const newNode = {\n            listener,\n            listenerType,\n            passive: optionsIsObj && Boolean(options.passive),\n            once: optionsIsObj && Boolean(options.once),\n            next: null,\n        };\n\n        // Set it as the first node if the first node is null.\n        let node = listeners.get(eventName);\n        if (node === undefined) {\n            listeners.set(eventName, newNode);\n            return\n        }\n\n        // Traverse to the tail while checking duplication..\n        let prev = null;\n        while (node != null) {\n            if (\n                node.listener === listener &&\n                node.listenerType === listenerType\n            ) {\n                // Should ignore duplication.\n                return\n            }\n            prev = node;\n            node = node.next;\n        }\n\n        // Add it.\n        prev.next = newNode;\n    },\n\n    /**\n     * Remove a given listener from this event target.\n     * @param {string} eventName The event name to remove.\n     * @param {Function} listener The listener to remove.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {void}\n     */\n    removeEventListener(eventName, listener, options) {\n        if (listener == null) {\n            return\n        }\n\n        const listeners = getListeners(this);\n        const capture = isObject(options)\n            ? Boolean(options.capture)\n            : Boolean(options);\n        const listenerType = capture ? CAPTURE : BUBBLE;\n\n        let prev = null;\n        let node = listeners.get(eventName);\n        while (node != null) {\n            if (\n                node.listener === listener &&\n                node.listenerType === listenerType\n            ) {\n                if (prev !== null) {\n                    prev.next = node.next;\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next);\n                } else {\n                    listeners.delete(eventName);\n                }\n                return\n            }\n\n            prev = node;\n            node = node.next;\n        }\n    },\n\n    /**\n     * Dispatch a given event.\n     * @param {Event|{type:string}} event The event to dispatch.\n     * @returns {boolean} `false` if canceled.\n     */\n    dispatchEvent(event) {\n        if (event == null || typeof event.type !== \"string\") {\n            throw new TypeError('\"event.type\" should be a string.')\n        }\n\n        // If listeners aren't registered, terminate.\n        const listeners = getListeners(this);\n        const eventName = event.type;\n        let node = listeners.get(eventName);\n        if (node == null) {\n            return true\n        }\n\n        // Since we cannot rewrite several properties, so wrap object.\n        const wrappedEvent = wrapEvent(this, event);\n\n        // This doesn't process capturing phase and bubbling phase.\n        // This isn't participating in a tree.\n        let prev = null;\n        while (node != null) {\n            // Remove this listener if it's once\n            if (node.once) {\n                if (prev !== null) {\n                    prev.next = node.next;\n                } else if (node.next !== null) {\n                    listeners.set(eventName, node.next);\n                } else {\n                    listeners.delete(eventName);\n                }\n            } else {\n                prev = node;\n            }\n\n            // Call this listener\n            setPassiveListener(\n                wrappedEvent,\n                node.passive ? node.listener : null\n            );\n            if (typeof node.listener === \"function\") {\n                try {\n                    node.listener.call(this, wrappedEvent);\n                } catch (err) {\n                    if (\n                        typeof console !== \"undefined\" &&\n                        typeof console.error === \"function\"\n                    ) {\n                        console.error(err);\n                    }\n                }\n            } else if (\n                node.listenerType !== ATTRIBUTE &&\n                typeof node.listener.handleEvent === \"function\"\n            ) {\n                node.listener.handleEvent(wrappedEvent);\n            }\n\n            // Break if `event.stopImmediatePropagation` was called.\n            if (isStopped(wrappedEvent)) {\n                break\n            }\n\n            node = node.next;\n        }\n        setPassiveListener(wrappedEvent, null);\n        setEventPhase(wrappedEvent, 0);\n        setCurrentTarget(wrappedEvent, null);\n\n        return !wrappedEvent.defaultPrevented\n    },\n};\n\n// `constructor` is not enumerable.\nObject.defineProperty(EventTarget.prototype, \"constructor\", {\n    value: EventTarget,\n    configurable: true,\n    writable: true,\n});\n\n// Ensure `eventTarget instanceof window.EventTarget` is `true`.\nif (\n    typeof window !== \"undefined\" &&\n    typeof window.EventTarget !== \"undefined\"\n) {\n    Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);\n}\n\nexports.defineEventAttribute = defineEventAttribute;\nexports.EventTarget = EventTarget;\nexports.default = EventTarget;\n\nmodule.exports = EventTarget\nmodule.exports.EventTarget = module.exports[\"default\"] = EventTarget\nmodule.exports.defineEventAttribute = defineEventAttribute\n//# sourceMappingURL=event-target-shim.js.map\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdirpSync = require('../mkdirs').mkdirsSync\nconst utimesSync = require('../util/utimes.js').utimesMillisSync\nconst stat = require('../util/stat')\n\nfunction copySync (src, dest, opts) {\n  if (typeof opts === 'function') {\n    opts = { filter: opts }\n  }\n\n  opts = opts || {}\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269`)\n  }\n\n  const { srcStat, destStat } = stat.checkPathsSync(src, dest, 'copy')\n  stat.checkParentPathsSync(src, srcStat, dest, 'copy')\n  return handleFilterAndCopy(destStat, src, dest, opts)\n}\n\nfunction handleFilterAndCopy (destStat, src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest)) return\n  const destParent = path.dirname(dest)\n  if (!fs.existsSync(destParent)) mkdirpSync(destParent)\n  return startCopy(destStat, src, dest, opts)\n}\n\nfunction startCopy (destStat, src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest)) return\n  return getStats(destStat, src, dest, opts)\n}\n\nfunction getStats (destStat, src, dest, opts) {\n  const statSync = opts.dereference ? fs.statSync : fs.lstatSync\n  const srcStat = statSync(src)\n\n  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isFile() ||\n           srcStat.isCharacterDevice() ||\n           srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts)\n}\n\nfunction onFile (srcStat, destStat, src, dest, opts) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts)\n  return mayCopyFile(srcStat, src, dest, opts)\n}\n\nfunction mayCopyFile (srcStat, src, dest, opts) {\n  if (opts.overwrite) {\n    fs.unlinkSync(dest)\n    return copyFile(srcStat, src, dest, opts)\n  } else if (opts.errorOnExist) {\n    throw new Error(`'${dest}' already exists`)\n  }\n}\n\nfunction copyFile (srcStat, src, dest, opts) {\n  if (typeof fs.copyFileSync === 'function') {\n    fs.copyFileSync(src, dest)\n    fs.chmodSync(dest, srcStat.mode)\n    if (opts.preserveTimestamps) {\n      return utimesSync(dest, srcStat.atime, srcStat.mtime)\n    }\n    return\n  }\n  return copyFileFallback(srcStat, src, dest, opts)\n}\n\nfunction copyFileFallback (srcStat, src, dest, opts) {\n  const BUF_LENGTH = 64 * 1024\n  const _buff = require('../util/buffer')(BUF_LENGTH)\n\n  const fdr = fs.openSync(src, 'r')\n  const fdw = fs.openSync(dest, 'w', srcStat.mode)\n  let pos = 0\n\n  while (pos < srcStat.size) {\n    const bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos)\n    fs.writeSync(fdw, _buff, 0, bytesRead)\n    pos += bytesRead\n  }\n\n  if (opts.preserveTimestamps) fs.futimesSync(fdw, srcStat.atime, srcStat.mtime)\n\n  fs.closeSync(fdr)\n  fs.closeSync(fdw)\n}\n\nfunction onDir (srcStat, destStat, src, dest, opts) {\n  if (!destStat) return mkDirAndCopy(srcStat, src, dest, opts)\n  if (destStat && !destStat.isDirectory()) {\n    throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)\n  }\n  return copyDir(src, dest, opts)\n}\n\nfunction mkDirAndCopy (srcStat, src, dest, opts) {\n  fs.mkdirSync(dest)\n  copyDir(src, dest, opts)\n  return fs.chmodSync(dest, srcStat.mode)\n}\n\nfunction copyDir (src, dest, opts) {\n  fs.readdirSync(src).forEach(item => copyDirItem(item, src, dest, opts))\n}\n\nfunction copyDirItem (item, src, dest, opts) {\n  const srcItem = path.join(src, item)\n  const destItem = path.join(dest, item)\n  const { destStat } = stat.checkPathsSync(srcItem, destItem, 'copy')\n  return startCopy(destStat, srcItem, destItem, opts)\n}\n\nfunction onLink (destStat, src, dest, opts) {\n  let resolvedSrc = fs.readlinkSync(src)\n  if (opts.dereference) {\n    resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n  }\n\n  if (!destStat) {\n    return fs.symlinkSync(resolvedSrc, dest)\n  } else {\n    let resolvedDest\n    try {\n      resolvedDest = fs.readlinkSync(dest)\n    } catch (err) {\n      // dest exists and is a regular file or directory,\n      // Windows may throw UNKNOWN error. If dest already exists,\n      // fs throws error anyway, so no need to guard against it here.\n      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlinkSync(resolvedSrc, dest)\n      throw err\n    }\n    if (opts.dereference) {\n      resolvedDest = path.resolve(process.cwd(), resolvedDest)\n    }\n    if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)\n    }\n\n    // prevent copy if src is a subdir of dest since unlinking\n    // dest in this case would result in removing src contents\n    // and therefore a broken symlink would be created.\n    if (fs.statSync(dest).isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)\n    }\n    return copyLink(resolvedSrc, dest)\n  }\n}\n\nfunction copyLink (resolvedSrc, dest) {\n  fs.unlinkSync(dest)\n  return fs.symlinkSync(resolvedSrc, dest)\n}\n\nmodule.exports = copySync\n","'use strict'\n\nmodule.exports = {\n  copySync: require('./copy-sync')\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdirp = require('../mkdirs').mkdirs\nconst pathExists = require('../path-exists').pathExists\nconst utimes = require('../util/utimes').utimesMillis\nconst stat = require('../util/stat')\n\nfunction copy (src, dest, opts, cb) {\n  if (typeof opts === 'function' && !cb) {\n    cb = opts\n    opts = {}\n  } else if (typeof opts === 'function') {\n    opts = { filter: opts }\n  }\n\n  cb = cb || function () {}\n  opts = opts || {}\n\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269`)\n  }\n\n  stat.checkPaths(src, dest, 'copy', (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat, destStat } = stats\n    stat.checkParentPaths(src, srcStat, dest, 'copy', err => {\n      if (err) return cb(err)\n      if (opts.filter) return handleFilter(checkParentDir, destStat, src, dest, opts, cb)\n      return checkParentDir(destStat, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction checkParentDir (destStat, src, dest, opts, cb) {\n  const destParent = path.dirname(dest)\n  pathExists(destParent, (err, dirExists) => {\n    if (err) return cb(err)\n    if (dirExists) return startCopy(destStat, src, dest, opts, cb)\n    mkdirp(destParent, err => {\n      if (err) return cb(err)\n      return startCopy(destStat, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction handleFilter (onInclude, destStat, src, dest, opts, cb) {\n  Promise.resolve(opts.filter(src, dest)).then(include => {\n    if (include) return onInclude(destStat, src, dest, opts, cb)\n    return cb()\n  }, error => cb(error))\n}\n\nfunction startCopy (destStat, src, dest, opts, cb) {\n  if (opts.filter) return handleFilter(getStats, destStat, src, dest, opts, cb)\n  return getStats(destStat, src, dest, opts, cb)\n}\n\nfunction getStats (destStat, src, dest, opts, cb) {\n  const stat = opts.dereference ? fs.stat : fs.lstat\n  stat(src, (err, srcStat) => {\n    if (err) return cb(err)\n\n    if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts, cb)\n    else if (srcStat.isFile() ||\n             srcStat.isCharacterDevice() ||\n             srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts, cb)\n    else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts, cb)\n  })\n}\n\nfunction onFile (srcStat, destStat, src, dest, opts, cb) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts, cb)\n  return mayCopyFile(srcStat, src, dest, opts, cb)\n}\n\nfunction mayCopyFile (srcStat, src, dest, opts, cb) {\n  if (opts.overwrite) {\n    fs.unlink(dest, err => {\n      if (err) return cb(err)\n      return copyFile(srcStat, src, dest, opts, cb)\n    })\n  } else if (opts.errorOnExist) {\n    return cb(new Error(`'${dest}' already exists`))\n  } else return cb()\n}\n\nfunction copyFile (srcStat, src, dest, opts, cb) {\n  if (typeof fs.copyFile === 'function') {\n    return fs.copyFile(src, dest, err => {\n      if (err) return cb(err)\n      return setDestModeAndTimestamps(srcStat, dest, opts, cb)\n    })\n  }\n  return copyFileFallback(srcStat, src, dest, opts, cb)\n}\n\nfunction copyFileFallback (srcStat, src, dest, opts, cb) {\n  const rs = fs.createReadStream(src)\n  rs.on('error', err => cb(err)).once('open', () => {\n    const ws = fs.createWriteStream(dest, { mode: srcStat.mode })\n    ws.on('error', err => cb(err))\n      .on('open', () => rs.pipe(ws))\n      .once('close', () => setDestModeAndTimestamps(srcStat, dest, opts, cb))\n  })\n}\n\nfunction setDestModeAndTimestamps (srcStat, dest, opts, cb) {\n  fs.chmod(dest, srcStat.mode, err => {\n    if (err) return cb(err)\n    if (opts.preserveTimestamps) {\n      return utimes(dest, srcStat.atime, srcStat.mtime, cb)\n    }\n    return cb()\n  })\n}\n\nfunction onDir (srcStat, destStat, src, dest, opts, cb) {\n  if (!destStat) return mkDirAndCopy(srcStat, src, dest, opts, cb)\n  if (destStat && !destStat.isDirectory()) {\n    return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`))\n  }\n  return copyDir(src, dest, opts, cb)\n}\n\nfunction mkDirAndCopy (srcStat, src, dest, opts, cb) {\n  fs.mkdir(dest, err => {\n    if (err) return cb(err)\n    copyDir(src, dest, opts, err => {\n      if (err) return cb(err)\n      return fs.chmod(dest, srcStat.mode, cb)\n    })\n  })\n}\n\nfunction copyDir (src, dest, opts, cb) {\n  fs.readdir(src, (err, items) => {\n    if (err) return cb(err)\n    return copyDirItems(items, src, dest, opts, cb)\n  })\n}\n\nfunction copyDirItems (items, src, dest, opts, cb) {\n  const item = items.pop()\n  if (!item) return cb()\n  return copyDirItem(items, item, src, dest, opts, cb)\n}\n\nfunction copyDirItem (items, item, src, dest, opts, cb) {\n  const srcItem = path.join(src, item)\n  const destItem = path.join(dest, item)\n  stat.checkPaths(srcItem, destItem, 'copy', (err, stats) => {\n    if (err) return cb(err)\n    const { destStat } = stats\n    startCopy(destStat, srcItem, destItem, opts, err => {\n      if (err) return cb(err)\n      return copyDirItems(items, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction onLink (destStat, src, dest, opts, cb) {\n  fs.readlink(src, (err, resolvedSrc) => {\n    if (err) return cb(err)\n    if (opts.dereference) {\n      resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n    }\n\n    if (!destStat) {\n      return fs.symlink(resolvedSrc, dest, cb)\n    } else {\n      fs.readlink(dest, (err, resolvedDest) => {\n        if (err) {\n          // dest exists and is a regular file or directory,\n          // Windows may throw UNKNOWN error. If dest already exists,\n          // fs throws error anyway, so no need to guard against it here.\n          if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest, cb)\n          return cb(err)\n        }\n        if (opts.dereference) {\n          resolvedDest = path.resolve(process.cwd(), resolvedDest)\n        }\n        if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n          return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`))\n        }\n\n        // do not copy if src is a subdir of dest since unlinking\n        // dest in this case would result in removing src contents\n        // and therefore a broken symlink would be created.\n        if (destStat.isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n          return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`))\n        }\n        return copyLink(resolvedSrc, dest, cb)\n      })\n    }\n  })\n}\n\nfunction copyLink (resolvedSrc, dest, cb) {\n  fs.unlink(dest, err => {\n    if (err) return cb(err)\n    return fs.symlink(resolvedSrc, dest, cb)\n  })\n}\n\nmodule.exports = copy\n","'use strict'\n\nconst u = require('universalify').fromCallback\nmodule.exports = {\n  copy: u(require('./copy'))\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdir = require('../mkdirs')\nconst remove = require('../remove')\n\nconst emptyDir = u(function emptyDir (dir, callback) {\n  callback = callback || function () {}\n  fs.readdir(dir, (err, items) => {\n    if (err) return mkdir.mkdirs(dir, callback)\n\n    items = items.map(item => path.join(dir, item))\n\n    deleteItem()\n\n    function deleteItem () {\n      const item = items.pop()\n      if (!item) return callback()\n      remove.remove(item, err => {\n        if (err) return callback(err)\n        deleteItem()\n      })\n    }\n  })\n})\n\nfunction emptyDirSync (dir) {\n  let items\n  try {\n    items = fs.readdirSync(dir)\n  } catch (err) {\n    return mkdir.mkdirsSync(dir)\n  }\n\n  items.forEach(item => {\n    item = path.join(dir, item)\n    remove.removeSync(item)\n  })\n}\n\nmodule.exports = {\n  emptyDirSync,\n  emptydirSync: emptyDirSync,\n  emptyDir,\n  emptydir: emptyDir\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst path = require('path')\nconst fs = require('graceful-fs')\nconst mkdir = require('../mkdirs')\nconst pathExists = require('../path-exists').pathExists\n\nfunction createFile (file, callback) {\n  function makeFile () {\n    fs.writeFile(file, '', err => {\n      if (err) return callback(err)\n      callback()\n    })\n  }\n\n  fs.stat(file, (err, stats) => { // eslint-disable-line handle-callback-err\n    if (!err && stats.isFile()) return callback()\n    const dir = path.dirname(file)\n    pathExists(dir, (err, dirExists) => {\n      if (err) return callback(err)\n      if (dirExists) return makeFile()\n      mkdir.mkdirs(dir, err => {\n        if (err) return callback(err)\n        makeFile()\n      })\n    })\n  })\n}\n\nfunction createFileSync (file) {\n  let stats\n  try {\n    stats = fs.statSync(file)\n  } catch (e) {}\n  if (stats && stats.isFile()) return\n\n  const dir = path.dirname(file)\n  if (!fs.existsSync(dir)) {\n    mkdir.mkdirsSync(dir)\n  }\n\n  fs.writeFileSync(file, '')\n}\n\nmodule.exports = {\n  createFile: u(createFile),\n  createFileSync\n}\n","'use strict'\n\nconst file = require('./file')\nconst link = require('./link')\nconst symlink = require('./symlink')\n\nmodule.exports = {\n  // file\n  createFile: file.createFile,\n  createFileSync: file.createFileSync,\n  ensureFile: file.createFile,\n  ensureFileSync: file.createFileSync,\n  // link\n  createLink: link.createLink,\n  createLinkSync: link.createLinkSync,\n  ensureLink: link.createLink,\n  ensureLinkSync: link.createLinkSync,\n  // symlink\n  createSymlink: symlink.createSymlink,\n  createSymlinkSync: symlink.createSymlinkSync,\n  ensureSymlink: symlink.createSymlink,\n  ensureSymlinkSync: symlink.createSymlinkSync\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst path = require('path')\nconst fs = require('graceful-fs')\nconst mkdir = require('../mkdirs')\nconst pathExists = require('../path-exists').pathExists\n\nfunction createLink (srcpath, dstpath, callback) {\n  function makeLink (srcpath, dstpath) {\n    fs.link(srcpath, dstpath, err => {\n      if (err) return callback(err)\n      callback(null)\n    })\n  }\n\n  pathExists(dstpath, (err, destinationExists) => {\n    if (err) return callback(err)\n    if (destinationExists) return callback(null)\n    fs.lstat(srcpath, (err) => {\n      if (err) {\n        err.message = err.message.replace('lstat', 'ensureLink')\n        return callback(err)\n      }\n\n      const dir = path.dirname(dstpath)\n      pathExists(dir, (err, dirExists) => {\n        if (err) return callback(err)\n        if (dirExists) return makeLink(srcpath, dstpath)\n        mkdir.mkdirs(dir, err => {\n          if (err) return callback(err)\n          makeLink(srcpath, dstpath)\n        })\n      })\n    })\n  })\n}\n\nfunction createLinkSync (srcpath, dstpath) {\n  const destinationExists = fs.existsSync(dstpath)\n  if (destinationExists) return undefined\n\n  try {\n    fs.lstatSync(srcpath)\n  } catch (err) {\n    err.message = err.message.replace('lstat', 'ensureLink')\n    throw err\n  }\n\n  const dir = path.dirname(dstpath)\n  const dirExists = fs.existsSync(dir)\n  if (dirExists) return fs.linkSync(srcpath, dstpath)\n  mkdir.mkdirsSync(dir)\n\n  return fs.linkSync(srcpath, dstpath)\n}\n\nmodule.exports = {\n  createLink: u(createLink),\n  createLinkSync\n}\n","'use strict'\n\nconst path = require('path')\nconst fs = require('graceful-fs')\nconst pathExists = require('../path-exists').pathExists\n\n/**\n * Function that returns two types of paths, one relative to symlink, and one\n * relative to the current working directory. Checks if path is absolute or\n * relative. If the path is relative, this function checks if the path is\n * relative to symlink or relative to current working directory. This is an\n * initiative to find a smarter `srcpath` to supply when building symlinks.\n * This allows you to determine which path to use out of one of three possible\n * types of source paths. The first is an absolute path. This is detected by\n * `path.isAbsolute()`. When an absolute path is provided, it is checked to\n * see if it exists. If it does it's used, if not an error is returned\n * (callback)/ thrown (sync). The other two options for `srcpath` are a\n * relative url. By default Node's `fs.symlink` works by creating a symlink\n * using `dstpath` and expects the `srcpath` to be relative to the newly\n * created symlink. If you provide a `srcpath` that does not exist on the file\n * system it results in a broken symlink. To minimize this, the function\n * checks to see if the 'relative to symlink' source file exists, and if it\n * does it will use it. If it does not, it checks if there's a file that\n * exists that is relative to the current working directory, if does its used.\n * This preserves the expectations of the original fs.symlink spec and adds\n * the ability to pass in `relative to current working direcotry` paths.\n */\n\nfunction symlinkPaths (srcpath, dstpath, callback) {\n  if (path.isAbsolute(srcpath)) {\n    return fs.lstat(srcpath, (err) => {\n      if (err) {\n        err.message = err.message.replace('lstat', 'ensureSymlink')\n        return callback(err)\n      }\n      return callback(null, {\n        'toCwd': srcpath,\n        'toDst': srcpath\n      })\n    })\n  } else {\n    const dstdir = path.dirname(dstpath)\n    const relativeToDst = path.join(dstdir, srcpath)\n    return pathExists(relativeToDst, (err, exists) => {\n      if (err) return callback(err)\n      if (exists) {\n        return callback(null, {\n          'toCwd': relativeToDst,\n          'toDst': srcpath\n        })\n      } else {\n        return fs.lstat(srcpath, (err) => {\n          if (err) {\n            err.message = err.message.replace('lstat', 'ensureSymlink')\n            return callback(err)\n          }\n          return callback(null, {\n            'toCwd': srcpath,\n            'toDst': path.relative(dstdir, srcpath)\n          })\n        })\n      }\n    })\n  }\n}\n\nfunction symlinkPathsSync (srcpath, dstpath) {\n  let exists\n  if (path.isAbsolute(srcpath)) {\n    exists = fs.existsSync(srcpath)\n    if (!exists) throw new Error('absolute srcpath does not exist')\n    return {\n      'toCwd': srcpath,\n      'toDst': srcpath\n    }\n  } else {\n    const dstdir = path.dirname(dstpath)\n    const relativeToDst = path.join(dstdir, srcpath)\n    exists = fs.existsSync(relativeToDst)\n    if (exists) {\n      return {\n        'toCwd': relativeToDst,\n        'toDst': srcpath\n      }\n    } else {\n      exists = fs.existsSync(srcpath)\n      if (!exists) throw new Error('relative srcpath does not exist')\n      return {\n        'toCwd': srcpath,\n        'toDst': path.relative(dstdir, srcpath)\n      }\n    }\n  }\n}\n\nmodule.exports = {\n  symlinkPaths,\n  symlinkPathsSync\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\n\nfunction symlinkType (srcpath, type, callback) {\n  callback = (typeof type === 'function') ? type : callback\n  type = (typeof type === 'function') ? false : type\n  if (type) return callback(null, type)\n  fs.lstat(srcpath, (err, stats) => {\n    if (err) return callback(null, 'file')\n    type = (stats && stats.isDirectory()) ? 'dir' : 'file'\n    callback(null, type)\n  })\n}\n\nfunction symlinkTypeSync (srcpath, type) {\n  let stats\n\n  if (type) return type\n  try {\n    stats = fs.lstatSync(srcpath)\n  } catch (e) {\n    return 'file'\n  }\n  return (stats && stats.isDirectory()) ? 'dir' : 'file'\n}\n\nmodule.exports = {\n  symlinkType,\n  symlinkTypeSync\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst path = require('path')\nconst fs = require('graceful-fs')\nconst _mkdirs = require('../mkdirs')\nconst mkdirs = _mkdirs.mkdirs\nconst mkdirsSync = _mkdirs.mkdirsSync\n\nconst _symlinkPaths = require('./symlink-paths')\nconst symlinkPaths = _symlinkPaths.symlinkPaths\nconst symlinkPathsSync = _symlinkPaths.symlinkPathsSync\n\nconst _symlinkType = require('./symlink-type')\nconst symlinkType = _symlinkType.symlinkType\nconst symlinkTypeSync = _symlinkType.symlinkTypeSync\n\nconst pathExists = require('../path-exists').pathExists\n\nfunction createSymlink (srcpath, dstpath, type, callback) {\n  callback = (typeof type === 'function') ? type : callback\n  type = (typeof type === 'function') ? false : type\n\n  pathExists(dstpath, (err, destinationExists) => {\n    if (err) return callback(err)\n    if (destinationExists) return callback(null)\n    symlinkPaths(srcpath, dstpath, (err, relative) => {\n      if (err) return callback(err)\n      srcpath = relative.toDst\n      symlinkType(relative.toCwd, type, (err, type) => {\n        if (err) return callback(err)\n        const dir = path.dirname(dstpath)\n        pathExists(dir, (err, dirExists) => {\n          if (err) return callback(err)\n          if (dirExists) return fs.symlink(srcpath, dstpath, type, callback)\n          mkdirs(dir, err => {\n            if (err) return callback(err)\n            fs.symlink(srcpath, dstpath, type, callback)\n          })\n        })\n      })\n    })\n  })\n}\n\nfunction createSymlinkSync (srcpath, dstpath, type) {\n  const destinationExists = fs.existsSync(dstpath)\n  if (destinationExists) return undefined\n\n  const relative = symlinkPathsSync(srcpath, dstpath)\n  srcpath = relative.toDst\n  type = symlinkTypeSync(relative.toCwd, type)\n  const dir = path.dirname(dstpath)\n  const exists = fs.existsSync(dir)\n  if (exists) return fs.symlinkSync(srcpath, dstpath, type)\n  mkdirsSync(dir)\n  return fs.symlinkSync(srcpath, dstpath, type)\n}\n\nmodule.exports = {\n  createSymlink: u(createSymlink),\n  createSymlinkSync\n}\n","'use strict'\n// This is adapted from https://github.com/normalize/mz\n// Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors\nconst u = require('universalify').fromCallback\nconst fs = require('graceful-fs')\n\nconst api = [\n  'access',\n  'appendFile',\n  'chmod',\n  'chown',\n  'close',\n  'copyFile',\n  'fchmod',\n  'fchown',\n  'fdatasync',\n  'fstat',\n  'fsync',\n  'ftruncate',\n  'futimes',\n  'lchown',\n  'lchmod',\n  'link',\n  'lstat',\n  'mkdir',\n  'mkdtemp',\n  'open',\n  'readFile',\n  'readdir',\n  'readlink',\n  'realpath',\n  'rename',\n  'rmdir',\n  'stat',\n  'symlink',\n  'truncate',\n  'unlink',\n  'utimes',\n  'writeFile'\n].filter(key => {\n  // Some commands are not available on some systems. Ex:\n  // fs.copyFile was added in Node.js v8.5.0\n  // fs.mkdtemp was added in Node.js v5.10.0\n  // fs.lchown is not available on at least some Linux\n  return typeof fs[key] === 'function'\n})\n\n// Export all keys:\nObject.keys(fs).forEach(key => {\n  if (key === 'promises') {\n    // fs.promises is a getter property that triggers ExperimentalWarning\n    // Don't re-export it here, the getter is defined in \"lib/index.js\"\n    return\n  }\n  exports[key] = fs[key]\n})\n\n// Universalify async methods:\napi.forEach(method => {\n  exports[method] = u(fs[method])\n})\n\n// We differ from mz/fs in that we still ship the old, broken, fs.exists()\n// since we are a drop-in replacement for the native module\nexports.exists = function (filename, callback) {\n  if (typeof callback === 'function') {\n    return fs.exists(filename, callback)\n  }\n  return new Promise(resolve => {\n    return fs.exists(filename, resolve)\n  })\n}\n\n// fs.read() & fs.write need special treatment due to multiple callback args\n\nexports.read = function (fd, buffer, offset, length, position, callback) {\n  if (typeof callback === 'function') {\n    return fs.read(fd, buffer, offset, length, position, callback)\n  }\n  return new Promise((resolve, reject) => {\n    fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {\n      if (err) return reject(err)\n      resolve({ bytesRead, buffer })\n    })\n  })\n}\n\n// Function signature can be\n// fs.write(fd, buffer[, offset[, length[, position]]], callback)\n// OR\n// fs.write(fd, string[, position[, encoding]], callback)\n// We need to handle both cases, so we use ...args\nexports.write = function (fd, buffer, ...args) {\n  if (typeof args[args.length - 1] === 'function') {\n    return fs.write(fd, buffer, ...args)\n  }\n\n  return new Promise((resolve, reject) => {\n    fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {\n      if (err) return reject(err)\n      resolve({ bytesWritten, buffer })\n    })\n  })\n}\n\n// fs.realpath.native only available in Node v9.2+\nif (typeof fs.realpath.native === 'function') {\n  exports.realpath.native = u(fs.realpath.native)\n}\n","'use strict'\n\nmodule.exports = Object.assign(\n  {},\n  // Export promiseified graceful-fs:\n  require('./fs'),\n  // Export extra methods:\n  require('./copy-sync'),\n  require('./copy'),\n  require('./empty'),\n  require('./ensure'),\n  require('./json'),\n  require('./mkdirs'),\n  require('./move-sync'),\n  require('./move'),\n  require('./output'),\n  require('./path-exists'),\n  require('./remove')\n)\n\n// Export fs.promises as a getter property so that we don't trigger\n// ExperimentalWarning before fs.promises is actually accessed.\nconst fs = require('fs')\nif (Object.getOwnPropertyDescriptor(fs, 'promises')) {\n  Object.defineProperty(module.exports, 'promises', {\n    get () { return fs.promises }\n  })\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst jsonFile = require('./jsonfile')\n\njsonFile.outputJson = u(require('./output-json'))\njsonFile.outputJsonSync = require('./output-json-sync')\n// aliases\njsonFile.outputJSON = jsonFile.outputJson\njsonFile.outputJSONSync = jsonFile.outputJsonSync\njsonFile.writeJSON = jsonFile.writeJson\njsonFile.writeJSONSync = jsonFile.writeJsonSync\njsonFile.readJSON = jsonFile.readJson\njsonFile.readJSONSync = jsonFile.readJsonSync\n\nmodule.exports = jsonFile\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst jsonFile = require('jsonfile')\n\nmodule.exports = {\n  // jsonfile exports\n  readJson: u(jsonFile.readFile),\n  readJsonSync: jsonFile.readFileSync,\n  writeJson: u(jsonFile.writeFile),\n  writeJsonSync: jsonFile.writeFileSync\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdir = require('../mkdirs')\nconst jsonFile = require('./jsonfile')\n\nfunction outputJsonSync (file, data, options) {\n  const dir = path.dirname(file)\n\n  if (!fs.existsSync(dir)) {\n    mkdir.mkdirsSync(dir)\n  }\n\n  jsonFile.writeJsonSync(file, data, options)\n}\n\nmodule.exports = outputJsonSync\n","'use strict'\n\nconst path = require('path')\nconst mkdir = require('../mkdirs')\nconst pathExists = require('../path-exists').pathExists\nconst jsonFile = require('./jsonfile')\n\nfunction outputJson (file, data, options, callback) {\n  if (typeof options === 'function') {\n    callback = options\n    options = {}\n  }\n\n  const dir = path.dirname(file)\n\n  pathExists(dir, (err, itDoes) => {\n    if (err) return callback(err)\n    if (itDoes) return jsonFile.writeJson(file, data, options, callback)\n\n    mkdir.mkdirs(dir, err => {\n      if (err) return callback(err)\n      jsonFile.writeJson(file, data, options, callback)\n    })\n  })\n}\n\nmodule.exports = outputJson\n","'use strict'\nconst u = require('universalify').fromCallback\nconst mkdirs = u(require('./mkdirs'))\nconst mkdirsSync = require('./mkdirs-sync')\n\nmodule.exports = {\n  mkdirs,\n  mkdirsSync,\n  // alias\n  mkdirp: mkdirs,\n  mkdirpSync: mkdirsSync,\n  ensureDir: mkdirs,\n  ensureDirSync: mkdirsSync\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst invalidWin32Path = require('./win32').invalidWin32Path\n\nconst o777 = parseInt('0777', 8)\n\nfunction mkdirsSync (p, opts, made) {\n  if (!opts || typeof opts !== 'object') {\n    opts = { mode: opts }\n  }\n\n  let mode = opts.mode\n  const xfs = opts.fs || fs\n\n  if (process.platform === 'win32' && invalidWin32Path(p)) {\n    const errInval = new Error(p + ' contains invalid WIN32 path characters.')\n    errInval.code = 'EINVAL'\n    throw errInval\n  }\n\n  if (mode === undefined) {\n    mode = o777 & (~process.umask())\n  }\n  if (!made) made = null\n\n  p = path.resolve(p)\n\n  try {\n    xfs.mkdirSync(p, mode)\n    made = made || p\n  } catch (err0) {\n    if (err0.code === 'ENOENT') {\n      if (path.dirname(p) === p) throw err0\n      made = mkdirsSync(path.dirname(p), opts, made)\n      mkdirsSync(p, opts, made)\n    } else {\n      // In the case of any other error, just see if there's a dir there\n      // already. If so, then hooray!  If not, then something is borked.\n      let stat\n      try {\n        stat = xfs.statSync(p)\n      } catch (err1) {\n        throw err0\n      }\n      if (!stat.isDirectory()) throw err0\n    }\n  }\n\n  return made\n}\n\nmodule.exports = mkdirsSync\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst invalidWin32Path = require('./win32').invalidWin32Path\n\nconst o777 = parseInt('0777', 8)\n\nfunction mkdirs (p, opts, callback, made) {\n  if (typeof opts === 'function') {\n    callback = opts\n    opts = {}\n  } else if (!opts || typeof opts !== 'object') {\n    opts = { mode: opts }\n  }\n\n  if (process.platform === 'win32' && invalidWin32Path(p)) {\n    const errInval = new Error(p + ' contains invalid WIN32 path characters.')\n    errInval.code = 'EINVAL'\n    return callback(errInval)\n  }\n\n  let mode = opts.mode\n  const xfs = opts.fs || fs\n\n  if (mode === undefined) {\n    mode = o777 & (~process.umask())\n  }\n  if (!made) made = null\n\n  callback = callback || function () {}\n  p = path.resolve(p)\n\n  xfs.mkdir(p, mode, er => {\n    if (!er) {\n      made = made || p\n      return callback(null, made)\n    }\n    switch (er.code) {\n      case 'ENOENT':\n        if (path.dirname(p) === p) return callback(er)\n        mkdirs(path.dirname(p), opts, (er, made) => {\n          if (er) callback(er, made)\n          else mkdirs(p, opts, callback, made)\n        })\n        break\n\n      // In the case of any other error, just see if there's a dir\n      // there already.  If so, then hooray!  If not, then something\n      // is borked.\n      default:\n        xfs.stat(p, (er2, stat) => {\n          // if the stat fails, then that's super weird.\n          // let the original error be the failure reason.\n          if (er2 || !stat.isDirectory()) callback(er, made)\n          else callback(null, made)\n        })\n        break\n    }\n  })\n}\n\nmodule.exports = mkdirs\n","'use strict'\n\nconst path = require('path')\n\n// get drive on windows\nfunction getRootPath (p) {\n  p = path.normalize(path.resolve(p)).split(path.sep)\n  if (p.length > 0) return p[0]\n  return null\n}\n\n// http://stackoverflow.com/a/62888/10333 contains more accurate\n// TODO: expand to include the rest\nconst INVALID_PATH_CHARS = /[<>:\"|?*]/\n\nfunction invalidWin32Path (p) {\n  const rp = getRootPath(p)\n  p = p.replace(rp, '')\n  return INVALID_PATH_CHARS.test(p)\n}\n\nmodule.exports = {\n  getRootPath,\n  invalidWin32Path\n}\n","'use strict'\n\nmodule.exports = {\n  moveSync: require('./move-sync')\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst copySync = require('../copy-sync').copySync\nconst removeSync = require('../remove').removeSync\nconst mkdirpSync = require('../mkdirs').mkdirpSync\nconst stat = require('../util/stat')\n\nfunction moveSync (src, dest, opts) {\n  opts = opts || {}\n  const overwrite = opts.overwrite || opts.clobber || false\n\n  const { srcStat } = stat.checkPathsSync(src, dest, 'move')\n  stat.checkParentPathsSync(src, srcStat, dest, 'move')\n  mkdirpSync(path.dirname(dest))\n  return doRename(src, dest, overwrite)\n}\n\nfunction doRename (src, dest, overwrite) {\n  if (overwrite) {\n    removeSync(dest)\n    return rename(src, dest, overwrite)\n  }\n  if (fs.existsSync(dest)) throw new Error('dest already exists.')\n  return rename(src, dest, overwrite)\n}\n\nfunction rename (src, dest, overwrite) {\n  try {\n    fs.renameSync(src, dest)\n  } catch (err) {\n    if (err.code !== 'EXDEV') throw err\n    return moveAcrossDevice(src, dest, overwrite)\n  }\n}\n\nfunction moveAcrossDevice (src, dest, overwrite) {\n  const opts = {\n    overwrite,\n    errorOnExist: true\n  }\n  copySync(src, dest, opts)\n  return removeSync(src)\n}\n\nmodule.exports = moveSync\n","'use strict'\n\nconst u = require('universalify').fromCallback\nmodule.exports = {\n  move: u(require('./move'))\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst copy = require('../copy').copy\nconst remove = require('../remove').remove\nconst mkdirp = require('../mkdirs').mkdirp\nconst pathExists = require('../path-exists').pathExists\nconst stat = require('../util/stat')\n\nfunction move (src, dest, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  }\n\n  const overwrite = opts.overwrite || opts.clobber || false\n\n  stat.checkPaths(src, dest, 'move', (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat } = stats\n    stat.checkParentPaths(src, srcStat, dest, 'move', err => {\n      if (err) return cb(err)\n      mkdirp(path.dirname(dest), err => {\n        if (err) return cb(err)\n        return doRename(src, dest, overwrite, cb)\n      })\n    })\n  })\n}\n\nfunction doRename (src, dest, overwrite, cb) {\n  if (overwrite) {\n    return remove(dest, err => {\n      if (err) return cb(err)\n      return rename(src, dest, overwrite, cb)\n    })\n  }\n  pathExists(dest, (err, destExists) => {\n    if (err) return cb(err)\n    if (destExists) return cb(new Error('dest already exists.'))\n    return rename(src, dest, overwrite, cb)\n  })\n}\n\nfunction rename (src, dest, overwrite, cb) {\n  fs.rename(src, dest, err => {\n    if (!err) return cb()\n    if (err.code !== 'EXDEV') return cb(err)\n    return moveAcrossDevice(src, dest, overwrite, cb)\n  })\n}\n\nfunction moveAcrossDevice (src, dest, overwrite, cb) {\n  const opts = {\n    overwrite,\n    errorOnExist: true\n  }\n  copy(src, dest, opts, err => {\n    if (err) return cb(err)\n    return remove(src, cb)\n  })\n}\n\nmodule.exports = move\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdir = require('../mkdirs')\nconst pathExists = require('../path-exists').pathExists\n\nfunction outputFile (file, data, encoding, callback) {\n  if (typeof encoding === 'function') {\n    callback = encoding\n    encoding = 'utf8'\n  }\n\n  const dir = path.dirname(file)\n  pathExists(dir, (err, itDoes) => {\n    if (err) return callback(err)\n    if (itDoes) return fs.writeFile(file, data, encoding, callback)\n\n    mkdir.mkdirs(dir, err => {\n      if (err) return callback(err)\n\n      fs.writeFile(file, data, encoding, callback)\n    })\n  })\n}\n\nfunction outputFileSync (file, ...args) {\n  const dir = path.dirname(file)\n  if (fs.existsSync(dir)) {\n    return fs.writeFileSync(file, ...args)\n  }\n  mkdir.mkdirsSync(dir)\n  fs.writeFileSync(file, ...args)\n}\n\nmodule.exports = {\n  outputFile: u(outputFile),\n  outputFileSync\n}\n","'use strict'\nconst u = require('universalify').fromPromise\nconst fs = require('../fs')\n\nfunction pathExists (path) {\n  return fs.access(path).then(() => true).catch(() => false)\n}\n\nmodule.exports = {\n  pathExists: u(pathExists),\n  pathExistsSync: fs.existsSync\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst rimraf = require('./rimraf')\n\nmodule.exports = {\n  remove: u(rimraf),\n  removeSync: rimraf.sync\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst assert = require('assert')\n\nconst isWindows = (process.platform === 'win32')\n\nfunction defaults (options) {\n  const methods = [\n    'unlink',\n    'chmod',\n    'stat',\n    'lstat',\n    'rmdir',\n    'readdir'\n  ]\n  methods.forEach(m => {\n    options[m] = options[m] || fs[m]\n    m = m + 'Sync'\n    options[m] = options[m] || fs[m]\n  })\n\n  options.maxBusyTries = options.maxBusyTries || 3\n}\n\nfunction rimraf (p, options, cb) {\n  let busyTries = 0\n\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  assert(p, 'rimraf: missing path')\n  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')\n  assert.strictEqual(typeof cb, 'function', 'rimraf: callback function required')\n  assert(options, 'rimraf: invalid options argument provided')\n  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')\n\n  defaults(options)\n\n  rimraf_(p, options, function CB (er) {\n    if (er) {\n      if ((er.code === 'EBUSY' || er.code === 'ENOTEMPTY' || er.code === 'EPERM') &&\n          busyTries < options.maxBusyTries) {\n        busyTries++\n        const time = busyTries * 100\n        // try again, with the same exact callback as this one.\n        return setTimeout(() => rimraf_(p, options, CB), time)\n      }\n\n      // already gone\n      if (er.code === 'ENOENT') er = null\n    }\n\n    cb(er)\n  })\n}\n\n// Two possible strategies.\n// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR\n// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR\n//\n// Both result in an extra syscall when you guess wrong.  However, there\n// are likely far more normal files in the world than directories.  This\n// is based on the assumption that a the average number of files per\n// directory is >= 1.\n//\n// If anyone ever complains about this, then I guess the strategy could\n// be made configurable somehow.  But until then, YAGNI.\nfunction rimraf_ (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  // sunos lets the root user unlink directories, which is... weird.\n  // so we have to lstat here and make sure it's not a dir.\n  options.lstat(p, (er, st) => {\n    if (er && er.code === 'ENOENT') {\n      return cb(null)\n    }\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er && er.code === 'EPERM' && isWindows) {\n      return fixWinEPERM(p, options, er, cb)\n    }\n\n    if (st && st.isDirectory()) {\n      return rmdir(p, options, er, cb)\n    }\n\n    options.unlink(p, er => {\n      if (er) {\n        if (er.code === 'ENOENT') {\n          return cb(null)\n        }\n        if (er.code === 'EPERM') {\n          return (isWindows)\n            ? fixWinEPERM(p, options, er, cb)\n            : rmdir(p, options, er, cb)\n        }\n        if (er.code === 'EISDIR') {\n          return rmdir(p, options, er, cb)\n        }\n      }\n      return cb(er)\n    })\n  })\n}\n\nfunction fixWinEPERM (p, options, er, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n  if (er) {\n    assert(er instanceof Error)\n  }\n\n  options.chmod(p, 0o666, er2 => {\n    if (er2) {\n      cb(er2.code === 'ENOENT' ? null : er)\n    } else {\n      options.stat(p, (er3, stats) => {\n        if (er3) {\n          cb(er3.code === 'ENOENT' ? null : er)\n        } else if (stats.isDirectory()) {\n          rmdir(p, options, er, cb)\n        } else {\n          options.unlink(p, cb)\n        }\n      })\n    }\n  })\n}\n\nfunction fixWinEPERMSync (p, options, er) {\n  let stats\n\n  assert(p)\n  assert(options)\n  if (er) {\n    assert(er instanceof Error)\n  }\n\n  try {\n    options.chmodSync(p, 0o666)\n  } catch (er2) {\n    if (er2.code === 'ENOENT') {\n      return\n    } else {\n      throw er\n    }\n  }\n\n  try {\n    stats = options.statSync(p)\n  } catch (er3) {\n    if (er3.code === 'ENOENT') {\n      return\n    } else {\n      throw er\n    }\n  }\n\n  if (stats.isDirectory()) {\n    rmdirSync(p, options, er)\n  } else {\n    options.unlinkSync(p)\n  }\n}\n\nfunction rmdir (p, options, originalEr, cb) {\n  assert(p)\n  assert(options)\n  if (originalEr) {\n    assert(originalEr instanceof Error)\n  }\n  assert(typeof cb === 'function')\n\n  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)\n  // if we guessed wrong, and it's not a directory, then\n  // raise the original error.\n  options.rmdir(p, er => {\n    if (er && (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')) {\n      rmkids(p, options, cb)\n    } else if (er && er.code === 'ENOTDIR') {\n      cb(originalEr)\n    } else {\n      cb(er)\n    }\n  })\n}\n\nfunction rmkids (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  options.readdir(p, (er, files) => {\n    if (er) return cb(er)\n\n    let n = files.length\n    let errState\n\n    if (n === 0) return options.rmdir(p, cb)\n\n    files.forEach(f => {\n      rimraf(path.join(p, f), options, er => {\n        if (errState) {\n          return\n        }\n        if (er) return cb(errState = er)\n        if (--n === 0) {\n          options.rmdir(p, cb)\n        }\n      })\n    })\n  })\n}\n\n// this looks simpler, and is strictly *faster*, but will\n// tie up the JavaScript thread and fail on excessively\n// deep directory trees.\nfunction rimrafSync (p, options) {\n  let st\n\n  options = options || {}\n  defaults(options)\n\n  assert(p, 'rimraf: missing path')\n  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')\n  assert(options, 'rimraf: missing options')\n  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')\n\n  try {\n    st = options.lstatSync(p)\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      return\n    }\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er.code === 'EPERM' && isWindows) {\n      fixWinEPERMSync(p, options, er)\n    }\n  }\n\n  try {\n    // sunos lets the root user unlink directories, which is... weird.\n    if (st && st.isDirectory()) {\n      rmdirSync(p, options, null)\n    } else {\n      options.unlinkSync(p)\n    }\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      return\n    } else if (er.code === 'EPERM') {\n      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)\n    } else if (er.code !== 'EISDIR') {\n      throw er\n    }\n    rmdirSync(p, options, er)\n  }\n}\n\nfunction rmdirSync (p, options, originalEr) {\n  assert(p)\n  assert(options)\n  if (originalEr) {\n    assert(originalEr instanceof Error)\n  }\n\n  try {\n    options.rmdirSync(p)\n  } catch (er) {\n    if (er.code === 'ENOTDIR') {\n      throw originalEr\n    } else if (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM') {\n      rmkidsSync(p, options)\n    } else if (er.code !== 'ENOENT') {\n      throw er\n    }\n  }\n}\n\nfunction rmkidsSync (p, options) {\n  assert(p)\n  assert(options)\n  options.readdirSync(p).forEach(f => rimrafSync(path.join(p, f), options))\n\n  if (isWindows) {\n    // We only end up here once we got ENOTEMPTY at least once, and\n    // at this point, we are guaranteed to have removed all the kids.\n    // So, we know that it won't be ENOENT or ENOTDIR or anything else.\n    // try really hard to delete stuff on windows, because it has a\n    // PROFOUNDLY annoying habit of not closing handles promptly when\n    // files are deleted, resulting in spurious ENOTEMPTY errors.\n    const startTime = Date.now()\n    do {\n      try {\n        const ret = options.rmdirSync(p, options)\n        return ret\n      } catch (er) { }\n    } while (Date.now() - startTime < 500) // give up after 500ms\n  } else {\n    const ret = options.rmdirSync(p, options)\n    return ret\n  }\n}\n\nmodule.exports = rimraf\nrimraf.sync = rimrafSync\n","'use strict'\n/* eslint-disable node/no-deprecated-api */\nmodule.exports = function (size) {\n  if (typeof Buffer.allocUnsafe === 'function') {\n    try {\n      return Buffer.allocUnsafe(size)\n    } catch (e) {\n      return new Buffer(size)\n    }\n  }\n  return new Buffer(size)\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\n\nconst NODE_VERSION_MAJOR_WITH_BIGINT = 10\nconst NODE_VERSION_MINOR_WITH_BIGINT = 5\nconst NODE_VERSION_PATCH_WITH_BIGINT = 0\nconst nodeVersion = process.versions.node.split('.')\nconst nodeVersionMajor = Number.parseInt(nodeVersion[0], 10)\nconst nodeVersionMinor = Number.parseInt(nodeVersion[1], 10)\nconst nodeVersionPatch = Number.parseInt(nodeVersion[2], 10)\n\nfunction nodeSupportsBigInt () {\n  if (nodeVersionMajor > NODE_VERSION_MAJOR_WITH_BIGINT) {\n    return true\n  } else if (nodeVersionMajor === NODE_VERSION_MAJOR_WITH_BIGINT) {\n    if (nodeVersionMinor > NODE_VERSION_MINOR_WITH_BIGINT) {\n      return true\n    } else if (nodeVersionMinor === NODE_VERSION_MINOR_WITH_BIGINT) {\n      if (nodeVersionPatch >= NODE_VERSION_PATCH_WITH_BIGINT) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\nfunction getStats (src, dest, cb) {\n  if (nodeSupportsBigInt()) {\n    fs.stat(src, { bigint: true }, (err, srcStat) => {\n      if (err) return cb(err)\n      fs.stat(dest, { bigint: true }, (err, destStat) => {\n        if (err) {\n          if (err.code === 'ENOENT') return cb(null, { srcStat, destStat: null })\n          return cb(err)\n        }\n        return cb(null, { srcStat, destStat })\n      })\n    })\n  } else {\n    fs.stat(src, (err, srcStat) => {\n      if (err) return cb(err)\n      fs.stat(dest, (err, destStat) => {\n        if (err) {\n          if (err.code === 'ENOENT') return cb(null, { srcStat, destStat: null })\n          return cb(err)\n        }\n        return cb(null, { srcStat, destStat })\n      })\n    })\n  }\n}\n\nfunction getStatsSync (src, dest) {\n  let srcStat, destStat\n  if (nodeSupportsBigInt()) {\n    srcStat = fs.statSync(src, { bigint: true })\n  } else {\n    srcStat = fs.statSync(src)\n  }\n  try {\n    if (nodeSupportsBigInt()) {\n      destStat = fs.statSync(dest, { bigint: true })\n    } else {\n      destStat = fs.statSync(dest)\n    }\n  } catch (err) {\n    if (err.code === 'ENOENT') return { srcStat, destStat: null }\n    throw err\n  }\n  return { srcStat, destStat }\n}\n\nfunction checkPaths (src, dest, funcName, cb) {\n  getStats(src, dest, (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat, destStat } = stats\n    if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n      return cb(new Error('Source and destination must not be the same.'))\n    }\n    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n      return cb(new Error(errMsg(src, dest, funcName)))\n    }\n    return cb(null, { srcStat, destStat })\n  })\n}\n\nfunction checkPathsSync (src, dest, funcName) {\n  const { srcStat, destStat } = getStatsSync(src, dest)\n  if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n    throw new Error('Source and destination must not be the same.')\n  }\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return { srcStat, destStat }\n}\n\n// recursively check if dest parent is a subdirectory of src.\n// It works for all file types including symlinks since it\n// checks the src and dest inodes. It starts from the deepest\n// parent and stops once it reaches the src parent or the root path.\nfunction checkParentPaths (src, srcStat, dest, funcName, cb) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return cb()\n  if (nodeSupportsBigInt()) {\n    fs.stat(destParent, { bigint: true }, (err, destStat) => {\n      if (err) {\n        if (err.code === 'ENOENT') return cb()\n        return cb(err)\n      }\n      if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n        return cb(new Error(errMsg(src, dest, funcName)))\n      }\n      return checkParentPaths(src, srcStat, destParent, funcName, cb)\n    })\n  } else {\n    fs.stat(destParent, (err, destStat) => {\n      if (err) {\n        if (err.code === 'ENOENT') return cb()\n        return cb(err)\n      }\n      if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n        return cb(new Error(errMsg(src, dest, funcName)))\n      }\n      return checkParentPaths(src, srcStat, destParent, funcName, cb)\n    })\n  }\n}\n\nfunction checkParentPathsSync (src, srcStat, dest, funcName) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return\n  let destStat\n  try {\n    if (nodeSupportsBigInt()) {\n      destStat = fs.statSync(destParent, { bigint: true })\n    } else {\n      destStat = fs.statSync(destParent)\n    }\n  } catch (err) {\n    if (err.code === 'ENOENT') return\n    throw err\n  }\n  if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return checkParentPathsSync(src, srcStat, destParent, funcName)\n}\n\n// return true if dest is a subdir of src, otherwise false.\n// It only checks the path strings.\nfunction isSrcSubdir (src, dest) {\n  const srcArr = path.resolve(src).split(path.sep).filter(i => i)\n  const destArr = path.resolve(dest).split(path.sep).filter(i => i)\n  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true)\n}\n\nfunction errMsg (src, dest, funcName) {\n  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`\n}\n\nmodule.exports = {\n  checkPaths,\n  checkPathsSync,\n  checkParentPaths,\n  checkParentPathsSync,\n  isSrcSubdir\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst os = require('os')\nconst path = require('path')\n\n// HFS, ext{2,3}, FAT do not, Node.js v0.10 does not\nfunction hasMillisResSync () {\n  let tmpfile = path.join('millis-test-sync' + Date.now().toString() + Math.random().toString().slice(2))\n  tmpfile = path.join(os.tmpdir(), tmpfile)\n\n  // 550 millis past UNIX epoch\n  const d = new Date(1435410243862)\n  fs.writeFileSync(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141')\n  const fd = fs.openSync(tmpfile, 'r+')\n  fs.futimesSync(fd, d, d)\n  fs.closeSync(fd)\n  return fs.statSync(tmpfile).mtime > 1435410243000\n}\n\nfunction hasMillisRes (callback) {\n  let tmpfile = path.join('millis-test' + Date.now().toString() + Math.random().toString().slice(2))\n  tmpfile = path.join(os.tmpdir(), tmpfile)\n\n  // 550 millis past UNIX epoch\n  const d = new Date(1435410243862)\n  fs.writeFile(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141', err => {\n    if (err) return callback(err)\n    fs.open(tmpfile, 'r+', (err, fd) => {\n      if (err) return callback(err)\n      fs.futimes(fd, d, d, err => {\n        if (err) return callback(err)\n        fs.close(fd, err => {\n          if (err) return callback(err)\n          fs.stat(tmpfile, (err, stats) => {\n            if (err) return callback(err)\n            callback(null, stats.mtime > 1435410243000)\n          })\n        })\n      })\n    })\n  })\n}\n\nfunction timeRemoveMillis (timestamp) {\n  if (typeof timestamp === 'number') {\n    return Math.floor(timestamp / 1000) * 1000\n  } else if (timestamp instanceof Date) {\n    return new Date(Math.floor(timestamp.getTime() / 1000) * 1000)\n  } else {\n    throw new Error('fs-extra: timeRemoveMillis() unknown parameter type')\n  }\n}\n\nfunction utimesMillis (path, atime, mtime, callback) {\n  // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)\n  fs.open(path, 'r+', (err, fd) => {\n    if (err) return callback(err)\n    fs.futimes(fd, atime, mtime, futimesErr => {\n      fs.close(fd, closeErr => {\n        if (callback) callback(futimesErr || closeErr)\n      })\n    })\n  })\n}\n\nfunction utimesMillisSync (path, atime, mtime) {\n  const fd = fs.openSync(path, 'r+')\n  fs.futimesSync(fd, atime, mtime)\n  return fs.closeSync(fd)\n}\n\nmodule.exports = {\n  hasMillisRes,\n  hasMillisResSync,\n  timeRemoveMillis,\n  utimesMillis,\n  utimesMillisSync\n}\n","'use strict'\n\nmodule.exports = clone\n\nfunction clone (obj) {\n  if (obj === null || typeof obj !== 'object')\n    return obj\n\n  if (obj instanceof Object)\n    var copy = { __proto__: obj.__proto__ }\n  else\n    var copy = Object.create(null)\n\n  Object.getOwnPropertyNames(obj).forEach(function (key) {\n    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))\n  })\n\n  return copy\n}\n","var fs = require('fs')\nvar polyfills = require('./polyfills.js')\nvar legacy = require('./legacy-streams.js')\nvar clone = require('./clone.js')\n\nvar util = require('util')\n\n/* istanbul ignore next - node 0.x polyfill */\nvar gracefulQueue\nvar previousSymbol\n\n/* istanbul ignore else - node 0.x polyfill */\nif (typeof Symbol === 'function' && typeof Symbol.for === 'function') {\n  gracefulQueue = Symbol.for('graceful-fs.queue')\n  // This is used in testing by future versions\n  previousSymbol = Symbol.for('graceful-fs.previous')\n} else {\n  gracefulQueue = '___graceful-fs.queue'\n  previousSymbol = '___graceful-fs.previous'\n}\n\nfunction noop () {}\n\nvar debug = noop\nif (util.debuglog)\n  debug = util.debuglog('gfs4')\nelse if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || ''))\n  debug = function() {\n    var m = util.format.apply(util, arguments)\n    m = 'GFS4: ' + m.split(/\\n/).join('\\nGFS4: ')\n    console.error(m)\n  }\n\n// Once time initialization\nif (!global[gracefulQueue]) {\n  // This queue can be shared by multiple loaded instances\n  var queue = []\n  Object.defineProperty(global, gracefulQueue, {\n    get: function() {\n      return queue\n    }\n  })\n\n  // Patch fs.close/closeSync to shared queue version, because we need\n  // to retry() whenever a close happens *anywhere* in the program.\n  // This is essential when multiple graceful-fs instances are\n  // in play at the same time.\n  fs.close = (function (fs$close) {\n    function close (fd, cb) {\n      return fs$close.call(fs, fd, function (err) {\n        // This function uses the graceful-fs shared queue\n        if (!err) {\n          retry()\n        }\n\n        if (typeof cb === 'function')\n          cb.apply(this, arguments)\n      })\n    }\n\n    Object.defineProperty(close, previousSymbol, {\n      value: fs$close\n    })\n    return close\n  })(fs.close)\n\n  fs.closeSync = (function (fs$closeSync) {\n    function closeSync (fd) {\n      // This function uses the graceful-fs shared queue\n      fs$closeSync.apply(fs, arguments)\n      retry()\n    }\n\n    Object.defineProperty(closeSync, previousSymbol, {\n      value: fs$closeSync\n    })\n    return closeSync\n  })(fs.closeSync)\n\n  if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || '')) {\n    process.on('exit', function() {\n      debug(global[gracefulQueue])\n      require('assert').equal(global[gracefulQueue].length, 0)\n    })\n  }\n}\n\nmodule.exports = patch(clone(fs))\nif (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {\n    module.exports = patch(fs)\n    fs.__patched = true;\n}\n\nfunction patch (fs) {\n  // Everything that references the open() function needs to be in here\n  polyfills(fs)\n  fs.gracefulify = patch\n\n  fs.createReadStream = createReadStream\n  fs.createWriteStream = createWriteStream\n  var fs$readFile = fs.readFile\n  fs.readFile = readFile\n  function readFile (path, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$readFile(path, options, cb)\n\n    function go$readFile (path, options, cb) {\n      return fs$readFile(path, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$readFile, [path, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$writeFile = fs.writeFile\n  fs.writeFile = writeFile\n  function writeFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$writeFile(path, data, options, cb)\n\n    function go$writeFile (path, data, options, cb) {\n      return fs$writeFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$writeFile, [path, data, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$appendFile = fs.appendFile\n  if (fs$appendFile)\n    fs.appendFile = appendFile\n  function appendFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$appendFile(path, data, options, cb)\n\n    function go$appendFile (path, data, options, cb) {\n      return fs$appendFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$appendFile, [path, data, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$readdir = fs.readdir\n  fs.readdir = readdir\n  function readdir (path, options, cb) {\n    var args = [path]\n    if (typeof options !== 'function') {\n      args.push(options)\n    } else {\n      cb = options\n    }\n    args.push(go$readdir$cb)\n\n    return go$readdir(args)\n\n    function go$readdir$cb (err, files) {\n      if (files && files.sort)\n        files.sort()\n\n      if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n        enqueue([go$readdir, [args]])\n\n      else {\n        if (typeof cb === 'function')\n          cb.apply(this, arguments)\n        retry()\n      }\n    }\n  }\n\n  function go$readdir (args) {\n    return fs$readdir.apply(fs, args)\n  }\n\n  if (process.version.substr(0, 4) === 'v0.8') {\n    var legStreams = legacy(fs)\n    ReadStream = legStreams.ReadStream\n    WriteStream = legStreams.WriteStream\n  }\n\n  var fs$ReadStream = fs.ReadStream\n  if (fs$ReadStream) {\n    ReadStream.prototype = Object.create(fs$ReadStream.prototype)\n    ReadStream.prototype.open = ReadStream$open\n  }\n\n  var fs$WriteStream = fs.WriteStream\n  if (fs$WriteStream) {\n    WriteStream.prototype = Object.create(fs$WriteStream.prototype)\n    WriteStream.prototype.open = WriteStream$open\n  }\n\n  Object.defineProperty(fs, 'ReadStream', {\n    get: function () {\n      return ReadStream\n    },\n    set: function (val) {\n      ReadStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n  Object.defineProperty(fs, 'WriteStream', {\n    get: function () {\n      return WriteStream\n    },\n    set: function (val) {\n      WriteStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n\n  // legacy names\n  var FileReadStream = ReadStream\n  Object.defineProperty(fs, 'FileReadStream', {\n    get: function () {\n      return FileReadStream\n    },\n    set: function (val) {\n      FileReadStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n  var FileWriteStream = WriteStream\n  Object.defineProperty(fs, 'FileWriteStream', {\n    get: function () {\n      return FileWriteStream\n    },\n    set: function (val) {\n      FileWriteStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n\n  function ReadStream (path, options) {\n    if (this instanceof ReadStream)\n      return fs$ReadStream.apply(this, arguments), this\n    else\n      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)\n  }\n\n  function ReadStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        if (that.autoClose)\n          that.destroy()\n\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n        that.read()\n      }\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (this instanceof WriteStream)\n      return fs$WriteStream.apply(this, arguments), this\n    else\n      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)\n  }\n\n  function WriteStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        that.destroy()\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n      }\n    })\n  }\n\n  function createReadStream (path, options) {\n    return new fs.ReadStream(path, options)\n  }\n\n  function createWriteStream (path, options) {\n    return new fs.WriteStream(path, options)\n  }\n\n  var fs$open = fs.open\n  fs.open = open\n  function open (path, flags, mode, cb) {\n    if (typeof mode === 'function')\n      cb = mode, mode = null\n\n    return go$open(path, flags, mode, cb)\n\n    function go$open (path, flags, mode, cb) {\n      return fs$open(path, flags, mode, function (err, fd) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$open, [path, flags, mode, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  return fs\n}\n\nfunction enqueue (elem) {\n  debug('ENQUEUE', elem[0].name, elem[1])\n  global[gracefulQueue].push(elem)\n}\n\nfunction retry () {\n  var elem = global[gracefulQueue].shift()\n  if (elem) {\n    debug('RETRY', elem[0].name, elem[1])\n    elem[0].apply(null, elem[1])\n  }\n}\n","var Stream = require('stream').Stream\n\nmodule.exports = legacy\n\nfunction legacy (fs) {\n  return {\n    ReadStream: ReadStream,\n    WriteStream: WriteStream\n  }\n\n  function ReadStream (path, options) {\n    if (!(this instanceof ReadStream)) return new ReadStream(path, options);\n\n    Stream.call(this);\n\n    var self = this;\n\n    this.path = path;\n    this.fd = null;\n    this.readable = true;\n    this.paused = false;\n\n    this.flags = 'r';\n    this.mode = 438; /*=0666*/\n    this.bufferSize = 64 * 1024;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.encoding) this.setEncoding(this.encoding);\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.end === undefined) {\n        this.end = Infinity;\n      } else if ('number' !== typeof this.end) {\n        throw TypeError('end must be a Number');\n      }\n\n      if (this.start > this.end) {\n        throw new Error('start must be <= end');\n      }\n\n      this.pos = this.start;\n    }\n\n    if (this.fd !== null) {\n      process.nextTick(function() {\n        self._read();\n      });\n      return;\n    }\n\n    fs.open(this.path, this.flags, this.mode, function (err, fd) {\n      if (err) {\n        self.emit('error', err);\n        self.readable = false;\n        return;\n      }\n\n      self.fd = fd;\n      self.emit('open', fd);\n      self._read();\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (!(this instanceof WriteStream)) return new WriteStream(path, options);\n\n    Stream.call(this);\n\n    this.path = path;\n    this.fd = null;\n    this.writable = true;\n\n    this.flags = 'w';\n    this.encoding = 'binary';\n    this.mode = 438; /*=0666*/\n    this.bytesWritten = 0;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.start < 0) {\n        throw new Error('start must be >= zero');\n      }\n\n      this.pos = this.start;\n    }\n\n    this.busy = false;\n    this._queue = [];\n\n    if (this.fd === null) {\n      this._open = fs.open;\n      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);\n      this.flush();\n    }\n  }\n}\n","var constants = require('constants')\n\nvar origCwd = process.cwd\nvar cwd = null\n\nvar platform = process.env.GRACEFUL_FS_PLATFORM || process.platform\n\nprocess.cwd = function() {\n  if (!cwd)\n    cwd = origCwd.call(process)\n  return cwd\n}\ntry {\n  process.cwd()\n} catch (er) {}\n\nvar chdir = process.chdir\nprocess.chdir = function(d) {\n  cwd = null\n  chdir.call(process, d)\n}\n\nmodule.exports = patch\n\nfunction patch (fs) {\n  // (re-)implement some things that are known busted or missing.\n\n  // lchmod, broken prior to 0.6.2\n  // back-port the fix here.\n  if (constants.hasOwnProperty('O_SYMLINK') &&\n      process.version.match(/^v0\\.6\\.[0-2]|^v0\\.5\\./)) {\n    patchLchmod(fs)\n  }\n\n  // lutimes implementation, or no-op\n  if (!fs.lutimes) {\n    patchLutimes(fs)\n  }\n\n  // https://github.com/isaacs/node-graceful-fs/issues/4\n  // Chown should not fail on einval or eperm if non-root.\n  // It should not fail on enosys ever, as this just indicates\n  // that a fs doesn't support the intended operation.\n\n  fs.chown = chownFix(fs.chown)\n  fs.fchown = chownFix(fs.fchown)\n  fs.lchown = chownFix(fs.lchown)\n\n  fs.chmod = chmodFix(fs.chmod)\n  fs.fchmod = chmodFix(fs.fchmod)\n  fs.lchmod = chmodFix(fs.lchmod)\n\n  fs.chownSync = chownFixSync(fs.chownSync)\n  fs.fchownSync = chownFixSync(fs.fchownSync)\n  fs.lchownSync = chownFixSync(fs.lchownSync)\n\n  fs.chmodSync = chmodFixSync(fs.chmodSync)\n  fs.fchmodSync = chmodFixSync(fs.fchmodSync)\n  fs.lchmodSync = chmodFixSync(fs.lchmodSync)\n\n  fs.stat = statFix(fs.stat)\n  fs.fstat = statFix(fs.fstat)\n  fs.lstat = statFix(fs.lstat)\n\n  fs.statSync = statFixSync(fs.statSync)\n  fs.fstatSync = statFixSync(fs.fstatSync)\n  fs.lstatSync = statFixSync(fs.lstatSync)\n\n  // if lchmod/lchown do not exist, then make them no-ops\n  if (!fs.lchmod) {\n    fs.lchmod = function (path, mode, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchmodSync = function () {}\n  }\n  if (!fs.lchown) {\n    fs.lchown = function (path, uid, gid, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchownSync = function () {}\n  }\n\n  // on Windows, A/V software can lock the directory, causing this\n  // to fail with an EACCES or EPERM if the directory contains newly\n  // created files.  Try again on failure, for up to 60 seconds.\n\n  // Set the timeout this long because some Windows Anti-Virus, such as Parity\n  // bit9, may lock files for up to a minute, causing npm package install\n  // failures. Also, take care to yield the scheduler. Windows scheduling gives\n  // CPU to a busy looping process, which can cause the program causing the lock\n  // contention to be starved of CPU by node, so the contention doesn't resolve.\n  if (platform === \"win32\") {\n    fs.rename = (function (fs$rename) { return function (from, to, cb) {\n      var start = Date.now()\n      var backoff = 0;\n      fs$rename(from, to, function CB (er) {\n        if (er\n            && (er.code === \"EACCES\" || er.code === \"EPERM\")\n            && Date.now() - start < 60000) {\n          setTimeout(function() {\n            fs.stat(to, function (stater, st) {\n              if (stater && stater.code === \"ENOENT\")\n                fs$rename(from, to, CB);\n              else\n                cb(er)\n            })\n          }, backoff)\n          if (backoff < 100)\n            backoff += 10;\n          return;\n        }\n        if (cb) cb(er)\n      })\n    }})(fs.rename)\n  }\n\n  // if read() returns EAGAIN, then just try it again.\n  fs.read = (function (fs$read) {\n    function read (fd, buffer, offset, length, position, callback_) {\n      var callback\n      if (callback_ && typeof callback_ === 'function') {\n        var eagCounter = 0\n        callback = function (er, _, __) {\n          if (er && er.code === 'EAGAIN' && eagCounter < 10) {\n            eagCounter ++\n            return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n          }\n          callback_.apply(this, arguments)\n        }\n      }\n      return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n    }\n\n    // This ensures `util.promisify` works as it does for native `fs.read`.\n    read.__proto__ = fs$read\n    return read\n  })(fs.read)\n\n  fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {\n    var eagCounter = 0\n    while (true) {\n      try {\n        return fs$readSync.call(fs, fd, buffer, offset, length, position)\n      } catch (er) {\n        if (er.code === 'EAGAIN' && eagCounter < 10) {\n          eagCounter ++\n          continue\n        }\n        throw er\n      }\n    }\n  }})(fs.readSync)\n\n  function patchLchmod (fs) {\n    fs.lchmod = function (path, mode, callback) {\n      fs.open( path\n             , constants.O_WRONLY | constants.O_SYMLINK\n             , mode\n             , function (err, fd) {\n        if (err) {\n          if (callback) callback(err)\n          return\n        }\n        // prefer to return the chmod error, if one occurs,\n        // but still try to close, and report closing errors if they occur.\n        fs.fchmod(fd, mode, function (err) {\n          fs.close(fd, function(err2) {\n            if (callback) callback(err || err2)\n          })\n        })\n      })\n    }\n\n    fs.lchmodSync = function (path, mode) {\n      var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)\n\n      // prefer to return the chmod error, if one occurs,\n      // but still try to close, and report closing errors if they occur.\n      var threw = true\n      var ret\n      try {\n        ret = fs.fchmodSync(fd, mode)\n        threw = false\n      } finally {\n        if (threw) {\n          try {\n            fs.closeSync(fd)\n          } catch (er) {}\n        } else {\n          fs.closeSync(fd)\n        }\n      }\n      return ret\n    }\n  }\n\n  function patchLutimes (fs) {\n    if (constants.hasOwnProperty(\"O_SYMLINK\")) {\n      fs.lutimes = function (path, at, mt, cb) {\n        fs.open(path, constants.O_SYMLINK, function (er, fd) {\n          if (er) {\n            if (cb) cb(er)\n            return\n          }\n          fs.futimes(fd, at, mt, function (er) {\n            fs.close(fd, function (er2) {\n              if (cb) cb(er || er2)\n            })\n          })\n        })\n      }\n\n      fs.lutimesSync = function (path, at, mt) {\n        var fd = fs.openSync(path, constants.O_SYMLINK)\n        var ret\n        var threw = true\n        try {\n          ret = fs.futimesSync(fd, at, mt)\n          threw = false\n        } finally {\n          if (threw) {\n            try {\n              fs.closeSync(fd)\n            } catch (er) {}\n          } else {\n            fs.closeSync(fd)\n          }\n        }\n        return ret\n      }\n\n    } else {\n      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }\n      fs.lutimesSync = function () {}\n    }\n  }\n\n  function chmodFix (orig) {\n    if (!orig) return orig\n    return function (target, mode, cb) {\n      return orig.call(fs, target, mode, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chmodFixSync (orig) {\n    if (!orig) return orig\n    return function (target, mode) {\n      try {\n        return orig.call(fs, target, mode)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n\n  function chownFix (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid, cb) {\n      return orig.call(fs, target, uid, gid, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chownFixSync (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid) {\n      try {\n        return orig.call(fs, target, uid, gid)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n  function statFix (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target, options, cb) {\n      if (typeof options === 'function') {\n        cb = options\n        options = null\n      }\n      function callback (er, stats) {\n        if (stats) {\n          if (stats.uid < 0) stats.uid += 0x100000000\n          if (stats.gid < 0) stats.gid += 0x100000000\n        }\n        if (cb) cb.apply(this, arguments)\n      }\n      return options ? orig.call(fs, target, options, callback)\n        : orig.call(fs, target, callback)\n    }\n  }\n\n  function statFixSync (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target, options) {\n      var stats = options ? orig.call(fs, target, options)\n        : orig.call(fs, target)\n      if (stats.uid < 0) stats.uid += 0x100000000\n      if (stats.gid < 0) stats.gid += 0x100000000\n      return stats;\n    }\n  }\n\n  // ENOSYS means that the fs doesn't support the op. Just ignore\n  // that, because it doesn't matter.\n  //\n  // if there's no getuid, or if getuid() is something other\n  // than 0, and the error is EINVAL or EPERM, then just ignore\n  // it.\n  //\n  // This specific case is a silent failure in cp, install, tar,\n  // and most other unix tools that manage permissions.\n  //\n  // When running as root, or if other types of errors are\n  // encountered, then it's strict.\n  function chownErOk (er) {\n    if (!er)\n      return true\n\n    if (er.code === \"ENOSYS\")\n      return true\n\n    var nonroot = !process.getuid || process.getuid() !== 0\n    if (nonroot) {\n      if (er.code === \"EINVAL\" || er.code === \"EPERM\")\n        return true\n    }\n\n    return false\n  }\n}\n","'use strict';\nconst net = require('net');\n\nclass Locked extends Error {\n\tconstructor(port) {\n\t\tsuper(`${port} is locked`);\n\t}\n}\n\nconst lockedPorts = {\n\told: new Set(),\n\tyoung: new Set()\n};\n\n// On this interval, the old locked ports are discarded,\n// the young locked ports are moved to old locked ports,\n// and a new young set for locked ports are created.\nconst releaseOldLockedPortsIntervalMs = 1000 * 15;\n\n// Lazily create interval on first use\nlet interval;\n\nconst getAvailablePort = options => new Promise((resolve, reject) => {\n\tconst server = net.createServer();\n\tserver.unref();\n\tserver.on('error', reject);\n\tserver.listen(options, () => {\n\t\tconst {port} = server.address();\n\t\tserver.close(() => {\n\t\t\tresolve(port);\n\t\t});\n\t});\n});\n\nconst portCheckSequence = function * (ports) {\n\tif (ports) {\n\t\tyield * ports;\n\t}\n\n\tyield 0; // Fall back to 0 if anything else failed\n};\n\nmodule.exports = async options => {\n\tlet ports;\n\n\tif (options) {\n\t\tports = typeof options.port === 'number' ? [options.port] : options.port;\n\t}\n\n\tif (interval === undefined) {\n\t\tinterval = setInterval(() => {\n\t\t\tlockedPorts.old = lockedPorts.young;\n\t\t\tlockedPorts.young = new Set();\n\t\t}, releaseOldLockedPortsIntervalMs);\n\n\t\t// Does not exist in some environments (Electron, Jest jsdom env, browser, etc).\n\t\tif (interval.unref) {\n\t\t\tinterval.unref();\n\t\t}\n\t}\n\n\tfor (const port of portCheckSequence(ports)) {\n\t\ttry {\n\t\t\tlet availablePort = await getAvailablePort({...options, port}); // eslint-disable-line no-await-in-loop\n\t\t\twhile (lockedPorts.old.has(availablePort) || lockedPorts.young.has(availablePort)) {\n\t\t\t\tif (port !== 0) {\n\t\t\t\t\tthrow new Locked(port);\n\t\t\t\t}\n\n\t\t\t\tavailablePort = await getAvailablePort({...options, port}); // eslint-disable-line no-await-in-loop\n\t\t\t}\n\n\t\t\tlockedPorts.young.add(availablePort);\n\t\t\treturn availablePort;\n\t\t} catch (error) {\n\t\t\tif (!['EADDRINUSE', 'EACCES'].includes(error.code) && !(error instanceof Locked)) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow new Error('No available ports found');\n};\n\nmodule.exports.makeRange = (from, to) => {\n\tif (!Number.isInteger(from) || !Number.isInteger(to)) {\n\t\tthrow new TypeError('`from` and `to` must be integer numbers');\n\t}\n\n\tif (from < 1024 || from > 65535) {\n\t\tthrow new RangeError('`from` must be between 1024 and 65535');\n\t}\n\n\tif (to < 1024 || to > 65536) {\n\t\tthrow new RangeError('`to` must be between 1024 and 65536');\n\t}\n\n\tif (to < from) {\n\t\tthrow new RangeError('`to` must be greater than or equal to `from`');\n\t}\n\n\tconst generator = function * (from, to) {\n\t\tfor (let port = from; port <= to; port++) {\n\t\t\tyield port;\n\t\t}\n\t};\n\n\treturn generator(from, to);\n};\n","'use strict';\n/* eslint-disable yoda */\nmodule.exports = x => {\n\tif (Number.isNaN(x)) {\n\t\treturn false;\n\t}\n\n\t// code points are derived from:\n\t// http://www.unix.org/Public/UNIDATA/EastAsianWidth.txt\n\tif (\n\t\tx >= 0x1100 && (\n\t\t\tx <= 0x115f ||  // Hangul Jamo\n\t\t\tx === 0x2329 || // LEFT-POINTING ANGLE BRACKET\n\t\t\tx === 0x232a || // RIGHT-POINTING ANGLE BRACKET\n\t\t\t// CJK Radicals Supplement .. Enclosed CJK Letters and Months\n\t\t\t(0x2e80 <= x && x <= 0x3247 && x !== 0x303f) ||\n\t\t\t// Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A\n\t\t\t(0x3250 <= x && x <= 0x4dbf) ||\n\t\t\t// CJK Unified Ideographs .. Yi Radicals\n\t\t\t(0x4e00 <= x && x <= 0xa4c6) ||\n\t\t\t// Hangul Jamo Extended-A\n\t\t\t(0xa960 <= x && x <= 0xa97c) ||\n\t\t\t// Hangul Syllables\n\t\t\t(0xac00 <= x && x <= 0xd7a3) ||\n\t\t\t// CJK Compatibility Ideographs\n\t\t\t(0xf900 <= x && x <= 0xfaff) ||\n\t\t\t// Vertical Forms\n\t\t\t(0xfe10 <= x && x <= 0xfe19) ||\n\t\t\t// CJK Compatibility Forms .. Small Form Variants\n\t\t\t(0xfe30 <= x && x <= 0xfe6b) ||\n\t\t\t// Halfwidth and Fullwidth Forms\n\t\t\t(0xff01 <= x && x <= 0xff60) ||\n\t\t\t(0xffe0 <= x && x <= 0xffe6) ||\n\t\t\t// Kana Supplement\n\t\t\t(0x1b000 <= x && x <= 0x1b001) ||\n\t\t\t// Enclosed Ideographic Supplement\n\t\t\t(0x1f200 <= x && x <= 0x1f251) ||\n\t\t\t// CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane\n\t\t\t(0x20000 <= x && x <= 0x3fffd)\n\t\t)\n\t) {\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n","module.exports      = isTypedArray\nisTypedArray.strict = isStrictTypedArray\nisTypedArray.loose  = isLooseTypedArray\n\nvar toString = Object.prototype.toString\nvar names = {\n    '[object Int8Array]': true\n  , '[object Int16Array]': true\n  , '[object Int32Array]': true\n  , '[object Uint8Array]': true\n  , '[object Uint8ClampedArray]': true\n  , '[object Uint16Array]': true\n  , '[object Uint32Array]': true\n  , '[object Float32Array]': true\n  , '[object Float64Array]': true\n}\n\nfunction isTypedArray(arr) {\n  return (\n       isStrictTypedArray(arr)\n    || isLooseTypedArray(arr)\n  )\n}\n\nfunction isStrictTypedArray(arr) {\n  return (\n       arr instanceof Int8Array\n    || arr instanceof Int16Array\n    || arr instanceof Int32Array\n    || arr instanceof Uint8Array\n    || arr instanceof Uint8ClampedArray\n    || arr instanceof Uint16Array\n    || arr instanceof Uint32Array\n    || arr instanceof Float32Array\n    || arr instanceof Float64Array\n  )\n}\n\nfunction isLooseTypedArray(arr) {\n  return names[toString.call(arr)]\n}\n","/**\n * [js-sha256]{@link https://github.com/emn178/js-sha256}\n *\n * @version 0.9.0\n * @author Chen, Yi-Cyuan [emn178@gmail.com]\n * @copyright Chen, Yi-Cyuan 2014-2017\n * @license MIT\n */\n/*jslint bitwise: true */\n(function () {\n  'use strict';\n\n  var ERROR = 'input is invalid type';\n  var WINDOW = typeof window === 'object';\n  var root = WINDOW ? window : {};\n  if (root.JS_SHA256_NO_WINDOW) {\n    WINDOW = false;\n  }\n  var WEB_WORKER = !WINDOW && typeof self === 'object';\n  var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;\n  if (NODE_JS) {\n    root = global;\n  } else if (WEB_WORKER) {\n    root = self;\n  }\n  var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && typeof module === 'object' && module.exports;\n  var AMD = typeof define === 'function' && define.amd;\n  var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';\n  var HEX_CHARS = '0123456789abcdef'.split('');\n  var EXTRA = [-2147483648, 8388608, 32768, 128];\n  var SHIFT = [24, 16, 8, 0];\n  var K = [\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n  ];\n  var OUTPUT_TYPES = ['hex', 'array', 'digest', 'arrayBuffer'];\n\n  var blocks = [];\n\n  if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {\n    Array.isArray = function (obj) {\n      return Object.prototype.toString.call(obj) === '[object Array]';\n    };\n  }\n\n  if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {\n    ArrayBuffer.isView = function (obj) {\n      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;\n    };\n  }\n\n  var createOutputMethod = function (outputType, is224) {\n    return function (message) {\n      return new Sha256(is224, true).update(message)[outputType]();\n    };\n  };\n\n  var createMethod = function (is224) {\n    var method = createOutputMethod('hex', is224);\n    if (NODE_JS) {\n      method = nodeWrap(method, is224);\n    }\n    method.create = function () {\n      return new Sha256(is224);\n    };\n    method.update = function (message) {\n      return method.create().update(message);\n    };\n    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {\n      var type = OUTPUT_TYPES[i];\n      method[type] = createOutputMethod(type, is224);\n    }\n    return method;\n  };\n\n  var nodeWrap = function (method, is224) {\n    var crypto = eval(\"require('crypto')\");\n    var Buffer = eval(\"require('buffer').Buffer\");\n    var algorithm = is224 ? 'sha224' : 'sha256';\n    var nodeMethod = function (message) {\n      if (typeof message === 'string') {\n        return crypto.createHash(algorithm).update(message, 'utf8').digest('hex');\n      } else {\n        if (message === null || message === undefined) {\n          throw new Error(ERROR);\n        } else if (message.constructor === ArrayBuffer) {\n          message = new Uint8Array(message);\n        }\n      }\n      if (Array.isArray(message) || ArrayBuffer.isView(message) ||\n        message.constructor === Buffer) {\n        return crypto.createHash(algorithm).update(new Buffer(message)).digest('hex');\n      } else {\n        return method(message);\n      }\n    };\n    return nodeMethod;\n  };\n\n  var createHmacOutputMethod = function (outputType, is224) {\n    return function (key, message) {\n      return new HmacSha256(key, is224, true).update(message)[outputType]();\n    };\n  };\n\n  var createHmacMethod = function (is224) {\n    var method = createHmacOutputMethod('hex', is224);\n    method.create = function (key) {\n      return new HmacSha256(key, is224);\n    };\n    method.update = function (key, message) {\n      return method.create(key).update(message);\n    };\n    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {\n      var type = OUTPUT_TYPES[i];\n      method[type] = createHmacOutputMethod(type, is224);\n    }\n    return method;\n  };\n\n  function Sha256(is224, sharedMemory) {\n    if (sharedMemory) {\n      blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] =\n        blocks[4] = blocks[5] = blocks[6] = blocks[7] =\n        blocks[8] = blocks[9] = blocks[10] = blocks[11] =\n        blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;\n      this.blocks = blocks;\n    } else {\n      this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    }\n\n    if (is224) {\n      this.h0 = 0xc1059ed8;\n      this.h1 = 0x367cd507;\n      this.h2 = 0x3070dd17;\n      this.h3 = 0xf70e5939;\n      this.h4 = 0xffc00b31;\n      this.h5 = 0x68581511;\n      this.h6 = 0x64f98fa7;\n      this.h7 = 0xbefa4fa4;\n    } else { // 256\n      this.h0 = 0x6a09e667;\n      this.h1 = 0xbb67ae85;\n      this.h2 = 0x3c6ef372;\n      this.h3 = 0xa54ff53a;\n      this.h4 = 0x510e527f;\n      this.h5 = 0x9b05688c;\n      this.h6 = 0x1f83d9ab;\n      this.h7 = 0x5be0cd19;\n    }\n\n    this.block = this.start = this.bytes = this.hBytes = 0;\n    this.finalized = this.hashed = false;\n    this.first = true;\n    this.is224 = is224;\n  }\n\n  Sha256.prototype.update = function (message) {\n    if (this.finalized) {\n      return;\n    }\n    var notString, type = typeof message;\n    if (type !== 'string') {\n      if (type === 'object') {\n        if (message === null) {\n          throw new Error(ERROR);\n        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {\n          message = new Uint8Array(message);\n        } else if (!Array.isArray(message)) {\n          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {\n            throw new Error(ERROR);\n          }\n        }\n      } else {\n        throw new Error(ERROR);\n      }\n      notString = true;\n    }\n    var code, index = 0, i, length = message.length, blocks = this.blocks;\n\n    while (index < length) {\n      if (this.hashed) {\n        this.hashed = false;\n        blocks[0] = this.block;\n        blocks[16] = blocks[1] = blocks[2] = blocks[3] =\n          blocks[4] = blocks[5] = blocks[6] = blocks[7] =\n          blocks[8] = blocks[9] = blocks[10] = blocks[11] =\n          blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;\n      }\n\n      if (notString) {\n        for (i = this.start; index < length && i < 64; ++index) {\n          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];\n        }\n      } else {\n        for (i = this.start; index < length && i < 64; ++index) {\n          code = message.charCodeAt(index);\n          if (code < 0x80) {\n            blocks[i >> 2] |= code << SHIFT[i++ & 3];\n          } else if (code < 0x800) {\n            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n          } else if (code < 0xd800 || code >= 0xe000) {\n            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n          } else {\n            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));\n            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n          }\n        }\n      }\n\n      this.lastByteIndex = i;\n      this.bytes += i - this.start;\n      if (i >= 64) {\n        this.block = blocks[16];\n        this.start = i - 64;\n        this.hash();\n        this.hashed = true;\n      } else {\n        this.start = i;\n      }\n    }\n    if (this.bytes > 4294967295) {\n      this.hBytes += this.bytes / 4294967296 << 0;\n      this.bytes = this.bytes % 4294967296;\n    }\n    return this;\n  };\n\n  Sha256.prototype.finalize = function () {\n    if (this.finalized) {\n      return;\n    }\n    this.finalized = true;\n    var blocks = this.blocks, i = this.lastByteIndex;\n    blocks[16] = this.block;\n    blocks[i >> 2] |= EXTRA[i & 3];\n    this.block = blocks[16];\n    if (i >= 56) {\n      if (!this.hashed) {\n        this.hash();\n      }\n      blocks[0] = this.block;\n      blocks[16] = blocks[1] = blocks[2] = blocks[3] =\n        blocks[4] = blocks[5] = blocks[6] = blocks[7] =\n        blocks[8] = blocks[9] = blocks[10] = blocks[11] =\n        blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;\n    }\n    blocks[14] = this.hBytes << 3 | this.bytes >>> 29;\n    blocks[15] = this.bytes << 3;\n    this.hash();\n  };\n\n  Sha256.prototype.hash = function () {\n    var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f = this.h5, g = this.h6,\n      h = this.h7, blocks = this.blocks, j, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;\n\n    for (j = 16; j < 64; ++j) {\n      // rightrotate\n      t1 = blocks[j - 15];\n      s0 = ((t1 >>> 7) | (t1 << 25)) ^ ((t1 >>> 18) | (t1 << 14)) ^ (t1 >>> 3);\n      t1 = blocks[j - 2];\n      s1 = ((t1 >>> 17) | (t1 << 15)) ^ ((t1 >>> 19) | (t1 << 13)) ^ (t1 >>> 10);\n      blocks[j] = blocks[j - 16] + s0 + blocks[j - 7] + s1 << 0;\n    }\n\n    bc = b & c;\n    for (j = 0; j < 64; j += 4) {\n      if (this.first) {\n        if (this.is224) {\n          ab = 300032;\n          t1 = blocks[0] - 1413257819;\n          h = t1 - 150054599 << 0;\n          d = t1 + 24177077 << 0;\n        } else {\n          ab = 704751109;\n          t1 = blocks[0] - 210244248;\n          h = t1 - 1521486534 << 0;\n          d = t1 + 143694565 << 0;\n        }\n        this.first = false;\n      } else {\n        s0 = ((a >>> 2) | (a << 30)) ^ ((a >>> 13) | (a << 19)) ^ ((a >>> 22) | (a << 10));\n        s1 = ((e >>> 6) | (e << 26)) ^ ((e >>> 11) | (e << 21)) ^ ((e >>> 25) | (e << 7));\n        ab = a & b;\n        maj = ab ^ (a & c) ^ bc;\n        ch = (e & f) ^ (~e & g);\n        t1 = h + s1 + ch + K[j] + blocks[j];\n        t2 = s0 + maj;\n        h = d + t1 << 0;\n        d = t1 + t2 << 0;\n      }\n      s0 = ((d >>> 2) | (d << 30)) ^ ((d >>> 13) | (d << 19)) ^ ((d >>> 22) | (d << 10));\n      s1 = ((h >>> 6) | (h << 26)) ^ ((h >>> 11) | (h << 21)) ^ ((h >>> 25) | (h << 7));\n      da = d & a;\n      maj = da ^ (d & b) ^ ab;\n      ch = (h & e) ^ (~h & f);\n      t1 = g + s1 + ch + K[j + 1] + blocks[j + 1];\n      t2 = s0 + maj;\n      g = c + t1 << 0;\n      c = t1 + t2 << 0;\n      s0 = ((c >>> 2) | (c << 30)) ^ ((c >>> 13) | (c << 19)) ^ ((c >>> 22) | (c << 10));\n      s1 = ((g >>> 6) | (g << 26)) ^ ((g >>> 11) | (g << 21)) ^ ((g >>> 25) | (g << 7));\n      cd = c & d;\n      maj = cd ^ (c & a) ^ da;\n      ch = (g & h) ^ (~g & e);\n      t1 = f + s1 + ch + K[j + 2] + blocks[j + 2];\n      t2 = s0 + maj;\n      f = b + t1 << 0;\n      b = t1 + t2 << 0;\n      s0 = ((b >>> 2) | (b << 30)) ^ ((b >>> 13) | (b << 19)) ^ ((b >>> 22) | (b << 10));\n      s1 = ((f >>> 6) | (f << 26)) ^ ((f >>> 11) | (f << 21)) ^ ((f >>> 25) | (f << 7));\n      bc = b & c;\n      maj = bc ^ (b & d) ^ cd;\n      ch = (f & g) ^ (~f & h);\n      t1 = e + s1 + ch + K[j + 3] + blocks[j + 3];\n      t2 = s0 + maj;\n      e = a + t1 << 0;\n      a = t1 + t2 << 0;\n    }\n\n    this.h0 = this.h0 + a << 0;\n    this.h1 = this.h1 + b << 0;\n    this.h2 = this.h2 + c << 0;\n    this.h3 = this.h3 + d << 0;\n    this.h4 = this.h4 + e << 0;\n    this.h5 = this.h5 + f << 0;\n    this.h6 = this.h6 + g << 0;\n    this.h7 = this.h7 + h << 0;\n  };\n\n  Sha256.prototype.hex = function () {\n    this.finalize();\n\n    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5,\n      h6 = this.h6, h7 = this.h7;\n\n    var hex = HEX_CHARS[(h0 >> 28) & 0x0F] + HEX_CHARS[(h0 >> 24) & 0x0F] +\n      HEX_CHARS[(h0 >> 20) & 0x0F] + HEX_CHARS[(h0 >> 16) & 0x0F] +\n      HEX_CHARS[(h0 >> 12) & 0x0F] + HEX_CHARS[(h0 >> 8) & 0x0F] +\n      HEX_CHARS[(h0 >> 4) & 0x0F] + HEX_CHARS[h0 & 0x0F] +\n      HEX_CHARS[(h1 >> 28) & 0x0F] + HEX_CHARS[(h1 >> 24) & 0x0F] +\n      HEX_CHARS[(h1 >> 20) & 0x0F] + HEX_CHARS[(h1 >> 16) & 0x0F] +\n      HEX_CHARS[(h1 >> 12) & 0x0F] + HEX_CHARS[(h1 >> 8) & 0x0F] +\n      HEX_CHARS[(h1 >> 4) & 0x0F] + HEX_CHARS[h1 & 0x0F] +\n      HEX_CHARS[(h2 >> 28) & 0x0F] + HEX_CHARS[(h2 >> 24) & 0x0F] +\n      HEX_CHARS[(h2 >> 20) & 0x0F] + HEX_CHARS[(h2 >> 16) & 0x0F] +\n      HEX_CHARS[(h2 >> 12) & 0x0F] + HEX_CHARS[(h2 >> 8) & 0x0F] +\n      HEX_CHARS[(h2 >> 4) & 0x0F] + HEX_CHARS[h2 & 0x0F] +\n      HEX_CHARS[(h3 >> 28) & 0x0F] + HEX_CHARS[(h3 >> 24) & 0x0F] +\n      HEX_CHARS[(h3 >> 20) & 0x0F] + HEX_CHARS[(h3 >> 16) & 0x0F] +\n      HEX_CHARS[(h3 >> 12) & 0x0F] + HEX_CHARS[(h3 >> 8) & 0x0F] +\n      HEX_CHARS[(h3 >> 4) & 0x0F] + HEX_CHARS[h3 & 0x0F] +\n      HEX_CHARS[(h4 >> 28) & 0x0F] + HEX_CHARS[(h4 >> 24) & 0x0F] +\n      HEX_CHARS[(h4 >> 20) & 0x0F] + HEX_CHARS[(h4 >> 16) & 0x0F] +\n      HEX_CHARS[(h4 >> 12) & 0x0F] + HEX_CHARS[(h4 >> 8) & 0x0F] +\n      HEX_CHARS[(h4 >> 4) & 0x0F] + HEX_CHARS[h4 & 0x0F] +\n      HEX_CHARS[(h5 >> 28) & 0x0F] + HEX_CHARS[(h5 >> 24) & 0x0F] +\n      HEX_CHARS[(h5 >> 20) & 0x0F] + HEX_CHARS[(h5 >> 16) & 0x0F] +\n      HEX_CHARS[(h5 >> 12) & 0x0F] + HEX_CHARS[(h5 >> 8) & 0x0F] +\n      HEX_CHARS[(h5 >> 4) & 0x0F] + HEX_CHARS[h5 & 0x0F] +\n      HEX_CHARS[(h6 >> 28) & 0x0F] + HEX_CHARS[(h6 >> 24) & 0x0F] +\n      HEX_CHARS[(h6 >> 20) & 0x0F] + HEX_CHARS[(h6 >> 16) & 0x0F] +\n      HEX_CHARS[(h6 >> 12) & 0x0F] + HEX_CHARS[(h6 >> 8) & 0x0F] +\n      HEX_CHARS[(h6 >> 4) & 0x0F] + HEX_CHARS[h6 & 0x0F];\n    if (!this.is224) {\n      hex += HEX_CHARS[(h7 >> 28) & 0x0F] + HEX_CHARS[(h7 >> 24) & 0x0F] +\n        HEX_CHARS[(h7 >> 20) & 0x0F] + HEX_CHARS[(h7 >> 16) & 0x0F] +\n        HEX_CHARS[(h7 >> 12) & 0x0F] + HEX_CHARS[(h7 >> 8) & 0x0F] +\n        HEX_CHARS[(h7 >> 4) & 0x0F] + HEX_CHARS[h7 & 0x0F];\n    }\n    return hex;\n  };\n\n  Sha256.prototype.toString = Sha256.prototype.hex;\n\n  Sha256.prototype.digest = function () {\n    this.finalize();\n\n    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5,\n      h6 = this.h6, h7 = this.h7;\n\n    var arr = [\n      (h0 >> 24) & 0xFF, (h0 >> 16) & 0xFF, (h0 >> 8) & 0xFF, h0 & 0xFF,\n      (h1 >> 24) & 0xFF, (h1 >> 16) & 0xFF, (h1 >> 8) & 0xFF, h1 & 0xFF,\n      (h2 >> 24) & 0xFF, (h2 >> 16) & 0xFF, (h2 >> 8) & 0xFF, h2 & 0xFF,\n      (h3 >> 24) & 0xFF, (h3 >> 16) & 0xFF, (h3 >> 8) & 0xFF, h3 & 0xFF,\n      (h4 >> 24) & 0xFF, (h4 >> 16) & 0xFF, (h4 >> 8) & 0xFF, h4 & 0xFF,\n      (h5 >> 24) & 0xFF, (h5 >> 16) & 0xFF, (h5 >> 8) & 0xFF, h5 & 0xFF,\n      (h6 >> 24) & 0xFF, (h6 >> 16) & 0xFF, (h6 >> 8) & 0xFF, h6 & 0xFF\n    ];\n    if (!this.is224) {\n      arr.push((h7 >> 24) & 0xFF, (h7 >> 16) & 0xFF, (h7 >> 8) & 0xFF, h7 & 0xFF);\n    }\n    return arr;\n  };\n\n  Sha256.prototype.array = Sha256.prototype.digest;\n\n  Sha256.prototype.arrayBuffer = function () {\n    this.finalize();\n\n    var buffer = new ArrayBuffer(this.is224 ? 28 : 32);\n    var dataView = new DataView(buffer);\n    dataView.setUint32(0, this.h0);\n    dataView.setUint32(4, this.h1);\n    dataView.setUint32(8, this.h2);\n    dataView.setUint32(12, this.h3);\n    dataView.setUint32(16, this.h4);\n    dataView.setUint32(20, this.h5);\n    dataView.setUint32(24, this.h6);\n    if (!this.is224) {\n      dataView.setUint32(28, this.h7);\n    }\n    return buffer;\n  };\n\n  function HmacSha256(key, is224, sharedMemory) {\n    var i, type = typeof key;\n    if (type === 'string') {\n      var bytes = [], length = key.length, index = 0, code;\n      for (i = 0; i < length; ++i) {\n        code = key.charCodeAt(i);\n        if (code < 0x80) {\n          bytes[index++] = code;\n        } else if (code < 0x800) {\n          bytes[index++] = (0xc0 | (code >> 6));\n          bytes[index++] = (0x80 | (code & 0x3f));\n        } else if (code < 0xd800 || code >= 0xe000) {\n          bytes[index++] = (0xe0 | (code >> 12));\n          bytes[index++] = (0x80 | ((code >> 6) & 0x3f));\n          bytes[index++] = (0x80 | (code & 0x3f));\n        } else {\n          code = 0x10000 + (((code & 0x3ff) << 10) | (key.charCodeAt(++i) & 0x3ff));\n          bytes[index++] = (0xf0 | (code >> 18));\n          bytes[index++] = (0x80 | ((code >> 12) & 0x3f));\n          bytes[index++] = (0x80 | ((code >> 6) & 0x3f));\n          bytes[index++] = (0x80 | (code & 0x3f));\n        }\n      }\n      key = bytes;\n    } else {\n      if (type === 'object') {\n        if (key === null) {\n          throw new Error(ERROR);\n        } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {\n          key = new Uint8Array(key);\n        } else if (!Array.isArray(key)) {\n          if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {\n            throw new Error(ERROR);\n          }\n        }\n      } else {\n        throw new Error(ERROR);\n      }\n    }\n\n    if (key.length > 64) {\n      key = (new Sha256(is224, true)).update(key).array();\n    }\n\n    var oKeyPad = [], iKeyPad = [];\n    for (i = 0; i < 64; ++i) {\n      var b = key[i] || 0;\n      oKeyPad[i] = 0x5c ^ b;\n      iKeyPad[i] = 0x36 ^ b;\n    }\n\n    Sha256.call(this, is224, sharedMemory);\n\n    this.update(iKeyPad);\n    this.oKeyPad = oKeyPad;\n    this.inner = true;\n    this.sharedMemory = sharedMemory;\n  }\n  HmacSha256.prototype = new Sha256();\n\n  HmacSha256.prototype.finalize = function () {\n    Sha256.prototype.finalize.call(this);\n    if (this.inner) {\n      this.inner = false;\n      var innerHash = this.array();\n      Sha256.call(this, this.is224, this.sharedMemory);\n      this.update(this.oKeyPad);\n      this.update(innerHash);\n      Sha256.prototype.finalize.call(this);\n    }\n  };\n\n  var exports = createMethod();\n  exports.sha256 = exports;\n  exports.sha224 = createMethod(true);\n  exports.sha256.hmac = createHmacMethod();\n  exports.sha224.hmac = createHmacMethod(true);\n\n  if (COMMON_JS) {\n    module.exports = exports;\n  } else {\n    root.sha256 = exports.sha256;\n    root.sha224 = exports.sha224;\n    if (AMD) {\n      define(function () {\n        return exports;\n      });\n    }\n  }\n})();\n","var _fs\ntry {\n  _fs = require('graceful-fs')\n} catch (_) {\n  _fs = require('fs')\n}\n\nfunction readFile (file, options, callback) {\n  if (callback == null) {\n    callback = options\n    options = {}\n  }\n\n  if (typeof options === 'string') {\n    options = {encoding: options}\n  }\n\n  options = options || {}\n  var fs = options.fs || _fs\n\n  var shouldThrow = true\n  if ('throws' in options) {\n    shouldThrow = options.throws\n  }\n\n  fs.readFile(file, options, function (err, data) {\n    if (err) return callback(err)\n\n    data = stripBom(data)\n\n    var obj\n    try {\n      obj = JSON.parse(data, options ? options.reviver : null)\n    } catch (err2) {\n      if (shouldThrow) {\n        err2.message = file + ': ' + err2.message\n        return callback(err2)\n      } else {\n        return callback(null, null)\n      }\n    }\n\n    callback(null, obj)\n  })\n}\n\nfunction readFileSync (file, options) {\n  options = options || {}\n  if (typeof options === 'string') {\n    options = {encoding: options}\n  }\n\n  var fs = options.fs || _fs\n\n  var shouldThrow = true\n  if ('throws' in options) {\n    shouldThrow = options.throws\n  }\n\n  try {\n    var content = fs.readFileSync(file, options)\n    content = stripBom(content)\n    return JSON.parse(content, options.reviver)\n  } catch (err) {\n    if (shouldThrow) {\n      err.message = file + ': ' + err.message\n      throw err\n    } else {\n      return null\n    }\n  }\n}\n\nfunction stringify (obj, options) {\n  var spaces\n  var EOL = '\\n'\n  if (typeof options === 'object' && options !== null) {\n    if (options.spaces) {\n      spaces = options.spaces\n    }\n    if (options.EOL) {\n      EOL = options.EOL\n    }\n  }\n\n  var str = JSON.stringify(obj, options ? options.replacer : null, spaces)\n\n  return str.replace(/\\n/g, EOL) + EOL\n}\n\nfunction writeFile (file, obj, options, callback) {\n  if (callback == null) {\n    callback = options\n    options = {}\n  }\n  options = options || {}\n  var fs = options.fs || _fs\n\n  var str = ''\n  try {\n    str = stringify(obj, options)\n  } catch (err) {\n    // Need to return whether a callback was passed or not\n    if (callback) callback(err, null)\n    return\n  }\n\n  fs.writeFile(file, str, options, callback)\n}\n\nfunction writeFileSync (file, obj, options) {\n  options = options || {}\n  var fs = options.fs || _fs\n\n  var str = stringify(obj, options)\n  // not sure if fs.writeFileSync returns anything, but just in case\n  return fs.writeFileSync(file, str, options)\n}\n\nfunction stripBom (content) {\n  // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified\n  if (Buffer.isBuffer(content)) content = content.toString('utf8')\n  content = content.replace(/^\\uFEFF/, '')\n  return content\n}\n\nvar jsonfile = {\n  readFile: readFile,\n  readFileSync: readFileSync,\n  writeFile: writeFile,\n  writeFileSync: writeFileSync\n}\n\nmodule.exports = jsonfile\n","'use strict'\n\nmodule.exports = clone\n\nfunction clone (obj) {\n  if (obj === null || typeof obj !== 'object')\n    return obj\n\n  if (obj instanceof Object)\n    var copy = { __proto__: obj.__proto__ }\n  else\n    var copy = Object.create(null)\n\n  Object.getOwnPropertyNames(obj).forEach(function (key) {\n    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))\n  })\n\n  return copy\n}\n","var fs = require('fs')\nvar polyfills = require('./polyfills.js')\nvar legacy = require('./legacy-streams.js')\nvar clone = require('./clone.js')\n\nvar util = require('util')\n\n/* istanbul ignore next - node 0.x polyfill */\nvar gracefulQueue\nvar previousSymbol\n\n/* istanbul ignore else - node 0.x polyfill */\nif (typeof Symbol === 'function' && typeof Symbol.for === 'function') {\n  gracefulQueue = Symbol.for('graceful-fs.queue')\n  // This is used in testing by future versions\n  previousSymbol = Symbol.for('graceful-fs.previous')\n} else {\n  gracefulQueue = '___graceful-fs.queue'\n  previousSymbol = '___graceful-fs.previous'\n}\n\nfunction noop () {}\n\nvar debug = noop\nif (util.debuglog)\n  debug = util.debuglog('gfs4')\nelse if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || ''))\n  debug = function() {\n    var m = util.format.apply(util, arguments)\n    m = 'GFS4: ' + m.split(/\\n/).join('\\nGFS4: ')\n    console.error(m)\n  }\n\n// Once time initialization\nif (!global[gracefulQueue]) {\n  // This queue can be shared by multiple loaded instances\n  var queue = []\n  Object.defineProperty(global, gracefulQueue, {\n    get: function() {\n      return queue\n    }\n  })\n\n  // Patch fs.close/closeSync to shared queue version, because we need\n  // to retry() whenever a close happens *anywhere* in the program.\n  // This is essential when multiple graceful-fs instances are\n  // in play at the same time.\n  fs.close = (function (fs$close) {\n    function close (fd, cb) {\n      return fs$close.call(fs, fd, function (err) {\n        // This function uses the graceful-fs shared queue\n        if (!err) {\n          retry()\n        }\n\n        if (typeof cb === 'function')\n          cb.apply(this, arguments)\n      })\n    }\n\n    Object.defineProperty(close, previousSymbol, {\n      value: fs$close\n    })\n    return close\n  })(fs.close)\n\n  fs.closeSync = (function (fs$closeSync) {\n    function closeSync (fd) {\n      // This function uses the graceful-fs shared queue\n      fs$closeSync.apply(fs, arguments)\n      retry()\n    }\n\n    Object.defineProperty(closeSync, previousSymbol, {\n      value: fs$closeSync\n    })\n    return closeSync\n  })(fs.closeSync)\n\n  if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || '')) {\n    process.on('exit', function() {\n      debug(global[gracefulQueue])\n      require('assert').equal(global[gracefulQueue].length, 0)\n    })\n  }\n}\n\nmodule.exports = patch(clone(fs))\nif (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {\n    module.exports = patch(fs)\n    fs.__patched = true;\n}\n\nfunction patch (fs) {\n  // Everything that references the open() function needs to be in here\n  polyfills(fs)\n  fs.gracefulify = patch\n\n  fs.createReadStream = createReadStream\n  fs.createWriteStream = createWriteStream\n  var fs$readFile = fs.readFile\n  fs.readFile = readFile\n  function readFile (path, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$readFile(path, options, cb)\n\n    function go$readFile (path, options, cb) {\n      return fs$readFile(path, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$readFile, [path, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$writeFile = fs.writeFile\n  fs.writeFile = writeFile\n  function writeFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$writeFile(path, data, options, cb)\n\n    function go$writeFile (path, data, options, cb) {\n      return fs$writeFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$writeFile, [path, data, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$appendFile = fs.appendFile\n  if (fs$appendFile)\n    fs.appendFile = appendFile\n  function appendFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$appendFile(path, data, options, cb)\n\n    function go$appendFile (path, data, options, cb) {\n      return fs$appendFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$appendFile, [path, data, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$readdir = fs.readdir\n  fs.readdir = readdir\n  function readdir (path, options, cb) {\n    var args = [path]\n    if (typeof options !== 'function') {\n      args.push(options)\n    } else {\n      cb = options\n    }\n    args.push(go$readdir$cb)\n\n    return go$readdir(args)\n\n    function go$readdir$cb (err, files) {\n      if (files && files.sort)\n        files.sort()\n\n      if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n        enqueue([go$readdir, [args]])\n\n      else {\n        if (typeof cb === 'function')\n          cb.apply(this, arguments)\n        retry()\n      }\n    }\n  }\n\n  function go$readdir (args) {\n    return fs$readdir.apply(fs, args)\n  }\n\n  if (process.version.substr(0, 4) === 'v0.8') {\n    var legStreams = legacy(fs)\n    ReadStream = legStreams.ReadStream\n    WriteStream = legStreams.WriteStream\n  }\n\n  var fs$ReadStream = fs.ReadStream\n  if (fs$ReadStream) {\n    ReadStream.prototype = Object.create(fs$ReadStream.prototype)\n    ReadStream.prototype.open = ReadStream$open\n  }\n\n  var fs$WriteStream = fs.WriteStream\n  if (fs$WriteStream) {\n    WriteStream.prototype = Object.create(fs$WriteStream.prototype)\n    WriteStream.prototype.open = WriteStream$open\n  }\n\n  Object.defineProperty(fs, 'ReadStream', {\n    get: function () {\n      return ReadStream\n    },\n    set: function (val) {\n      ReadStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n  Object.defineProperty(fs, 'WriteStream', {\n    get: function () {\n      return WriteStream\n    },\n    set: function (val) {\n      WriteStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n\n  // legacy names\n  var FileReadStream = ReadStream\n  Object.defineProperty(fs, 'FileReadStream', {\n    get: function () {\n      return FileReadStream\n    },\n    set: function (val) {\n      FileReadStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n  var FileWriteStream = WriteStream\n  Object.defineProperty(fs, 'FileWriteStream', {\n    get: function () {\n      return FileWriteStream\n    },\n    set: function (val) {\n      FileWriteStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n\n  function ReadStream (path, options) {\n    if (this instanceof ReadStream)\n      return fs$ReadStream.apply(this, arguments), this\n    else\n      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)\n  }\n\n  function ReadStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        if (that.autoClose)\n          that.destroy()\n\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n        that.read()\n      }\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (this instanceof WriteStream)\n      return fs$WriteStream.apply(this, arguments), this\n    else\n      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)\n  }\n\n  function WriteStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        that.destroy()\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n      }\n    })\n  }\n\n  function createReadStream (path, options) {\n    return new fs.ReadStream(path, options)\n  }\n\n  function createWriteStream (path, options) {\n    return new fs.WriteStream(path, options)\n  }\n\n  var fs$open = fs.open\n  fs.open = open\n  function open (path, flags, mode, cb) {\n    if (typeof mode === 'function')\n      cb = mode, mode = null\n\n    return go$open(path, flags, mode, cb)\n\n    function go$open (path, flags, mode, cb) {\n      return fs$open(path, flags, mode, function (err, fd) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$open, [path, flags, mode, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  return fs\n}\n\nfunction enqueue (elem) {\n  debug('ENQUEUE', elem[0].name, elem[1])\n  global[gracefulQueue].push(elem)\n}\n\nfunction retry () {\n  var elem = global[gracefulQueue].shift()\n  if (elem) {\n    debug('RETRY', elem[0].name, elem[1])\n    elem[0].apply(null, elem[1])\n  }\n}\n","var Stream = require('stream').Stream\n\nmodule.exports = legacy\n\nfunction legacy (fs) {\n  return {\n    ReadStream: ReadStream,\n    WriteStream: WriteStream\n  }\n\n  function ReadStream (path, options) {\n    if (!(this instanceof ReadStream)) return new ReadStream(path, options);\n\n    Stream.call(this);\n\n    var self = this;\n\n    this.path = path;\n    this.fd = null;\n    this.readable = true;\n    this.paused = false;\n\n    this.flags = 'r';\n    this.mode = 438; /*=0666*/\n    this.bufferSize = 64 * 1024;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.encoding) this.setEncoding(this.encoding);\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.end === undefined) {\n        this.end = Infinity;\n      } else if ('number' !== typeof this.end) {\n        throw TypeError('end must be a Number');\n      }\n\n      if (this.start > this.end) {\n        throw new Error('start must be <= end');\n      }\n\n      this.pos = this.start;\n    }\n\n    if (this.fd !== null) {\n      process.nextTick(function() {\n        self._read();\n      });\n      return;\n    }\n\n    fs.open(this.path, this.flags, this.mode, function (err, fd) {\n      if (err) {\n        self.emit('error', err);\n        self.readable = false;\n        return;\n      }\n\n      self.fd = fd;\n      self.emit('open', fd);\n      self._read();\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (!(this instanceof WriteStream)) return new WriteStream(path, options);\n\n    Stream.call(this);\n\n    this.path = path;\n    this.fd = null;\n    this.writable = true;\n\n    this.flags = 'w';\n    this.encoding = 'binary';\n    this.mode = 438; /*=0666*/\n    this.bytesWritten = 0;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.start < 0) {\n        throw new Error('start must be >= zero');\n      }\n\n      this.pos = this.start;\n    }\n\n    this.busy = false;\n    this._queue = [];\n\n    if (this.fd === null) {\n      this._open = fs.open;\n      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);\n      this.flush();\n    }\n  }\n}\n","var constants = require('constants')\n\nvar origCwd = process.cwd\nvar cwd = null\n\nvar platform = process.env.GRACEFUL_FS_PLATFORM || process.platform\n\nprocess.cwd = function() {\n  if (!cwd)\n    cwd = origCwd.call(process)\n  return cwd\n}\ntry {\n  process.cwd()\n} catch (er) {}\n\nvar chdir = process.chdir\nprocess.chdir = function(d) {\n  cwd = null\n  chdir.call(process, d)\n}\n\nmodule.exports = patch\n\nfunction patch (fs) {\n  // (re-)implement some things that are known busted or missing.\n\n  // lchmod, broken prior to 0.6.2\n  // back-port the fix here.\n  if (constants.hasOwnProperty('O_SYMLINK') &&\n      process.version.match(/^v0\\.6\\.[0-2]|^v0\\.5\\./)) {\n    patchLchmod(fs)\n  }\n\n  // lutimes implementation, or no-op\n  if (!fs.lutimes) {\n    patchLutimes(fs)\n  }\n\n  // https://github.com/isaacs/node-graceful-fs/issues/4\n  // Chown should not fail on einval or eperm if non-root.\n  // It should not fail on enosys ever, as this just indicates\n  // that a fs doesn't support the intended operation.\n\n  fs.chown = chownFix(fs.chown)\n  fs.fchown = chownFix(fs.fchown)\n  fs.lchown = chownFix(fs.lchown)\n\n  fs.chmod = chmodFix(fs.chmod)\n  fs.fchmod = chmodFix(fs.fchmod)\n  fs.lchmod = chmodFix(fs.lchmod)\n\n  fs.chownSync = chownFixSync(fs.chownSync)\n  fs.fchownSync = chownFixSync(fs.fchownSync)\n  fs.lchownSync = chownFixSync(fs.lchownSync)\n\n  fs.chmodSync = chmodFixSync(fs.chmodSync)\n  fs.fchmodSync = chmodFixSync(fs.fchmodSync)\n  fs.lchmodSync = chmodFixSync(fs.lchmodSync)\n\n  fs.stat = statFix(fs.stat)\n  fs.fstat = statFix(fs.fstat)\n  fs.lstat = statFix(fs.lstat)\n\n  fs.statSync = statFixSync(fs.statSync)\n  fs.fstatSync = statFixSync(fs.fstatSync)\n  fs.lstatSync = statFixSync(fs.lstatSync)\n\n  // if lchmod/lchown do not exist, then make them no-ops\n  if (!fs.lchmod) {\n    fs.lchmod = function (path, mode, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchmodSync = function () {}\n  }\n  if (!fs.lchown) {\n    fs.lchown = function (path, uid, gid, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchownSync = function () {}\n  }\n\n  // on Windows, A/V software can lock the directory, causing this\n  // to fail with an EACCES or EPERM if the directory contains newly\n  // created files.  Try again on failure, for up to 60 seconds.\n\n  // Set the timeout this long because some Windows Anti-Virus, such as Parity\n  // bit9, may lock files for up to a minute, causing npm package install\n  // failures. Also, take care to yield the scheduler. Windows scheduling gives\n  // CPU to a busy looping process, which can cause the program causing the lock\n  // contention to be starved of CPU by node, so the contention doesn't resolve.\n  if (platform === \"win32\") {\n    fs.rename = (function (fs$rename) { return function (from, to, cb) {\n      var start = Date.now()\n      var backoff = 0;\n      fs$rename(from, to, function CB (er) {\n        if (er\n            && (er.code === \"EACCES\" || er.code === \"EPERM\")\n            && Date.now() - start < 60000) {\n          setTimeout(function() {\n            fs.stat(to, function (stater, st) {\n              if (stater && stater.code === \"ENOENT\")\n                fs$rename(from, to, CB);\n              else\n                cb(er)\n            })\n          }, backoff)\n          if (backoff < 100)\n            backoff += 10;\n          return;\n        }\n        if (cb) cb(er)\n      })\n    }})(fs.rename)\n  }\n\n  // if read() returns EAGAIN, then just try it again.\n  fs.read = (function (fs$read) {\n    function read (fd, buffer, offset, length, position, callback_) {\n      var callback\n      if (callback_ && typeof callback_ === 'function') {\n        var eagCounter = 0\n        callback = function (er, _, __) {\n          if (er && er.code === 'EAGAIN' && eagCounter < 10) {\n            eagCounter ++\n            return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n          }\n          callback_.apply(this, arguments)\n        }\n      }\n      return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n    }\n\n    // This ensures `util.promisify` works as it does for native `fs.read`.\n    read.__proto__ = fs$read\n    return read\n  })(fs.read)\n\n  fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {\n    var eagCounter = 0\n    while (true) {\n      try {\n        return fs$readSync.call(fs, fd, buffer, offset, length, position)\n      } catch (er) {\n        if (er.code === 'EAGAIN' && eagCounter < 10) {\n          eagCounter ++\n          continue\n        }\n        throw er\n      }\n    }\n  }})(fs.readSync)\n\n  function patchLchmod (fs) {\n    fs.lchmod = function (path, mode, callback) {\n      fs.open( path\n             , constants.O_WRONLY | constants.O_SYMLINK\n             , mode\n             , function (err, fd) {\n        if (err) {\n          if (callback) callback(err)\n          return\n        }\n        // prefer to return the chmod error, if one occurs,\n        // but still try to close, and report closing errors if they occur.\n        fs.fchmod(fd, mode, function (err) {\n          fs.close(fd, function(err2) {\n            if (callback) callback(err || err2)\n          })\n        })\n      })\n    }\n\n    fs.lchmodSync = function (path, mode) {\n      var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)\n\n      // prefer to return the chmod error, if one occurs,\n      // but still try to close, and report closing errors if they occur.\n      var threw = true\n      var ret\n      try {\n        ret = fs.fchmodSync(fd, mode)\n        threw = false\n      } finally {\n        if (threw) {\n          try {\n            fs.closeSync(fd)\n          } catch (er) {}\n        } else {\n          fs.closeSync(fd)\n        }\n      }\n      return ret\n    }\n  }\n\n  function patchLutimes (fs) {\n    if (constants.hasOwnProperty(\"O_SYMLINK\")) {\n      fs.lutimes = function (path, at, mt, cb) {\n        fs.open(path, constants.O_SYMLINK, function (er, fd) {\n          if (er) {\n            if (cb) cb(er)\n            return\n          }\n          fs.futimes(fd, at, mt, function (er) {\n            fs.close(fd, function (er2) {\n              if (cb) cb(er || er2)\n            })\n          })\n        })\n      }\n\n      fs.lutimesSync = function (path, at, mt) {\n        var fd = fs.openSync(path, constants.O_SYMLINK)\n        var ret\n        var threw = true\n        try {\n          ret = fs.futimesSync(fd, at, mt)\n          threw = false\n        } finally {\n          if (threw) {\n            try {\n              fs.closeSync(fd)\n            } catch (er) {}\n          } else {\n            fs.closeSync(fd)\n          }\n        }\n        return ret\n      }\n\n    } else {\n      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }\n      fs.lutimesSync = function () {}\n    }\n  }\n\n  function chmodFix (orig) {\n    if (!orig) return orig\n    return function (target, mode, cb) {\n      return orig.call(fs, target, mode, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chmodFixSync (orig) {\n    if (!orig) return orig\n    return function (target, mode) {\n      try {\n        return orig.call(fs, target, mode)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n\n  function chownFix (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid, cb) {\n      return orig.call(fs, target, uid, gid, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chownFixSync (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid) {\n      try {\n        return orig.call(fs, target, uid, gid)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n  function statFix (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target, options, cb) {\n      if (typeof options === 'function') {\n        cb = options\n        options = null\n      }\n      function callback (er, stats) {\n        if (stats) {\n          if (stats.uid < 0) stats.uid += 0x100000000\n          if (stats.gid < 0) stats.gid += 0x100000000\n        }\n        if (cb) cb.apply(this, arguments)\n      }\n      return options ? orig.call(fs, target, options, callback)\n        : orig.call(fs, target, callback)\n    }\n  }\n\n  function statFixSync (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target, options) {\n      var stats = options ? orig.call(fs, target, options)\n        : orig.call(fs, target)\n      if (stats.uid < 0) stats.uid += 0x100000000\n      if (stats.gid < 0) stats.gid += 0x100000000\n      return stats;\n    }\n  }\n\n  // ENOSYS means that the fs doesn't support the op. Just ignore\n  // that, because it doesn't matter.\n  //\n  // if there's no getuid, or if getuid() is something other\n  // than 0, and the error is EINVAL or EPERM, then just ignore\n  // it.\n  //\n  // This specific case is a silent failure in cp, install, tar,\n  // and most other unix tools that manage permissions.\n  //\n  // When running as root, or if other types of errors are\n  // encountered, then it's strict.\n  function chownErOk (er) {\n    if (!er)\n      return true\n\n    if (er.code === \"ENOSYS\")\n      return true\n\n    var nonroot = !process.getuid || process.getuid() !== 0\n    if (nonroot) {\n      if (er.code === \"EINVAL\" || er.code === \"EPERM\")\n        return true\n    }\n\n    return false\n  }\n}\n","var fs = require('fs')\n\nvar wx = 'wx'\nif (process.version.match(/^v0\\.[0-6]/)) {\n  var c = require('constants')\n  wx = c.O_TRUNC | c.O_CREAT | c.O_WRONLY | c.O_EXCL\n}\n\nvar os = require('os')\nexports.filetime = 'ctime'\nif (os.platform() == \"win32\") {\n  exports.filetime = 'mtime'\n}\n\nvar debug\nvar util = require('util')\nif (util.debuglog)\n  debug = util.debuglog('LOCKFILE')\nelse if (/\\blockfile\\b/i.test(process.env.NODE_DEBUG))\n  debug = function() {\n    var msg = util.format.apply(util, arguments)\n    console.error('LOCKFILE %d %s', process.pid, msg)\n  }\nelse\n  debug = function() {}\n\nvar locks = {}\n\nfunction hasOwnProperty (obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop)\n}\n\nvar onExit = require('signal-exit')\nonExit(function () {\n  debug('exit listener')\n  // cleanup\n  Object.keys(locks).forEach(exports.unlockSync)\n})\n\n// XXX https://github.com/joyent/node/issues/3555\n// Remove when node 0.8 is deprecated.\nif (/^v0\\.[0-8]\\./.test(process.version)) {\n  debug('uncaughtException, version = %s', process.version)\n  process.on('uncaughtException', function H (er) {\n    debug('uncaughtException')\n    var l = process.listeners('uncaughtException').filter(function (h) {\n      return h !== H\n    })\n    if (!l.length) {\n      // cleanup\n      try { Object.keys(locks).forEach(exports.unlockSync) } catch (e) {}\n      process.removeListener('uncaughtException', H)\n      throw er\n    }\n  })\n}\n\nexports.unlock = function (path, cb) {\n  debug('unlock', path)\n  // best-effort.  unlocking an already-unlocked lock is a noop\n  delete locks[path]\n  fs.unlink(path, function (unlinkEr) { cb && cb() })\n}\n\nexports.unlockSync = function (path) {\n  debug('unlockSync', path)\n  // best-effort.  unlocking an already-unlocked lock is a noop\n  try { fs.unlinkSync(path) } catch (er) {}\n  delete locks[path]\n}\n\n\n// if the file can be opened in readonly mode, then it's there.\n// if the error is something other than ENOENT, then it's not.\nexports.check = function (path, opts, cb) {\n  if (typeof opts === 'function') cb = opts, opts = {}\n  debug('check', path, opts)\n  fs.open(path, 'r', function (er, fd) {\n    if (er) {\n      if (er.code !== 'ENOENT') return cb(er)\n      return cb(null, false)\n    }\n\n    if (!opts.stale) {\n      return fs.close(fd, function (er) {\n        return cb(er, true)\n      })\n    }\n\n    fs.fstat(fd, function (er, st) {\n      if (er) return fs.close(fd, function (er2) {\n        return cb(er)\n      })\n\n      fs.close(fd, function (er) {\n        var age = Date.now() - st[exports.filetime].getTime()\n        return cb(er, age <= opts.stale)\n      })\n    })\n  })\n}\n\nexports.checkSync = function (path, opts) {\n  opts = opts || {}\n  debug('checkSync', path, opts)\n  if (opts.wait) {\n    throw new Error('opts.wait not supported sync for obvious reasons')\n  }\n\n  try {\n    var fd = fs.openSync(path, 'r')\n  } catch (er) {\n    if (er.code !== 'ENOENT') throw er\n    return false\n  }\n\n  if (!opts.stale) {\n    try { fs.closeSync(fd) } catch (er) {}\n    return true\n  }\n\n  // file exists.  however, might be stale\n  if (opts.stale) {\n    try {\n      var st = fs.fstatSync(fd)\n    } finally {\n      fs.closeSync(fd)\n    }\n    var age = Date.now() - st[exports.filetime].getTime()\n    return (age <= opts.stale)\n  }\n}\n\n\n\nvar req = 1\nexports.lock = function (path, opts, cb) {\n  if (typeof opts === 'function') cb = opts, opts = {}\n  opts.req = opts.req || req++\n  debug('lock', path, opts)\n  opts.start = opts.start || Date.now()\n\n  if (typeof opts.retries === 'number' && opts.retries > 0) {\n    debug('has retries', opts.retries)\n    var retries = opts.retries\n    opts.retries = 0\n    cb = (function (orig) { return function cb (er, fd) {\n      debug('retry-mutated callback')\n      retries -= 1\n      if (!er || retries < 0) return orig(er, fd)\n\n      debug('lock retry', path, opts)\n\n      if (opts.retryWait) setTimeout(retry, opts.retryWait)\n      else retry()\n\n      function retry () {\n        opts.start = Date.now()\n        debug('retrying', opts.start)\n        exports.lock(path, opts, cb)\n      }\n    }})(cb)\n  }\n\n  // try to engage the lock.\n  // if this succeeds, then we're in business.\n  fs.open(path, wx, function (er, fd) {\n    if (!er) {\n      debug('locked', path, fd)\n      locks[path] = fd\n      return fs.close(fd, function () {\n        return cb()\n      })\n    }\n\n    debug('failed to acquire lock', er)\n\n    // something other than \"currently locked\"\n    // maybe eperm or something.\n    if (er.code !== 'EEXIST') {\n      debug('not EEXIST error', er)\n      return cb(er)\n    }\n\n    // someone's got this one.  see if it's valid.\n    if (!opts.stale) return notStale(er, path, opts, cb)\n\n    return maybeStale(er, path, opts, false, cb)\n  })\n  debug('lock return')\n}\n\n\n// Staleness checking algorithm\n// 1. acquire $lock, fail\n// 2. stat $lock, find that it is stale\n// 3. acquire $lock.STALE\n// 4. stat $lock, assert that it is still stale\n// 5. unlink $lock\n// 6. link $lock.STALE $lock\n// 7. unlink $lock.STALE\n// On any failure, clean up whatever we've done, and raise the error.\nfunction maybeStale (originalEr, path, opts, hasStaleLock, cb) {\n  fs.stat(path, function (statEr, st) {\n    if (statEr) {\n      if (statEr.code === 'ENOENT') {\n        // expired already!\n        opts.stale = false\n        debug('lock stale enoent retry', path, opts)\n        exports.lock(path, opts, cb)\n        return\n      }\n      return cb(statEr)\n    }\n\n    var age = Date.now() - st[exports.filetime].getTime()\n    if (age <= opts.stale) return notStale(originalEr, path, opts, cb)\n\n    debug('lock stale', path, opts)\n    if (hasStaleLock) {\n      exports.unlock(path, function (er) {\n        if (er) return cb(er)\n        debug('lock stale retry', path, opts)\n        fs.link(path + '.STALE', path, function (er) {\n          fs.unlink(path + '.STALE', function () {\n            // best effort.  if the unlink fails, oh well.\n            cb(er)\n          })\n        })\n      })\n    } else {\n      debug('acquire .STALE file lock', opts)\n      exports.lock(path + '.STALE', opts, function (er) {\n        if (er) return cb(er)\n        maybeStale(originalEr, path, opts, true, cb)\n      })\n    }\n  })\n}\n\nfunction notStale (er, path, opts, cb) {\n  debug('notStale', path, opts)\n\n  // if we can't wait, then just call it a failure\n  if (typeof opts.wait !== 'number' || opts.wait <= 0) {\n    debug('notStale, wait is not a number')\n    return cb(er)\n  }\n\n  // poll for some ms for the lock to clear\n  var now = Date.now()\n  var start = opts.start || now\n  var end = start + opts.wait\n\n  if (end <= now)\n    return cb(er)\n\n  debug('now=%d, wait until %d (delta=%d)', start, end, end-start)\n  var wait = Math.min(end - start, opts.pollPeriod || 100)\n  var timer = setTimeout(poll, wait)\n\n  function poll () {\n    debug('notStale, polling', path, opts)\n    exports.lock(path, opts, cb)\n  }\n}\n\nexports.lockSync = function (path, opts) {\n  opts = opts || {}\n  opts.req = opts.req || req++\n  debug('lockSync', path, opts)\n  if (opts.wait || opts.retryWait) {\n    throw new Error('opts.wait not supported sync for obvious reasons')\n  }\n\n  try {\n    var fd = fs.openSync(path, wx)\n    locks[path] = fd\n    try { fs.closeSync(fd) } catch (er) {}\n    debug('locked sync!', path, fd)\n    return\n  } catch (er) {\n    if (er.code !== 'EEXIST') return retryThrow(path, opts, er)\n\n    if (opts.stale) {\n      var st = fs.statSync(path)\n      var ct = st[exports.filetime].getTime()\n      if (!(ct % 1000) && (opts.stale % 1000)) {\n        // probably don't have subsecond resolution.\n        // round up the staleness indicator.\n        // Yes, this will be wrong 1/1000 times on platforms\n        // with subsecond stat precision, but that's acceptable\n        // in exchange for not mistakenly removing locks on\n        // most other systems.\n        opts.stale = 1000 * Math.ceil(opts.stale / 1000)\n      }\n      var age = Date.now() - ct\n      if (age > opts.stale) {\n        debug('lockSync stale', path, opts, age)\n        exports.unlockSync(path)\n        return exports.lockSync(path, opts)\n      }\n    }\n\n    // failed to lock!\n    debug('failed to lock', path, opts, er)\n    return retryThrow(path, opts, er)\n  }\n}\n\nfunction retryThrow (path, opts, er) {\n  if (typeof opts.retries === 'number' && opts.retries > 0) {\n    var newRT = opts.retries - 1\n    debug('retryThrow', path, opts, newRT)\n    opts.retries = newRT\n    return exports.lockSync(path, opts)\n  }\n  throw er\n}\n\n","'use strict'\n\n// A linked list to keep track of recently-used-ness\nconst Yallist = require('yallist')\n\nconst MAX = Symbol('max')\nconst LENGTH = Symbol('length')\nconst LENGTH_CALCULATOR = Symbol('lengthCalculator')\nconst ALLOW_STALE = Symbol('allowStale')\nconst MAX_AGE = Symbol('maxAge')\nconst DISPOSE = Symbol('dispose')\nconst NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet')\nconst LRU_LIST = Symbol('lruList')\nconst CACHE = Symbol('cache')\nconst UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet')\n\nconst naiveLength = () => 1\n\n// lruList is a yallist where the head is the youngest\n// item, and the tail is the oldest.  the list contains the Hit\n// objects as the entries.\n// Each Hit object has a reference to its Yallist.Node.  This\n// never changes.\n//\n// cache is a Map (or PseudoMap) that matches the keys to\n// the Yallist.Node object.\nclass LRUCache {\n  constructor (options) {\n    if (typeof options === 'number')\n      options = { max: options }\n\n    if (!options)\n      options = {}\n\n    if (options.max && (typeof options.max !== 'number' || options.max < 0))\n      throw new TypeError('max must be a non-negative number')\n    // Kind of weird to have a default max of Infinity, but oh well.\n    const max = this[MAX] = options.max || Infinity\n\n    const lc = options.length || naiveLength\n    this[LENGTH_CALCULATOR] = (typeof lc !== 'function') ? naiveLength : lc\n    this[ALLOW_STALE] = options.stale || false\n    if (options.maxAge && typeof options.maxAge !== 'number')\n      throw new TypeError('maxAge must be a number')\n    this[MAX_AGE] = options.maxAge || 0\n    this[DISPOSE] = options.dispose\n    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false\n    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false\n    this.reset()\n  }\n\n  // resize the cache when the max changes.\n  set max (mL) {\n    if (typeof mL !== 'number' || mL < 0)\n      throw new TypeError('max must be a non-negative number')\n\n    this[MAX] = mL || Infinity\n    trim(this)\n  }\n  get max () {\n    return this[MAX]\n  }\n\n  set allowStale (allowStale) {\n    this[ALLOW_STALE] = !!allowStale\n  }\n  get allowStale () {\n    return this[ALLOW_STALE]\n  }\n\n  set maxAge (mA) {\n    if (typeof mA !== 'number')\n      throw new TypeError('maxAge must be a non-negative number')\n\n    this[MAX_AGE] = mA\n    trim(this)\n  }\n  get maxAge () {\n    return this[MAX_AGE]\n  }\n\n  // resize the cache when the lengthCalculator changes.\n  set lengthCalculator (lC) {\n    if (typeof lC !== 'function')\n      lC = naiveLength\n\n    if (lC !== this[LENGTH_CALCULATOR]) {\n      this[LENGTH_CALCULATOR] = lC\n      this[LENGTH] = 0\n      this[LRU_LIST].forEach(hit => {\n        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)\n        this[LENGTH] += hit.length\n      })\n    }\n    trim(this)\n  }\n  get lengthCalculator () { return this[LENGTH_CALCULATOR] }\n\n  get length () { return this[LENGTH] }\n  get itemCount () { return this[LRU_LIST].length }\n\n  rforEach (fn, thisp) {\n    thisp = thisp || this\n    for (let walker = this[LRU_LIST].tail; walker !== null;) {\n      const prev = walker.prev\n      forEachStep(this, fn, walker, thisp)\n      walker = prev\n    }\n  }\n\n  forEach (fn, thisp) {\n    thisp = thisp || this\n    for (let walker = this[LRU_LIST].head; walker !== null;) {\n      const next = walker.next\n      forEachStep(this, fn, walker, thisp)\n      walker = next\n    }\n  }\n\n  keys () {\n    return this[LRU_LIST].toArray().map(k => k.key)\n  }\n\n  values () {\n    return this[LRU_LIST].toArray().map(k => k.value)\n  }\n\n  reset () {\n    if (this[DISPOSE] &&\n        this[LRU_LIST] &&\n        this[LRU_LIST].length) {\n      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value))\n    }\n\n    this[CACHE] = new Map() // hash of items by key\n    this[LRU_LIST] = new Yallist() // list of items in order of use recency\n    this[LENGTH] = 0 // length of items in the list\n  }\n\n  dump () {\n    return this[LRU_LIST].map(hit =>\n      isStale(this, hit) ? false : {\n        k: hit.key,\n        v: hit.value,\n        e: hit.now + (hit.maxAge || 0)\n      }).toArray().filter(h => h)\n  }\n\n  dumpLru () {\n    return this[LRU_LIST]\n  }\n\n  set (key, value, maxAge) {\n    maxAge = maxAge || this[MAX_AGE]\n\n    if (maxAge && typeof maxAge !== 'number')\n      throw new TypeError('maxAge must be a number')\n\n    const now = maxAge ? Date.now() : 0\n    const len = this[LENGTH_CALCULATOR](value, key)\n\n    if (this[CACHE].has(key)) {\n      if (len > this[MAX]) {\n        del(this, this[CACHE].get(key))\n        return false\n      }\n\n      const node = this[CACHE].get(key)\n      const item = node.value\n\n      // dispose of the old one before overwriting\n      // split out into 2 ifs for better coverage tracking\n      if (this[DISPOSE]) {\n        if (!this[NO_DISPOSE_ON_SET])\n          this[DISPOSE](key, item.value)\n      }\n\n      item.now = now\n      item.maxAge = maxAge\n      item.value = value\n      this[LENGTH] += len - item.length\n      item.length = len\n      this.get(key)\n      trim(this)\n      return true\n    }\n\n    const hit = new Entry(key, value, len, now, maxAge)\n\n    // oversized objects fall out of cache automatically.\n    if (hit.length > this[MAX]) {\n      if (this[DISPOSE])\n        this[DISPOSE](key, value)\n\n      return false\n    }\n\n    this[LENGTH] += hit.length\n    this[LRU_LIST].unshift(hit)\n    this[CACHE].set(key, this[LRU_LIST].head)\n    trim(this)\n    return true\n  }\n\n  has (key) {\n    if (!this[CACHE].has(key)) return false\n    const hit = this[CACHE].get(key).value\n    return !isStale(this, hit)\n  }\n\n  get (key) {\n    return get(this, key, true)\n  }\n\n  peek (key) {\n    return get(this, key, false)\n  }\n\n  pop () {\n    const node = this[LRU_LIST].tail\n    if (!node)\n      return null\n\n    del(this, node)\n    return node.value\n  }\n\n  del (key) {\n    del(this, this[CACHE].get(key))\n  }\n\n  load (arr) {\n    // reset the cache\n    this.reset()\n\n    const now = Date.now()\n    // A previous serialized cache has the most recent items first\n    for (let l = arr.length - 1; l >= 0; l--) {\n      const hit = arr[l]\n      const expiresAt = hit.e || 0\n      if (expiresAt === 0)\n        // the item was created without expiration in a non aged cache\n        this.set(hit.k, hit.v)\n      else {\n        const maxAge = expiresAt - now\n        // dont add already expired items\n        if (maxAge > 0) {\n          this.set(hit.k, hit.v, maxAge)\n        }\n      }\n    }\n  }\n\n  prune () {\n    this[CACHE].forEach((value, key) => get(this, key, false))\n  }\n}\n\nconst get = (self, key, doUse) => {\n  const node = self[CACHE].get(key)\n  if (node) {\n    const hit = node.value\n    if (isStale(self, hit)) {\n      del(self, node)\n      if (!self[ALLOW_STALE])\n        return undefined\n    } else {\n      if (doUse) {\n        if (self[UPDATE_AGE_ON_GET])\n          node.value.now = Date.now()\n        self[LRU_LIST].unshiftNode(node)\n      }\n    }\n    return hit.value\n  }\n}\n\nconst isStale = (self, hit) => {\n  if (!hit || (!hit.maxAge && !self[MAX_AGE]))\n    return false\n\n  const diff = Date.now() - hit.now\n  return hit.maxAge ? diff > hit.maxAge\n    : self[MAX_AGE] && (diff > self[MAX_AGE])\n}\n\nconst trim = self => {\n  if (self[LENGTH] > self[MAX]) {\n    for (let walker = self[LRU_LIST].tail;\n      self[LENGTH] > self[MAX] && walker !== null;) {\n      // We know that we're about to delete this one, and also\n      // what the next least recently used key will be, so just\n      // go ahead and set it now.\n      const prev = walker.prev\n      del(self, walker)\n      walker = prev\n    }\n  }\n}\n\nconst del = (self, node) => {\n  if (node) {\n    const hit = node.value\n    if (self[DISPOSE])\n      self[DISPOSE](hit.key, hit.value)\n\n    self[LENGTH] -= hit.length\n    self[CACHE].delete(hit.key)\n    self[LRU_LIST].removeNode(node)\n  }\n}\n\nclass Entry {\n  constructor (key, value, length, now, maxAge) {\n    this.key = key\n    this.value = value\n    this.length = length\n    this.now = now\n    this.maxAge = maxAge || 0\n  }\n}\n\nconst forEachStep = (self, fn, node, thisp) => {\n  let hit = node.value\n  if (isStale(self, hit)) {\n    del(self, node)\n    if (!self[ALLOW_STALE])\n      hit = undefined\n  }\n  if (hit)\n    fn.call(thisp, hit.value, hit.key, self)\n}\n\nmodule.exports = LRUCache\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","import Stream from 'stream';\nimport http from 'http';\nimport Url from 'url';\nimport https from 'https';\nimport zlib from 'zlib';\n\n// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js\n\n// fix for \"Readable\" isn't a named export issue\nconst Readable = Stream.Readable;\n\nconst BUFFER = Symbol('buffer');\nconst TYPE = Symbol('type');\n\nclass Blob {\n\tconstructor() {\n\t\tthis[TYPE] = '';\n\n\t\tconst blobParts = arguments[0];\n\t\tconst options = arguments[1];\n\n\t\tconst buffers = [];\n\t\tlet size = 0;\n\n\t\tif (blobParts) {\n\t\t\tconst a = blobParts;\n\t\t\tconst length = Number(a.length);\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tconst element = a[i];\n\t\t\t\tlet buffer;\n\t\t\t\tif (element instanceof Buffer) {\n\t\t\t\t\tbuffer = element;\n\t\t\t\t} else if (ArrayBuffer.isView(element)) {\n\t\t\t\t\tbuffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);\n\t\t\t\t} else if (element instanceof ArrayBuffer) {\n\t\t\t\t\tbuffer = Buffer.from(element);\n\t\t\t\t} else if (element instanceof Blob) {\n\t\t\t\t\tbuffer = element[BUFFER];\n\t\t\t\t} else {\n\t\t\t\t\tbuffer = Buffer.from(typeof element === 'string' ? element : String(element));\n\t\t\t\t}\n\t\t\t\tsize += buffer.length;\n\t\t\t\tbuffers.push(buffer);\n\t\t\t}\n\t\t}\n\n\t\tthis[BUFFER] = Buffer.concat(buffers);\n\n\t\tlet type = options && options.type !== undefined && String(options.type).toLowerCase();\n\t\tif (type && !/[^\\u0020-\\u007E]/.test(type)) {\n\t\t\tthis[TYPE] = type;\n\t\t}\n\t}\n\tget size() {\n\t\treturn this[BUFFER].length;\n\t}\n\tget type() {\n\t\treturn this[TYPE];\n\t}\n\ttext() {\n\t\treturn Promise.resolve(this[BUFFER].toString());\n\t}\n\tarrayBuffer() {\n\t\tconst buf = this[BUFFER];\n\t\tconst ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n\t\treturn Promise.resolve(ab);\n\t}\n\tstream() {\n\t\tconst readable = new Readable();\n\t\treadable._read = function () {};\n\t\treadable.push(this[BUFFER]);\n\t\treadable.push(null);\n\t\treturn readable;\n\t}\n\ttoString() {\n\t\treturn '[object Blob]';\n\t}\n\tslice() {\n\t\tconst size = this.size;\n\n\t\tconst start = arguments[0];\n\t\tconst end = arguments[1];\n\t\tlet relativeStart, relativeEnd;\n\t\tif (start === undefined) {\n\t\t\trelativeStart = 0;\n\t\t} else if (start < 0) {\n\t\t\trelativeStart = Math.max(size + start, 0);\n\t\t} else {\n\t\t\trelativeStart = Math.min(start, size);\n\t\t}\n\t\tif (end === undefined) {\n\t\t\trelativeEnd = size;\n\t\t} else if (end < 0) {\n\t\t\trelativeEnd = Math.max(size + end, 0);\n\t\t} else {\n\t\t\trelativeEnd = Math.min(end, size);\n\t\t}\n\t\tconst span = Math.max(relativeEnd - relativeStart, 0);\n\n\t\tconst buffer = this[BUFFER];\n\t\tconst slicedBuffer = buffer.slice(relativeStart, relativeStart + span);\n\t\tconst blob = new Blob([], { type: arguments[2] });\n\t\tblob[BUFFER] = slicedBuffer;\n\t\treturn blob;\n\t}\n}\n\nObject.defineProperties(Blob.prototype, {\n\tsize: { enumerable: true },\n\ttype: { enumerable: true },\n\tslice: { enumerable: true }\n});\n\nObject.defineProperty(Blob.prototype, Symbol.toStringTag, {\n\tvalue: 'Blob',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\n/**\n * fetch-error.js\n *\n * FetchError interface for operational errors\n */\n\n/**\n * Create FetchError instance\n *\n * @param   String      message      Error message for human\n * @param   String      type         Error type for machine\n * @param   String      systemError  For Node.js system error\n * @return  FetchError\n */\nfunction FetchError(message, type, systemError) {\n  Error.call(this, message);\n\n  this.message = message;\n  this.type = type;\n\n  // when err.type is `system`, err.code contains system error code\n  if (systemError) {\n    this.code = this.errno = systemError.code;\n  }\n\n  // hide custom error implementation details from end-users\n  Error.captureStackTrace(this, this.constructor);\n}\n\nFetchError.prototype = Object.create(Error.prototype);\nFetchError.prototype.constructor = FetchError;\nFetchError.prototype.name = 'FetchError';\n\nlet convert;\ntry {\n\tconvert = require('encoding').convert;\n} catch (e) {}\n\nconst INTERNALS = Symbol('Body internals');\n\n// fix an issue where \"PassThrough\" isn't a named export for node <10\nconst PassThrough = Stream.PassThrough;\n\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nfunction Body(body) {\n\tvar _this = this;\n\n\tvar _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n\t    _ref$size = _ref.size;\n\n\tlet size = _ref$size === undefined ? 0 : _ref$size;\n\tvar _ref$timeout = _ref.timeout;\n\tlet timeout = _ref$timeout === undefined ? 0 : _ref$timeout;\n\n\tif (body == null) {\n\t\t// body is undefined or null\n\t\tbody = null;\n\t} else if (isURLSearchParams(body)) {\n\t\t// body is a URLSearchParams\n\t\tbody = Buffer.from(body.toString());\n\t} else if (isBlob(body)) ; else if (Buffer.isBuffer(body)) ; else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {\n\t\t// body is ArrayBuffer\n\t\tbody = Buffer.from(body);\n\t} else if (ArrayBuffer.isView(body)) {\n\t\t// body is ArrayBufferView\n\t\tbody = Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n\t} else if (body instanceof Stream) ; else {\n\t\t// none of the above\n\t\t// coerce to string then buffer\n\t\tbody = Buffer.from(String(body));\n\t}\n\tthis[INTERNALS] = {\n\t\tbody,\n\t\tdisturbed: false,\n\t\terror: null\n\t};\n\tthis.size = size;\n\tthis.timeout = timeout;\n\n\tif (body instanceof Stream) {\n\t\tbody.on('error', function (err) {\n\t\t\tconst error = err.name === 'AbortError' ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, 'system', err);\n\t\t\t_this[INTERNALS].error = error;\n\t\t});\n\t}\n}\n\nBody.prototype = {\n\tget body() {\n\t\treturn this[INTERNALS].body;\n\t},\n\n\tget bodyUsed() {\n\t\treturn this[INTERNALS].disturbed;\n\t},\n\n\t/**\n  * Decode response as ArrayBuffer\n  *\n  * @return  Promise\n  */\n\tarrayBuffer() {\n\t\treturn consumeBody.call(this).then(function (buf) {\n\t\t\treturn buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n\t\t});\n\t},\n\n\t/**\n  * Return raw response as Blob\n  *\n  * @return Promise\n  */\n\tblob() {\n\t\tlet ct = this.headers && this.headers.get('content-type') || '';\n\t\treturn consumeBody.call(this).then(function (buf) {\n\t\t\treturn Object.assign(\n\t\t\t// Prevent copying\n\t\t\tnew Blob([], {\n\t\t\t\ttype: ct.toLowerCase()\n\t\t\t}), {\n\t\t\t\t[BUFFER]: buf\n\t\t\t});\n\t\t});\n\t},\n\n\t/**\n  * Decode response as json\n  *\n  * @return  Promise\n  */\n\tjson() {\n\t\tvar _this2 = this;\n\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\ttry {\n\t\t\t\treturn JSON.parse(buffer.toString());\n\t\t\t} catch (err) {\n\t\t\t\treturn Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, 'invalid-json'));\n\t\t\t}\n\t\t});\n\t},\n\n\t/**\n  * Decode response as text\n  *\n  * @return  Promise\n  */\n\ttext() {\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\treturn buffer.toString();\n\t\t});\n\t},\n\n\t/**\n  * Decode response as buffer (non-spec api)\n  *\n  * @return  Promise\n  */\n\tbuffer() {\n\t\treturn consumeBody.call(this);\n\t},\n\n\t/**\n  * Decode response as text, while automatically detecting the encoding and\n  * trying to decode to UTF-8 (non-spec api)\n  *\n  * @return  Promise\n  */\n\ttextConverted() {\n\t\tvar _this3 = this;\n\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\treturn convertBody(buffer, _this3.headers);\n\t\t});\n\t}\n};\n\n// In browsers, all properties are enumerable.\nObject.defineProperties(Body.prototype, {\n\tbody: { enumerable: true },\n\tbodyUsed: { enumerable: true },\n\tarrayBuffer: { enumerable: true },\n\tblob: { enumerable: true },\n\tjson: { enumerable: true },\n\ttext: { enumerable: true }\n});\n\nBody.mixIn = function (proto) {\n\tfor (const name of Object.getOwnPropertyNames(Body.prototype)) {\n\t\t// istanbul ignore else: future proof\n\t\tif (!(name in proto)) {\n\t\t\tconst desc = Object.getOwnPropertyDescriptor(Body.prototype, name);\n\t\t\tObject.defineProperty(proto, name, desc);\n\t\t}\n\t}\n};\n\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return  Promise\n */\nfunction consumeBody() {\n\tvar _this4 = this;\n\n\tif (this[INTERNALS].disturbed) {\n\t\treturn Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));\n\t}\n\n\tthis[INTERNALS].disturbed = true;\n\n\tif (this[INTERNALS].error) {\n\t\treturn Body.Promise.reject(this[INTERNALS].error);\n\t}\n\n\tlet body = this.body;\n\n\t// body is null\n\tif (body === null) {\n\t\treturn Body.Promise.resolve(Buffer.alloc(0));\n\t}\n\n\t// body is blob\n\tif (isBlob(body)) {\n\t\tbody = body.stream();\n\t}\n\n\t// body is buffer\n\tif (Buffer.isBuffer(body)) {\n\t\treturn Body.Promise.resolve(body);\n\t}\n\n\t// istanbul ignore if: should never happen\n\tif (!(body instanceof Stream)) {\n\t\treturn Body.Promise.resolve(Buffer.alloc(0));\n\t}\n\n\t// body is stream\n\t// get ready to actually consume the body\n\tlet accum = [];\n\tlet accumBytes = 0;\n\tlet abort = false;\n\n\treturn new Body.Promise(function (resolve, reject) {\n\t\tlet resTimeout;\n\n\t\t// allow timeout on slow response body\n\t\tif (_this4.timeout) {\n\t\t\tresTimeout = setTimeout(function () {\n\t\t\t\tabort = true;\n\t\t\t\treject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, 'body-timeout'));\n\t\t\t}, _this4.timeout);\n\t\t}\n\n\t\t// handle stream errors\n\t\tbody.on('error', function (err) {\n\t\t\tif (err.name === 'AbortError') {\n\t\t\t\t// if the request was aborted, reject with this Error\n\t\t\t\tabort = true;\n\t\t\t\treject(err);\n\t\t\t} else {\n\t\t\t\t// other errors, such as incorrect content-encoding\n\t\t\t\treject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, 'system', err));\n\t\t\t}\n\t\t});\n\n\t\tbody.on('data', function (chunk) {\n\t\t\tif (abort || chunk === null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (_this4.size && accumBytes + chunk.length > _this4.size) {\n\t\t\t\tabort = true;\n\t\t\t\treject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, 'max-size'));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\taccumBytes += chunk.length;\n\t\t\taccum.push(chunk);\n\t\t});\n\n\t\tbody.on('end', function () {\n\t\t\tif (abort) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tclearTimeout(resTimeout);\n\n\t\t\ttry {\n\t\t\t\tresolve(Buffer.concat(accum, accumBytes));\n\t\t\t} catch (err) {\n\t\t\t\t// handle streams that have accumulated too much data (issue #414)\n\t\t\t\treject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, 'system', err));\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Detect buffer encoding and convert to target encoding\n * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding\n *\n * @param   Buffer  buffer    Incoming buffer\n * @param   String  encoding  Target encoding\n * @return  String\n */\nfunction convertBody(buffer, headers) {\n\tif (typeof convert !== 'function') {\n\t\tthrow new Error('The package `encoding` must be installed to use the textConverted() function');\n\t}\n\n\tconst ct = headers.get('content-type');\n\tlet charset = 'utf-8';\n\tlet res, str;\n\n\t// header\n\tif (ct) {\n\t\tres = /charset=([^;]*)/i.exec(ct);\n\t}\n\n\t// no charset in content type, peek at response body for at most 1024 bytes\n\tstr = buffer.slice(0, 1024).toString();\n\n\t// html5\n\tif (!res && str) {\n\t\tres = /<meta.+?charset=(['\"])(.+?)\\1/i.exec(str);\n\t}\n\n\t// html4\n\tif (!res && str) {\n\t\tres = /<meta[\\s]+?http-equiv=(['\"])content-type\\1[\\s]+?content=(['\"])(.+?)\\2/i.exec(str);\n\n\t\tif (res) {\n\t\t\tres = /charset=(.*)/i.exec(res.pop());\n\t\t}\n\t}\n\n\t// xml\n\tif (!res && str) {\n\t\tres = /<\\?xml.+?encoding=(['\"])(.+?)\\1/i.exec(str);\n\t}\n\n\t// found charset\n\tif (res) {\n\t\tcharset = res.pop();\n\n\t\t// prevent decode issues when sites use incorrect encoding\n\t\t// ref: https://hsivonen.fi/encoding-menu/\n\t\tif (charset === 'gb2312' || charset === 'gbk') {\n\t\t\tcharset = 'gb18030';\n\t\t}\n\t}\n\n\t// turn raw buffers into a single utf-8 buffer\n\treturn convert(buffer, 'UTF-8', charset).toString();\n}\n\n/**\n * Detect a URLSearchParams object\n * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143\n *\n * @param   Object  obj     Object to detect by type or brand\n * @return  String\n */\nfunction isURLSearchParams(obj) {\n\t// Duck-typing as a necessary condition.\n\tif (typeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function') {\n\t\treturn false;\n\t}\n\n\t// Brand-checking and more duck-typing as optional condition.\n\treturn obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';\n}\n\n/**\n * Check if `obj` is a W3C `Blob` object (which `File` inherits from)\n * @param  {*} obj\n * @return {boolean}\n */\nfunction isBlob(obj) {\n\treturn typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);\n}\n\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed  instance  Response or Request instance\n * @return  Mixed\n */\nfunction clone(instance) {\n\tlet p1, p2;\n\tlet body = instance.body;\n\n\t// don't allow cloning a used body\n\tif (instance.bodyUsed) {\n\t\tthrow new Error('cannot clone body after it is used');\n\t}\n\n\t// check that body is a stream and not form-data object\n\t// note: we can't clone the form-data object without having it as a dependency\n\tif (body instanceof Stream && typeof body.getBoundary !== 'function') {\n\t\t// tee instance body\n\t\tp1 = new PassThrough();\n\t\tp2 = new PassThrough();\n\t\tbody.pipe(p1);\n\t\tbody.pipe(p2);\n\t\t// set instance body to teed body and return the other teed body\n\t\tinstance[INTERNALS].body = p1;\n\t\tbody = p2;\n\t}\n\n\treturn body;\n}\n\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param   Mixed  instance  Any options.body input\n */\nfunction extractContentType(body) {\n\tif (body === null) {\n\t\t// body is null\n\t\treturn null;\n\t} else if (typeof body === 'string') {\n\t\t// body is string\n\t\treturn 'text/plain;charset=UTF-8';\n\t} else if (isURLSearchParams(body)) {\n\t\t// body is a URLSearchParams\n\t\treturn 'application/x-www-form-urlencoded;charset=UTF-8';\n\t} else if (isBlob(body)) {\n\t\t// body is blob\n\t\treturn body.type || null;\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\treturn null;\n\t} else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {\n\t\t// body is ArrayBuffer\n\t\treturn null;\n\t} else if (ArrayBuffer.isView(body)) {\n\t\t// body is ArrayBufferView\n\t\treturn null;\n\t} else if (typeof body.getBoundary === 'function') {\n\t\t// detect form data input from form-data module\n\t\treturn `multipart/form-data;boundary=${body.getBoundary()}`;\n\t} else if (body instanceof Stream) {\n\t\t// body is stream\n\t\t// can't really do much about this\n\t\treturn null;\n\t} else {\n\t\t// Body constructor defaults other things to string\n\t\treturn 'text/plain;charset=UTF-8';\n\t}\n}\n\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param   Body    instance   Instance of Body\n * @return  Number?            Number of bytes, or null if not possible\n */\nfunction getTotalBytes(instance) {\n\tconst body = instance.body;\n\n\n\tif (body === null) {\n\t\t// body is null\n\t\treturn 0;\n\t} else if (isBlob(body)) {\n\t\treturn body.size;\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\treturn body.length;\n\t} else if (body && typeof body.getLengthSync === 'function') {\n\t\t// detect form data input from form-data module\n\t\tif (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x\n\t\tbody.hasKnownLength && body.hasKnownLength()) {\n\t\t\t// 2.x\n\t\t\treturn body.getLengthSync();\n\t\t}\n\t\treturn null;\n\t} else {\n\t\t// body is stream\n\t\treturn null;\n\t}\n}\n\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param   Body    instance   Instance of Body\n * @return  Void\n */\nfunction writeToStream(dest, instance) {\n\tconst body = instance.body;\n\n\n\tif (body === null) {\n\t\t// body is null\n\t\tdest.end();\n\t} else if (isBlob(body)) {\n\t\tbody.stream().pipe(dest);\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\tdest.write(body);\n\t\tdest.end();\n\t} else {\n\t\t// body is stream\n\t\tbody.pipe(dest);\n\t}\n}\n\n// expose Promise\nBody.Promise = global.Promise;\n\n/**\n * headers.js\n *\n * Headers class offers convenient helpers\n */\n\nconst invalidTokenRegex = /[^\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]/;\nconst invalidHeaderCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/;\n\nfunction validateName(name) {\n\tname = `${name}`;\n\tif (invalidTokenRegex.test(name) || name === '') {\n\t\tthrow new TypeError(`${name} is not a legal HTTP header name`);\n\t}\n}\n\nfunction validateValue(value) {\n\tvalue = `${value}`;\n\tif (invalidHeaderCharRegex.test(value)) {\n\t\tthrow new TypeError(`${value} is not a legal HTTP header value`);\n\t}\n}\n\n/**\n * Find the key in the map object given a header name.\n *\n * Returns undefined if not found.\n *\n * @param   String  name  Header name\n * @return  String|Undefined\n */\nfunction find(map, name) {\n\tname = name.toLowerCase();\n\tfor (const key in map) {\n\t\tif (key.toLowerCase() === name) {\n\t\t\treturn key;\n\t\t}\n\t}\n\treturn undefined;\n}\n\nconst MAP = Symbol('map');\nclass Headers {\n\t/**\n  * Headers class\n  *\n  * @param   Object  headers  Response headers\n  * @return  Void\n  */\n\tconstructor() {\n\t\tlet init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n\t\tthis[MAP] = Object.create(null);\n\n\t\tif (init instanceof Headers) {\n\t\t\tconst rawHeaders = init.raw();\n\t\t\tconst headerNames = Object.keys(rawHeaders);\n\n\t\t\tfor (const headerName of headerNames) {\n\t\t\t\tfor (const value of rawHeaders[headerName]) {\n\t\t\t\t\tthis.append(headerName, value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// We don't worry about converting prop to ByteString here as append()\n\t\t// will handle it.\n\t\tif (init == null) ; else if (typeof init === 'object') {\n\t\t\tconst method = init[Symbol.iterator];\n\t\t\tif (method != null) {\n\t\t\t\tif (typeof method !== 'function') {\n\t\t\t\t\tthrow new TypeError('Header pairs must be iterable');\n\t\t\t\t}\n\n\t\t\t\t// sequence<sequence<ByteString>>\n\t\t\t\t// Note: per spec we have to first exhaust the lists then process them\n\t\t\t\tconst pairs = [];\n\t\t\t\tfor (const pair of init) {\n\t\t\t\t\tif (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {\n\t\t\t\t\t\tthrow new TypeError('Each header pair must be iterable');\n\t\t\t\t\t}\n\t\t\t\t\tpairs.push(Array.from(pair));\n\t\t\t\t}\n\n\t\t\t\tfor (const pair of pairs) {\n\t\t\t\t\tif (pair.length !== 2) {\n\t\t\t\t\t\tthrow new TypeError('Each header pair must be a name/value tuple');\n\t\t\t\t\t}\n\t\t\t\t\tthis.append(pair[0], pair[1]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// record<ByteString, ByteString>\n\t\t\t\tfor (const key of Object.keys(init)) {\n\t\t\t\t\tconst value = init[key];\n\t\t\t\t\tthis.append(key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new TypeError('Provided initializer must be an object');\n\t\t}\n\t}\n\n\t/**\n  * Return combined header value given name\n  *\n  * @param   String  name  Header name\n  * @return  Mixed\n  */\n\tget(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key === undefined) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this[MAP][key].join(', ');\n\t}\n\n\t/**\n  * Iterate over all headers\n  *\n  * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)\n  * @param   Boolean   thisArg   `this` context for callback function\n  * @return  Void\n  */\n\tforEach(callback) {\n\t\tlet thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n\t\tlet pairs = getHeaders(this);\n\t\tlet i = 0;\n\t\twhile (i < pairs.length) {\n\t\t\tvar _pairs$i = pairs[i];\n\t\t\tconst name = _pairs$i[0],\n\t\t\t      value = _pairs$i[1];\n\n\t\t\tcallback.call(thisArg, value, name, this);\n\t\t\tpairs = getHeaders(this);\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/**\n  * Overwrite header values given name\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */\n\tset(name, value) {\n\t\tname = `${name}`;\n\t\tvalue = `${value}`;\n\t\tvalidateName(name);\n\t\tvalidateValue(value);\n\t\tconst key = find(this[MAP], name);\n\t\tthis[MAP][key !== undefined ? key : name] = [value];\n\t}\n\n\t/**\n  * Append a value onto existing header\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */\n\tappend(name, value) {\n\t\tname = `${name}`;\n\t\tvalue = `${value}`;\n\t\tvalidateName(name);\n\t\tvalidateValue(value);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key !== undefined) {\n\t\t\tthis[MAP][key].push(value);\n\t\t} else {\n\t\t\tthis[MAP][name] = [value];\n\t\t}\n\t}\n\n\t/**\n  * Check for header name existence\n  *\n  * @param   String   name  Header name\n  * @return  Boolean\n  */\n\thas(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\treturn find(this[MAP], name) !== undefined;\n\t}\n\n\t/**\n  * Delete all header values given name\n  *\n  * @param   String  name  Header name\n  * @return  Void\n  */\n\tdelete(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key !== undefined) {\n\t\t\tdelete this[MAP][key];\n\t\t}\n\t}\n\n\t/**\n  * Return raw headers (non-spec api)\n  *\n  * @return  Object\n  */\n\traw() {\n\t\treturn this[MAP];\n\t}\n\n\t/**\n  * Get an iterator on keys.\n  *\n  * @return  Iterator\n  */\n\tkeys() {\n\t\treturn createHeadersIterator(this, 'key');\n\t}\n\n\t/**\n  * Get an iterator on values.\n  *\n  * @return  Iterator\n  */\n\tvalues() {\n\t\treturn createHeadersIterator(this, 'value');\n\t}\n\n\t/**\n  * Get an iterator on entries.\n  *\n  * This is the default iterator of the Headers object.\n  *\n  * @return  Iterator\n  */\n\t[Symbol.iterator]() {\n\t\treturn createHeadersIterator(this, 'key+value');\n\t}\n}\nHeaders.prototype.entries = Headers.prototype[Symbol.iterator];\n\nObject.defineProperty(Headers.prototype, Symbol.toStringTag, {\n\tvalue: 'Headers',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nObject.defineProperties(Headers.prototype, {\n\tget: { enumerable: true },\n\tforEach: { enumerable: true },\n\tset: { enumerable: true },\n\tappend: { enumerable: true },\n\thas: { enumerable: true },\n\tdelete: { enumerable: true },\n\tkeys: { enumerable: true },\n\tvalues: { enumerable: true },\n\tentries: { enumerable: true }\n});\n\nfunction getHeaders(headers) {\n\tlet kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';\n\n\tconst keys = Object.keys(headers[MAP]).sort();\n\treturn keys.map(kind === 'key' ? function (k) {\n\t\treturn k.toLowerCase();\n\t} : kind === 'value' ? function (k) {\n\t\treturn headers[MAP][k].join(', ');\n\t} : function (k) {\n\t\treturn [k.toLowerCase(), headers[MAP][k].join(', ')];\n\t});\n}\n\nconst INTERNAL = Symbol('internal');\n\nfunction createHeadersIterator(target, kind) {\n\tconst iterator = Object.create(HeadersIteratorPrototype);\n\titerator[INTERNAL] = {\n\t\ttarget,\n\t\tkind,\n\t\tindex: 0\n\t};\n\treturn iterator;\n}\n\nconst HeadersIteratorPrototype = Object.setPrototypeOf({\n\tnext() {\n\t\t// istanbul ignore if\n\t\tif (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {\n\t\t\tthrow new TypeError('Value of `this` is not a HeadersIterator');\n\t\t}\n\n\t\tvar _INTERNAL = this[INTERNAL];\n\t\tconst target = _INTERNAL.target,\n\t\t      kind = _INTERNAL.kind,\n\t\t      index = _INTERNAL.index;\n\n\t\tconst values = getHeaders(target, kind);\n\t\tconst len = values.length;\n\t\tif (index >= len) {\n\t\t\treturn {\n\t\t\t\tvalue: undefined,\n\t\t\t\tdone: true\n\t\t\t};\n\t\t}\n\n\t\tthis[INTERNAL].index = index + 1;\n\n\t\treturn {\n\t\t\tvalue: values[index],\n\t\t\tdone: false\n\t\t};\n\t}\n}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));\n\nObject.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {\n\tvalue: 'HeadersIterator',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\n/**\n * Export the Headers object in a form that Node.js can consume.\n *\n * @param   Headers  headers\n * @return  Object\n */\nfunction exportNodeCompatibleHeaders(headers) {\n\tconst obj = Object.assign({ __proto__: null }, headers[MAP]);\n\n\t// http.request() only supports string as Host header. This hack makes\n\t// specifying custom Host header possible.\n\tconst hostHeaderKey = find(headers[MAP], 'Host');\n\tif (hostHeaderKey !== undefined) {\n\t\tobj[hostHeaderKey] = obj[hostHeaderKey][0];\n\t}\n\n\treturn obj;\n}\n\n/**\n * Create a Headers object from an object of headers, ignoring those that do\n * not conform to HTTP grammar productions.\n *\n * @param   Object  obj  Object of headers\n * @return  Headers\n */\nfunction createHeadersLenient(obj) {\n\tconst headers = new Headers();\n\tfor (const name of Object.keys(obj)) {\n\t\tif (invalidTokenRegex.test(name)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (Array.isArray(obj[name])) {\n\t\t\tfor (const val of obj[name]) {\n\t\t\t\tif (invalidHeaderCharRegex.test(val)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (headers[MAP][name] === undefined) {\n\t\t\t\t\theaders[MAP][name] = [val];\n\t\t\t\t} else {\n\t\t\t\t\theaders[MAP][name].push(val);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!invalidHeaderCharRegex.test(obj[name])) {\n\t\t\theaders[MAP][name] = [obj[name]];\n\t\t}\n\t}\n\treturn headers;\n}\n\nconst INTERNALS$1 = Symbol('Response internals');\n\n// fix an issue where \"STATUS_CODES\" aren't a named export for node <10\nconst STATUS_CODES = http.STATUS_CODES;\n\n/**\n * Response class\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nclass Response {\n\tconstructor() {\n\t\tlet body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t\tlet opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\tBody.call(this, body, opts);\n\n\t\tconst status = opts.status || 200;\n\t\tconst headers = new Headers(opts.headers);\n\n\t\tif (body != null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(body);\n\t\t\tif (contentType) {\n\t\t\t\theaders.append('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tthis[INTERNALS$1] = {\n\t\t\turl: opts.url,\n\t\t\tstatus,\n\t\t\tstatusText: opts.statusText || STATUS_CODES[status],\n\t\t\theaders,\n\t\t\tcounter: opts.counter\n\t\t};\n\t}\n\n\tget url() {\n\t\treturn this[INTERNALS$1].url || '';\n\t}\n\n\tget status() {\n\t\treturn this[INTERNALS$1].status;\n\t}\n\n\t/**\n  * Convenience property representing if the request ended normally\n  */\n\tget ok() {\n\t\treturn this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;\n\t}\n\n\tget redirected() {\n\t\treturn this[INTERNALS$1].counter > 0;\n\t}\n\n\tget statusText() {\n\t\treturn this[INTERNALS$1].statusText;\n\t}\n\n\tget headers() {\n\t\treturn this[INTERNALS$1].headers;\n\t}\n\n\t/**\n  * Clone this response\n  *\n  * @return  Response\n  */\n\tclone() {\n\t\treturn new Response(clone(this), {\n\t\t\turl: this.url,\n\t\t\tstatus: this.status,\n\t\t\tstatusText: this.statusText,\n\t\t\theaders: this.headers,\n\t\t\tok: this.ok,\n\t\t\tredirected: this.redirected\n\t\t});\n\t}\n}\n\nBody.mixIn(Response.prototype);\n\nObject.defineProperties(Response.prototype, {\n\turl: { enumerable: true },\n\tstatus: { enumerable: true },\n\tok: { enumerable: true },\n\tredirected: { enumerable: true },\n\tstatusText: { enumerable: true },\n\theaders: { enumerable: true },\n\tclone: { enumerable: true }\n});\n\nObject.defineProperty(Response.prototype, Symbol.toStringTag, {\n\tvalue: 'Response',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nconst INTERNALS$2 = Symbol('Request internals');\n\n// fix an issue where \"format\", \"parse\" aren't a named export for node <10\nconst parse_url = Url.parse;\nconst format_url = Url.format;\n\nconst streamDestructionSupported = 'destroy' in Stream.Readable.prototype;\n\n/**\n * Check if a value is an instance of Request.\n *\n * @param   Mixed   input\n * @return  Boolean\n */\nfunction isRequest(input) {\n\treturn typeof input === 'object' && typeof input[INTERNALS$2] === 'object';\n}\n\nfunction isAbortSignal(signal) {\n\tconst proto = signal && typeof signal === 'object' && Object.getPrototypeOf(signal);\n\treturn !!(proto && proto.constructor.name === 'AbortSignal');\n}\n\n/**\n * Request class\n *\n * @param   Mixed   input  Url or Request instance\n * @param   Object  init   Custom options\n * @return  Void\n */\nclass Request {\n\tconstructor(input) {\n\t\tlet init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\tlet parsedURL;\n\n\t\t// normalize input\n\t\tif (!isRequest(input)) {\n\t\t\tif (input && input.href) {\n\t\t\t\t// in order to support Node.js' Url objects; though WHATWG's URL objects\n\t\t\t\t// will fall into this branch also (since their `toString()` will return\n\t\t\t\t// `href` property anyway)\n\t\t\t\tparsedURL = parse_url(input.href);\n\t\t\t} else {\n\t\t\t\t// coerce input to a string before attempting to parse\n\t\t\t\tparsedURL = parse_url(`${input}`);\n\t\t\t}\n\t\t\tinput = {};\n\t\t} else {\n\t\t\tparsedURL = parse_url(input.url);\n\t\t}\n\n\t\tlet method = init.method || input.method || 'GET';\n\t\tmethod = method.toUpperCase();\n\n\t\tif ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {\n\t\t\tthrow new TypeError('Request with GET/HEAD method cannot have body');\n\t\t}\n\n\t\tlet inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;\n\n\t\tBody.call(this, inputBody, {\n\t\t\ttimeout: init.timeout || input.timeout || 0,\n\t\t\tsize: init.size || input.size || 0\n\t\t});\n\n\t\tconst headers = new Headers(init.headers || input.headers || {});\n\n\t\tif (inputBody != null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(inputBody);\n\t\t\tif (contentType) {\n\t\t\t\theaders.append('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tlet signal = isRequest(input) ? input.signal : null;\n\t\tif ('signal' in init) signal = init.signal;\n\n\t\tif (signal != null && !isAbortSignal(signal)) {\n\t\t\tthrow new TypeError('Expected signal to be an instanceof AbortSignal');\n\t\t}\n\n\t\tthis[INTERNALS$2] = {\n\t\t\tmethod,\n\t\t\tredirect: init.redirect || input.redirect || 'follow',\n\t\t\theaders,\n\t\t\tparsedURL,\n\t\t\tsignal\n\t\t};\n\n\t\t// node-fetch-only options\n\t\tthis.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;\n\t\tthis.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;\n\t\tthis.counter = init.counter || input.counter || 0;\n\t\tthis.agent = init.agent || input.agent;\n\t}\n\n\tget method() {\n\t\treturn this[INTERNALS$2].method;\n\t}\n\n\tget url() {\n\t\treturn format_url(this[INTERNALS$2].parsedURL);\n\t}\n\n\tget headers() {\n\t\treturn this[INTERNALS$2].headers;\n\t}\n\n\tget redirect() {\n\t\treturn this[INTERNALS$2].redirect;\n\t}\n\n\tget signal() {\n\t\treturn this[INTERNALS$2].signal;\n\t}\n\n\t/**\n  * Clone this request\n  *\n  * @return  Request\n  */\n\tclone() {\n\t\treturn new Request(this);\n\t}\n}\n\nBody.mixIn(Request.prototype);\n\nObject.defineProperty(Request.prototype, Symbol.toStringTag, {\n\tvalue: 'Request',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nObject.defineProperties(Request.prototype, {\n\tmethod: { enumerable: true },\n\turl: { enumerable: true },\n\theaders: { enumerable: true },\n\tredirect: { enumerable: true },\n\tclone: { enumerable: true },\n\tsignal: { enumerable: true }\n});\n\n/**\n * Convert a Request to Node.js http request options.\n *\n * @param   Request  A Request instance\n * @return  Object   The options object to be passed to http.request\n */\nfunction getNodeRequestOptions(request) {\n\tconst parsedURL = request[INTERNALS$2].parsedURL;\n\tconst headers = new Headers(request[INTERNALS$2].headers);\n\n\t// fetch step 1.3\n\tif (!headers.has('Accept')) {\n\t\theaders.set('Accept', '*/*');\n\t}\n\n\t// Basic fetch\n\tif (!parsedURL.protocol || !parsedURL.hostname) {\n\t\tthrow new TypeError('Only absolute URLs are supported');\n\t}\n\n\tif (!/^https?:$/.test(parsedURL.protocol)) {\n\t\tthrow new TypeError('Only HTTP(S) protocols are supported');\n\t}\n\n\tif (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {\n\t\tthrow new Error('Cancellation of streamed requests with AbortSignal is not supported in node < 8');\n\t}\n\n\t// HTTP-network-or-cache fetch steps 2.4-2.7\n\tlet contentLengthValue = null;\n\tif (request.body == null && /^(POST|PUT)$/i.test(request.method)) {\n\t\tcontentLengthValue = '0';\n\t}\n\tif (request.body != null) {\n\t\tconst totalBytes = getTotalBytes(request);\n\t\tif (typeof totalBytes === 'number') {\n\t\t\tcontentLengthValue = String(totalBytes);\n\t\t}\n\t}\n\tif (contentLengthValue) {\n\t\theaders.set('Content-Length', contentLengthValue);\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.11\n\tif (!headers.has('User-Agent')) {\n\t\theaders.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.15\n\tif (request.compress && !headers.has('Accept-Encoding')) {\n\t\theaders.set('Accept-Encoding', 'gzip,deflate');\n\t}\n\n\tlet agent = request.agent;\n\tif (typeof agent === 'function') {\n\t\tagent = agent(parsedURL);\n\t}\n\n\tif (!headers.has('Connection') && !agent) {\n\t\theaders.set('Connection', 'close');\n\t}\n\n\t// HTTP-network fetch step 4.2\n\t// chunked encoding is handled by Node.js\n\n\treturn Object.assign({}, parsedURL, {\n\t\tmethod: request.method,\n\t\theaders: exportNodeCompatibleHeaders(headers),\n\t\tagent\n\t});\n}\n\n/**\n * abort-error.js\n *\n * AbortError interface for cancelled requests\n */\n\n/**\n * Create AbortError instance\n *\n * @param   String      message      Error message for human\n * @return  AbortError\n */\nfunction AbortError(message) {\n  Error.call(this, message);\n\n  this.type = 'aborted';\n  this.message = message;\n\n  // hide custom error implementation details from end-users\n  Error.captureStackTrace(this, this.constructor);\n}\n\nAbortError.prototype = Object.create(Error.prototype);\nAbortError.prototype.constructor = AbortError;\nAbortError.prototype.name = 'AbortError';\n\n// fix an issue where \"PassThrough\", \"resolve\" aren't a named export for node <10\nconst PassThrough$1 = Stream.PassThrough;\nconst resolve_url = Url.resolve;\n\n/**\n * Fetch function\n *\n * @param   Mixed    url   Absolute url or Request instance\n * @param   Object   opts  Fetch options\n * @return  Promise\n */\nfunction fetch(url, opts) {\n\n\t// allow custom promise\n\tif (!fetch.Promise) {\n\t\tthrow new Error('native promise missing, set fetch.Promise to your favorite alternative');\n\t}\n\n\tBody.Promise = fetch.Promise;\n\n\t// wrap http.request into fetch\n\treturn new fetch.Promise(function (resolve, reject) {\n\t\t// build request object\n\t\tconst request = new Request(url, opts);\n\t\tconst options = getNodeRequestOptions(request);\n\n\t\tconst send = (options.protocol === 'https:' ? https : http).request;\n\t\tconst signal = request.signal;\n\n\t\tlet response = null;\n\n\t\tconst abort = function abort() {\n\t\t\tlet error = new AbortError('The user aborted a request.');\n\t\t\treject(error);\n\t\t\tif (request.body && request.body instanceof Stream.Readable) {\n\t\t\t\trequest.body.destroy(error);\n\t\t\t}\n\t\t\tif (!response || !response.body) return;\n\t\t\tresponse.body.emit('error', error);\n\t\t};\n\n\t\tif (signal && signal.aborted) {\n\t\t\tabort();\n\t\t\treturn;\n\t\t}\n\n\t\tconst abortAndFinalize = function abortAndFinalize() {\n\t\t\tabort();\n\t\t\tfinalize();\n\t\t};\n\n\t\t// send request\n\t\tconst req = send(options);\n\t\tlet reqTimeout;\n\n\t\tif (signal) {\n\t\t\tsignal.addEventListener('abort', abortAndFinalize);\n\t\t}\n\n\t\tfunction finalize() {\n\t\t\treq.abort();\n\t\t\tif (signal) signal.removeEventListener('abort', abortAndFinalize);\n\t\t\tclearTimeout(reqTimeout);\n\t\t}\n\n\t\tif (request.timeout) {\n\t\t\treq.once('socket', function (socket) {\n\t\t\t\treqTimeout = setTimeout(function () {\n\t\t\t\t\treject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));\n\t\t\t\t\tfinalize();\n\t\t\t\t}, request.timeout);\n\t\t\t});\n\t\t}\n\n\t\treq.on('error', function (err) {\n\t\t\treject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));\n\t\t\tfinalize();\n\t\t});\n\n\t\treq.on('response', function (res) {\n\t\t\tclearTimeout(reqTimeout);\n\n\t\t\tconst headers = createHeadersLenient(res.headers);\n\n\t\t\t// HTTP fetch step 5\n\t\t\tif (fetch.isRedirect(res.statusCode)) {\n\t\t\t\t// HTTP fetch step 5.2\n\t\t\t\tconst location = headers.get('Location');\n\n\t\t\t\t// HTTP fetch step 5.3\n\t\t\t\tconst locationURL = location === null ? null : resolve_url(request.url, location);\n\n\t\t\t\t// HTTP fetch step 5.5\n\t\t\t\tswitch (request.redirect) {\n\t\t\t\t\tcase 'error':\n\t\t\t\t\t\treject(new FetchError(`redirect mode is set to error: ${request.url}`, 'no-redirect'));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase 'manual':\n\t\t\t\t\t\t// node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.\n\t\t\t\t\t\tif (locationURL !== null) {\n\t\t\t\t\t\t\t// handle corrupted header\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\theaders.set('Location', locationURL);\n\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t// istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request\n\t\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'follow':\n\t\t\t\t\t\t// HTTP-redirect fetch step 2\n\t\t\t\t\t\tif (locationURL === null) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 5\n\t\t\t\t\t\tif (request.counter >= request.follow) {\n\t\t\t\t\t\t\treject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 6 (counter increment)\n\t\t\t\t\t\t// Create a new Request object.\n\t\t\t\t\t\tconst requestOpts = {\n\t\t\t\t\t\t\theaders: new Headers(request.headers),\n\t\t\t\t\t\t\tfollow: request.follow,\n\t\t\t\t\t\t\tcounter: request.counter + 1,\n\t\t\t\t\t\t\tagent: request.agent,\n\t\t\t\t\t\t\tcompress: request.compress,\n\t\t\t\t\t\t\tmethod: request.method,\n\t\t\t\t\t\t\tbody: request.body,\n\t\t\t\t\t\t\tsignal: request.signal,\n\t\t\t\t\t\t\ttimeout: request.timeout\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 9\n\t\t\t\t\t\tif (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {\n\t\t\t\t\t\t\treject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 11\n\t\t\t\t\t\tif (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {\n\t\t\t\t\t\t\trequestOpts.method = 'GET';\n\t\t\t\t\t\t\trequestOpts.body = undefined;\n\t\t\t\t\t\t\trequestOpts.headers.delete('content-length');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 15\n\t\t\t\t\t\tresolve(fetch(new Request(locationURL, requestOpts)));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// prepare response\n\t\t\tres.once('end', function () {\n\t\t\t\tif (signal) signal.removeEventListener('abort', abortAndFinalize);\n\t\t\t});\n\t\t\tlet body = res.pipe(new PassThrough$1());\n\n\t\t\tconst response_options = {\n\t\t\t\turl: request.url,\n\t\t\t\tstatus: res.statusCode,\n\t\t\t\tstatusText: res.statusMessage,\n\t\t\t\theaders: headers,\n\t\t\t\tsize: request.size,\n\t\t\t\ttimeout: request.timeout,\n\t\t\t\tcounter: request.counter\n\t\t\t};\n\n\t\t\t// HTTP-network fetch step 12.1.1.3\n\t\t\tconst codings = headers.get('Content-Encoding');\n\n\t\t\t// HTTP-network fetch step 12.1.1.4: handle content codings\n\n\t\t\t// in following scenarios we ignore compression support\n\t\t\t// 1. compression support is disabled\n\t\t\t// 2. HEAD request\n\t\t\t// 3. no Content-Encoding header\n\t\t\t// 4. no content response (204)\n\t\t\t// 5. content not modified response (304)\n\t\t\tif (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// For Node v6+\n\t\t\t// Be less strict when decoding compressed responses, since sometimes\n\t\t\t// servers send slightly invalid responses that are still accepted\n\t\t\t// by common browsers.\n\t\t\t// Always using Z_SYNC_FLUSH is what cURL does.\n\t\t\tconst zlibOptions = {\n\t\t\t\tflush: zlib.Z_SYNC_FLUSH,\n\t\t\t\tfinishFlush: zlib.Z_SYNC_FLUSH\n\t\t\t};\n\n\t\t\t// for gzip\n\t\t\tif (codings == 'gzip' || codings == 'x-gzip') {\n\t\t\t\tbody = body.pipe(zlib.createGunzip(zlibOptions));\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// for deflate\n\t\t\tif (codings == 'deflate' || codings == 'x-deflate') {\n\t\t\t\t// handle the infamous raw deflate response from old servers\n\t\t\t\t// a hack for old IIS and Apache servers\n\t\t\t\tconst raw = res.pipe(new PassThrough$1());\n\t\t\t\traw.once('data', function (chunk) {\n\t\t\t\t\t// see http://stackoverflow.com/questions/37519828\n\t\t\t\t\tif ((chunk[0] & 0x0F) === 0x08) {\n\t\t\t\t\t\tbody = body.pipe(zlib.createInflate());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbody = body.pipe(zlib.createInflateRaw());\n\t\t\t\t\t}\n\t\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\t\tresolve(response);\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// for br\n\t\t\tif (codings == 'br' && typeof zlib.createBrotliDecompress === 'function') {\n\t\t\t\tbody = body.pipe(zlib.createBrotliDecompress());\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// otherwise, use response as-is\n\t\t\tresponse = new Response(body, response_options);\n\t\t\tresolve(response);\n\t\t});\n\n\t\twriteToStream(req, request);\n\t});\n}\n/**\n * Redirect code matching\n *\n * @param   Number   code  Status code\n * @return  Boolean\n */\nfetch.isRedirect = function (code) {\n\treturn code === 301 || code === 302 || code === 303 || code === 307 || code === 308;\n};\n\n// expose Promise\nfetch.Promise = global.Promise;\n\nexport default fetch;\nexport { Headers, Request, Response, FetchError };\n","var fs = require('fs')\nvar path = require('path')\nvar os = require('os')\n\n// Workaround to fix webpack's build warnings: 'the request of a dependency is an expression'\nvar runtimeRequire = typeof __webpack_require__ === 'function' ? __non_webpack_require__ : require // eslint-disable-line\n\nvar vars = (process.config && process.config.variables) || {}\nvar prebuildsOnly = !!process.env.PREBUILDS_ONLY\nvar abi = process.versions.modules // TODO: support old node where this is undef\nvar runtime = isElectron() ? 'electron' : 'node'\nvar arch = os.arch()\nvar platform = os.platform()\nvar libc = process.env.LIBC || (isAlpine(platform) ? 'musl' : 'glibc')\nvar armv = process.env.ARM_VERSION || (arch === 'arm64' ? '8' : vars.arm_version) || ''\nvar uv = (process.versions.uv || '').split('.')[0]\n\nmodule.exports = load\n\nfunction load (dir) {\n  return runtimeRequire(load.path(dir))\n}\n\nload.path = function (dir) {\n  dir = path.resolve(dir || '.')\n\n  try {\n    var name = runtimeRequire(path.join(dir, 'package.json')).name.toUpperCase().replace(/-/g, '_')\n    if (process.env[name + '_PREBUILD']) dir = process.env[name + '_PREBUILD']\n  } catch (err) {}\n\n  if (!prebuildsOnly) {\n    var release = getFirst(path.join(dir, 'build/Release'), matchBuild)\n    if (release) return release\n\n    var debug = getFirst(path.join(dir, 'build/Debug'), matchBuild)\n    if (debug) return debug\n  }\n\n  var prebuild = resolve(dir)\n  if (prebuild) return prebuild\n\n  var nearby = resolve(path.dirname(process.execPath))\n  if (nearby) return nearby\n\n  var target = [\n    'platform=' + platform,\n    'arch=' + arch,\n    'runtime=' + runtime,\n    'abi=' + abi,\n    'uv=' + uv,\n    armv ? 'armv=' + armv : '',\n    'libc=' + libc,\n    'node=' + process.versions.node,\n    (process.versions && process.versions.electron) ? 'electron=' + process.versions.electron : '',\n    typeof __webpack_require__ === 'function' ? 'webpack=true' : '' // eslint-disable-line\n  ].filter(Boolean).join(' ')\n\n  throw new Error('No native build was found for ' + target + '\\n    loaded from: ' + dir + '\\n')\n\n  function resolve (dir) {\n    // Find most specific flavor first\n    var prebuilds = path.join(dir, 'prebuilds', platform + '-' + arch)\n    var parsed = readdirSync(prebuilds).map(parseTags)\n    var candidates = parsed.filter(matchTags(runtime, abi))\n    var winner = candidates.sort(compareTags(runtime))[0]\n    if (winner) return path.join(prebuilds, winner.file)\n  }\n}\n\nfunction readdirSync (dir) {\n  try {\n    return fs.readdirSync(dir)\n  } catch (err) {\n    return []\n  }\n}\n\nfunction getFirst (dir, filter) {\n  var files = readdirSync(dir).filter(filter)\n  return files[0] && path.join(dir, files[0])\n}\n\nfunction matchBuild (name) {\n  return /\\.node$/.test(name)\n}\n\nfunction parseTags (file) {\n  var arr = file.split('.')\n  var extension = arr.pop()\n  var tags = { file: file, specificity: 0 }\n\n  if (extension !== 'node') return\n\n  for (var i = 0; i < arr.length; i++) {\n    var tag = arr[i]\n\n    if (tag === 'node' || tag === 'electron' || tag === 'node-webkit') {\n      tags.runtime = tag\n    } else if (tag === 'napi') {\n      tags.napi = true\n    } else if (tag.slice(0, 3) === 'abi') {\n      tags.abi = tag.slice(3)\n    } else if (tag.slice(0, 2) === 'uv') {\n      tags.uv = tag.slice(2)\n    } else if (tag.slice(0, 4) === 'armv') {\n      tags.armv = tag.slice(4)\n    } else if (tag === 'glibc' || tag === 'musl') {\n      tags.libc = tag\n    } else {\n      continue\n    }\n\n    tags.specificity++\n  }\n\n  return tags\n}\n\nfunction matchTags (runtime, abi) {\n  return function (tags) {\n    if (tags == null) return false\n    if (tags.runtime !== runtime && !runtimeAgnostic(tags)) return false\n    if (tags.abi !== abi && !tags.napi) return false\n    if (tags.uv && tags.uv !== uv) return false\n    if (tags.armv && tags.armv !== armv) return false\n    if (tags.libc && tags.libc !== libc) return false\n\n    return true\n  }\n}\n\nfunction runtimeAgnostic (tags) {\n  return tags.runtime === 'node' && tags.napi\n}\n\nfunction compareTags (runtime) {\n  // Precedence: non-agnostic runtime, abi over napi, then by specificity.\n  return function (a, b) {\n    if (a.runtime !== b.runtime) {\n      return a.runtime === runtime ? -1 : 1\n    } else if (a.abi !== b.abi) {\n      return a.abi ? -1 : 1\n    } else if (a.specificity !== b.specificity) {\n      return a.specificity > b.specificity ? -1 : 1\n    } else {\n      return 0\n    }\n  }\n}\n\nfunction isElectron () {\n  if (process.versions && process.versions.electron) return true\n  if (process.env.ELECTRON_RUN_AS_NODE) return true\n  return typeof window !== 'undefined' && window.process && window.process.type === 'renderer'\n}\n\nfunction isAlpine (platform) {\n  return platform === 'linux' && fs.existsSync('/etc/alpine-release')\n}\n\n// Exposed for unit tests\n// TODO: move to lib\nload.parseTags = parseTags\nload.matchTags = matchTags\nload.compareTags = compareTags\n","/*!\n * RSA library for Node.js\n *\n * Author: rzcoder\n * License MIT\n */\n\nvar constants = require('constants');\nvar rsa = require('./libs/rsa.js');\nvar crypt = require('crypto');\nvar ber = require('asn1').Ber;\nvar _ = require('./utils')._;\nvar utils = require('./utils');\nvar schemes = require('./schemes/schemes.js');\nvar formats = require('./formats/formats.js');\n\nif (typeof constants.RSA_NO_PADDING === \"undefined\") {\n    //patch for node v0.10.x, constants do not defined\n    constants.RSA_NO_PADDING = 3;\n}\n\nmodule.exports = (function () {\n    var SUPPORTED_HASH_ALGORITHMS = {\n        node10: ['md4', 'md5', 'ripemd160', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512'],\n        node: ['md4', 'md5', 'ripemd160', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512'],\n        iojs: ['md4', 'md5', 'ripemd160', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512'],\n        browser: ['md5', 'ripemd160', 'sha1', 'sha256', 'sha512']\n    };\n\n    var DEFAULT_ENCRYPTION_SCHEME = 'pkcs1_oaep';\n    var DEFAULT_SIGNING_SCHEME = 'pkcs1';\n\n    var DEFAULT_EXPORT_FORMAT = 'private';\n    var EXPORT_FORMAT_ALIASES = {\n        'private': 'pkcs1-private-pem',\n        'private-der': 'pkcs1-private-der',\n        'public': 'pkcs8-public-pem',\n        'public-der': 'pkcs8-public-der',\n    };\n\n    /**\n     * @param key {string|buffer|object} Key in PEM format, or data for generate key {b: bits, e: exponent}\n     * @constructor\n     */\n    function NodeRSA(key, format, options) {\n        if (!(this instanceof NodeRSA)) {\n            return new NodeRSA(key, format, options);\n        }\n\n        if (_.isObject(format)) {\n            options = format;\n            format = undefined;\n        }\n\n        this.$options = {\n            signingScheme: DEFAULT_SIGNING_SCHEME,\n            signingSchemeOptions: {\n                hash: 'sha256',\n                saltLength: null\n            },\n            encryptionScheme: DEFAULT_ENCRYPTION_SCHEME,\n            encryptionSchemeOptions: {\n                hash: 'sha1',\n                label: null\n            },\n            environment: utils.detectEnvironment(),\n            rsaUtils: this\n        };\n        this.keyPair = new rsa.Key();\n        this.$cache = {};\n\n        if (Buffer.isBuffer(key) || _.isString(key)) {\n            this.importKey(key, format);\n        } else if (_.isObject(key)) {\n            this.generateKeyPair(key.b, key.e);\n        }\n\n        this.setOptions(options);\n    }\n\n    /**\n     * Set and validate options for key instance\n     * @param options\n     */\n    NodeRSA.prototype.setOptions = function (options) {\n        options = options || {};\n        if (options.environment) {\n            this.$options.environment = options.environment;\n        }\n\n        if (options.signingScheme) {\n            if (_.isString(options.signingScheme)) {\n                var signingScheme = options.signingScheme.toLowerCase().split('-');\n                if (signingScheme.length == 1) {\n                    if (SUPPORTED_HASH_ALGORITHMS.node.indexOf(signingScheme[0]) > -1) {\n                        this.$options.signingSchemeOptions = {\n                            hash: signingScheme[0]\n                        };\n                        this.$options.signingScheme = DEFAULT_SIGNING_SCHEME;\n                    } else {\n                        this.$options.signingScheme = signingScheme[0];\n                        this.$options.signingSchemeOptions = {\n                            hash: null\n                        };\n                    }\n                } else {\n                    this.$options.signingSchemeOptions = {\n                        hash: signingScheme[1]\n                    };\n                    this.$options.signingScheme = signingScheme[0];\n                }\n            } else if (_.isObject(options.signingScheme)) {\n                this.$options.signingScheme = options.signingScheme.scheme || DEFAULT_SIGNING_SCHEME;\n                this.$options.signingSchemeOptions = _.omit(options.signingScheme, 'scheme');\n            }\n\n            if (!schemes.isSignature(this.$options.signingScheme)) {\n                throw Error('Unsupported signing scheme');\n            }\n\n            if (this.$options.signingSchemeOptions.hash &&\n                SUPPORTED_HASH_ALGORITHMS[this.$options.environment].indexOf(this.$options.signingSchemeOptions.hash) === -1) {\n                throw Error('Unsupported hashing algorithm for ' + this.$options.environment + ' environment');\n            }\n        }\n\n        if (options.encryptionScheme) {\n            if (_.isString(options.encryptionScheme)) {\n                this.$options.encryptionScheme = options.encryptionScheme.toLowerCase();\n                this.$options.encryptionSchemeOptions = {};\n            } else if (_.isObject(options.encryptionScheme)) {\n                this.$options.encryptionScheme = options.encryptionScheme.scheme || DEFAULT_ENCRYPTION_SCHEME;\n                this.$options.encryptionSchemeOptions = _.omit(options.encryptionScheme, 'scheme');\n            }\n\n            if (!schemes.isEncryption(this.$options.encryptionScheme)) {\n                throw Error('Unsupported encryption scheme');\n            }\n\n            if (this.$options.encryptionSchemeOptions.hash &&\n                SUPPORTED_HASH_ALGORITHMS[this.$options.environment].indexOf(this.$options.encryptionSchemeOptions.hash) === -1) {\n                throw Error('Unsupported hashing algorithm for ' + this.$options.environment + ' environment');\n            }\n        }\n\n        this.keyPair.setOptions(this.$options);\n    };\n\n    /**\n     * Generate private/public keys pair\n     *\n     * @param bits {int} length key in bits. Default 2048.\n     * @param exp {int} public exponent. Default 65537.\n     * @returns {NodeRSA}\n     */\n    NodeRSA.prototype.generateKeyPair = function (bits, exp) {\n        bits = bits || 2048;\n        exp = exp || 65537;\n\n        if (bits % 8 !== 0) {\n            throw Error('Key size must be a multiple of 8.');\n        }\n\n        this.keyPair.generate(bits, exp.toString(16));\n        this.$cache = {};\n        return this;\n    };\n\n    /**\n     * Importing key\n     * @param keyData {string|buffer|Object}\n     * @param format {string}\n     */\n    NodeRSA.prototype.importKey = function (keyData, format) {\n        if (!keyData) {\n            throw Error(\"Empty key given\");\n        }\n\n        if (format) {\n            format = EXPORT_FORMAT_ALIASES[format] || format;\n        }\n\n        if (!formats.detectAndImport(this.keyPair, keyData, format) && format === undefined) {\n            throw Error(\"Key format must be specified\");\n        }\n        \n        this.$cache = {};\n        \n        return this;\n    };\n\n    /**\n     * Exporting key\n     * @param [format] {string}\n     */\n    NodeRSA.prototype.exportKey = function (format) {\n        format = format || DEFAULT_EXPORT_FORMAT;\n        format = EXPORT_FORMAT_ALIASES[format] || format;\n\n        if (!this.$cache[format]) {\n            this.$cache[format] = formats.detectAndExport(this.keyPair, format);\n        }\n\n        return this.$cache[format];\n    };\n\n    /**\n     * Check if key pair contains private key\n     */\n    NodeRSA.prototype.isPrivate = function () {\n        return this.keyPair.isPrivate();\n    };\n\n    /**\n     * Check if key pair contains public key\n     * @param [strict] {boolean} - public key only, return false if have private exponent\n     */\n    NodeRSA.prototype.isPublic = function (strict) {\n        return this.keyPair.isPublic(strict);\n    };\n\n    /**\n     * Check if key pair doesn't contains any data\n     */\n    NodeRSA.prototype.isEmpty = function (strict) {\n        return !(this.keyPair.n || this.keyPair.e || this.keyPair.d);\n    };\n\n    /**\n     * Encrypting data method with public key\n     *\n     * @param buffer {string|number|object|array|Buffer} - data for encrypting. Object and array will convert to JSON string.\n     * @param encoding {string} - optional. Encoding for output result, may be 'buffer', 'binary', 'hex' or 'base64'. Default 'buffer'.\n     * @param source_encoding {string} - optional. Encoding for given string. Default utf8.\n     * @returns {string|Buffer}\n     */\n    NodeRSA.prototype.encrypt = function (buffer, encoding, source_encoding) {\n        return this.$$encryptKey(false, buffer, encoding, source_encoding);\n    };\n\n    /**\n     * Decrypting data method with private key\n     *\n     * @param buffer {Buffer} - buffer for decrypting\n     * @param encoding - encoding for result string, can also take 'json' or 'buffer' for the automatic conversion of this type\n     * @returns {Buffer|object|string}\n     */\n    NodeRSA.prototype.decrypt = function (buffer, encoding) {\n        return this.$$decryptKey(false, buffer, encoding);\n    };\n\n    /**\n     * Encrypting data method with private key\n     *\n     * Parameters same as `encrypt` method\n     */\n    NodeRSA.prototype.encryptPrivate = function (buffer, encoding, source_encoding) {\n        return this.$$encryptKey(true, buffer, encoding, source_encoding);\n    };\n\n    /**\n     * Decrypting data method with public key\n     *\n     * Parameters same as `decrypt` method\n     */\n    NodeRSA.prototype.decryptPublic = function (buffer, encoding) {\n        return this.$$decryptKey(true, buffer, encoding);\n    };\n\n    /**\n     * Encrypting data method with custom key\n     */\n    NodeRSA.prototype.$$encryptKey = function (usePrivate, buffer, encoding, source_encoding) {\n        try {\n            var res = this.keyPair.encrypt(this.$getDataForEncrypt(buffer, source_encoding), usePrivate);\n\n            if (encoding == 'buffer' || !encoding) {\n                return res;\n            } else {\n                return res.toString(encoding);\n            }\n        } catch (e) {\n            throw Error('Error during encryption. Original error: ' + e);\n        }\n    };\n\n    /**\n     * Decrypting data method with custom key\n     */\n    NodeRSA.prototype.$$decryptKey = function (usePublic, buffer, encoding) {\n        try {\n            buffer = _.isString(buffer) ? Buffer.from(buffer, 'base64') : buffer;\n            var res = this.keyPair.decrypt(buffer, usePublic);\n\n            if (res === null) {\n                throw Error('Key decrypt method returns null.');\n            }\n\n            return this.$getDecryptedData(res, encoding);\n        } catch (e) {\n            throw Error('Error during decryption (probably incorrect key). Original error: ' + e);\n        }\n    };\n\n    /**\n     *  Signing data\n     *\n     * @param buffer {string|number|object|array|Buffer} - data for signing. Object and array will convert to JSON string.\n     * @param encoding {string} - optional. Encoding for output result, may be 'buffer', 'binary', 'hex' or 'base64'. Default 'buffer'.\n     * @param source_encoding {string} - optional. Encoding for given string. Default utf8.\n     * @returns {string|Buffer}\n     */\n    NodeRSA.prototype.sign = function (buffer, encoding, source_encoding) {\n        if (!this.isPrivate()) {\n            throw Error(\"This is not private key\");\n        }\n\n        var res = this.keyPair.sign(this.$getDataForEncrypt(buffer, source_encoding));\n\n        if (encoding && encoding != 'buffer') {\n            res = res.toString(encoding);\n        }\n\n        return res;\n    };\n\n    /**\n     *  Verifying signed data\n     *\n     * @param buffer - signed data\n     * @param signature\n     * @param source_encoding {string} - optional. Encoding for given string. Default utf8.\n     * @param signature_encoding - optional. Encoding of given signature. May be 'buffer', 'binary', 'hex' or 'base64'. Default 'buffer'.\n     * @returns {*}\n     */\n    NodeRSA.prototype.verify = function (buffer, signature, source_encoding, signature_encoding) {\n        if (!this.isPublic()) {\n            throw Error(\"This is not public key\");\n        }\n        signature_encoding = (!signature_encoding || signature_encoding == 'buffer' ? null : signature_encoding);\n        return this.keyPair.verify(this.$getDataForEncrypt(buffer, source_encoding), signature, signature_encoding);\n    };\n\n    /**\n     * Returns key size in bits\n     * @returns {int}\n     */\n    NodeRSA.prototype.getKeySize = function () {\n        return this.keyPair.keySize;\n    };\n\n    /**\n     * Returns max message length in bytes (for 1 chunk) depending on current encryption scheme\n     * @returns {int}\n     */\n    NodeRSA.prototype.getMaxMessageSize = function () {\n        return this.keyPair.maxMessageLength;\n    };\n\n    /**\n     * Preparing given data for encrypting/signing. Just make new/return Buffer object.\n     *\n     * @param buffer {string|number|object|array|Buffer} - data for encrypting. Object and array will convert to JSON string.\n     * @param encoding {string} - optional. Encoding for given string. Default utf8.\n     * @returns {Buffer}\n     */\n    NodeRSA.prototype.$getDataForEncrypt = function (buffer, encoding) {\n        if (_.isString(buffer) || _.isNumber(buffer)) {\n            return Buffer.from('' + buffer, encoding || 'utf8');\n        } else if (Buffer.isBuffer(buffer)) {\n            return buffer;\n        } else if (_.isObject(buffer)) {\n            return Buffer.from(JSON.stringify(buffer));\n        } else {\n            throw Error(\"Unexpected data type\");\n        }\n    };\n\n    /**\n     *\n     * @param buffer {Buffer} - decrypted data.\n     * @param encoding - optional. Encoding for result output. May be 'buffer', 'json' or any of Node.js Buffer supported encoding.\n     * @returns {*}\n     */\n    NodeRSA.prototype.$getDecryptedData = function (buffer, encoding) {\n        encoding = encoding || 'buffer';\n\n        if (encoding == 'buffer') {\n            return buffer;\n        } else if (encoding == 'json') {\n            return JSON.parse(buffer.toString());\n        } else {\n            return buffer.toString(encoding);\n        }\n    };\n\n    return NodeRSA;\n})();\n","var crypt = require('crypto');\r\n\r\nmodule.exports = {\r\n    getEngine: function (keyPair, options) {\r\n        var engine = require('./js.js');\r\n        if (options.environment === 'node') {\r\n            if (typeof crypt.publicEncrypt === 'function' && typeof crypt.privateDecrypt === 'function') {\r\n                if (typeof crypt.privateEncrypt === 'function' && typeof crypt.publicDecrypt === 'function') {\r\n                    engine = require('./io.js');\r\n                } else {\r\n                    engine = require('./node12.js');\r\n                }\r\n            }\r\n        }\r\n        return engine(keyPair, options);\r\n    }\r\n};","var crypto = require('crypto');\r\nvar constants = require('constants');\r\nvar schemes = require('../schemes/schemes.js');\r\n\r\nmodule.exports = function (keyPair, options) {\r\n    var pkcs1Scheme = schemes.pkcs1.makeScheme(keyPair, options);\r\n\r\n    return {\r\n        encrypt: function (buffer, usePrivate) {\r\n            var padding;\r\n            if (usePrivate) {\r\n                padding = constants.RSA_PKCS1_PADDING;\r\n                if (options.encryptionSchemeOptions && options.encryptionSchemeOptions.padding) {\r\n                    padding = options.encryptionSchemeOptions.padding;\r\n                }\r\n                return crypto.privateEncrypt({\r\n                    key: options.rsaUtils.exportKey('private'),\r\n                    padding: padding\r\n                }, buffer);\r\n            } else {\r\n                padding = constants.RSA_PKCS1_OAEP_PADDING;\r\n                if (options.encryptionScheme === 'pkcs1') {\r\n                    padding = constants.RSA_PKCS1_PADDING;\r\n                }\r\n                if (options.encryptionSchemeOptions && options.encryptionSchemeOptions.padding) {\r\n                    padding = options.encryptionSchemeOptions.padding;\r\n                }\r\n\r\n                var data = buffer;\r\n                if (padding === constants.RSA_NO_PADDING) {\r\n                    data = pkcs1Scheme.pkcs0pad(buffer);\r\n                }\r\n\r\n                return crypto.publicEncrypt({\r\n                    key: options.rsaUtils.exportKey('public'),\r\n                    padding: padding\r\n                }, data);\r\n            }\r\n        },\r\n\r\n        decrypt: function (buffer, usePublic) {\r\n            var padding;\r\n            if (usePublic) {\r\n                padding = constants.RSA_PKCS1_PADDING;\r\n                if (options.encryptionSchemeOptions && options.encryptionSchemeOptions.padding) {\r\n                    padding = options.encryptionSchemeOptions.padding;\r\n                }\r\n                return crypto.publicDecrypt({\r\n                    key: options.rsaUtils.exportKey('public'),\r\n                    padding: padding\r\n                }, buffer);\r\n            } else {\r\n                padding = constants.RSA_PKCS1_OAEP_PADDING;\r\n                if (options.encryptionScheme === 'pkcs1') {\r\n                    padding = constants.RSA_PKCS1_PADDING;\r\n                }\r\n                if (options.encryptionSchemeOptions && options.encryptionSchemeOptions.padding) {\r\n                    padding = options.encryptionSchemeOptions.padding;\r\n                }\r\n                var res = crypto.privateDecrypt({\r\n                    key: options.rsaUtils.exportKey('private'),\r\n                    padding: padding\r\n                }, buffer);\r\n\r\n                if (padding === constants.RSA_NO_PADDING) {\r\n                    return pkcs1Scheme.pkcs0unpad(res);\r\n                }\r\n                return res;\r\n            }\r\n        }\r\n    };\r\n};","var BigInteger = require('../libs/jsbn.js');\r\nvar schemes = require('../schemes/schemes.js');\r\n\r\nmodule.exports = function (keyPair, options) {\r\n    var pkcs1Scheme = schemes.pkcs1.makeScheme(keyPair, options);\r\n\r\n    return {\r\n        encrypt: function (buffer, usePrivate) {\r\n            var m, c;\r\n            if (usePrivate) {\r\n                /* Type 1: zeros padding for private key encrypt */\r\n                m = new BigInteger(pkcs1Scheme.encPad(buffer, {type: 1}));\r\n                c = keyPair.$doPrivate(m);\r\n            } else {\r\n                m = new BigInteger(keyPair.encryptionScheme.encPad(buffer));\r\n                c = keyPair.$doPublic(m);\r\n            }\r\n            return c.toBuffer(keyPair.encryptedDataLength);\r\n        },\r\n\r\n        decrypt: function (buffer, usePublic) {\r\n            var m, c = new BigInteger(buffer);\r\n\r\n            if (usePublic) {\r\n                m = keyPair.$doPublic(c);\r\n                /* Type 1: zeros padding for private key decrypt */\r\n                return pkcs1Scheme.encUnPad(m.toBuffer(keyPair.encryptedDataLength), {type: 1});\r\n            } else {\r\n                m = keyPair.$doPrivate(c);\r\n                return keyPair.encryptionScheme.encUnPad(m.toBuffer(keyPair.encryptedDataLength));\r\n            }\r\n        }\r\n    };\r\n};","var crypto = require('crypto');\r\nvar constants = require('constants');\r\nvar schemes = require('../schemes/schemes.js');\r\n\r\nmodule.exports = function (keyPair, options) {\r\n    var jsEngine = require('./js.js')(keyPair, options);\r\n    var pkcs1Scheme = schemes.pkcs1.makeScheme(keyPair, options);\r\n\r\n    return {\r\n        encrypt: function (buffer, usePrivate) {\r\n            if (usePrivate) {\r\n                return jsEngine.encrypt(buffer, usePrivate);\r\n            }\r\n            var padding = constants.RSA_PKCS1_OAEP_PADDING;\r\n            if (options.encryptionScheme === 'pkcs1') {\r\n                padding = constants.RSA_PKCS1_PADDING;\r\n            }\r\n            if (options.encryptionSchemeOptions && options.encryptionSchemeOptions.padding) {\r\n                padding = options.encryptionSchemeOptions.padding;\r\n            }\r\n\r\n            var data = buffer;\r\n            if (padding === constants.RSA_NO_PADDING) {\r\n                data = pkcs1Scheme.pkcs0pad(buffer);\r\n            }\r\n\r\n            return crypto.publicEncrypt({\r\n                key: options.rsaUtils.exportKey('public'),\r\n                padding: padding\r\n            }, data);\r\n        },\r\n\r\n        decrypt: function (buffer, usePublic) {\r\n            if (usePublic) {\r\n                return jsEngine.decrypt(buffer, usePublic);\r\n            }\r\n            var padding = constants.RSA_PKCS1_OAEP_PADDING;\r\n            if (options.encryptionScheme === 'pkcs1') {\r\n                padding = constants.RSA_PKCS1_PADDING;\r\n            }\r\n            if (options.encryptionSchemeOptions && options.encryptionSchemeOptions.padding) {\r\n                padding = options.encryptionSchemeOptions.padding;\r\n            }\r\n\r\n            var res = crypto.privateDecrypt({\r\n                key: options.rsaUtils.exportKey('private'),\r\n                padding: padding\r\n            }, buffer);\r\n\r\n            if (padding === constants.RSA_NO_PADDING) {\r\n                return pkcs1Scheme.pkcs0unpad(res);\r\n            }\r\n            return res;\r\n        }\r\n    };\r\n};","var _ = require('../utils')._;\r\nvar utils = require('../utils');\r\n\r\nmodule.exports = {\r\n    privateExport: function (key, options) {\r\n        return {\r\n            n: key.n.toBuffer(),\r\n            e: key.e,\r\n            d: key.d.toBuffer(),\r\n            p: key.p.toBuffer(),\r\n            q: key.q.toBuffer(),\r\n            dmp1: key.dmp1.toBuffer(),\r\n            dmq1: key.dmq1.toBuffer(),\r\n            coeff: key.coeff.toBuffer()\r\n        };\r\n    },\r\n\r\n    privateImport: function (key, data, options) {\r\n        if (data.n && data.e && data.d && data.p && data.q && data.dmp1 && data.dmq1 && data.coeff) {\r\n            key.setPrivate(\r\n                data.n,\r\n                data.e,\r\n                data.d,\r\n                data.p,\r\n                data.q,\r\n                data.dmp1,\r\n                data.dmq1,\r\n                data.coeff\r\n            );\r\n        } else {\r\n            throw Error(\"Invalid key data\");\r\n        }\r\n    },\r\n\r\n    publicExport: function (key, options) {\r\n        return {\r\n            n: key.n.toBuffer(),\r\n            e: key.e\r\n        };\r\n    },\r\n\r\n    publicImport: function (key, data, options) {\r\n        if (data.n && data.e) {\r\n            key.setPublic(\r\n                data.n,\r\n                data.e\r\n            );\r\n        } else {\r\n            throw Error(\"Invalid key data\");\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Trying autodetect and import key\r\n     * @param key\r\n     * @param data\r\n     */\r\n    autoImport: function (key, data) {\r\n        if (data.n && data.e) {\r\n            if (data.d && data.p && data.q && data.dmp1 && data.dmq1 && data.coeff) {\r\n                module.exports.privateImport(key, data);\r\n                return true;\r\n            } else {\r\n                module.exports.publicImport(key, data);\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n};\r\n","var _ = require('../utils')._;\r\n\r\nfunction formatParse(format) {\r\n    format = format.split('-');\r\n    var keyType = 'private';\r\n    var keyOpt = {type: 'default'};\r\n\r\n    for (var i = 1; i < format.length; i++) {\r\n        if (format[i]) {\r\n            switch (format[i]) {\r\n                case 'public':\r\n                    keyType = format[i];\r\n                    break;\r\n                case 'private':\r\n                    keyType = format[i];\r\n                    break;\r\n                case 'pem':\r\n                    keyOpt.type = format[i];\r\n                    break;\r\n                case 'der':\r\n                    keyOpt.type = format[i];\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return {scheme: format[0], keyType: keyType, keyOpt: keyOpt};\r\n}\r\n\r\nmodule.exports = {\r\n    pkcs1: require('./pkcs1'),\r\n    pkcs8: require('./pkcs8'),\r\n    components: require('./components'),\r\n\r\n    isPrivateExport: function (format) {\r\n        return module.exports[format] && typeof module.exports[format].privateExport === 'function';\r\n    },\r\n\r\n    isPrivateImport: function (format) {\r\n        return module.exports[format] && typeof module.exports[format].privateImport === 'function';\r\n    },\r\n\r\n    isPublicExport: function (format) {\r\n        return module.exports[format] && typeof module.exports[format].publicExport === 'function';\r\n    },\r\n\r\n    isPublicImport: function (format) {\r\n        return module.exports[format] && typeof module.exports[format].publicImport === 'function';\r\n    },\r\n\r\n    detectAndImport: function (key, data, format) {\r\n        if (format === undefined) {\r\n            for (var scheme in module.exports) {\r\n                if (typeof module.exports[scheme].autoImport === 'function' && module.exports[scheme].autoImport(key, data)) {\r\n                    return true;\r\n                }\r\n            }\r\n        } else if (format) {\r\n            var fmt = formatParse(format);\r\n\r\n            if (module.exports[fmt.scheme]) {\r\n                if (fmt.keyType === 'private') {\r\n                    module.exports[fmt.scheme].privateImport(key, data, fmt.keyOpt);\r\n                } else {\r\n                    module.exports[fmt.scheme].publicImport(key, data, fmt.keyOpt);\r\n                }\r\n            } else {\r\n                throw Error('Unsupported key format');\r\n            }\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    detectAndExport: function (key, format) {\r\n        if (format) {\r\n            var fmt = formatParse(format);\r\n\r\n            if (module.exports[fmt.scheme]) {\r\n                if (fmt.keyType === 'private') {\r\n                    if (!key.isPrivate()) {\r\n                        throw Error(\"This is not private key\");\r\n                    }\r\n                    return module.exports[fmt.scheme].privateExport(key, fmt.keyOpt);\r\n                } else {\r\n                    if (!key.isPublic()) {\r\n                        throw Error(\"This is not public key\");\r\n                    }\r\n                    return module.exports[fmt.scheme].publicExport(key, fmt.keyOpt);\r\n                }\r\n            } else {\r\n                throw Error('Unsupported key format');\r\n            }\r\n        }\r\n    }\r\n};","var ber = require('asn1').Ber;\nvar _ = require('../utils')._;\nvar utils = require('../utils');\n\nconst PRIVATE_OPENING_BOUNDARY = '-----BEGIN RSA PRIVATE KEY-----';\nconst PRIVATE_CLOSING_BOUNDARY = '-----END RSA PRIVATE KEY-----';\n\nconst PUBLIC_OPENING_BOUNDARY = '-----BEGIN RSA PUBLIC KEY-----';\nconst PUBLIC_CLOSING_BOUNDARY = '-----END RSA PUBLIC KEY-----';\n\nmodule.exports = {\n    privateExport: function (key, options) {\n        options = options || {};\n\n        var n = key.n.toBuffer();\n        var d = key.d.toBuffer();\n        var p = key.p.toBuffer();\n        var q = key.q.toBuffer();\n        var dmp1 = key.dmp1.toBuffer();\n        var dmq1 = key.dmq1.toBuffer();\n        var coeff = key.coeff.toBuffer();\n\n        var length = n.length + d.length + p.length + q.length + dmp1.length + dmq1.length + coeff.length + 512; // magic\n        var writer = new ber.Writer({size: length});\n\n        writer.startSequence();\n        writer.writeInt(0);\n        writer.writeBuffer(n, 2);\n        writer.writeInt(key.e);\n        writer.writeBuffer(d, 2);\n        writer.writeBuffer(p, 2);\n        writer.writeBuffer(q, 2);\n        writer.writeBuffer(dmp1, 2);\n        writer.writeBuffer(dmq1, 2);\n        writer.writeBuffer(coeff, 2);\n        writer.endSequence();\n\n        if (options.type === 'der') {\n            return writer.buffer;\n        } else {\n            return PRIVATE_OPENING_BOUNDARY + '\\n' + utils.linebrk(writer.buffer.toString('base64'), 64) + '\\n' + PRIVATE_CLOSING_BOUNDARY;\n        }\n    },\n\n    privateImport: function (key, data, options) {\n        options = options || {};\n        var buffer;\n\n        if (options.type !== 'der') {\n            if (Buffer.isBuffer(data)) {\n                data = data.toString('utf8');\n            }\n\n            if (_.isString(data)) {\n                var pem = utils.trimSurroundingText(data, PRIVATE_OPENING_BOUNDARY, PRIVATE_CLOSING_BOUNDARY)\n                    .replace(/\\s+|\\n\\r|\\n|\\r$/gm, '');\n                buffer = Buffer.from(pem, 'base64');\n            } else {\n                throw Error('Unsupported key format');\n            }\n        } else if (Buffer.isBuffer(data)) {\n            buffer = data;\n        } else {\n            throw Error('Unsupported key format');\n        }\n\n        var reader = new ber.Reader(buffer);\n        reader.readSequence();\n        reader.readString(2, true); // just zero\n        key.setPrivate(\n            reader.readString(2, true),  // modulus\n            reader.readString(2, true),  // publicExponent\n            reader.readString(2, true),  // privateExponent\n            reader.readString(2, true),  // prime1\n            reader.readString(2, true),  // prime2\n            reader.readString(2, true),  // exponent1 -- d mod (p1)\n            reader.readString(2, true),  // exponent2 -- d mod (q-1)\n            reader.readString(2, true)   // coefficient -- (inverse of q) mod p\n        );\n    },\n\n    publicExport: function (key, options) {\n        options = options || {};\n\n        var n = key.n.toBuffer();\n        var length = n.length + 512; // magic\n\n        var bodyWriter = new ber.Writer({size: length});\n        bodyWriter.startSequence();\n        bodyWriter.writeBuffer(n, 2);\n        bodyWriter.writeInt(key.e);\n        bodyWriter.endSequence();\n\n        if (options.type === 'der') {\n            return bodyWriter.buffer;\n        } else {\n            return PUBLIC_OPENING_BOUNDARY + '\\n' + utils.linebrk(bodyWriter.buffer.toString('base64'), 64) + '\\n' + PUBLIC_CLOSING_BOUNDARY;\n        }\n    },\n\n    publicImport: function (key, data, options) {\n        options = options || {};\n        var buffer;\n\n        if (options.type !== 'der') {\n            if (Buffer.isBuffer(data)) {\n                data = data.toString('utf8');\n            }\n\n            if (_.isString(data)) {\n                var pem = utils.trimSurroundingText(data, PUBLIC_OPENING_BOUNDARY, PUBLIC_CLOSING_BOUNDARY)\n                    .replace(/\\s+|\\n\\r|\\n|\\r$/gm, '');\n                buffer = Buffer.from(pem, 'base64');\n            }\n        } else if (Buffer.isBuffer(data)) {\n            buffer = data;\n        } else {\n            throw Error('Unsupported key format');\n        }\n\n        var body = new ber.Reader(buffer);\n        body.readSequence();\n        key.setPublic(\n            body.readString(0x02, true), // modulus\n            body.readString(0x02, true)  // publicExponent\n        );\n    },\n\n    /**\n     * Trying autodetect and import key\n     * @param key\n     * @param data\n     */\n    autoImport: function (key, data) {\n        // [\\S\\s]* matches zero or more of any character\n        if (/^[\\S\\s]*-----BEGIN RSA PRIVATE KEY-----\\s*(?=(([A-Za-z0-9+/=]+\\s*)+))\\1-----END RSA PRIVATE KEY-----[\\S\\s]*$/g.test(data)) {\n            module.exports.privateImport(key, data);\n            return true;\n        }\n\n        if (/^[\\S\\s]*-----BEGIN RSA PUBLIC KEY-----\\s*(?=(([A-Za-z0-9+/=]+\\s*)+))\\1-----END RSA PUBLIC KEY-----[\\S\\s]*$/g.test(data)) {\n            module.exports.publicImport(key, data);\n            return true;\n        }\n\n        return false;\n    }\n};","var ber = require('asn1').Ber;\nvar _ = require('../utils')._;\nvar PUBLIC_RSA_OID = '1.2.840.113549.1.1.1';\nvar utils = require('../utils');\n\nconst PRIVATE_OPENING_BOUNDARY = '-----BEGIN PRIVATE KEY-----';\nconst PRIVATE_CLOSING_BOUNDARY = '-----END PRIVATE KEY-----';\n\nconst PUBLIC_OPENING_BOUNDARY = '-----BEGIN PUBLIC KEY-----';\nconst PUBLIC_CLOSING_BOUNDARY = '-----END PUBLIC KEY-----';\n\nmodule.exports = {\n    privateExport: function (key, options) {\n        options = options || {};\n\n        var n = key.n.toBuffer();\n        var d = key.d.toBuffer();\n        var p = key.p.toBuffer();\n        var q = key.q.toBuffer();\n        var dmp1 = key.dmp1.toBuffer();\n        var dmq1 = key.dmq1.toBuffer();\n        var coeff = key.coeff.toBuffer();\n\n        var length = n.length + d.length + p.length + q.length + dmp1.length + dmq1.length + coeff.length + 512; // magic\n        var bodyWriter = new ber.Writer({size: length});\n\n        bodyWriter.startSequence();\n        bodyWriter.writeInt(0);\n        bodyWriter.writeBuffer(n, 2);\n        bodyWriter.writeInt(key.e);\n        bodyWriter.writeBuffer(d, 2);\n        bodyWriter.writeBuffer(p, 2);\n        bodyWriter.writeBuffer(q, 2);\n        bodyWriter.writeBuffer(dmp1, 2);\n        bodyWriter.writeBuffer(dmq1, 2);\n        bodyWriter.writeBuffer(coeff, 2);\n        bodyWriter.endSequence();\n\n        var writer = new ber.Writer({size: length});\n        writer.startSequence();\n        writer.writeInt(0);\n        writer.startSequence();\n        writer.writeOID(PUBLIC_RSA_OID);\n        writer.writeNull();\n        writer.endSequence();\n        writer.writeBuffer(bodyWriter.buffer, 4);\n        writer.endSequence();\n\n        if (options.type === 'der') {\n            return writer.buffer;\n        } else {\n            return PRIVATE_OPENING_BOUNDARY + '\\n' + utils.linebrk(writer.buffer.toString('base64'), 64) + '\\n' + PRIVATE_CLOSING_BOUNDARY;\n        }\n    },\n\n    privateImport: function (key, data, options) {\n        options = options || {};\n        var buffer;\n\n        if (options.type !== 'der') {\n            if (Buffer.isBuffer(data)) {\n                data = data.toString('utf8');\n            }\n\n            if (_.isString(data)) {\n                var pem = utils.trimSurroundingText(data, PRIVATE_OPENING_BOUNDARY, PRIVATE_CLOSING_BOUNDARY)\n                    .replace('-----END PRIVATE KEY-----', '')\n                    .replace(/\\s+|\\n\\r|\\n|\\r$/gm, '');\n                buffer = Buffer.from(pem, 'base64');\n            } else {\n                throw Error('Unsupported key format');\n            }\n        } else if (Buffer.isBuffer(data)) {\n            buffer = data;\n        } else {\n            throw Error('Unsupported key format');\n        }\n\n        var reader = new ber.Reader(buffer);\n        reader.readSequence();\n        reader.readInt(0);\n        var header = new ber.Reader(reader.readString(0x30, true));\n\n        if (header.readOID(0x06, true) !== PUBLIC_RSA_OID) {\n            throw Error('Invalid Public key format');\n        }\n\n        var body = new ber.Reader(reader.readString(0x04, true));\n        body.readSequence();\n        body.readString(2, true); // just zero\n        key.setPrivate(\n            body.readString(2, true),  // modulus\n            body.readString(2, true),  // publicExponent\n            body.readString(2, true),  // privateExponent\n            body.readString(2, true),  // prime1\n            body.readString(2, true),  // prime2\n            body.readString(2, true),  // exponent1 -- d mod (p1)\n            body.readString(2, true),  // exponent2 -- d mod (q-1)\n            body.readString(2, true)   // coefficient -- (inverse of q) mod p\n        );\n    },\n\n    publicExport: function (key, options) {\n        options = options || {};\n\n        var n = key.n.toBuffer();\n        var length = n.length + 512; // magic\n\n        var bodyWriter = new ber.Writer({size: length});\n        bodyWriter.writeByte(0);\n        bodyWriter.startSequence();\n        bodyWriter.writeBuffer(n, 2);\n        bodyWriter.writeInt(key.e);\n        bodyWriter.endSequence();\n\n        var writer = new ber.Writer({size: length});\n        writer.startSequence();\n        writer.startSequence();\n        writer.writeOID(PUBLIC_RSA_OID);\n        writer.writeNull();\n        writer.endSequence();\n        writer.writeBuffer(bodyWriter.buffer, 3);\n        writer.endSequence();\n\n        if (options.type === 'der') {\n            return writer.buffer;\n        } else {\n            return PUBLIC_OPENING_BOUNDARY + '\\n' + utils.linebrk(writer.buffer.toString('base64'), 64) + '\\n' + PUBLIC_CLOSING_BOUNDARY;\n        }\n    },\n\n    publicImport: function (key, data, options) {\n        options = options || {};\n        var buffer;\n\n        if (options.type !== 'der') {\n            if (Buffer.isBuffer(data)) {\n                data = data.toString('utf8');\n            }\n\n            if (_.isString(data)) {\n                var pem = utils.trimSurroundingText(data, PUBLIC_OPENING_BOUNDARY, PUBLIC_CLOSING_BOUNDARY)\n                    .replace(/\\s+|\\n\\r|\\n|\\r$/gm, '');\n                buffer = Buffer.from(pem, 'base64');\n            }\n        } else if (Buffer.isBuffer(data)) {\n            buffer = data;\n        } else {\n            throw Error('Unsupported key format');\n        }\n\n        var reader = new ber.Reader(buffer);\n        reader.readSequence();\n        var header = new ber.Reader(reader.readString(0x30, true));\n\n        if (header.readOID(0x06, true) !== PUBLIC_RSA_OID) {\n            throw Error('Invalid Public key format');\n        }\n\n        var body = new ber.Reader(reader.readString(0x03, true));\n        body.readByte();\n        body.readSequence();\n        key.setPublic(\n            body.readString(0x02, true), // modulus\n            body.readString(0x02, true)  // publicExponent\n        );\n    },\n\n    /**\n     * Trying autodetect and import key\n     * @param key\n     * @param data\n     */\n    autoImport: function (key, data) {\n        if (/^[\\S\\s]*-----BEGIN PRIVATE KEY-----\\s*(?=(([A-Za-z0-9+/=]+\\s*)+))\\1-----END PRIVATE KEY-----[\\S\\s]*$/g.test(data)) {\n            module.exports.privateImport(key, data);\n            return true;\n        }\n\n        if (/^[\\S\\s]*-----BEGIN PUBLIC KEY-----\\s*(?=(([A-Za-z0-9+/=]+\\s*)+))\\1-----END PUBLIC KEY-----[\\S\\s]*$/g.test(data)) {\n            module.exports.publicImport(key, data);\n            return true;\n        }\n\n        return false;\n    }\n};\n","/*\r\n * Basic JavaScript BN library - subset useful for RSA encryption.\r\n * \r\n * Copyright (c) 2003-2005  Tom Wu\r\n * All Rights Reserved.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS-IS\" AND WITHOUT WARRANTY OF ANY KIND, \r\n * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY \r\n * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  \r\n *\r\n * IN NO EVENT SHALL TOM WU BE LIABLE FOR ANY SPECIAL, INCIDENTAL,\r\n * INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER\r\n * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF\r\n * THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY, ARISING OUT\r\n * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\r\n *\r\n * In addition, the following condition applies:\r\n *\r\n * All redistributions must retain an intact copy of this copyright notice\r\n * and disclaimer.\r\n */\r\n\r\n/*\r\n * Added Node.js Buffers support\r\n * 2014 rzcoder\r\n */\r\n\r\nvar crypt = require('crypto');\r\nvar _ = require('../utils')._;\r\n\r\n// Bits per digit\r\nvar dbits;\r\n\r\n// JavaScript engine analysis\r\nvar canary = 0xdeadbeefcafe;\r\nvar j_lm = ((canary & 0xffffff) == 0xefcafe);\r\n\r\n// (public) Constructor\r\nfunction BigInteger(a, b) {\r\n    if (a != null) {\r\n        if (\"number\" == typeof a) {\r\n            this.fromNumber(a, b);\r\n        } else if (Buffer.isBuffer(a)) {\r\n            this.fromBuffer(a);\r\n        } else if (b == null && \"string\" != typeof a) {\r\n            this.fromByteArray(a);\r\n        } else {\r\n            this.fromString(a, b);\r\n        }\r\n    }\r\n}\r\n\r\n// return new, unset BigInteger\r\nfunction nbi() {\r\n    return new BigInteger(null);\r\n}\r\n\r\n// am: Compute w_j += (x*this_i), propagate carries,\r\n// c is initial carry, returns final carry.\r\n// c < 3*dvalue, x < 2*dvalue, this_i < dvalue\r\n// We need to select the fastest one that works in this environment.\r\n\r\n// am1: use a single mult and divide to get the high bits,\r\n// max digit bits should be 26 because\r\n// max internal value = 2*dvalue^2-2*dvalue (< 2^53)\r\nfunction am1(i, x, w, j, c, n) {\r\n    while (--n >= 0) {\r\n        var v = x * this[i++] + w[j] + c;\r\n        c = Math.floor(v / 0x4000000);\r\n        w[j++] = v & 0x3ffffff;\r\n    }\r\n    return c;\r\n}\r\n// am2 avoids a big mult-and-extract completely.\r\n// Max digit bits should be <= 30 because we do bitwise ops\r\n// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\r\nfunction am2(i, x, w, j, c, n) {\r\n    var xl = x & 0x7fff, xh = x >> 15;\r\n    while (--n >= 0) {\r\n        var l = this[i] & 0x7fff;\r\n        var h = this[i++] >> 15;\r\n        var m = xh * l + h * xl;\r\n        l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);\r\n        c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);\r\n        w[j++] = l & 0x3fffffff;\r\n    }\r\n    return c;\r\n}\r\n// Alternately, set max digit bits to 28 since some\r\n// browsers slow down when dealing with 32-bit numbers.\r\nfunction am3(i, x, w, j, c, n) {\r\n    var xl = x & 0x3fff, xh = x >> 14;\r\n    while (--n >= 0) {\r\n        var l = this[i] & 0x3fff;\r\n        var h = this[i++] >> 14;\r\n        var m = xh * l + h * xl;\r\n        l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;\r\n        c = (l >> 28) + (m >> 14) + xh * h;\r\n        w[j++] = l & 0xfffffff;\r\n    }\r\n    return c;\r\n}\r\n\r\n// We need to select the fastest one that works in this environment. \r\n//if (j_lm && (navigator.appName == \"Microsoft Internet Explorer\")) {\r\n//\tBigInteger.prototype.am = am2;\r\n//\tdbits = 30;\r\n//} else if (j_lm && (navigator.appName != \"Netscape\")) {\r\n//\tBigInteger.prototype.am = am1;\r\n//\tdbits = 26;\r\n//} else { // Mozilla/Netscape seems to prefer am3\r\n//\tBigInteger.prototype.am = am3;\r\n//\tdbits = 28;\r\n//}\r\n\r\n// For node.js, we pick am3 with max dbits to 28.\r\nBigInteger.prototype.am = am3;\r\ndbits = 28;\r\n\r\nBigInteger.prototype.DB = dbits;\r\nBigInteger.prototype.DM = ((1 << dbits) - 1);\r\nBigInteger.prototype.DV = (1 << dbits);\r\n\r\nvar BI_FP = 52;\r\nBigInteger.prototype.FV = Math.pow(2, BI_FP);\r\nBigInteger.prototype.F1 = BI_FP - dbits;\r\nBigInteger.prototype.F2 = 2 * dbits - BI_FP;\r\n\r\n// Digit conversions\r\nvar BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\r\nvar BI_RC = new Array();\r\nvar rr, vv;\r\nrr = \"0\".charCodeAt(0);\r\nfor (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\r\nrr = \"a\".charCodeAt(0);\r\nfor (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\r\nrr = \"A\".charCodeAt(0);\r\nfor (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\r\n\r\nfunction int2char(n) {\r\n    return BI_RM.charAt(n);\r\n}\r\nfunction intAt(s, i) {\r\n    var c = BI_RC[s.charCodeAt(i)];\r\n    return (c == null) ? -1 : c;\r\n}\r\n\r\n// (protected) copy this to r\r\nfunction bnpCopyTo(r) {\r\n    for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];\r\n    r.t = this.t;\r\n    r.s = this.s;\r\n}\r\n\r\n// (protected) set from integer value x, -DV <= x < DV\r\nfunction bnpFromInt(x) {\r\n    this.t = 1;\r\n    this.s = (x < 0) ? -1 : 0;\r\n    if (x > 0) this[0] = x;\r\n    else if (x < -1) this[0] = x + DV;\r\n    else this.t = 0;\r\n}\r\n\r\n// return bigint initialized to value\r\nfunction nbv(i) {\r\n    var r = nbi();\r\n    r.fromInt(i);\r\n    return r;\r\n}\r\n\r\n// (protected) set from string and radix\r\nfunction bnpFromString(data, radix, unsigned) {\r\n    var k;\r\n    switch (radix) {\r\n        case 2:\r\n            k = 1;\r\n            break;\r\n        case 4:\r\n            k = 2;\r\n            break;\r\n        case 8:\r\n            k = 3;\r\n            break;\r\n        case 16:\r\n            k = 4;\r\n            break;\r\n        case 32:\r\n            k = 5;\r\n            break;\r\n        case 256:\r\n            k = 8;\r\n            break;\r\n        default:\r\n            this.fromRadix(data, radix);\r\n            return;\r\n    }\r\n\r\n    this.t = 0;\r\n    this.s = 0;\r\n\r\n    var i = data.length;\r\n    var mi = false;\r\n    var sh = 0;\r\n\r\n    while (--i >= 0) {\r\n        var x = (k == 8) ? data[i] & 0xff : intAt(data, i);\r\n        if (x < 0) {\r\n            if (data.charAt(i) == \"-\") mi = true;\r\n            continue;\r\n        }\r\n        mi = false;\r\n        if (sh === 0)\r\n            this[this.t++] = x;\r\n        else if (sh + k > this.DB) {\r\n            this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;\r\n            this[this.t++] = (x >> (this.DB - sh));\r\n        }\r\n        else\r\n            this[this.t - 1] |= x << sh;\r\n        sh += k;\r\n        if (sh >= this.DB) sh -= this.DB;\r\n    }\r\n    if ((!unsigned) && k == 8 && (data[0] & 0x80) != 0) {\r\n        this.s = -1;\r\n        if (sh > 0) this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;\r\n    }\r\n    this.clamp();\r\n    if (mi) BigInteger.ZERO.subTo(this, this);\r\n}\r\n\r\nfunction bnpFromByteArray(a, unsigned) {\r\n    this.fromString(a, 256, unsigned)\r\n}\r\n\r\nfunction bnpFromBuffer(a) {\r\n    this.fromString(a, 256, true)\r\n}\r\n\r\n// (protected) clamp off excess high words\r\nfunction bnpClamp() {\r\n    var c = this.s & this.DM;\r\n    while (this.t > 0 && this[this.t - 1] == c) --this.t;\r\n}\r\n\r\n// (public) return string representation in given radix\r\nfunction bnToString(b) {\r\n    if (this.s < 0) return \"-\" + this.negate().toString(b);\r\n    var k;\r\n    if (b == 16) k = 4;\r\n    else if (b == 8) k = 3;\r\n    else if (b == 2) k = 1;\r\n    else if (b == 32) k = 5;\r\n    else if (b == 4) k = 2;\r\n    else return this.toRadix(b);\r\n    var km = (1 << k) - 1, d, m = false, r = \"\", i = this.t;\r\n    var p = this.DB - (i * this.DB) % k;\r\n    if (i-- > 0) {\r\n        if (p < this.DB && (d = this[i] >> p) > 0) {\r\n            m = true;\r\n            r = int2char(d);\r\n        }\r\n        while (i >= 0) {\r\n            if (p < k) {\r\n                d = (this[i] & ((1 << p) - 1)) << (k - p);\r\n                d |= this[--i] >> (p += this.DB - k);\r\n            }\r\n            else {\r\n                d = (this[i] >> (p -= k)) & km;\r\n                if (p <= 0) {\r\n                    p += this.DB;\r\n                    --i;\r\n                }\r\n            }\r\n            if (d > 0) m = true;\r\n            if (m) r += int2char(d);\r\n        }\r\n    }\r\n    return m ? r : \"0\";\r\n}\r\n\r\n// (public) -this\r\nfunction bnNegate() {\r\n    var r = nbi();\r\n    BigInteger.ZERO.subTo(this, r);\r\n    return r;\r\n}\r\n\r\n// (public) |this|\r\nfunction bnAbs() {\r\n    return (this.s < 0) ? this.negate() : this;\r\n}\r\n\r\n// (public) return + if this > a, - if this < a, 0 if equal\r\nfunction bnCompareTo(a) {\r\n    var r = this.s - a.s;\r\n    if (r != 0) return r;\r\n    var i = this.t;\r\n    r = i - a.t;\r\n    if (r != 0) return (this.s < 0) ? -r : r;\r\n    while (--i >= 0) if ((r = this[i] - a[i]) != 0) return r;\r\n    return 0;\r\n}\r\n\r\n// returns bit length of the integer x\r\nfunction nbits(x) {\r\n    var r = 1, t;\r\n    if ((t = x >>> 16) != 0) {\r\n        x = t;\r\n        r += 16;\r\n    }\r\n    if ((t = x >> 8) != 0) {\r\n        x = t;\r\n        r += 8;\r\n    }\r\n    if ((t = x >> 4) != 0) {\r\n        x = t;\r\n        r += 4;\r\n    }\r\n    if ((t = x >> 2) != 0) {\r\n        x = t;\r\n        r += 2;\r\n    }\r\n    if ((t = x >> 1) != 0) {\r\n        x = t;\r\n        r += 1;\r\n    }\r\n    return r;\r\n}\r\n\r\n// (public) return the number of bits in \"this\"\r\nfunction bnBitLength() {\r\n    if (this.t <= 0) return 0;\r\n    return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));\r\n}\r\n\r\n// (protected) r = this << n*DB\r\nfunction bnpDLShiftTo(n, r) {\r\n    var i;\r\n    for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];\r\n    for (i = n - 1; i >= 0; --i) r[i] = 0;\r\n    r.t = this.t + n;\r\n    r.s = this.s;\r\n}\r\n\r\n// (protected) r = this >> n*DB\r\nfunction bnpDRShiftTo(n, r) {\r\n    for (var i = n; i < this.t; ++i) r[i - n] = this[i];\r\n    r.t = Math.max(this.t - n, 0);\r\n    r.s = this.s;\r\n}\r\n\r\n// (protected) r = this << n\r\nfunction bnpLShiftTo(n, r) {\r\n    var bs = n % this.DB;\r\n    var cbs = this.DB - bs;\r\n    var bm = (1 << cbs) - 1;\r\n    var ds = Math.floor(n / this.DB), c = (this.s << bs) & this.DM, i;\r\n    for (i = this.t - 1; i >= 0; --i) {\r\n        r[i + ds + 1] = (this[i] >> cbs) | c;\r\n        c = (this[i] & bm) << bs;\r\n    }\r\n    for (i = ds - 1; i >= 0; --i) r[i] = 0;\r\n    r[ds] = c;\r\n    r.t = this.t + ds + 1;\r\n    r.s = this.s;\r\n    r.clamp();\r\n}\r\n\r\n// (protected) r = this >> n\r\nfunction bnpRShiftTo(n, r) {\r\n    r.s = this.s;\r\n    var ds = Math.floor(n / this.DB);\r\n    if (ds >= this.t) {\r\n        r.t = 0;\r\n        return;\r\n    }\r\n    var bs = n % this.DB;\r\n    var cbs = this.DB - bs;\r\n    var bm = (1 << bs) - 1;\r\n    r[0] = this[ds] >> bs;\r\n    for (var i = ds + 1; i < this.t; ++i) {\r\n        r[i - ds - 1] |= (this[i] & bm) << cbs;\r\n        r[i - ds] = this[i] >> bs;\r\n    }\r\n    if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;\r\n    r.t = this.t - ds;\r\n    r.clamp();\r\n}\r\n\r\n// (protected) r = this - a\r\nfunction bnpSubTo(a, r) {\r\n    var i = 0, c = 0, m = Math.min(a.t, this.t);\r\n    while (i < m) {\r\n        c += this[i] - a[i];\r\n        r[i++] = c & this.DM;\r\n        c >>= this.DB;\r\n    }\r\n    if (a.t < this.t) {\r\n        c -= a.s;\r\n        while (i < this.t) {\r\n            c += this[i];\r\n            r[i++] = c & this.DM;\r\n            c >>= this.DB;\r\n        }\r\n        c += this.s;\r\n    }\r\n    else {\r\n        c += this.s;\r\n        while (i < a.t) {\r\n            c -= a[i];\r\n            r[i++] = c & this.DM;\r\n            c >>= this.DB;\r\n        }\r\n        c -= a.s;\r\n    }\r\n    r.s = (c < 0) ? -1 : 0;\r\n    if (c < -1) r[i++] = this.DV + c;\r\n    else if (c > 0) r[i++] = c;\r\n    r.t = i;\r\n    r.clamp();\r\n}\r\n\r\n// (protected) r = this * a, r != this,a (HAC 14.12)\r\n// \"this\" should be the larger one if appropriate.\r\nfunction bnpMultiplyTo(a, r) {\r\n    var x = this.abs(), y = a.abs();\r\n    var i = x.t;\r\n    r.t = i + y.t;\r\n    while (--i >= 0) r[i] = 0;\r\n    for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);\r\n    r.s = 0;\r\n    r.clamp();\r\n    if (this.s != a.s) BigInteger.ZERO.subTo(r, r);\r\n}\r\n\r\n// (protected) r = this^2, r != this (HAC 14.16)\r\nfunction bnpSquareTo(r) {\r\n    var x = this.abs();\r\n    var i = r.t = 2 * x.t;\r\n    while (--i >= 0) r[i] = 0;\r\n    for (i = 0; i < x.t - 1; ++i) {\r\n        var c = x.am(i, x[i], r, 2 * i, 0, 1);\r\n        if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {\r\n            r[i + x.t] -= x.DV;\r\n            r[i + x.t + 1] = 1;\r\n        }\r\n    }\r\n    if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);\r\n    r.s = 0;\r\n    r.clamp();\r\n}\r\n\r\n// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\r\n// r != q, this != m.  q or r may be null.\r\nfunction bnpDivRemTo(m, q, r) {\r\n    var pm = m.abs();\r\n    if (pm.t <= 0) return;\r\n    var pt = this.abs();\r\n    if (pt.t < pm.t) {\r\n        if (q != null) q.fromInt(0);\r\n        if (r != null) this.copyTo(r);\r\n        return;\r\n    }\r\n    if (r == null) r = nbi();\r\n    var y = nbi(), ts = this.s, ms = m.s;\r\n    var nsh = this.DB - nbits(pm[pm.t - 1]);\t// normalize modulus\r\n    if (nsh > 0) {\r\n        pm.lShiftTo(nsh, y);\r\n        pt.lShiftTo(nsh, r);\r\n    }\r\n    else {\r\n        pm.copyTo(y);\r\n        pt.copyTo(r);\r\n    }\r\n    var ys = y.t;\r\n    var y0 = y[ys - 1];\r\n    if (y0 === 0) return;\r\n    var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);\r\n    var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;\r\n    var i = r.t, j = i - ys, t = (q == null) ? nbi() : q;\r\n    y.dlShiftTo(j, t);\r\n    if (r.compareTo(t) >= 0) {\r\n        r[r.t++] = 1;\r\n        r.subTo(t, r);\r\n    }\r\n    BigInteger.ONE.dlShiftTo(ys, t);\r\n    t.subTo(y, y);\t// \"negative\" y so we can replace sub with am later\r\n    while (y.t < ys) y[y.t++] = 0;\r\n    while (--j >= 0) {\r\n        // Estimate quotient digit\r\n        var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);\r\n        if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {\t// Try it out\r\n            y.dlShiftTo(j, t);\r\n            r.subTo(t, r);\r\n            while (r[i] < --qd) r.subTo(t, r);\r\n        }\r\n    }\r\n    if (q != null) {\r\n        r.drShiftTo(ys, q);\r\n        if (ts != ms) BigInteger.ZERO.subTo(q, q);\r\n    }\r\n    r.t = ys;\r\n    r.clamp();\r\n    if (nsh > 0) r.rShiftTo(nsh, r);\t// Denormalize remainder\r\n    if (ts < 0) BigInteger.ZERO.subTo(r, r);\r\n}\r\n\r\n// (public) this mod a\r\nfunction bnMod(a) {\r\n    var r = nbi();\r\n    this.abs().divRemTo(a, null, r);\r\n    if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);\r\n    return r;\r\n}\r\n\r\n// Modular reduction using \"classic\" algorithm\r\nfunction Classic(m) {\r\n    this.m = m;\r\n}\r\nfunction cConvert(x) {\r\n    if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\r\n    else return x;\r\n}\r\nfunction cRevert(x) {\r\n    return x;\r\n}\r\nfunction cReduce(x) {\r\n    x.divRemTo(this.m, null, x);\r\n}\r\nfunction cMulTo(x, y, r) {\r\n    x.multiplyTo(y, r);\r\n    this.reduce(r);\r\n}\r\nfunction cSqrTo(x, r) {\r\n    x.squareTo(r);\r\n    this.reduce(r);\r\n}\r\n\r\nClassic.prototype.convert = cConvert;\r\nClassic.prototype.revert = cRevert;\r\nClassic.prototype.reduce = cReduce;\r\nClassic.prototype.mulTo = cMulTo;\r\nClassic.prototype.sqrTo = cSqrTo;\r\n\r\n// (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\r\n// justification:\r\n//         xy == 1 (mod m)\r\n//         xy =  1+km\r\n//   xy(2-xy) = (1+km)(1-km)\r\n// x[y(2-xy)] = 1-k^2m^2\r\n// x[y(2-xy)] == 1 (mod m^2)\r\n// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\r\n// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\r\n// JS multiply \"overflows\" differently from C/C++, so care is needed here.\r\nfunction bnpInvDigit() {\r\n    if (this.t < 1) return 0;\r\n    var x = this[0];\r\n    if ((x & 1) === 0) return 0;\r\n    var y = x & 3;\t\t// y == 1/x mod 2^2\r\n    y = (y * (2 - (x & 0xf) * y)) & 0xf;\t// y == 1/x mod 2^4\r\n    y = (y * (2 - (x & 0xff) * y)) & 0xff;\t// y == 1/x mod 2^8\r\n    y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff;\t// y == 1/x mod 2^16\r\n    // last step - calculate inverse mod DV directly;\r\n    // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\r\n    y = (y * (2 - x * y % this.DV)) % this.DV;\t\t// y == 1/x mod 2^dbits\r\n    // we really want the negative inverse, and -DV < y < DV\r\n    return (y > 0) ? this.DV - y : -y;\r\n}\r\n\r\n// Montgomery reduction\r\nfunction Montgomery(m) {\r\n    this.m = m;\r\n    this.mp = m.invDigit();\r\n    this.mpl = this.mp & 0x7fff;\r\n    this.mph = this.mp >> 15;\r\n    this.um = (1 << (m.DB - 15)) - 1;\r\n    this.mt2 = 2 * m.t;\r\n}\r\n\r\n// xR mod m\r\nfunction montConvert(x) {\r\n    var r = nbi();\r\n    x.abs().dlShiftTo(this.m.t, r);\r\n    r.divRemTo(this.m, null, r);\r\n    if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);\r\n    return r;\r\n}\r\n\r\n// x/R mod m\r\nfunction montRevert(x) {\r\n    var r = nbi();\r\n    x.copyTo(r);\r\n    this.reduce(r);\r\n    return r;\r\n}\r\n\r\n// x = x/R mod m (HAC 14.32)\r\nfunction montReduce(x) {\r\n    while (x.t <= this.mt2)\t// pad x so am has enough room later\r\n        x[x.t++] = 0;\r\n    for (var i = 0; i < this.m.t; ++i) {\r\n        // faster way of calculating u0 = x[i]*mp mod DV\r\n        var j = x[i] & 0x7fff;\r\n        var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;\r\n        // use am to combine the multiply-shift-add into one call\r\n        j = i + this.m.t;\r\n        x[j] += this.m.am(0, u0, x, i, 0, this.m.t);\r\n        // propagate carry\r\n        while (x[j] >= x.DV) {\r\n            x[j] -= x.DV;\r\n            x[++j]++;\r\n        }\r\n    }\r\n    x.clamp();\r\n    x.drShiftTo(this.m.t, x);\r\n    if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\r\n}\r\n\r\n// r = \"x^2/R mod m\"; x != r\r\nfunction montSqrTo(x, r) {\r\n    x.squareTo(r);\r\n    this.reduce(r);\r\n}\r\n\r\n// r = \"xy/R mod m\"; x,y != r\r\nfunction montMulTo(x, y, r) {\r\n    x.multiplyTo(y, r);\r\n    this.reduce(r);\r\n}\r\n\r\nMontgomery.prototype.convert = montConvert;\r\nMontgomery.prototype.revert = montRevert;\r\nMontgomery.prototype.reduce = montReduce;\r\nMontgomery.prototype.mulTo = montMulTo;\r\nMontgomery.prototype.sqrTo = montSqrTo;\r\n\r\n// (protected) true iff this is even\r\nfunction bnpIsEven() {\r\n    return ((this.t > 0) ? (this[0] & 1) : this.s) === 0;\r\n}\r\n\r\n// (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\r\nfunction bnpExp(e, z) {\r\n    if (e > 0xffffffff || e < 1) return BigInteger.ONE;\r\n    var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e) - 1;\r\n    g.copyTo(r);\r\n    while (--i >= 0) {\r\n        z.sqrTo(r, r2);\r\n        if ((e & (1 << i)) > 0) z.mulTo(r2, g, r);\r\n        else {\r\n            var t = r;\r\n            r = r2;\r\n            r2 = t;\r\n        }\r\n    }\r\n    return z.revert(r);\r\n}\r\n\r\n// (public) this^e % m, 0 <= e < 2^32\r\nfunction bnModPowInt(e, m) {\r\n    var z;\r\n    if (e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);\r\n    return this.exp(e, z);\r\n}\r\n\r\n// Copyright (c) 2005-2009  Tom Wu\r\n// All Rights Reserved.\r\n// See \"LICENSE\" for details.\r\n\r\n// Extended JavaScript BN functions, required for RSA private ops.\r\n\r\n// Version 1.1: new BigInteger(\"0\", 10) returns \"proper\" zero\r\n// Version 1.2: square() API, isProbablePrime fix\r\n\r\n//(public)\r\nfunction bnClone() {\r\n    var r = nbi();\r\n    this.copyTo(r);\r\n    return r;\r\n}\r\n\r\n//(public) return value as integer\r\nfunction bnIntValue() {\r\n    if (this.s < 0) {\r\n        if (this.t == 1) return this[0] - this.DV;\r\n        else if (this.t === 0) return -1;\r\n    }\r\n    else if (this.t == 1) return this[0];\r\n    else if (this.t === 0) return 0;\r\n// assumes 16 < DB < 32\r\n    return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];\r\n}\r\n\r\n//(public) return value as byte\r\nfunction bnByteValue() {\r\n    return (this.t == 0) ? this.s : (this[0] << 24) >> 24;\r\n}\r\n\r\n//(public) return value as short (assumes DB>=16)\r\nfunction bnShortValue() {\r\n    return (this.t == 0) ? this.s : (this[0] << 16) >> 16;\r\n}\r\n\r\n//(protected) return x s.t. r^x < DV\r\nfunction bnpChunkSize(r) {\r\n    return Math.floor(Math.LN2 * this.DB / Math.log(r));\r\n}\r\n\r\n//(public) 0 if this === 0, 1 if this > 0\r\nfunction bnSigNum() {\r\n    if (this.s < 0) return -1;\r\n    else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\r\n    else return 1;\r\n}\r\n\r\n//(protected) convert to radix string\r\nfunction bnpToRadix(b) {\r\n    if (b == null) b = 10;\r\n    if (this.signum() === 0 || b < 2 || b > 36) return \"0\";\r\n    var cs = this.chunkSize(b);\r\n    var a = Math.pow(b, cs);\r\n    var d = nbv(a), y = nbi(), z = nbi(), r = \"\";\r\n    this.divRemTo(d, y, z);\r\n    while (y.signum() > 0) {\r\n        r = (a + z.intValue()).toString(b).substr(1) + r;\r\n        y.divRemTo(d, y, z);\r\n    }\r\n    return z.intValue().toString(b) + r;\r\n}\r\n\r\n//(protected) convert from radix string\r\nfunction bnpFromRadix(s, b) {\r\n    this.fromInt(0);\r\n    if (b == null) b = 10;\r\n    var cs = this.chunkSize(b);\r\n    var d = Math.pow(b, cs), mi = false, j = 0, w = 0;\r\n    for (var i = 0; i < s.length; ++i) {\r\n        var x = intAt(s, i);\r\n        if (x < 0) {\r\n            if (s.charAt(i) == \"-\" && this.signum() === 0) mi = true;\r\n            continue;\r\n        }\r\n        w = b * w + x;\r\n        if (++j >= cs) {\r\n            this.dMultiply(d);\r\n            this.dAddOffset(w, 0);\r\n            j = 0;\r\n            w = 0;\r\n        }\r\n    }\r\n    if (j > 0) {\r\n        this.dMultiply(Math.pow(b, j));\r\n        this.dAddOffset(w, 0);\r\n    }\r\n    if (mi) BigInteger.ZERO.subTo(this, this);\r\n}\r\n\r\n//(protected) alternate constructor\r\nfunction bnpFromNumber(a, b) {\r\n    if (\"number\" == typeof b) {\r\n        // new BigInteger(int,int,RNG)\r\n        if (a < 2) this.fromInt(1);\r\n        else {\r\n            this.fromNumber(a);\r\n            if (!this.testBit(a - 1))\t// force MSB set\r\n                this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);\r\n            if (this.isEven()) this.dAddOffset(1, 0); // force odd\r\n            while (!this.isProbablePrime(b)) {\r\n                this.dAddOffset(2, 0);\r\n                if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);\r\n            }\r\n        }\r\n    } else {\r\n        // new BigInteger(int,RNG)\r\n        var x = crypt.randomBytes((a >> 3) + 1)\r\n        var t = a & 7;\r\n\r\n        if (t > 0)\r\n            x[0] &= ((1 << t) - 1);\r\n        else\r\n            x[0] = 0;\r\n\r\n        this.fromByteArray(x);\r\n    }\r\n}\r\n\r\n//(public) convert to bigendian byte array\r\nfunction bnToByteArray() {\r\n    var i = this.t, r = new Array();\r\n    r[0] = this.s;\r\n    var p = this.DB - (i * this.DB) % 8, d, k = 0;\r\n    if (i-- > 0) {\r\n        if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)\r\n            r[k++] = d | (this.s << (this.DB - p));\r\n        while (i >= 0) {\r\n            if (p < 8) {\r\n                d = (this[i] & ((1 << p) - 1)) << (8 - p);\r\n                d |= this[--i] >> (p += this.DB - 8);\r\n            }\r\n            else {\r\n                d = (this[i] >> (p -= 8)) & 0xff;\r\n                if (p <= 0) {\r\n                    p += this.DB;\r\n                    --i;\r\n                }\r\n            }\r\n            if ((d & 0x80) != 0) d |= -256;\r\n            if (k === 0 && (this.s & 0x80) != (d & 0x80)) ++k;\r\n            if (k > 0 || d != this.s) r[k++] = d;\r\n        }\r\n    }\r\n    return r;\r\n}\r\n\r\n/**\r\n * return Buffer object\r\n * @param trim {boolean} slice buffer if first element == 0\r\n * @returns {Buffer}\r\n */\r\nfunction bnToBuffer(trimOrSize) {\r\n    var res = Buffer.from(this.toByteArray());\r\n    if (trimOrSize === true && res[0] === 0) {\r\n        res = res.slice(1);\r\n    } else if (_.isNumber(trimOrSize)) {\r\n        if (res.length > trimOrSize) {\r\n            for (var i = 0; i < res.length - trimOrSize; i++) {\r\n                if (res[i] !== 0) {\r\n                    return null;\r\n                }\r\n            }\r\n            return res.slice(res.length - trimOrSize);\r\n        } else if (res.length < trimOrSize) {\r\n            var padded = Buffer.alloc(trimOrSize);\r\n            padded.fill(0, 0, trimOrSize - res.length);\r\n            res.copy(padded, trimOrSize - res.length);\r\n            return padded;\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\nfunction bnEquals(a) {\r\n    return (this.compareTo(a) == 0);\r\n}\r\nfunction bnMin(a) {\r\n    return (this.compareTo(a) < 0) ? this : a;\r\n}\r\nfunction bnMax(a) {\r\n    return (this.compareTo(a) > 0) ? this : a;\r\n}\r\n\r\n//(protected) r = this op a (bitwise)\r\nfunction bnpBitwiseTo(a, op, r) {\r\n    var i, f, m = Math.min(a.t, this.t);\r\n    for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);\r\n    if (a.t < this.t) {\r\n        f = a.s & this.DM;\r\n        for (i = m; i < this.t; ++i) r[i] = op(this[i], f);\r\n        r.t = this.t;\r\n    }\r\n    else {\r\n        f = this.s & this.DM;\r\n        for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);\r\n        r.t = a.t;\r\n    }\r\n    r.s = op(this.s, a.s);\r\n    r.clamp();\r\n}\r\n\r\n//(public) this & a\r\nfunction op_and(x, y) {\r\n    return x & y;\r\n}\r\nfunction bnAnd(a) {\r\n    var r = nbi();\r\n    this.bitwiseTo(a, op_and, r);\r\n    return r;\r\n}\r\n\r\n//(public) this | a\r\nfunction op_or(x, y) {\r\n    return x | y;\r\n}\r\nfunction bnOr(a) {\r\n    var r = nbi();\r\n    this.bitwiseTo(a, op_or, r);\r\n    return r;\r\n}\r\n\r\n//(public) this ^ a\r\nfunction op_xor(x, y) {\r\n    return x ^ y;\r\n}\r\nfunction bnXor(a) {\r\n    var r = nbi();\r\n    this.bitwiseTo(a, op_xor, r);\r\n    return r;\r\n}\r\n\r\n//(public) this & ~a\r\nfunction op_andnot(x, y) {\r\n    return x & ~y;\r\n}\r\nfunction bnAndNot(a) {\r\n    var r = nbi();\r\n    this.bitwiseTo(a, op_andnot, r);\r\n    return r;\r\n}\r\n\r\n//(public) ~this\r\nfunction bnNot() {\r\n    var r = nbi();\r\n    for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];\r\n    r.t = this.t;\r\n    r.s = ~this.s;\r\n    return r;\r\n}\r\n\r\n//(public) this << n\r\nfunction bnShiftLeft(n) {\r\n    var r = nbi();\r\n    if (n < 0) this.rShiftTo(-n, r); else this.lShiftTo(n, r);\r\n    return r;\r\n}\r\n\r\n//(public) this >> n\r\nfunction bnShiftRight(n) {\r\n    var r = nbi();\r\n    if (n < 0) this.lShiftTo(-n, r); else this.rShiftTo(n, r);\r\n    return r;\r\n}\r\n\r\n//return index of lowest 1-bit in x, x < 2^31\r\nfunction lbit(x) {\r\n    if (x === 0) return -1;\r\n    var r = 0;\r\n    if ((x & 0xffff) === 0) {\r\n        x >>= 16;\r\n        r += 16;\r\n    }\r\n    if ((x & 0xff) === 0) {\r\n        x >>= 8;\r\n        r += 8;\r\n    }\r\n    if ((x & 0xf) === 0) {\r\n        x >>= 4;\r\n        r += 4;\r\n    }\r\n    if ((x & 3) === 0) {\r\n        x >>= 2;\r\n        r += 2;\r\n    }\r\n    if ((x & 1) === 0) ++r;\r\n    return r;\r\n}\r\n\r\n//(public) returns index of lowest 1-bit (or -1 if none)\r\nfunction bnGetLowestSetBit() {\r\n    for (var i = 0; i < this.t; ++i)\r\n        if (this[i] != 0) return i * this.DB + lbit(this[i]);\r\n    if (this.s < 0) return this.t * this.DB;\r\n    return -1;\r\n}\r\n\r\n//return number of 1 bits in x\r\nfunction cbit(x) {\r\n    var r = 0;\r\n    while (x != 0) {\r\n        x &= x - 1;\r\n        ++r;\r\n    }\r\n    return r;\r\n}\r\n\r\n//(public) return number of set bits\r\nfunction bnBitCount() {\r\n    var r = 0, x = this.s & this.DM;\r\n    for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);\r\n    return r;\r\n}\r\n\r\n//(public) true iff nth bit is set\r\nfunction bnTestBit(n) {\r\n    var j = Math.floor(n / this.DB);\r\n    if (j >= this.t) return (this.s != 0);\r\n    return ((this[j] & (1 << (n % this.DB))) != 0);\r\n}\r\n\r\n//(protected) this op (1<<n)\r\nfunction bnpChangeBit(n, op) {\r\n    var r = BigInteger.ONE.shiftLeft(n);\r\n    this.bitwiseTo(r, op, r);\r\n    return r;\r\n}\r\n\r\n//(public) this | (1<<n)\r\nfunction bnSetBit(n) {\r\n    return this.changeBit(n, op_or);\r\n}\r\n\r\n//(public) this & ~(1<<n)\r\nfunction bnClearBit(n) {\r\n    return this.changeBit(n, op_andnot);\r\n}\r\n\r\n//(public) this ^ (1<<n)\r\nfunction bnFlipBit(n) {\r\n    return this.changeBit(n, op_xor);\r\n}\r\n\r\n//(protected) r = this + a\r\nfunction bnpAddTo(a, r) {\r\n    var i = 0, c = 0, m = Math.min(a.t, this.t);\r\n    while (i < m) {\r\n        c += this[i] + a[i];\r\n        r[i++] = c & this.DM;\r\n        c >>= this.DB;\r\n    }\r\n    if (a.t < this.t) {\r\n        c += a.s;\r\n        while (i < this.t) {\r\n            c += this[i];\r\n            r[i++] = c & this.DM;\r\n            c >>= this.DB;\r\n        }\r\n        c += this.s;\r\n    }\r\n    else {\r\n        c += this.s;\r\n        while (i < a.t) {\r\n            c += a[i];\r\n            r[i++] = c & this.DM;\r\n            c >>= this.DB;\r\n        }\r\n        c += a.s;\r\n    }\r\n    r.s = (c < 0) ? -1 : 0;\r\n    if (c > 0) r[i++] = c;\r\n    else if (c < -1) r[i++] = this.DV + c;\r\n    r.t = i;\r\n    r.clamp();\r\n}\r\n\r\n//(public) this + a\r\nfunction bnAdd(a) {\r\n    var r = nbi();\r\n    this.addTo(a, r);\r\n    return r;\r\n}\r\n\r\n//(public) this - a\r\nfunction bnSubtract(a) {\r\n    var r = nbi();\r\n    this.subTo(a, r);\r\n    return r;\r\n}\r\n\r\n//(public) this * a\r\nfunction bnMultiply(a) {\r\n    var r = nbi();\r\n    this.multiplyTo(a, r);\r\n    return r;\r\n}\r\n\r\n// (public) this^2\r\nfunction bnSquare() {\r\n    var r = nbi();\r\n    this.squareTo(r);\r\n    return r;\r\n}\r\n\r\n//(public) this / a\r\nfunction bnDivide(a) {\r\n    var r = nbi();\r\n    this.divRemTo(a, r, null);\r\n    return r;\r\n}\r\n\r\n//(public) this % a\r\nfunction bnRemainder(a) {\r\n    var r = nbi();\r\n    this.divRemTo(a, null, r);\r\n    return r;\r\n}\r\n\r\n//(public) [this/a,this%a]\r\nfunction bnDivideAndRemainder(a) {\r\n    var q = nbi(), r = nbi();\r\n    this.divRemTo(a, q, r);\r\n    return new Array(q, r);\r\n}\r\n\r\n//(protected) this *= n, this >= 0, 1 < n < DV\r\nfunction bnpDMultiply(n) {\r\n    this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);\r\n    ++this.t;\r\n    this.clamp();\r\n}\r\n\r\n//(protected) this += n << w words, this >= 0\r\nfunction bnpDAddOffset(n, w) {\r\n    if (n === 0) return;\r\n    while (this.t <= w) this[this.t++] = 0;\r\n    this[w] += n;\r\n    while (this[w] >= this.DV) {\r\n        this[w] -= this.DV;\r\n        if (++w >= this.t) this[this.t++] = 0;\r\n        ++this[w];\r\n    }\r\n}\r\n\r\n//A \"null\" reducer\r\nfunction NullExp() {\r\n}\r\nfunction nNop(x) {\r\n    return x;\r\n}\r\nfunction nMulTo(x, y, r) {\r\n    x.multiplyTo(y, r);\r\n}\r\nfunction nSqrTo(x, r) {\r\n    x.squareTo(r);\r\n}\r\n\r\nNullExp.prototype.convert = nNop;\r\nNullExp.prototype.revert = nNop;\r\nNullExp.prototype.mulTo = nMulTo;\r\nNullExp.prototype.sqrTo = nSqrTo;\r\n\r\n//(public) this^e\r\nfunction bnPow(e) {\r\n    return this.exp(e, new NullExp());\r\n}\r\n\r\n//(protected) r = lower n words of \"this * a\", a.t <= n\r\n//\"this\" should be the larger one if appropriate.\r\nfunction bnpMultiplyLowerTo(a, n, r) {\r\n    var i = Math.min(this.t + a.t, n);\r\n    r.s = 0; // assumes a,this >= 0\r\n    r.t = i;\r\n    while (i > 0) r[--i] = 0;\r\n    var j;\r\n    for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);\r\n    for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);\r\n    r.clamp();\r\n}\r\n\r\n//(protected) r = \"this * a\" without lower n words, n > 0\r\n//\"this\" should be the larger one if appropriate.\r\nfunction bnpMultiplyUpperTo(a, n, r) {\r\n    --n;\r\n    var i = r.t = this.t + a.t - n;\r\n    r.s = 0; // assumes a,this >= 0\r\n    while (--i >= 0) r[i] = 0;\r\n    for (i = Math.max(n - this.t, 0); i < a.t; ++i)\r\n        r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);\r\n    r.clamp();\r\n    r.drShiftTo(1, r);\r\n}\r\n\r\n//Barrett modular reduction\r\nfunction Barrett(m) {\r\n// setup Barrett\r\n    this.r2 = nbi();\r\n    this.q3 = nbi();\r\n    BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);\r\n    this.mu = this.r2.divide(m);\r\n    this.m = m;\r\n}\r\n\r\nfunction barrettConvert(x) {\r\n    if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);\r\n    else if (x.compareTo(this.m) < 0) return x;\r\n    else {\r\n        var r = nbi();\r\n        x.copyTo(r);\r\n        this.reduce(r);\r\n        return r;\r\n    }\r\n}\r\n\r\nfunction barrettRevert(x) {\r\n    return x;\r\n}\r\n\r\n//x = x mod m (HAC 14.42)\r\nfunction barrettReduce(x) {\r\n    x.drShiftTo(this.m.t - 1, this.r2);\r\n    if (x.t > this.m.t + 1) {\r\n        x.t = this.m.t + 1;\r\n        x.clamp();\r\n    }\r\n    this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);\r\n    this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);\r\n    while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);\r\n    x.subTo(this.r2, x);\r\n    while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\r\n}\r\n\r\n//r = x^2 mod m; x != r\r\nfunction barrettSqrTo(x, r) {\r\n    x.squareTo(r);\r\n    this.reduce(r);\r\n}\r\n\r\n//r = x*y mod m; x,y != r\r\nfunction barrettMulTo(x, y, r) {\r\n    x.multiplyTo(y, r);\r\n    this.reduce(r);\r\n}\r\n\r\nBarrett.prototype.convert = barrettConvert;\r\nBarrett.prototype.revert = barrettRevert;\r\nBarrett.prototype.reduce = barrettReduce;\r\nBarrett.prototype.mulTo = barrettMulTo;\r\nBarrett.prototype.sqrTo = barrettSqrTo;\r\n\r\n//(public) this^e % m (HAC 14.85)\r\nfunction bnModPow(e, m) {\r\n    var i = e.bitLength(), k, r = nbv(1), z;\r\n    if (i <= 0) return r;\r\n    else if (i < 18) k = 1;\r\n    else if (i < 48) k = 3;\r\n    else if (i < 144) k = 4;\r\n    else if (i < 768) k = 5;\r\n    else k = 6;\r\n    if (i < 8)\r\n        z = new Classic(m);\r\n    else if (m.isEven())\r\n        z = new Barrett(m);\r\n    else\r\n        z = new Montgomery(m);\r\n\r\n// precomputation\r\n    var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;\r\n    g[1] = z.convert(this);\r\n    if (k > 1) {\r\n        var g2 = nbi();\r\n        z.sqrTo(g[1], g2);\r\n        while (n <= km) {\r\n            g[n] = nbi();\r\n            z.mulTo(g2, g[n - 2], g[n]);\r\n            n += 2;\r\n        }\r\n    }\r\n\r\n    var j = e.t - 1, w, is1 = true, r2 = nbi(), t;\r\n    i = nbits(e[j]) - 1;\r\n    while (j >= 0) {\r\n        if (i >= k1) w = (e[j] >> (i - k1)) & km;\r\n        else {\r\n            w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);\r\n            if (j > 0) w |= e[j - 1] >> (this.DB + i - k1);\r\n        }\r\n\r\n        n = k;\r\n        while ((w & 1) === 0) {\r\n            w >>= 1;\r\n            --n;\r\n        }\r\n        if ((i -= n) < 0) {\r\n            i += this.DB;\r\n            --j;\r\n        }\r\n        if (is1) {\t// ret == 1, don't bother squaring or multiplying it\r\n            g[w].copyTo(r);\r\n            is1 = false;\r\n        }\r\n        else {\r\n            while (n > 1) {\r\n                z.sqrTo(r, r2);\r\n                z.sqrTo(r2, r);\r\n                n -= 2;\r\n            }\r\n            if (n > 0) z.sqrTo(r, r2); else {\r\n                t = r;\r\n                r = r2;\r\n                r2 = t;\r\n            }\r\n            z.mulTo(r2, g[w], r);\r\n        }\r\n\r\n        while (j >= 0 && (e[j] & (1 << i)) === 0) {\r\n            z.sqrTo(r, r2);\r\n            t = r;\r\n            r = r2;\r\n            r2 = t;\r\n            if (--i < 0) {\r\n                i = this.DB - 1;\r\n                --j;\r\n            }\r\n        }\r\n    }\r\n    return z.revert(r);\r\n}\r\n\r\n//(public) gcd(this,a) (HAC 14.54)\r\nfunction bnGCD(a) {\r\n    var x = (this.s < 0) ? this.negate() : this.clone();\r\n    var y = (a.s < 0) ? a.negate() : a.clone();\r\n    if (x.compareTo(y) < 0) {\r\n        var t = x;\r\n        x = y;\r\n        y = t;\r\n    }\r\n    var i = x.getLowestSetBit(), g = y.getLowestSetBit();\r\n    if (g < 0) return x;\r\n    if (i < g) g = i;\r\n    if (g > 0) {\r\n        x.rShiftTo(g, x);\r\n        y.rShiftTo(g, y);\r\n    }\r\n    while (x.signum() > 0) {\r\n        if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);\r\n        if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);\r\n        if (x.compareTo(y) >= 0) {\r\n            x.subTo(y, x);\r\n            x.rShiftTo(1, x);\r\n        }\r\n        else {\r\n            y.subTo(x, y);\r\n            y.rShiftTo(1, y);\r\n        }\r\n    }\r\n    if (g > 0) y.lShiftTo(g, y);\r\n    return y;\r\n}\r\n\r\n//(protected) this % n, n < 2^26\r\nfunction bnpModInt(n) {\r\n    if (n <= 0) return 0;\r\n    var d = this.DV % n, r = (this.s < 0) ? n - 1 : 0;\r\n    if (this.t > 0)\r\n        if (d === 0) r = this[0] % n;\r\n        else for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;\r\n    return r;\r\n}\r\n\r\n//(public) 1/this % m (HAC 14.61)\r\nfunction bnModInverse(m) {\r\n    var ac = m.isEven();\r\n    if ((this.isEven() && ac) || m.signum() === 0) return BigInteger.ZERO;\r\n    var u = m.clone(), v = this.clone();\r\n    var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);\r\n    while (u.signum() != 0) {\r\n        while (u.isEven()) {\r\n            u.rShiftTo(1, u);\r\n            if (ac) {\r\n                if (!a.isEven() || !b.isEven()) {\r\n                    a.addTo(this, a);\r\n                    b.subTo(m, b);\r\n                }\r\n                a.rShiftTo(1, a);\r\n            }\r\n            else if (!b.isEven()) b.subTo(m, b);\r\n            b.rShiftTo(1, b);\r\n        }\r\n        while (v.isEven()) {\r\n            v.rShiftTo(1, v);\r\n            if (ac) {\r\n                if (!c.isEven() || !d.isEven()) {\r\n                    c.addTo(this, c);\r\n                    d.subTo(m, d);\r\n                }\r\n                c.rShiftTo(1, c);\r\n            }\r\n            else if (!d.isEven()) d.subTo(m, d);\r\n            d.rShiftTo(1, d);\r\n        }\r\n        if (u.compareTo(v) >= 0) {\r\n            u.subTo(v, u);\r\n            if (ac) a.subTo(c, a);\r\n            b.subTo(d, b);\r\n        }\r\n        else {\r\n            v.subTo(u, v);\r\n            if (ac) c.subTo(a, c);\r\n            d.subTo(b, d);\r\n        }\r\n    }\r\n    if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\r\n    if (d.compareTo(m) >= 0) return d.subtract(m);\r\n    if (d.signum() < 0) d.addTo(m, d); else return d;\r\n    if (d.signum() < 0) return d.add(m); else return d;\r\n}\r\n\r\nvar lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];\r\nvar lplim = (1 << 26) / lowprimes[lowprimes.length - 1];\r\n\r\n//(public) test primality with certainty >= 1-.5^t\r\nfunction bnIsProbablePrime(t) {\r\n    var i, x = this.abs();\r\n    if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {\r\n        for (i = 0; i < lowprimes.length; ++i)\r\n            if (x[0] == lowprimes[i]) return true;\r\n        return false;\r\n    }\r\n    if (x.isEven()) return false;\r\n    i = 1;\r\n    while (i < lowprimes.length) {\r\n        var m = lowprimes[i], j = i + 1;\r\n        while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];\r\n        m = x.modInt(m);\r\n        while (i < j) if (m % lowprimes[i++] === 0) return false;\r\n    }\r\n    return x.millerRabin(t);\r\n}\r\n\r\n//(protected) true if probably prime (HAC 4.24, Miller-Rabin)\r\nfunction bnpMillerRabin(t) {\r\n    var n1 = this.subtract(BigInteger.ONE);\r\n    var k = n1.getLowestSetBit();\r\n    if (k <= 0) return false;\r\n    var r = n1.shiftRight(k);\r\n    t = (t + 1) >> 1;\r\n    if (t > lowprimes.length) t = lowprimes.length;\r\n    var a = nbi();\r\n    for (var i = 0; i < t; ++i) {\r\n        //Pick bases at random, instead of starting at 2\r\n        a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);\r\n        var y = a.modPow(r, this);\r\n        if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {\r\n            var j = 1;\r\n            while (j++ < k && y.compareTo(n1) != 0) {\r\n                y = y.modPowInt(2, this);\r\n                if (y.compareTo(BigInteger.ONE) === 0) return false;\r\n            }\r\n            if (y.compareTo(n1) != 0) return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n// protected\r\nBigInteger.prototype.copyTo = bnpCopyTo;\r\nBigInteger.prototype.fromInt = bnpFromInt;\r\nBigInteger.prototype.fromString = bnpFromString;\r\nBigInteger.prototype.fromByteArray = bnpFromByteArray;\r\nBigInteger.prototype.fromBuffer = bnpFromBuffer;\r\nBigInteger.prototype.clamp = bnpClamp;\r\nBigInteger.prototype.dlShiftTo = bnpDLShiftTo;\r\nBigInteger.prototype.drShiftTo = bnpDRShiftTo;\r\nBigInteger.prototype.lShiftTo = bnpLShiftTo;\r\nBigInteger.prototype.rShiftTo = bnpRShiftTo;\r\nBigInteger.prototype.subTo = bnpSubTo;\r\nBigInteger.prototype.multiplyTo = bnpMultiplyTo;\r\nBigInteger.prototype.squareTo = bnpSquareTo;\r\nBigInteger.prototype.divRemTo = bnpDivRemTo;\r\nBigInteger.prototype.invDigit = bnpInvDigit;\r\nBigInteger.prototype.isEven = bnpIsEven;\r\nBigInteger.prototype.exp = bnpExp;\r\n\r\nBigInteger.prototype.chunkSize = bnpChunkSize;\r\nBigInteger.prototype.toRadix = bnpToRadix;\r\nBigInteger.prototype.fromRadix = bnpFromRadix;\r\nBigInteger.prototype.fromNumber = bnpFromNumber;\r\nBigInteger.prototype.bitwiseTo = bnpBitwiseTo;\r\nBigInteger.prototype.changeBit = bnpChangeBit;\r\nBigInteger.prototype.addTo = bnpAddTo;\r\nBigInteger.prototype.dMultiply = bnpDMultiply;\r\nBigInteger.prototype.dAddOffset = bnpDAddOffset;\r\nBigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\r\nBigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\r\nBigInteger.prototype.modInt = bnpModInt;\r\nBigInteger.prototype.millerRabin = bnpMillerRabin;\r\n\r\n\r\n// public\r\nBigInteger.prototype.toString = bnToString;\r\nBigInteger.prototype.negate = bnNegate;\r\nBigInteger.prototype.abs = bnAbs;\r\nBigInteger.prototype.compareTo = bnCompareTo;\r\nBigInteger.prototype.bitLength = bnBitLength;\r\nBigInteger.prototype.mod = bnMod;\r\nBigInteger.prototype.modPowInt = bnModPowInt;\r\n\r\nBigInteger.prototype.clone = bnClone;\r\nBigInteger.prototype.intValue = bnIntValue;\r\nBigInteger.prototype.byteValue = bnByteValue;\r\nBigInteger.prototype.shortValue = bnShortValue;\r\nBigInteger.prototype.signum = bnSigNum;\r\nBigInteger.prototype.toByteArray = bnToByteArray;\r\nBigInteger.prototype.toBuffer = bnToBuffer;\r\nBigInteger.prototype.equals = bnEquals;\r\nBigInteger.prototype.min = bnMin;\r\nBigInteger.prototype.max = bnMax;\r\nBigInteger.prototype.and = bnAnd;\r\nBigInteger.prototype.or = bnOr;\r\nBigInteger.prototype.xor = bnXor;\r\nBigInteger.prototype.andNot = bnAndNot;\r\nBigInteger.prototype.not = bnNot;\r\nBigInteger.prototype.shiftLeft = bnShiftLeft;\r\nBigInteger.prototype.shiftRight = bnShiftRight;\r\nBigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\r\nBigInteger.prototype.bitCount = bnBitCount;\r\nBigInteger.prototype.testBit = bnTestBit;\r\nBigInteger.prototype.setBit = bnSetBit;\r\nBigInteger.prototype.clearBit = bnClearBit;\r\nBigInteger.prototype.flipBit = bnFlipBit;\r\nBigInteger.prototype.add = bnAdd;\r\nBigInteger.prototype.subtract = bnSubtract;\r\nBigInteger.prototype.multiply = bnMultiply;\r\nBigInteger.prototype.divide = bnDivide;\r\nBigInteger.prototype.remainder = bnRemainder;\r\nBigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\r\nBigInteger.prototype.modPow = bnModPow;\r\nBigInteger.prototype.modInverse = bnModInverse;\r\nBigInteger.prototype.pow = bnPow;\r\nBigInteger.prototype.gcd = bnGCD;\r\nBigInteger.prototype.isProbablePrime = bnIsProbablePrime;\r\nBigInteger.int2char = int2char;\r\n\r\n// \"constants\"\r\nBigInteger.ZERO = nbv(0);\r\nBigInteger.ONE = nbv(1);\r\n\r\n// JSBN-specific extension\r\nBigInteger.prototype.square = bnSquare;\r\n\r\n//BigInteger interfaces not implemented in jsbn:\r\n\r\n//BigInteger(int signum, byte[] magnitude)\r\n//double doubleValue()\r\n//float floatValue()\r\n//int hashCode()\r\n//long longValue()\r\n//static BigInteger valueOf(long val)\r\n\r\nmodule.exports = BigInteger;","/*\n * RSA Encryption / Decryption with PKCS1 v2 Padding.\n * \n * Copyright (c) 2003-2005  Tom Wu\n * All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS-IS\" AND WITHOUT WARRANTY OF ANY KIND, \n * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY \n * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  \n *\n * IN NO EVENT SHALL TOM WU BE LIABLE FOR ANY SPECIAL, INCIDENTAL,\n * INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER\n * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF\n * THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY, ARISING OUT\n * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n *\n * In addition, the following condition applies:\n *\n * All redistributions must retain an intact copy of this copyright notice\n * and disclaimer.\n */\n\n/*\n * Node.js adaptation\n * long message support implementation\n * signing/verifying\n *\n * 2014 rzcoder\n */\n\nvar _ = require('../utils')._;\nvar crypt = require('crypto');\nvar BigInteger = require('./jsbn.js');\nvar utils = require('../utils.js');\nvar schemes = require('../schemes/schemes.js');\nvar encryptEngines = require('../encryptEngines/encryptEngines.js');\n\nexports.BigInteger = BigInteger;\nmodule.exports.Key = (function () {\n    /**\n     * RSA key constructor\n     *\n     * n - modulus\n     * e - publicExponent\n     * d - privateExponent\n     * p - prime1\n     * q - prime2\n     * dmp1 - exponent1 -- d mod (p1)\n     * dmq1 - exponent2 -- d mod (q-1)\n     * coeff - coefficient -- (inverse of q) mod p\n     */\n    function RSAKey() {\n        this.n = null;\n        this.e = 0;\n        this.d = null;\n        this.p = null;\n        this.q = null;\n        this.dmp1 = null;\n        this.dmq1 = null;\n        this.coeff = null;\n    }\n\n    RSAKey.prototype.setOptions = function (options) {\n        var signingSchemeProvider = schemes[options.signingScheme];\n        var encryptionSchemeProvider = schemes[options.encryptionScheme];\n\n        if (signingSchemeProvider === encryptionSchemeProvider) {\n            this.signingScheme = this.encryptionScheme = encryptionSchemeProvider.makeScheme(this, options);\n        } else {\n            this.encryptionScheme = encryptionSchemeProvider.makeScheme(this, options);\n            this.signingScheme = signingSchemeProvider.makeScheme(this, options);\n        }\n\n        this.encryptEngine = encryptEngines.getEngine(this, options);\n    };\n\n    /**\n     * Generate a new random private key B bits long, using public expt E\n     * @param B\n     * @param E\n     */\n    RSAKey.prototype.generate = function (B, E) {\n        var qs = B >> 1;\n        this.e = parseInt(E, 16);\n        var ee = new BigInteger(E, 16);\n        while (true) {\n            while (true) {\n                this.p = new BigInteger(B - qs, 1);\n                if (this.p.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) === 0 && this.p.isProbablePrime(10))\n                    break;\n            }\n            while (true) {\n                this.q = new BigInteger(qs, 1);\n                if (this.q.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) === 0 && this.q.isProbablePrime(10))\n                    break;\n            }\n            if (this.p.compareTo(this.q) <= 0) {\n                var t = this.p;\n                this.p = this.q;\n                this.q = t;\n            }\n            var p1 = this.p.subtract(BigInteger.ONE);\n            var q1 = this.q.subtract(BigInteger.ONE);\n            var phi = p1.multiply(q1);\n            if (phi.gcd(ee).compareTo(BigInteger.ONE) === 0) {\n                this.n = this.p.multiply(this.q);\n                if (this.n.bitLength() < B) {\n                    continue;\n                }\n                this.d = ee.modInverse(phi);\n                this.dmp1 = this.d.mod(p1);\n                this.dmq1 = this.d.mod(q1);\n                this.coeff = this.q.modInverse(this.p);\n                break;\n            }\n        }\n        this.$$recalculateCache();\n    };\n\n    /**\n     * Set the private key fields N, e, d and CRT params from buffers\n     *\n     * @param N\n     * @param E\n     * @param D\n     * @param P\n     * @param Q\n     * @param DP\n     * @param DQ\n     * @param C\n     */\n    RSAKey.prototype.setPrivate = function (N, E, D, P, Q, DP, DQ, C) {\n        if (N && E && D && N.length > 0 && (_.isNumber(E) || E.length > 0) && D.length > 0) {\n            this.n = new BigInteger(N);\n            this.e = _.isNumber(E) ? E : utils.get32IntFromBuffer(E, 0);\n            this.d = new BigInteger(D);\n\n            if (P && Q && DP && DQ && C) {\n                this.p = new BigInteger(P);\n                this.q = new BigInteger(Q);\n                this.dmp1 = new BigInteger(DP);\n                this.dmq1 = new BigInteger(DQ);\n                this.coeff = new BigInteger(C);\n            } else {\n                // TODO: re-calculate any missing CRT params\n            }\n            this.$$recalculateCache();\n        } else {\n            throw Error(\"Invalid RSA private key\");\n        }\n    };\n\n    /**\n     * Set the public key fields N and e from hex strings\n     * @param N\n     * @param E\n     */\n    RSAKey.prototype.setPublic = function (N, E) {\n        if (N && E && N.length > 0 && (_.isNumber(E) || E.length > 0)) {\n            this.n = new BigInteger(N);\n            this.e = _.isNumber(E) ? E : utils.get32IntFromBuffer(E, 0);\n            this.$$recalculateCache();\n        } else {\n            throw Error(\"Invalid RSA public key\");\n        }\n    };\n\n    /**\n     * private\n     * Perform raw private operation on \"x\": return x^d (mod n)\n     *\n     * @param x\n     * @returns {*}\n     */\n    RSAKey.prototype.$doPrivate = function (x) {\n        if (this.p || this.q) {\n            return x.modPow(this.d, this.n);\n        }\n\n        // TODO: re-calculate any missing CRT params\n        var xp = x.mod(this.p).modPow(this.dmp1, this.p);\n        var xq = x.mod(this.q).modPow(this.dmq1, this.q);\n\n        while (xp.compareTo(xq) < 0) {\n            xp = xp.add(this.p);\n        }\n        return xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq);\n    };\n\n    /**\n     * private\n     * Perform raw public operation on \"x\": return x^e (mod n)\n     *\n     * @param x\n     * @returns {*}\n     */\n    RSAKey.prototype.$doPublic = function (x) {\n        return x.modPowInt(this.e, this.n);\n    };\n\n    /**\n     * Return the PKCS#1 RSA encryption of buffer\n     * @param buffer {Buffer}\n     * @returns {Buffer}\n     */\n    RSAKey.prototype.encrypt = function (buffer, usePrivate) {\n        var buffers = [];\n        var results = [];\n        var bufferSize = buffer.length;\n        var buffersCount = Math.ceil(bufferSize / this.maxMessageLength) || 1; // total buffers count for encrypt\n        var dividedSize = Math.ceil(bufferSize / buffersCount || 1); // each buffer size\n\n        if (buffersCount == 1) {\n            buffers.push(buffer);\n        } else {\n            for (var bufNum = 0; bufNum < buffersCount; bufNum++) {\n                buffers.push(buffer.slice(bufNum * dividedSize, (bufNum + 1) * dividedSize));\n            }\n        }\n\n        for (var i = 0; i < buffers.length; i++) {\n            results.push(this.encryptEngine.encrypt(buffers[i], usePrivate));\n        }\n\n        return Buffer.concat(results);\n    };\n\n    /**\n     * Return the PKCS#1 RSA decryption of buffer\n     * @param buffer {Buffer}\n     * @returns {Buffer}\n     */\n    RSAKey.prototype.decrypt = function (buffer, usePublic) {\n        if (buffer.length % this.encryptedDataLength > 0) {\n            throw Error('Incorrect data or key');\n        }\n\n        var result = [];\n        var offset = 0;\n        var length = 0;\n        var buffersCount = buffer.length / this.encryptedDataLength;\n\n        for (var i = 0; i < buffersCount; i++) {\n            offset = i * this.encryptedDataLength;\n            length = offset + this.encryptedDataLength;\n            result.push(this.encryptEngine.decrypt(buffer.slice(offset, Math.min(length, buffer.length)), usePublic));\n        }\n\n        return Buffer.concat(result);\n    };\n\n    RSAKey.prototype.sign = function (buffer) {\n        return this.signingScheme.sign.apply(this.signingScheme, arguments);\n    };\n\n    RSAKey.prototype.verify = function (buffer, signature, signature_encoding) {\n        return this.signingScheme.verify.apply(this.signingScheme, arguments);\n    };\n\n    /**\n     * Check if key pair contains private key\n     */\n    RSAKey.prototype.isPrivate = function () {\n        return this.n && this.e && this.d && true || false;\n    };\n\n    /**\n     * Check if key pair contains public key\n     * @param strict {boolean} - public key only, return false if have private exponent\n     */\n    RSAKey.prototype.isPublic = function (strict) {\n        return this.n && this.e && !(strict && this.d) || false;\n    };\n\n    Object.defineProperty(RSAKey.prototype, 'keySize', {\n        get: function () {\n            return this.cache.keyBitLength;\n        }\n    });\n\n    Object.defineProperty(RSAKey.prototype, 'encryptedDataLength', {\n        get: function () {\n            return this.cache.keyByteLength;\n        }\n    });\n\n    Object.defineProperty(RSAKey.prototype, 'maxMessageLength', {\n        get: function () {\n            return this.encryptionScheme.maxMessageLength();\n        }\n    });\n\n    /**\n     * Caching key data\n     */\n    RSAKey.prototype.$$recalculateCache = function () {\n        this.cache = this.cache || {};\n        // Bit & byte length\n        this.cache.keyBitLength = this.n.bitLength();\n        this.cache.keyByteLength = (this.cache.keyBitLength + 6) >> 3;\n    };\n\n    return RSAKey;\n})();\n\n","/**\n * PKCS_OAEP signature scheme\n */\n\nvar BigInteger = require('../libs/jsbn');\nvar crypt = require('crypto');\n\nmodule.exports = {\n    isEncryption: true,\n    isSignature: false\n};\n\nmodule.exports.digestLength = {\n    md4: 16,\n    md5: 16,\n    ripemd160: 20,\n    rmd160: 20,\n    sha1: 20,\n    sha224: 28,\n    sha256: 32,\n    sha384: 48,\n    sha512: 64\n};\n\nvar DEFAULT_HASH_FUNCTION = 'sha1';\n\n/*\n * OAEP Mask Generation Function 1\n * Generates a buffer full of pseudorandom bytes given seed and maskLength.\n * Giving the same seed, maskLength, and hashFunction will result in the same exact byte values in the buffer.\n *\n * https://tools.ietf.org/html/rfc3447#appendix-B.2.1\n *\n * Parameters:\n * seed\t\t\t[Buffer]\tThe pseudo random seed for this function\n * maskLength\t[int]\t\tThe length of the output\n * hashFunction\t[String]\tThe hashing function to use. Will accept any valid crypto hash. Default \"sha1\"\n *\t\tSupports \"sha1\" and \"sha256\".\n *\t\tTo add another algorythm the algorythem must be accepted by crypto.createHash, and then the length of the output of the hash function (the digest) must be added to the digestLength object below.\n *\t\tMost RSA implementations will be expecting sha1\n */\nmodule.exports.eme_oaep_mgf1 = function (seed, maskLength, hashFunction) {\n    hashFunction = hashFunction || DEFAULT_HASH_FUNCTION;\n    var hLen = module.exports.digestLength[hashFunction];\n    var count = Math.ceil(maskLength / hLen);\n    var T = Buffer.alloc(hLen * count);\n    var c = Buffer.alloc(4);\n    for (var i = 0; i < count; ++i) {\n        var hash = crypt.createHash(hashFunction);\n        hash.update(seed);\n        c.writeUInt32BE(i, 0);\n        hash.update(c);\n        hash.digest().copy(T, i * hLen);\n    }\n    return T.slice(0, maskLength);\n};\n\nmodule.exports.makeScheme = function (key, options) {\n    function Scheme(key, options) {\n        this.key = key;\n        this.options = options;\n    }\n\n    Scheme.prototype.maxMessageLength = function () {\n        return this.key.encryptedDataLength - 2 * module.exports.digestLength[this.options.encryptionSchemeOptions.hash || DEFAULT_HASH_FUNCTION] - 2;\n    };\n\n    /**\n     * Pad input\n     * alg: PKCS1_OAEP\n     *\n     * https://tools.ietf.org/html/rfc3447#section-7.1.1\n     */\n    Scheme.prototype.encPad = function (buffer) {\n        var hash = this.options.encryptionSchemeOptions.hash || DEFAULT_HASH_FUNCTION;\n        var mgf = this.options.encryptionSchemeOptions.mgf || module.exports.eme_oaep_mgf1;\n        var label = this.options.encryptionSchemeOptions.label || Buffer.alloc(0);\n        var emLen = this.key.encryptedDataLength;\n\n        var hLen = module.exports.digestLength[hash];\n\n        // Make sure we can put message into an encoded message of emLen bytes\n        if (buffer.length > emLen - 2 * hLen - 2) {\n            throw new Error(\"Message is too long to encode into an encoded message with a length of \" + emLen + \" bytes, increase\" +\n            \"emLen to fix this error (minimum value for given parameters and options: \" + (emLen - 2 * hLen - 2) + \")\");\n        }\n\n        var lHash = crypt.createHash(hash);\n        lHash.update(label);\n        lHash = lHash.digest();\n\n        var PS = Buffer.alloc(emLen - buffer.length - 2 * hLen - 1); // Padding \"String\"\n        PS.fill(0); // Fill the buffer with octets of 0\n        PS[PS.length - 1] = 1;\n\n        var DB = Buffer.concat([lHash, PS, buffer]);\n        var seed = crypt.randomBytes(hLen);\n\n        // mask = dbMask\n        var mask = mgf(seed, DB.length, hash);\n        // XOR DB and dbMask together.\n        for (var i = 0; i < DB.length; i++) {\n            DB[i] ^= mask[i];\n        }\n        // DB = maskedDB\n\n        // mask = seedMask\n        mask = mgf(DB, hLen, hash);\n        // XOR seed and seedMask together.\n        for (i = 0; i < seed.length; i++) {\n            seed[i] ^= mask[i];\n        }\n        // seed = maskedSeed\n\n        var em = Buffer.alloc(1 + seed.length + DB.length);\n        em[0] = 0;\n        seed.copy(em, 1);\n        DB.copy(em, 1 + seed.length);\n\n        return em;\n    };\n\n    /**\n     * Unpad input\n     * alg: PKCS1_OAEP\n     *\n     * Note: This method works within the buffer given and modifies the values. It also returns a slice of the EM as the return Message.\n     * If the implementation requires that the EM parameter be unmodified then the implementation should pass in a clone of the EM buffer.\n     *\n     * https://tools.ietf.org/html/rfc3447#section-7.1.2\n     */\n    Scheme.prototype.encUnPad = function (buffer) {\n        var hash = this.options.encryptionSchemeOptions.hash || DEFAULT_HASH_FUNCTION;\n        var mgf = this.options.encryptionSchemeOptions.mgf || module.exports.eme_oaep_mgf1;\n        var label = this.options.encryptionSchemeOptions.label || Buffer.alloc(0);\n\n        var hLen = module.exports.digestLength[hash];\n\n        // Check to see if buffer is a properly encoded OAEP message\n        if (buffer.length < 2 * hLen + 2) {\n            throw new Error(\"Error decoding message, the supplied message is not long enough to be a valid OAEP encoded message\");\n        }\n\n        var seed = buffer.slice(1, hLen + 1);\t// seed = maskedSeed\n        var DB = buffer.slice(1 + hLen);\t\t// DB = maskedDB\n\n        var mask = mgf(DB, hLen, hash); // seedMask\n        // XOR maskedSeed and seedMask together to get the original seed.\n        for (var i = 0; i < seed.length; i++) {\n            seed[i] ^= mask[i];\n        }\n\n        mask = mgf(seed, DB.length, hash); // dbMask\n        // XOR DB and dbMask together to get the original data block.\n        for (i = 0; i < DB.length; i++) {\n            DB[i] ^= mask[i];\n        }\n\n        var lHash = crypt.createHash(hash);\n        lHash.update(label);\n        lHash = lHash.digest();\n\n        var lHashEM = DB.slice(0, hLen);\n        if (lHashEM.toString(\"hex\") != lHash.toString(\"hex\")) {\n            throw new Error(\"Error decoding message, the lHash calculated from the label provided and the lHash in the encrypted data do not match.\");\n        }\n\n        // Filter out padding\n        i = hLen;\n        while (DB[i++] === 0 && i < DB.length);\n        if (DB[i - 1] != 1) {\n            throw new Error(\"Error decoding message, there is no padding message separator byte\");\n        }\n\n        return DB.slice(i); // Message\n    };\n\n    return new Scheme(key, options);\n};\n","/**\n * PKCS1 padding and signature scheme\n */\n\nvar BigInteger = require('../libs/jsbn');\nvar crypt = require('crypto');\nvar constants = require('constants');\nvar SIGN_INFO_HEAD = {\n    md2: Buffer.from('3020300c06082a864886f70d020205000410', 'hex'),\n    md5: Buffer.from('3020300c06082a864886f70d020505000410', 'hex'),\n    sha1: Buffer.from('3021300906052b0e03021a05000414', 'hex'),\n    sha224: Buffer.from('302d300d06096086480165030402040500041c', 'hex'),\n    sha256: Buffer.from('3031300d060960864801650304020105000420', 'hex'),\n    sha384: Buffer.from('3041300d060960864801650304020205000430', 'hex'),\n    sha512: Buffer.from('3051300d060960864801650304020305000440', 'hex'),\n    ripemd160: Buffer.from('3021300906052b2403020105000414', 'hex'),\n    rmd160: Buffer.from('3021300906052b2403020105000414', 'hex')\n};\n\nvar SIGN_ALG_TO_HASH_ALIASES = {\n    'ripemd160': 'rmd160'\n};\n\nvar DEFAULT_HASH_FUNCTION = 'sha256';\n\nmodule.exports = {\n    isEncryption: true,\n    isSignature: true\n};\n\nmodule.exports.makeScheme = function (key, options) {\n    function Scheme(key, options) {\n        this.key = key;\n        this.options = options;\n    }\n\n    Scheme.prototype.maxMessageLength = function () {\n        if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {\n            return this.key.encryptedDataLength;\n        }\n        return this.key.encryptedDataLength - 11;\n    };\n\n    /**\n     * Pad input Buffer to encryptedDataLength bytes, and return Buffer.from\n     * alg: PKCS#1\n     * @param buffer\n     * @returns {Buffer}\n     */\n    Scheme.prototype.encPad = function (buffer, options) {\n        options = options || {};\n        var filled;\n        if (buffer.length > this.key.maxMessageLength) {\n            throw new Error(\"Message too long for RSA (n=\" + this.key.encryptedDataLength + \", l=\" + buffer.length + \")\");\n        }\n        if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {\n            //RSA_NO_PADDING treated like JAVA left pad with zero character\n            filled = Buffer.alloc(this.key.maxMessageLength - buffer.length);\n            filled.fill(0);\n            return Buffer.concat([filled, buffer]);\n        }\n\n        /* Type 1: zeros padding for private key encrypt */\n        if (options.type === 1) {\n            filled = Buffer.alloc(this.key.encryptedDataLength - buffer.length - 1);\n            filled.fill(0xff, 0, filled.length - 1);\n            filled[0] = 1;\n            filled[filled.length - 1] = 0;\n\n            return Buffer.concat([filled, buffer]);\n        } else {\n            /* random padding for public key encrypt */\n            filled = Buffer.alloc(this.key.encryptedDataLength - buffer.length);\n            filled[0] = 0;\n            filled[1] = 2;\n            var rand = crypt.randomBytes(filled.length - 3);\n            for (var i = 0; i < rand.length; i++) {\n                var r = rand[i];\n                while (r === 0) { // non-zero only\n                    r = crypt.randomBytes(1)[0];\n                }\n                filled[i + 2] = r;\n            }\n            filled[filled.length - 1] = 0;\n            return Buffer.concat([filled, buffer]);\n        }\n    };\n\n    /**\n     * Unpad input Buffer and, if valid, return the Buffer object\n     * alg: PKCS#1 (type 2, random)\n     * @param buffer\n     * @returns {Buffer}\n     */\n    Scheme.prototype.encUnPad = function (buffer, options) {\n        options = options || {};\n        var i = 0;\n\n        if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {\n            //RSA_NO_PADDING treated like JAVA left pad with zero character\n            var unPad;\n            if (typeof buffer.lastIndexOf == \"function\") { //patch for old node version\n                unPad = buffer.slice(buffer.lastIndexOf('\\0') + 1, buffer.length);\n            } else {\n                unPad = buffer.slice(String.prototype.lastIndexOf.call(buffer, '\\0') + 1, buffer.length);\n            }\n            return unPad;\n        }\n\n        if (buffer.length < 4) {\n            return null;\n        }\n\n        /* Type 1: zeros padding for private key decrypt */\n        if (options.type === 1) {\n            if (buffer[0] !== 0 || buffer[1] !== 1) {\n                return null;\n            }\n            i = 3;\n            while (buffer[i] !== 0) {\n                if (buffer[i] != 0xFF || ++i >= buffer.length) {\n                    return null;\n                }\n            }\n        } else {\n            /* random padding for public key decrypt */\n            if (buffer[0] !== 0 || buffer[1] !== 2) {\n                return null;\n            }\n            i = 3;\n            while (buffer[i] !== 0) {\n                if (++i >= buffer.length) {\n                    return null;\n                }\n            }\n        }\n        return buffer.slice(i + 1, buffer.length);\n    };\n\n    Scheme.prototype.sign = function (buffer) {\n        var hashAlgorithm = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;\n        if (this.options.environment === 'browser') {\n            hashAlgorithm = SIGN_ALG_TO_HASH_ALIASES[hashAlgorithm] || hashAlgorithm;\n\n            var hasher = crypt.createHash(hashAlgorithm);\n            hasher.update(buffer);\n            var hash = this.pkcs1pad(hasher.digest(), hashAlgorithm);\n            var res = this.key.$doPrivate(new BigInteger(hash)).toBuffer(this.key.encryptedDataLength);\n\n            return res;\n        } else {\n            var signer = crypt.createSign('RSA-' + hashAlgorithm.toUpperCase());\n            signer.update(buffer);\n            return signer.sign(this.options.rsaUtils.exportKey('private'));\n        }\n    };\n\n    Scheme.prototype.verify = function (buffer, signature, signature_encoding) {\n        if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {\n            //RSA_NO_PADDING has no verify data\n            return false;\n        }\n        var hashAlgorithm = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;\n        if (this.options.environment === 'browser') {\n            hashAlgorithm = SIGN_ALG_TO_HASH_ALIASES[hashAlgorithm] || hashAlgorithm;\n\n            if (signature_encoding) {\n                signature = Buffer.from(signature, signature_encoding);\n            }\n\n            var hasher = crypt.createHash(hashAlgorithm);\n            hasher.update(buffer);\n            var hash = this.pkcs1pad(hasher.digest(), hashAlgorithm);\n            var m = this.key.$doPublic(new BigInteger(signature));\n\n            return m.toBuffer().toString('hex') == hash.toString('hex');\n        } else {\n            var verifier = crypt.createVerify('RSA-' + hashAlgorithm.toUpperCase());\n            verifier.update(buffer);\n            return verifier.verify(this.options.rsaUtils.exportKey('public'), signature, signature_encoding);\n        }\n    };\n\n    /**\n     * PKCS#1 zero pad input buffer to max data length\n     * @param hashBuf\n     * @param hashAlgorithm\n     * @returns {*}\n     */\n    Scheme.prototype.pkcs0pad = function (buffer) {\n        var filled = Buffer.alloc(this.key.maxMessageLength - buffer.length);\n        filled.fill(0);\n        return Buffer.concat([filled, buffer]);\n    };\n\n    Scheme.prototype.pkcs0unpad = function (buffer) {\n        var unPad;\n        if (typeof buffer.lastIndexOf == \"function\") { //patch for old node version\n            unPad = buffer.slice(buffer.lastIndexOf('\\0') + 1, buffer.length);\n        } else {\n            unPad = buffer.slice(String.prototype.lastIndexOf.call(buffer, '\\0') + 1, buffer.length);\n        }\n\n        return unPad;\n    };\n\n    /**\n     * PKCS#1 pad input buffer to max data length\n     * @param hashBuf\n     * @param hashAlgorithm\n     * @returns {*}\n     */\n    Scheme.prototype.pkcs1pad = function (hashBuf, hashAlgorithm) {\n        var digest = SIGN_INFO_HEAD[hashAlgorithm];\n        if (!digest) {\n            throw Error('Unsupported hash algorithm');\n        }\n\n        var data = Buffer.concat([digest, hashBuf]);\n\n        if (data.length + 10 > this.key.encryptedDataLength) {\n            throw Error('Key is too short for signing algorithm (' + hashAlgorithm + ')');\n        }\n\n        var filled = Buffer.alloc(this.key.encryptedDataLength - data.length - 1);\n        filled.fill(0xff, 0, filled.length - 1);\n        filled[0] = 1;\n        filled[filled.length - 1] = 0;\n\n        var res = Buffer.concat([filled, data]);\n\n        return res;\n    };\n\n    return new Scheme(key, options);\n};\n\n\n","/**\r\n * PSS signature scheme\r\n */\r\n\r\nvar BigInteger = require('../libs/jsbn');\r\nvar crypt = require('crypto');\r\n\r\nmodule.exports = {\r\n    isEncryption: false,\r\n    isSignature: true\r\n};\r\n\r\nvar DEFAULT_HASH_FUNCTION = 'sha1';\r\nvar DEFAULT_SALT_LENGTH = 20;\r\n\r\nmodule.exports.makeScheme = function (key, options) {\r\n    var OAEP = require('./schemes').pkcs1_oaep;\r\n\r\n    /**\r\n     * @param key\r\n     * @param options\r\n     * options    [Object]    An object that contains the following keys that specify certain options for encoding.\r\n     *  >signingSchemeOptions\r\n     *     >hash    [String]    Hash function to use when encoding and generating masks. Must be a string accepted by node's crypto.createHash function. (default = \"sha1\")\r\n     *     >mgf    [function]    The mask generation function to use when encoding. (default = mgf1SHA1)\r\n     *     >sLen    [uint]        The length of the salt to generate. (default = 20)\r\n     * @constructor\r\n     */\r\n    function Scheme(key, options) {\r\n        this.key = key;\r\n        this.options = options;\r\n    }\r\n\r\n    Scheme.prototype.sign = function (buffer) {\r\n        var mHash = crypt.createHash(this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION);\r\n        mHash.update(buffer);\r\n\r\n        var encoded = this.emsa_pss_encode(mHash.digest(), this.key.keySize - 1);\r\n        return this.key.$doPrivate(new BigInteger(encoded)).toBuffer(this.key.encryptedDataLength);\r\n    };\r\n\r\n    Scheme.prototype.verify = function (buffer, signature, signature_encoding) {\r\n        if (signature_encoding) {\r\n            signature = Buffer.from(signature, signature_encoding);\r\n        }\r\n        signature = new BigInteger(signature);\r\n\r\n        var emLen = Math.ceil((this.key.keySize - 1) / 8);\r\n        var m = this.key.$doPublic(signature).toBuffer(emLen);\r\n\r\n        var mHash = crypt.createHash(this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION);\r\n        mHash.update(buffer);\r\n\r\n        return this.emsa_pss_verify(mHash.digest(), m, this.key.keySize - 1);\r\n    };\r\n\r\n    /*\r\n     * https://tools.ietf.org/html/rfc3447#section-9.1.1\r\n     *\r\n     * mHash\t[Buffer]\tHashed message to encode\r\n     * emBits\t[uint]\t\tMaximum length of output in bits. Must be at least 8hLen + 8sLen + 9 (hLen = Hash digest length in bytes | sLen = length of salt in bytes)\r\n     * @returns {Buffer} The encoded message\r\n     */\r\n    Scheme.prototype.emsa_pss_encode = function (mHash, emBits) {\r\n        var hash = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;\r\n        var mgf = this.options.signingSchemeOptions.mgf || OAEP.eme_oaep_mgf1;\r\n        var sLen = this.options.signingSchemeOptions.saltLength || DEFAULT_SALT_LENGTH;\r\n\r\n        var hLen = OAEP.digestLength[hash];\r\n        var emLen = Math.ceil(emBits / 8);\r\n\r\n        if (emLen < hLen + sLen + 2) {\r\n            throw new Error(\"Output length passed to emBits(\" + emBits + \") is too small for the options \" +\r\n                \"specified(\" + hash + \", \" + sLen + \"). To fix this issue increase the value of emBits. (minimum size: \" +\r\n                (8 * hLen + 8 * sLen + 9) + \")\"\r\n            );\r\n        }\r\n\r\n        var salt = crypt.randomBytes(sLen);\r\n\r\n        var Mapostrophe = Buffer.alloc(8 + hLen + sLen);\r\n        Mapostrophe.fill(0, 0, 8);\r\n        mHash.copy(Mapostrophe, 8);\r\n        salt.copy(Mapostrophe, 8 + mHash.length);\r\n\r\n        var H = crypt.createHash(hash);\r\n        H.update(Mapostrophe);\r\n        H = H.digest();\r\n\r\n        var PS = Buffer.alloc(emLen - salt.length - hLen - 2);\r\n        PS.fill(0);\r\n\r\n        var DB = Buffer.alloc(PS.length + 1 + salt.length);\r\n        PS.copy(DB);\r\n        DB[PS.length] = 0x01;\r\n        salt.copy(DB, PS.length + 1);\r\n\r\n        var dbMask = mgf(H, DB.length, hash);\r\n\r\n        // XOR DB and dbMask together\r\n        var maskedDB = Buffer.alloc(DB.length);\r\n        for (var i = 0; i < dbMask.length; i++) {\r\n            maskedDB[i] = DB[i] ^ dbMask[i];\r\n        }\r\n\r\n        var bits = 8 * emLen - emBits;\r\n        var mask = 255 ^ (255 >> 8 - bits << 8 - bits);\r\n        maskedDB[0] = maskedDB[0] & mask;\r\n\r\n        var EM = Buffer.alloc(maskedDB.length + H.length + 1);\r\n        maskedDB.copy(EM, 0);\r\n        H.copy(EM, maskedDB.length);\r\n        EM[EM.length - 1] = 0xbc;\r\n\r\n        return EM;\r\n    };\r\n\r\n    /*\r\n     * https://tools.ietf.org/html/rfc3447#section-9.1.2\r\n     *\r\n     * mHash\t[Buffer]\tHashed message\r\n     * EM\t\t[Buffer]\tSignature\r\n     * emBits\t[uint]\t\tLength of EM in bits. Must be at least 8hLen + 8sLen + 9 to be a valid signature. (hLen = Hash digest length in bytes | sLen = length of salt in bytes)\r\n     * @returns {Boolean} True if signature(EM) matches message(M)\r\n     */\r\n    Scheme.prototype.emsa_pss_verify = function (mHash, EM, emBits) {\r\n        var hash = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;\r\n        var mgf = this.options.signingSchemeOptions.mgf || OAEP.eme_oaep_mgf1;\r\n        var sLen = this.options.signingSchemeOptions.saltLength || DEFAULT_SALT_LENGTH;\r\n\r\n        var hLen = OAEP.digestLength[hash];\r\n        var emLen = Math.ceil(emBits / 8);\r\n\r\n        if (emLen < hLen + sLen + 2 || EM[EM.length - 1] != 0xbc) {\r\n            return false;\r\n        }\r\n\r\n        var DB = Buffer.alloc(emLen - hLen - 1);\r\n        EM.copy(DB, 0, 0, emLen - hLen - 1);\r\n\r\n        var mask = 0;\r\n        for (var i = 0, bits = 8 * emLen - emBits; i < bits; i++) {\r\n            mask |= 1 << (7 - i);\r\n        }\r\n\r\n        if ((DB[0] & mask) !== 0) {\r\n            return false;\r\n        }\r\n\r\n        var H = EM.slice(emLen - hLen - 1, emLen - 1);\r\n        var dbMask = mgf(H, DB.length, hash);\r\n\r\n        // Unmask DB\r\n        for (i = 0; i < DB.length; i++) {\r\n            DB[i] ^= dbMask[i];\r\n        }\r\n\r\n        bits = 8 * emLen - emBits;\r\n        mask = 255 ^ (255 >> 8 - bits << 8 - bits);\r\n        DB[0] = DB[0] & mask;\r\n\r\n        // Filter out padding\r\n        for (i = 0; DB[i] === 0 && i < DB.length; i++);\r\n        if (DB[i] != 1) {\r\n            return false;\r\n        }\r\n\r\n        var salt = DB.slice(DB.length - sLen);\r\n\r\n        var Mapostrophe = Buffer.alloc(8 + hLen + sLen);\r\n        Mapostrophe.fill(0, 0, 8);\r\n        mHash.copy(Mapostrophe, 8);\r\n        salt.copy(Mapostrophe, 8 + mHash.length);\r\n\r\n        var Hapostrophe = crypt.createHash(hash);\r\n        Hapostrophe.update(Mapostrophe);\r\n        Hapostrophe = Hapostrophe.digest();\r\n\r\n        return H.toString(\"hex\") === Hapostrophe.toString(\"hex\");\r\n    };\r\n\r\n    return new Scheme(key, options);\r\n};\r\n","module.exports = {\r\n    pkcs1: require('./pkcs1'),\r\n    pkcs1_oaep: require('./oaep'),\r\n    pss: require('./pss'),\r\n\r\n    /**\r\n     * Check if scheme has padding methods\r\n     * @param scheme {string}\r\n     * @returns {Boolean}\r\n     */\r\n    isEncryption: function (scheme) {\r\n        return module.exports[scheme] && module.exports[scheme].isEncryption;\r\n    },\r\n\r\n    /**\r\n     * Check if scheme has sign/verify methods\r\n     * @param scheme {string}\r\n     * @returns {Boolean}\r\n     */\r\n    isSignature: function (scheme) {\r\n        return module.exports[scheme] && module.exports[scheme].isSignature;\r\n    }\r\n};","/*\n * Utils functions\n *\n */\n\nvar crypt = require('crypto');\n\n/**\n * Break string str each maxLen symbols\n * @param str\n * @param maxLen\n * @returns {string}\n */\nmodule.exports.linebrk = function (str, maxLen) {\n    var res = '';\n    var i = 0;\n    while (i + maxLen < str.length) {\n        res += str.substring(i, i + maxLen) + \"\\n\";\n        i += maxLen;\n    }\n    return res + str.substring(i, str.length);\n};\n\nmodule.exports.detectEnvironment = function () {\n    if (typeof(window) !== 'undefined' && window && !(process && process.title === 'node')) {\n        return 'browser';\n    }\n\n    return 'node';\n};\n\n/**\n * Trying get a 32-bit unsigned integer from the partial buffer\n * @param buffer\n * @param offset\n * @returns {Number}\n */\nmodule.exports.get32IntFromBuffer = function (buffer, offset) {\n    offset = offset || 0;\n    var size = 0;\n    if ((size = buffer.length - offset) > 0) {\n        if (size >= 4) {\n            return buffer.readUIntBE(offset, size);\n        } else {\n            var res = 0;\n            for (var i = offset + size, d = 0; i > offset; i--, d += 2) {\n                res += buffer[i - 1] * Math.pow(16, d);\n            }\n            return res;\n        }\n    } else {\n        return NaN;\n    }\n};\n\nmodule.exports._ = {\n    isObject: function (value) {\n        var type = typeof value;\n        return !!value && (type == 'object' || type == 'function');\n    },\n\n    isString: function (value) {\n        return typeof value == 'string' || value instanceof String;\n    },\n\n    isNumber: function (value) {\n        return typeof value == 'number' || !isNaN(parseFloat(value)) && isFinite(value);\n    },\n\n    /**\n     * Returns copy of `obj` without `removeProp` field.\n     * @param obj\n     * @param removeProp\n     * @returns Object\n     */\n    omit: function (obj, removeProp) {\n        var newObj = {};\n        for (var prop in obj) {\n            if (!obj.hasOwnProperty(prop) || prop === removeProp) {\n                continue;\n            }\n            newObj[prop] = obj[prop];\n        }\n\n        return newObj;\n    }\n};\n\n/**\n * Strips everything around the opening and closing lines, including the lines\n * themselves.\n */\nmodule.exports.trimSurroundingText = function (data, opening, closing) {\n    var trimStartIndex = 0;\n    var trimEndIndex = data.length;\n\n    var openingBoundaryIndex = data.indexOf(opening);\n    if (openingBoundaryIndex >= 0) {\n        trimStartIndex = openingBoundaryIndex + opening.length;\n    }\n\n    var closingBoundaryIndex = data.indexOf(closing, openingBoundaryIndex);\n    if (closingBoundaryIndex >= 0) {\n        trimEndIndex = closingBoundaryIndex;\n    }\n\n    return data.substring(trimStartIndex, trimEndIndex);\n}","'use strict';\nconst pTry = require('p-try');\n\nconst pLimit = concurrency => {\n\tif (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {\n\t\treturn Promise.reject(new TypeError('Expected `concurrency` to be a number from 1 and up'));\n\t}\n\n\tconst queue = [];\n\tlet activeCount = 0;\n\n\tconst next = () => {\n\t\tactiveCount--;\n\n\t\tif (queue.length > 0) {\n\t\t\tqueue.shift()();\n\t\t}\n\t};\n\n\tconst run = (fn, resolve, ...args) => {\n\t\tactiveCount++;\n\n\t\tconst result = pTry(fn, ...args);\n\n\t\tresolve(result);\n\n\t\tresult.then(next, next);\n\t};\n\n\tconst enqueue = (fn, resolve, ...args) => {\n\t\tif (activeCount < concurrency) {\n\t\t\trun(fn, resolve, ...args);\n\t\t} else {\n\t\t\tqueue.push(run.bind(null, fn, resolve, ...args));\n\t\t}\n\t};\n\n\tconst generator = (fn, ...args) => new Promise(resolve => enqueue(fn, resolve, ...args));\n\tObject.defineProperties(generator, {\n\t\tactiveCount: {\n\t\t\tget: () => activeCount\n\t\t},\n\t\tpendingCount: {\n\t\t\tget: () => queue.length\n\t\t}\n\t});\n\n\treturn generator;\n};\n\nmodule.exports = pLimit;\nmodule.exports.default = pLimit;\n","'use strict';\n\nconst pTry = (fn, ...arguments_) => new Promise(resolve => {\n\tresolve(fn(...arguments_));\n});\n\nmodule.exports = pTry;\n// TODO: remove this in the next major version\nmodule.exports.default = pTry;\n","// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n","'use strict';\nconst fs = require('fs');\n\nmodule.exports = fp => new Promise(resolve => {\n\tfs.access(fp, err => {\n\t\tresolve(!err);\n\t});\n});\n\nmodule.exports.sync = fp => {\n\ttry {\n\t\tfs.accessSync(fp);\n\t\treturn true;\n\t} catch (err) {\n\t\treturn false;\n\t}\n};\n","const { PerformanceObserver, performance } = require('perf_hooks');\n\nconst entriesList = [];\nconst observer = new PerformanceObserver((perfObserverList) => {\n    entriesList.push(...perfObserverList.getEntries());\n});\n\nperformance.getEntries = () => {\n    return [...entriesList];\n};\n\nperformance.getEntriesByName = (name, type) => {\n    const result = entriesList.filter((entry) => {\n        const isSameName = (entry.name === name);\n        const isSameType = !type || (entry.type === type);\n\n        return isSameName && isSameType;\n    });\n\n    return [...result];\n};\n\nperformance.getEntriesByType = (type) => {\n    const result = entriesList.filter((entry) => {\n        return entry.type === type;\n    });\n\n    return [...result];\n};\n\nobserver.observe({\n    entryTypes: ['measure', 'mark'],\n    buffered: false,\n});\n\nmodule.exports = { PerformanceObserver, performance };\n","module.exports = require('crypto').randomBytes\n","'use strict';\n\nvar fs = require('fs'),\n  join = require('path').join,\n  resolve = require('path').resolve,\n  dirname = require('path').dirname,\n  defaultOptions = {\n    extensions: ['js', 'json', 'coffee'],\n    recurse: true,\n    rename: function (name) {\n      return name;\n    },\n    visit: function (obj) {\n      return obj;\n    }\n  };\n\nfunction checkFileInclusion(path, filename, options) {\n  return (\n    // verify file has valid extension\n    (new RegExp('\\\\.(' + options.extensions.join('|') + ')$', 'i').test(filename)) &&\n\n    // if options.include is a RegExp, evaluate it and make sure the path passes\n    !(options.include && options.include instanceof RegExp && !options.include.test(path)) &&\n\n    // if options.include is a function, evaluate it and make sure the path passes\n    !(options.include && typeof options.include === 'function' && !options.include(path, filename)) &&\n\n    // if options.exclude is a RegExp, evaluate it and make sure the path doesn't pass\n    !(options.exclude && options.exclude instanceof RegExp && options.exclude.test(path)) &&\n\n    // if options.exclude is a function, evaluate it and make sure the path doesn't pass\n    !(options.exclude && typeof options.exclude === 'function' && options.exclude(path, filename))\n  );\n}\n\nfunction requireDirectory(m, path, options) {\n  var retval = {};\n\n  // path is optional\n  if (path && !options && typeof path !== 'string') {\n    options = path;\n    path = null;\n  }\n\n  // default options\n  options = options || {};\n  for (var prop in defaultOptions) {\n    if (typeof options[prop] === 'undefined') {\n      options[prop] = defaultOptions[prop];\n    }\n  }\n\n  // if no path was passed in, assume the equivelant of __dirname from caller\n  // otherwise, resolve path relative to the equivalent of __dirname\n  path = !path ? dirname(m.filename) : resolve(dirname(m.filename), path);\n\n  // get the path of each file in specified directory, append to current tree node, recurse\n  fs.readdirSync(path).forEach(function (filename) {\n    var joined = join(path, filename),\n      files,\n      key,\n      obj;\n\n    if (fs.statSync(joined).isDirectory() && options.recurse) {\n      // this node is a directory; recurse\n      files = requireDirectory(m, joined, options);\n      // exclude empty directories\n      if (Object.keys(files).length) {\n        retval[options.rename(filename, joined, filename)] = files;\n      }\n    } else {\n      if (joined !== m.filename && checkFileInclusion(joined, filename, options)) {\n        // hash node key shouldn't include file extension\n        key = filename.substring(0, filename.lastIndexOf('.'));\n        obj = m.require(joined);\n        retval[options.rename(key, joined, filename)] = options.visit(obj, joined, filename) || obj;\n      }\n    }\n  });\n\n  return retval;\n}\n\nmodule.exports = requireDirectory;\nmodule.exports.defaults = defaultOptions;\n","/* eslint-disable node/no-deprecated-api */\n\n'use strict'\n\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\nvar safer = {}\n\nvar key\n\nfor (key in buffer) {\n  if (!buffer.hasOwnProperty(key)) continue\n  if (key === 'SlowBuffer' || key === 'Buffer') continue\n  safer[key] = buffer[key]\n}\n\nvar Safer = safer.Buffer = {}\nfor (key in Buffer) {\n  if (!Buffer.hasOwnProperty(key)) continue\n  if (key === 'allocUnsafe' || key === 'allocUnsafeSlow') continue\n  Safer[key] = Buffer[key]\n}\n\nsafer.Buffer.prototype = Buffer.prototype\n\nif (!Safer.from || Safer.from === Uint8Array.from) {\n  Safer.from = function (value, encodingOrOffset, length) {\n    if (typeof value === 'number') {\n      throw new TypeError('The \"value\" argument must not be of type number. Received type ' + typeof value)\n    }\n    if (value && typeof value.length === 'undefined') {\n      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value)\n    }\n    return Buffer(value, encodingOrOffset, length)\n  }\n}\n\nif (!Safer.alloc) {\n  Safer.alloc = function (size, fill, encoding) {\n    if (typeof size !== 'number') {\n      throw new TypeError('The \"size\" argument must be of type number. Received type ' + typeof size)\n    }\n    if (size < 0 || size >= 2 * (1 << 30)) {\n      throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n    }\n    var buf = Buffer(size)\n    if (!fill || fill.length === 0) {\n      buf.fill(0)\n    } else if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n    return buf\n  }\n}\n\nif (!safer.kStringMaxLength) {\n  try {\n    safer.kStringMaxLength = process.binding('buffer').kStringMaxLength\n  } catch (e) {\n    // we can't determine kStringMaxLength in environments where process.binding\n    // is unsupported, so let's not set it\n  }\n}\n\nif (!safer.constants) {\n  safer.constants = {\n    MAX_LENGTH: safer.kMaxLength\n  }\n  if (safer.kStringMaxLength) {\n    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength\n  }\n}\n\nmodule.exports = safer\n","exports = module.exports = SemVer\n\nvar debug\n/* istanbul ignore next */\nif (typeof process === 'object' &&\n    process.env &&\n    process.env.NODE_DEBUG &&\n    /\\bsemver\\b/i.test(process.env.NODE_DEBUG)) {\n  debug = function () {\n    var args = Array.prototype.slice.call(arguments, 0)\n    args.unshift('SEMVER')\n    console.log.apply(console, args)\n  }\n} else {\n  debug = function () {}\n}\n\n// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nexports.SEMVER_SPEC_VERSION = '2.0.0'\n\nvar MAX_LENGTH = 256\nvar MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||\n  /* istanbul ignore next */ 9007199254740991\n\n// Max safe segment length for coercion.\nvar MAX_SAFE_COMPONENT_LENGTH = 16\n\n// The actual regexps go on exports.re\nvar re = exports.re = []\nvar src = exports.src = []\nvar R = 0\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\nvar NUMERICIDENTIFIER = R++\nsrc[NUMERICIDENTIFIER] = '0|[1-9]\\\\d*'\nvar NUMERICIDENTIFIERLOOSE = R++\nsrc[NUMERICIDENTIFIERLOOSE] = '[0-9]+'\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\nvar NONNUMERICIDENTIFIER = R++\nsrc[NONNUMERICIDENTIFIER] = '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*'\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\nvar MAINVERSION = R++\nsrc[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[NUMERICIDENTIFIER] + ')'\n\nvar MAINVERSIONLOOSE = R++\nsrc[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')'\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\nvar PRERELEASEIDENTIFIER = R++\nsrc[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +\n                            '|' + src[NONNUMERICIDENTIFIER] + ')'\n\nvar PRERELEASEIDENTIFIERLOOSE = R++\nsrc[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +\n                                 '|' + src[NONNUMERICIDENTIFIER] + ')'\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\nvar PRERELEASE = R++\nsrc[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +\n                  '(?:\\\\.' + src[PRERELEASEIDENTIFIER] + ')*))'\n\nvar PRERELEASELOOSE = R++\nsrc[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +\n                       '(?:\\\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))'\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\nvar BUILDIDENTIFIER = R++\nsrc[BUILDIDENTIFIER] = '[0-9A-Za-z-]+'\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\nvar BUILD = R++\nsrc[BUILD] = '(?:\\\\+(' + src[BUILDIDENTIFIER] +\n             '(?:\\\\.' + src[BUILDIDENTIFIER] + ')*))'\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\nvar FULL = R++\nvar FULLPLAIN = 'v?' + src[MAINVERSION] +\n                src[PRERELEASE] + '?' +\n                src[BUILD] + '?'\n\nsrc[FULL] = '^' + FULLPLAIN + '$'\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\nvar LOOSEPLAIN = '[v=\\\\s]*' + src[MAINVERSIONLOOSE] +\n                 src[PRERELEASELOOSE] + '?' +\n                 src[BUILD] + '?'\n\nvar LOOSE = R++\nsrc[LOOSE] = '^' + LOOSEPLAIN + '$'\n\nvar GTLT = R++\nsrc[GTLT] = '((?:<|>)?=?)'\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\nvar XRANGEIDENTIFIERLOOSE = R++\nsrc[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\\\*'\nvar XRANGEIDENTIFIER = R++\nsrc[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\\\*'\n\nvar XRANGEPLAIN = R++\nsrc[XRANGEPLAIN] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:' + src[PRERELEASE] + ')?' +\n                   src[BUILD] + '?' +\n                   ')?)?'\n\nvar XRANGEPLAINLOOSE = R++\nsrc[XRANGEPLAINLOOSE] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:' + src[PRERELEASELOOSE] + ')?' +\n                        src[BUILD] + '?' +\n                        ')?)?'\n\nvar XRANGE = R++\nsrc[XRANGE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAIN] + '$'\nvar XRANGELOOSE = R++\nsrc[XRANGELOOSE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAINLOOSE] + '$'\n\n// Coercion.\n// Extract anything that could conceivably be a part of a valid semver\nvar COERCE = R++\nsrc[COERCE] = '(?:^|[^\\\\d])' +\n              '(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +\n              '(?:\\\\.(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +\n              '(?:\\\\.(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +\n              '(?:$|[^\\\\d])'\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\nvar LONETILDE = R++\nsrc[LONETILDE] = '(?:~>?)'\n\nvar TILDETRIM = R++\nsrc[TILDETRIM] = '(\\\\s*)' + src[LONETILDE] + '\\\\s+'\nre[TILDETRIM] = new RegExp(src[TILDETRIM], 'g')\nvar tildeTrimReplace = '$1~'\n\nvar TILDE = R++\nsrc[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$'\nvar TILDELOOSE = R++\nsrc[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$'\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\nvar LONECARET = R++\nsrc[LONECARET] = '(?:\\\\^)'\n\nvar CARETTRIM = R++\nsrc[CARETTRIM] = '(\\\\s*)' + src[LONECARET] + '\\\\s+'\nre[CARETTRIM] = new RegExp(src[CARETTRIM], 'g')\nvar caretTrimReplace = '$1^'\n\nvar CARET = R++\nsrc[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$'\nvar CARETLOOSE = R++\nsrc[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$'\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\nvar COMPARATORLOOSE = R++\nsrc[COMPARATORLOOSE] = '^' + src[GTLT] + '\\\\s*(' + LOOSEPLAIN + ')$|^$'\nvar COMPARATOR = R++\nsrc[COMPARATOR] = '^' + src[GTLT] + '\\\\s*(' + FULLPLAIN + ')$|^$'\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\nvar COMPARATORTRIM = R++\nsrc[COMPARATORTRIM] = '(\\\\s*)' + src[GTLT] +\n                      '\\\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')'\n\n// this one has to use the /g flag\nre[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g')\nvar comparatorTrimReplace = '$1$2$3'\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\nvar HYPHENRANGE = R++\nsrc[HYPHENRANGE] = '^\\\\s*(' + src[XRANGEPLAIN] + ')' +\n                   '\\\\s+-\\\\s+' +\n                   '(' + src[XRANGEPLAIN] + ')' +\n                   '\\\\s*$'\n\nvar HYPHENRANGELOOSE = R++\nsrc[HYPHENRANGELOOSE] = '^\\\\s*(' + src[XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s+-\\\\s+' +\n                        '(' + src[XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s*$'\n\n// Star ranges basically just allow anything at all.\nvar STAR = R++\nsrc[STAR] = '(<|>)?=?\\\\s*\\\\*'\n\n// Compile to actual regexp objects.\n// All are flag-free, unless they were created above with a flag.\nfor (var i = 0; i < R; i++) {\n  debug(i, src[i])\n  if (!re[i]) {\n    re[i] = new RegExp(src[i])\n  }\n}\n\nexports.parse = parse\nfunction parse (version, options) {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    }\n  }\n\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  if (version.length > MAX_LENGTH) {\n    return null\n  }\n\n  var r = options.loose ? re[LOOSE] : re[FULL]\n  if (!r.test(version)) {\n    return null\n  }\n\n  try {\n    return new SemVer(version, options)\n  } catch (er) {\n    return null\n  }\n}\n\nexports.valid = valid\nfunction valid (version, options) {\n  var v = parse(version, options)\n  return v ? v.version : null\n}\n\nexports.clean = clean\nfunction clean (version, options) {\n  var s = parse(version.trim().replace(/^[=v]+/, ''), options)\n  return s ? s.version : null\n}\n\nexports.SemVer = SemVer\n\nfunction SemVer (version, options) {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    }\n  }\n  if (version instanceof SemVer) {\n    if (version.loose === options.loose) {\n      return version\n    } else {\n      version = version.version\n    }\n  } else if (typeof version !== 'string') {\n    throw new TypeError('Invalid Version: ' + version)\n  }\n\n  if (version.length > MAX_LENGTH) {\n    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')\n  }\n\n  if (!(this instanceof SemVer)) {\n    return new SemVer(version, options)\n  }\n\n  debug('SemVer', version, options)\n  this.options = options\n  this.loose = !!options.loose\n\n  var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL])\n\n  if (!m) {\n    throw new TypeError('Invalid Version: ' + version)\n  }\n\n  this.raw = version\n\n  // these are actually numbers\n  this.major = +m[1]\n  this.minor = +m[2]\n  this.patch = +m[3]\n\n  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n    throw new TypeError('Invalid major version')\n  }\n\n  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n    throw new TypeError('Invalid minor version')\n  }\n\n  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n    throw new TypeError('Invalid patch version')\n  }\n\n  // numberify any prerelease numeric ids\n  if (!m[4]) {\n    this.prerelease = []\n  } else {\n    this.prerelease = m[4].split('.').map(function (id) {\n      if (/^[0-9]+$/.test(id)) {\n        var num = +id\n        if (num >= 0 && num < MAX_SAFE_INTEGER) {\n          return num\n        }\n      }\n      return id\n    })\n  }\n\n  this.build = m[5] ? m[5].split('.') : []\n  this.format()\n}\n\nSemVer.prototype.format = function () {\n  this.version = this.major + '.' + this.minor + '.' + this.patch\n  if (this.prerelease.length) {\n    this.version += '-' + this.prerelease.join('.')\n  }\n  return this.version\n}\n\nSemVer.prototype.toString = function () {\n  return this.version\n}\n\nSemVer.prototype.compare = function (other) {\n  debug('SemVer.compare', this.version, this.options, other)\n  if (!(other instanceof SemVer)) {\n    other = new SemVer(other, this.options)\n  }\n\n  return this.compareMain(other) || this.comparePre(other)\n}\n\nSemVer.prototype.compareMain = function (other) {\n  if (!(other instanceof SemVer)) {\n    other = new SemVer(other, this.options)\n  }\n\n  return compareIdentifiers(this.major, other.major) ||\n         compareIdentifiers(this.minor, other.minor) ||\n         compareIdentifiers(this.patch, other.patch)\n}\n\nSemVer.prototype.comparePre = function (other) {\n  if (!(other instanceof SemVer)) {\n    other = new SemVer(other, this.options)\n  }\n\n  // NOT having a prerelease is > having one\n  if (this.prerelease.length && !other.prerelease.length) {\n    return -1\n  } else if (!this.prerelease.length && other.prerelease.length) {\n    return 1\n  } else if (!this.prerelease.length && !other.prerelease.length) {\n    return 0\n  }\n\n  var i = 0\n  do {\n    var a = this.prerelease[i]\n    var b = other.prerelease[i]\n    debug('prerelease compare', i, a, b)\n    if (a === undefined && b === undefined) {\n      return 0\n    } else if (b === undefined) {\n      return 1\n    } else if (a === undefined) {\n      return -1\n    } else if (a === b) {\n      continue\n    } else {\n      return compareIdentifiers(a, b)\n    }\n  } while (++i)\n}\n\n// preminor will bump the version up to the next minor release, and immediately\n// down to pre-release. premajor and prepatch work the same way.\nSemVer.prototype.inc = function (release, identifier) {\n  switch (release) {\n    case 'premajor':\n      this.prerelease.length = 0\n      this.patch = 0\n      this.minor = 0\n      this.major++\n      this.inc('pre', identifier)\n      break\n    case 'preminor':\n      this.prerelease.length = 0\n      this.patch = 0\n      this.minor++\n      this.inc('pre', identifier)\n      break\n    case 'prepatch':\n      // If this is already a prerelease, it will bump to the next version\n      // drop any prereleases that might already exist, since they are not\n      // relevant at this point.\n      this.prerelease.length = 0\n      this.inc('patch', identifier)\n      this.inc('pre', identifier)\n      break\n    // If the input is a non-prerelease version, this acts the same as\n    // prepatch.\n    case 'prerelease':\n      if (this.prerelease.length === 0) {\n        this.inc('patch', identifier)\n      }\n      this.inc('pre', identifier)\n      break\n\n    case 'major':\n      // If this is a pre-major version, bump up to the same major version.\n      // Otherwise increment major.\n      // 1.0.0-5 bumps to 1.0.0\n      // 1.1.0 bumps to 2.0.0\n      if (this.minor !== 0 ||\n          this.patch !== 0 ||\n          this.prerelease.length === 0) {\n        this.major++\n      }\n      this.minor = 0\n      this.patch = 0\n      this.prerelease = []\n      break\n    case 'minor':\n      // If this is a pre-minor version, bump up to the same minor version.\n      // Otherwise increment minor.\n      // 1.2.0-5 bumps to 1.2.0\n      // 1.2.1 bumps to 1.3.0\n      if (this.patch !== 0 || this.prerelease.length === 0) {\n        this.minor++\n      }\n      this.patch = 0\n      this.prerelease = []\n      break\n    case 'patch':\n      // If this is not a pre-release version, it will increment the patch.\n      // If it is a pre-release it will bump up to the same patch version.\n      // 1.2.0-5 patches to 1.2.0\n      // 1.2.0 patches to 1.2.1\n      if (this.prerelease.length === 0) {\n        this.patch++\n      }\n      this.prerelease = []\n      break\n    // This probably shouldn't be used publicly.\n    // 1.0.0 \"pre\" would become 1.0.0-0 which is the wrong direction.\n    case 'pre':\n      if (this.prerelease.length === 0) {\n        this.prerelease = [0]\n      } else {\n        var i = this.prerelease.length\n        while (--i >= 0) {\n          if (typeof this.prerelease[i] === 'number') {\n            this.prerelease[i]++\n            i = -2\n          }\n        }\n        if (i === -1) {\n          // didn't increment anything\n          this.prerelease.push(0)\n        }\n      }\n      if (identifier) {\n        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n        if (this.prerelease[0] === identifier) {\n          if (isNaN(this.prerelease[1])) {\n            this.prerelease = [identifier, 0]\n          }\n        } else {\n          this.prerelease = [identifier, 0]\n        }\n      }\n      break\n\n    default:\n      throw new Error('invalid increment argument: ' + release)\n  }\n  this.format()\n  this.raw = this.version\n  return this\n}\n\nexports.inc = inc\nfunction inc (version, release, loose, identifier) {\n  if (typeof (loose) === 'string') {\n    identifier = loose\n    loose = undefined\n  }\n\n  try {\n    return new SemVer(version, loose).inc(release, identifier).version\n  } catch (er) {\n    return null\n  }\n}\n\nexports.diff = diff\nfunction diff (version1, version2) {\n  if (eq(version1, version2)) {\n    return null\n  } else {\n    var v1 = parse(version1)\n    var v2 = parse(version2)\n    var prefix = ''\n    if (v1.prerelease.length || v2.prerelease.length) {\n      prefix = 'pre'\n      var defaultResult = 'prerelease'\n    }\n    for (var key in v1) {\n      if (key === 'major' || key === 'minor' || key === 'patch') {\n        if (v1[key] !== v2[key]) {\n          return prefix + key\n        }\n      }\n    }\n    return defaultResult // may be undefined\n  }\n}\n\nexports.compareIdentifiers = compareIdentifiers\n\nvar numeric = /^[0-9]+$/\nfunction compareIdentifiers (a, b) {\n  var anum = numeric.test(a)\n  var bnum = numeric.test(b)\n\n  if (anum && bnum) {\n    a = +a\n    b = +b\n  }\n\n  return a === b ? 0\n    : (anum && !bnum) ? -1\n    : (bnum && !anum) ? 1\n    : a < b ? -1\n    : 1\n}\n\nexports.rcompareIdentifiers = rcompareIdentifiers\nfunction rcompareIdentifiers (a, b) {\n  return compareIdentifiers(b, a)\n}\n\nexports.major = major\nfunction major (a, loose) {\n  return new SemVer(a, loose).major\n}\n\nexports.minor = minor\nfunction minor (a, loose) {\n  return new SemVer(a, loose).minor\n}\n\nexports.patch = patch\nfunction patch (a, loose) {\n  return new SemVer(a, loose).patch\n}\n\nexports.compare = compare\nfunction compare (a, b, loose) {\n  return new SemVer(a, loose).compare(new SemVer(b, loose))\n}\n\nexports.compareLoose = compareLoose\nfunction compareLoose (a, b) {\n  return compare(a, b, true)\n}\n\nexports.rcompare = rcompare\nfunction rcompare (a, b, loose) {\n  return compare(b, a, loose)\n}\n\nexports.sort = sort\nfunction sort (list, loose) {\n  return list.sort(function (a, b) {\n    return exports.compare(a, b, loose)\n  })\n}\n\nexports.rsort = rsort\nfunction rsort (list, loose) {\n  return list.sort(function (a, b) {\n    return exports.rcompare(a, b, loose)\n  })\n}\n\nexports.gt = gt\nfunction gt (a, b, loose) {\n  return compare(a, b, loose) > 0\n}\n\nexports.lt = lt\nfunction lt (a, b, loose) {\n  return compare(a, b, loose) < 0\n}\n\nexports.eq = eq\nfunction eq (a, b, loose) {\n  return compare(a, b, loose) === 0\n}\n\nexports.neq = neq\nfunction neq (a, b, loose) {\n  return compare(a, b, loose) !== 0\n}\n\nexports.gte = gte\nfunction gte (a, b, loose) {\n  return compare(a, b, loose) >= 0\n}\n\nexports.lte = lte\nfunction lte (a, b, loose) {\n  return compare(a, b, loose) <= 0\n}\n\nexports.cmp = cmp\nfunction cmp (a, op, b, loose) {\n  switch (op) {\n    case '===':\n      if (typeof a === 'object')\n        a = a.version\n      if (typeof b === 'object')\n        b = b.version\n      return a === b\n\n    case '!==':\n      if (typeof a === 'object')\n        a = a.version\n      if (typeof b === 'object')\n        b = b.version\n      return a !== b\n\n    case '':\n    case '=':\n    case '==':\n      return eq(a, b, loose)\n\n    case '!=':\n      return neq(a, b, loose)\n\n    case '>':\n      return gt(a, b, loose)\n\n    case '>=':\n      return gte(a, b, loose)\n\n    case '<':\n      return lt(a, b, loose)\n\n    case '<=':\n      return lte(a, b, loose)\n\n    default:\n      throw new TypeError('Invalid operator: ' + op)\n  }\n}\n\nexports.Comparator = Comparator\nfunction Comparator (comp, options) {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    }\n  }\n\n  if (comp instanceof Comparator) {\n    if (comp.loose === !!options.loose) {\n      return comp\n    } else {\n      comp = comp.value\n    }\n  }\n\n  if (!(this instanceof Comparator)) {\n    return new Comparator(comp, options)\n  }\n\n  debug('comparator', comp, options)\n  this.options = options\n  this.loose = !!options.loose\n  this.parse(comp)\n\n  if (this.semver === ANY) {\n    this.value = ''\n  } else {\n    this.value = this.operator + this.semver.version\n  }\n\n  debug('comp', this)\n}\n\nvar ANY = {}\nComparator.prototype.parse = function (comp) {\n  var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR]\n  var m = comp.match(r)\n\n  if (!m) {\n    throw new TypeError('Invalid comparator: ' + comp)\n  }\n\n  this.operator = m[1]\n  if (this.operator === '=') {\n    this.operator = ''\n  }\n\n  // if it literally is just '>' or '' then allow anything.\n  if (!m[2]) {\n    this.semver = ANY\n  } else {\n    this.semver = new SemVer(m[2], this.options.loose)\n  }\n}\n\nComparator.prototype.toString = function () {\n  return this.value\n}\n\nComparator.prototype.test = function (version) {\n  debug('Comparator.test', version, this.options.loose)\n\n  if (this.semver === ANY) {\n    return true\n  }\n\n  if (typeof version === 'string') {\n    version = new SemVer(version, this.options)\n  }\n\n  return cmp(version, this.operator, this.semver, this.options)\n}\n\nComparator.prototype.intersects = function (comp, options) {\n  if (!(comp instanceof Comparator)) {\n    throw new TypeError('a Comparator is required')\n  }\n\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    }\n  }\n\n  var rangeTmp\n\n  if (this.operator === '') {\n    rangeTmp = new Range(comp.value, options)\n    return satisfies(this.value, rangeTmp, options)\n  } else if (comp.operator === '') {\n    rangeTmp = new Range(this.value, options)\n    return satisfies(comp.semver, rangeTmp, options)\n  }\n\n  var sameDirectionIncreasing =\n    (this.operator === '>=' || this.operator === '>') &&\n    (comp.operator === '>=' || comp.operator === '>')\n  var sameDirectionDecreasing =\n    (this.operator === '<=' || this.operator === '<') &&\n    (comp.operator === '<=' || comp.operator === '<')\n  var sameSemVer = this.semver.version === comp.semver.version\n  var differentDirectionsInclusive =\n    (this.operator === '>=' || this.operator === '<=') &&\n    (comp.operator === '>=' || comp.operator === '<=')\n  var oppositeDirectionsLessThan =\n    cmp(this.semver, '<', comp.semver, options) &&\n    ((this.operator === '>=' || this.operator === '>') &&\n    (comp.operator === '<=' || comp.operator === '<'))\n  var oppositeDirectionsGreaterThan =\n    cmp(this.semver, '>', comp.semver, options) &&\n    ((this.operator === '<=' || this.operator === '<') &&\n    (comp.operator === '>=' || comp.operator === '>'))\n\n  return sameDirectionIncreasing || sameDirectionDecreasing ||\n    (sameSemVer && differentDirectionsInclusive) ||\n    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan\n}\n\nexports.Range = Range\nfunction Range (range, options) {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    }\n  }\n\n  if (range instanceof Range) {\n    if (range.loose === !!options.loose &&\n        range.includePrerelease === !!options.includePrerelease) {\n      return range\n    } else {\n      return new Range(range.raw, options)\n    }\n  }\n\n  if (range instanceof Comparator) {\n    return new Range(range.value, options)\n  }\n\n  if (!(this instanceof Range)) {\n    return new Range(range, options)\n  }\n\n  this.options = options\n  this.loose = !!options.loose\n  this.includePrerelease = !!options.includePrerelease\n\n  // First, split based on boolean or ||\n  this.raw = range\n  this.set = range.split(/\\s*\\|\\|\\s*/).map(function (range) {\n    return this.parseRange(range.trim())\n  }, this).filter(function (c) {\n    // throw out any that are not relevant for whatever reason\n    return c.length\n  })\n\n  if (!this.set.length) {\n    throw new TypeError('Invalid SemVer Range: ' + range)\n  }\n\n  this.format()\n}\n\nRange.prototype.format = function () {\n  this.range = this.set.map(function (comps) {\n    return comps.join(' ').trim()\n  }).join('||').trim()\n  return this.range\n}\n\nRange.prototype.toString = function () {\n  return this.range\n}\n\nRange.prototype.parseRange = function (range) {\n  var loose = this.options.loose\n  range = range.trim()\n  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE]\n  range = range.replace(hr, hyphenReplace)\n  debug('hyphen replace', range)\n  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace)\n  debug('comparator trim', range, re[COMPARATORTRIM])\n\n  // `~ 1.2.3` => `~1.2.3`\n  range = range.replace(re[TILDETRIM], tildeTrimReplace)\n\n  // `^ 1.2.3` => `^1.2.3`\n  range = range.replace(re[CARETTRIM], caretTrimReplace)\n\n  // normalize spaces\n  range = range.split(/\\s+/).join(' ')\n\n  // At this point, the range is completely trimmed and\n  // ready to be split into comparators.\n\n  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR]\n  var set = range.split(' ').map(function (comp) {\n    return parseComparator(comp, this.options)\n  }, this).join(' ').split(/\\s+/)\n  if (this.options.loose) {\n    // in loose mode, throw out any that are not valid comparators\n    set = set.filter(function (comp) {\n      return !!comp.match(compRe)\n    })\n  }\n  set = set.map(function (comp) {\n    return new Comparator(comp, this.options)\n  }, this)\n\n  return set\n}\n\nRange.prototype.intersects = function (range, options) {\n  if (!(range instanceof Range)) {\n    throw new TypeError('a Range is required')\n  }\n\n  return this.set.some(function (thisComparators) {\n    return thisComparators.every(function (thisComparator) {\n      return range.set.some(function (rangeComparators) {\n        return rangeComparators.every(function (rangeComparator) {\n          return thisComparator.intersects(rangeComparator, options)\n        })\n      })\n    })\n  })\n}\n\n// Mostly just for testing and legacy API reasons\nexports.toComparators = toComparators\nfunction toComparators (range, options) {\n  return new Range(range, options).set.map(function (comp) {\n    return comp.map(function (c) {\n      return c.value\n    }).join(' ').trim().split(' ')\n  })\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nfunction parseComparator (comp, options) {\n  debug('comp', comp, options)\n  comp = replaceCarets(comp, options)\n  debug('caret', comp)\n  comp = replaceTildes(comp, options)\n  debug('tildes', comp)\n  comp = replaceXRanges(comp, options)\n  debug('xrange', comp)\n  comp = replaceStars(comp, options)\n  debug('stars', comp)\n  return comp\n}\n\nfunction isX (id) {\n  return !id || id.toLowerCase() === 'x' || id === '*'\n}\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0\nfunction replaceTildes (comp, options) {\n  return comp.trim().split(/\\s+/).map(function (comp) {\n    return replaceTilde(comp, options)\n  }).join(' ')\n}\n\nfunction replaceTilde (comp, options) {\n  var r = options.loose ? re[TILDELOOSE] : re[TILDE]\n  return comp.replace(r, function (_, M, m, p, pr) {\n    debug('tilde', comp, _, M, m, p, pr)\n    var ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'\n    } else if (isX(p)) {\n      // ~1.2 == >=1.2.0 <1.3.0\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'\n    } else if (pr) {\n      debug('replaceTilde pr', pr)\n      ret = '>=' + M + '.' + m + '.' + p + '-' + pr +\n            ' <' + M + '.' + (+m + 1) + '.0'\n    } else {\n      // ~1.2.3 == >=1.2.3 <1.3.0\n      ret = '>=' + M + '.' + m + '.' + p +\n            ' <' + M + '.' + (+m + 1) + '.0'\n    }\n\n    debug('tilde return', ret)\n    return ret\n  })\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0\n// ^1.2.3 --> >=1.2.3 <2.0.0\n// ^1.2.0 --> >=1.2.0 <2.0.0\nfunction replaceCarets (comp, options) {\n  return comp.trim().split(/\\s+/).map(function (comp) {\n    return replaceCaret(comp, options)\n  }).join(' ')\n}\n\nfunction replaceCaret (comp, options) {\n  debug('caret', comp, options)\n  var r = options.loose ? re[CARETLOOSE] : re[CARET]\n  return comp.replace(r, function (_, M, m, p, pr) {\n    debug('caret', comp, _, M, m, p, pr)\n    var ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'\n    } else if (isX(p)) {\n      if (M === '0') {\n        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'\n      } else {\n        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0'\n      }\n    } else if (pr) {\n      debug('replaceCaret pr', pr)\n      if (M === '0') {\n        if (m === '0') {\n          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +\n                ' <' + M + '.' + m + '.' + (+p + 1)\n        } else {\n          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +\n                ' <' + M + '.' + (+m + 1) + '.0'\n        }\n      } else {\n        ret = '>=' + M + '.' + m + '.' + p + '-' + pr +\n              ' <' + (+M + 1) + '.0.0'\n      }\n    } else {\n      debug('no pr')\n      if (M === '0') {\n        if (m === '0') {\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + m + '.' + (+p + 1)\n        } else {\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + (+m + 1) + '.0'\n        }\n      } else {\n        ret = '>=' + M + '.' + m + '.' + p +\n              ' <' + (+M + 1) + '.0.0'\n      }\n    }\n\n    debug('caret return', ret)\n    return ret\n  })\n}\n\nfunction replaceXRanges (comp, options) {\n  debug('replaceXRanges', comp, options)\n  return comp.split(/\\s+/).map(function (comp) {\n    return replaceXRange(comp, options)\n  }).join(' ')\n}\n\nfunction replaceXRange (comp, options) {\n  comp = comp.trim()\n  var r = options.loose ? re[XRANGELOOSE] : re[XRANGE]\n  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr)\n    var xM = isX(M)\n    var xm = xM || isX(m)\n    var xp = xm || isX(p)\n    var anyX = xp\n\n    if (gtlt === '=' && anyX) {\n      gtlt = ''\n    }\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0'\n      } else {\n        // nothing is forbidden\n        ret = '*'\n      }\n    } else if (gtlt && anyX) {\n      // we know patch is an x, because we have any x at all.\n      // replace X with 0\n      if (xm) {\n        m = 0\n      }\n      p = 0\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        // >1.2.3 => >= 1.2.4\n        gtlt = '>='\n        if (xm) {\n          M = +M + 1\n          m = 0\n          p = 0\n        } else {\n          m = +m + 1\n          p = 0\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<'\n        if (xm) {\n          M = +M + 1\n        } else {\n          m = +m + 1\n        }\n      }\n\n      ret = gtlt + M + '.' + m + '.' + p\n    } else if (xm) {\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'\n    } else if (xp) {\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'\n    }\n\n    debug('xRange return', ret)\n\n    return ret\n  })\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nfunction replaceStars (comp, options) {\n  debug('replaceStars', comp, options)\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp.trim().replace(re[STAR], '')\n}\n\n// This function is passed to string.replace(re[HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0\nfunction hyphenReplace ($0,\n  from, fM, fm, fp, fpr, fb,\n  to, tM, tm, tp, tpr, tb) {\n  if (isX(fM)) {\n    from = ''\n  } else if (isX(fm)) {\n    from = '>=' + fM + '.0.0'\n  } else if (isX(fp)) {\n    from = '>=' + fM + '.' + fm + '.0'\n  } else {\n    from = '>=' + from\n  }\n\n  if (isX(tM)) {\n    to = ''\n  } else if (isX(tm)) {\n    to = '<' + (+tM + 1) + '.0.0'\n  } else if (isX(tp)) {\n    to = '<' + tM + '.' + (+tm + 1) + '.0'\n  } else if (tpr) {\n    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr\n  } else {\n    to = '<=' + to\n  }\n\n  return (from + ' ' + to).trim()\n}\n\n// if ANY of the sets match ALL of its comparators, then pass\nRange.prototype.test = function (version) {\n  if (!version) {\n    return false\n  }\n\n  if (typeof version === 'string') {\n    version = new SemVer(version, this.options)\n  }\n\n  for (var i = 0; i < this.set.length; i++) {\n    if (testSet(this.set[i], version, this.options)) {\n      return true\n    }\n  }\n  return false\n}\n\nfunction testSet (set, version, options) {\n  for (var i = 0; i < set.length; i++) {\n    if (!set[i].test(version)) {\n      return false\n    }\n  }\n\n  if (version.prerelease.length && !options.includePrerelease) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (i = 0; i < set.length; i++) {\n      debug(set[i].semver)\n      if (set[i].semver === ANY) {\n        continue\n      }\n\n      if (set[i].semver.prerelease.length > 0) {\n        var allowed = set[i].semver\n        if (allowed.major === version.major &&\n            allowed.minor === version.minor &&\n            allowed.patch === version.patch) {\n          return true\n        }\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false\n  }\n\n  return true\n}\n\nexports.satisfies = satisfies\nfunction satisfies (version, range, options) {\n  try {\n    range = new Range(range, options)\n  } catch (er) {\n    return false\n  }\n  return range.test(version)\n}\n\nexports.maxSatisfying = maxSatisfying\nfunction maxSatisfying (versions, range, options) {\n  var max = null\n  var maxSV = null\n  try {\n    var rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach(function (v) {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!max || maxSV.compare(v) === -1) {\n        // compare(max, v, true)\n        max = v\n        maxSV = new SemVer(max, options)\n      }\n    }\n  })\n  return max\n}\n\nexports.minSatisfying = minSatisfying\nfunction minSatisfying (versions, range, options) {\n  var min = null\n  var minSV = null\n  try {\n    var rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach(function (v) {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!min || minSV.compare(v) === 1) {\n        // compare(min, v, true)\n        min = v\n        minSV = new SemVer(min, options)\n      }\n    }\n  })\n  return min\n}\n\nexports.minVersion = minVersion\nfunction minVersion (range, loose) {\n  range = new Range(range, loose)\n\n  var minver = new SemVer('0.0.0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = new SemVer('0.0.0-0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = null\n  for (var i = 0; i < range.set.length; ++i) {\n    var comparators = range.set[i]\n\n    comparators.forEach(function (comparator) {\n      // Clone to avoid manipulating the comparator's semver object.\n      var compver = new SemVer(comparator.semver.version)\n      switch (comparator.operator) {\n        case '>':\n          if (compver.prerelease.length === 0) {\n            compver.patch++\n          } else {\n            compver.prerelease.push(0)\n          }\n          compver.raw = compver.format()\n          /* fallthrough */\n        case '':\n        case '>=':\n          if (!minver || gt(minver, compver)) {\n            minver = compver\n          }\n          break\n        case '<':\n        case '<=':\n          /* Ignore maximum versions */\n          break\n        /* istanbul ignore next */\n        default:\n          throw new Error('Unexpected operation: ' + comparator.operator)\n      }\n    })\n  }\n\n  if (minver && range.test(minver)) {\n    return minver\n  }\n\n  return null\n}\n\nexports.validRange = validRange\nfunction validRange (range, options) {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, options).range || '*'\n  } catch (er) {\n    return null\n  }\n}\n\n// Determine if version is less than all the versions possible in the range\nexports.ltr = ltr\nfunction ltr (version, range, options) {\n  return outside(version, range, '<', options)\n}\n\n// Determine if version is greater than all the versions possible in the range.\nexports.gtr = gtr\nfunction gtr (version, range, options) {\n  return outside(version, range, '>', options)\n}\n\nexports.outside = outside\nfunction outside (version, range, hilo, options) {\n  version = new SemVer(version, options)\n  range = new Range(range, options)\n\n  var gtfn, ltefn, ltfn, comp, ecomp\n  switch (hilo) {\n    case '>':\n      gtfn = gt\n      ltefn = lte\n      ltfn = lt\n      comp = '>'\n      ecomp = '>='\n      break\n    case '<':\n      gtfn = lt\n      ltefn = gte\n      ltfn = gt\n      comp = '<'\n      ecomp = '<='\n      break\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"')\n  }\n\n  // If it satisifes the range it is not outside\n  if (satisfies(version, range, options)) {\n    return false\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (var i = 0; i < range.set.length; ++i) {\n    var comparators = range.set[i]\n\n    var high = null\n    var low = null\n\n    comparators.forEach(function (comparator) {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator('>=0.0.0')\n      }\n      high = high || comparator\n      low = low || comparator\n      if (gtfn(comparator.semver, high.semver, options)) {\n        high = comparator\n      } else if (ltfn(comparator.semver, low.semver, options)) {\n        low = comparator\n      }\n    })\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false\n    }\n  }\n  return true\n}\n\nexports.prerelease = prerelease\nfunction prerelease (version, options) {\n  var parsed = parse(version, options)\n  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null\n}\n\nexports.intersects = intersects\nfunction intersects (r1, r2, options) {\n  r1 = new Range(r1, options)\n  r2 = new Range(r2, options)\n  return r1.intersects(r2)\n}\n\nexports.coerce = coerce\nfunction coerce (version) {\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  var match = version.match(re[COERCE])\n\n  if (match == null) {\n    return null\n  }\n\n  return parse(match[1] +\n    '.' + (match[2] || '0') +\n    '.' + (match[3] || '0'))\n}\n","module.exports = function (blocking) {\n  [process.stdout, process.stderr].forEach(function (stream) {\n    if (stream._handle && stream.isTTY && typeof stream._handle.setBlocking === 'function') {\n      stream._handle.setBlocking(blocking)\n    }\n  })\n}\n","'use strict'\n\nfunction isFunction (funktion) {\n  return typeof funktion === 'function'\n}\n\n// Default to complaining loudly when things don't go according to plan.\nvar logger = console.error.bind(console)\n\n// Sets a property on an object, preserving its enumerability.\n// This function assumes that the property is already writable.\nfunction defineProperty (obj, name, value) {\n  var enumerable = !!obj[name] && obj.propertyIsEnumerable(name)\n  Object.defineProperty(obj, name, {\n    configurable: true,\n    enumerable: enumerable,\n    writable: true,\n    value: value\n  })\n}\n\n// Keep initialization idempotent.\nfunction shimmer (options) {\n  if (options && options.logger) {\n    if (!isFunction(options.logger)) logger(\"new logger isn't a function, not replacing\")\n    else logger = options.logger\n  }\n}\n\nfunction wrap (nodule, name, wrapper) {\n  if (!nodule || !nodule[name]) {\n    logger('no original function ' + name + ' to wrap')\n    return\n  }\n\n  if (!wrapper) {\n    logger('no wrapper function')\n    logger((new Error()).stack)\n    return\n  }\n\n  if (!isFunction(nodule[name]) || !isFunction(wrapper)) {\n    logger('original object and wrapper must be functions')\n    return\n  }\n\n  var original = nodule[name]\n  var wrapped = wrapper(original, name)\n\n  defineProperty(wrapped, '__original', original)\n  defineProperty(wrapped, '__unwrap', function () {\n    if (nodule[name] === wrapped) defineProperty(nodule, name, original)\n  })\n  defineProperty(wrapped, '__wrapped', true)\n\n  defineProperty(nodule, name, wrapped)\n  return wrapped\n}\n\nfunction massWrap (nodules, names, wrapper) {\n  if (!nodules) {\n    logger('must provide one or more modules to patch')\n    logger((new Error()).stack)\n    return\n  } else if (!Array.isArray(nodules)) {\n    nodules = [nodules]\n  }\n\n  if (!(names && Array.isArray(names))) {\n    logger('must provide one or more functions to wrap on modules')\n    return\n  }\n\n  nodules.forEach(function (nodule) {\n    names.forEach(function (name) {\n      wrap(nodule, name, wrapper)\n    })\n  })\n}\n\nfunction unwrap (nodule, name) {\n  if (!nodule || !nodule[name]) {\n    logger('no function to unwrap.')\n    logger((new Error()).stack)\n    return\n  }\n\n  if (!nodule[name].__unwrap) {\n    logger('no original to unwrap to -- has ' + name + ' already been unwrapped?')\n  } else {\n    return nodule[name].__unwrap()\n  }\n}\n\nfunction massUnwrap (nodules, names) {\n  if (!nodules) {\n    logger('must provide one or more modules to patch')\n    logger((new Error()).stack)\n    return\n  } else if (!Array.isArray(nodules)) {\n    nodules = [nodules]\n  }\n\n  if (!(names && Array.isArray(names))) {\n    logger('must provide one or more functions to unwrap on modules')\n    return\n  }\n\n  nodules.forEach(function (nodule) {\n    names.forEach(function (name) {\n      unwrap(nodule, name)\n    })\n  })\n}\n\nshimmer.wrap = wrap\nshimmer.massWrap = massWrap\nshimmer.unwrap = unwrap\nshimmer.massUnwrap = massUnwrap\n\nmodule.exports = shimmer\n","// Note: since nyc uses this module to output coverage, any lines\n// that are in the direct sync flow of nyc's outputCoverage are\n// ignored, since we can never get coverage for them.\nvar assert = require('assert')\nvar signals = require('./signals.js')\nvar isWin = /^win/i.test(process.platform)\n\nvar EE = require('events')\n/* istanbul ignore if */\nif (typeof EE !== 'function') {\n  EE = EE.EventEmitter\n}\n\nvar emitter\nif (process.__signal_exit_emitter__) {\n  emitter = process.__signal_exit_emitter__\n} else {\n  emitter = process.__signal_exit_emitter__ = new EE()\n  emitter.count = 0\n  emitter.emitted = {}\n}\n\n// Because this emitter is a global, we have to check to see if a\n// previous version of this library failed to enable infinite listeners.\n// I know what you're about to say.  But literally everything about\n// signal-exit is a compromise with evil.  Get used to it.\nif (!emitter.infinite) {\n  emitter.setMaxListeners(Infinity)\n  emitter.infinite = true\n}\n\nmodule.exports = function (cb, opts) {\n  assert.equal(typeof cb, 'function', 'a callback must be provided for exit handler')\n\n  if (loaded === false) {\n    load()\n  }\n\n  var ev = 'exit'\n  if (opts && opts.alwaysLast) {\n    ev = 'afterexit'\n  }\n\n  var remove = function () {\n    emitter.removeListener(ev, cb)\n    if (emitter.listeners('exit').length === 0 &&\n        emitter.listeners('afterexit').length === 0) {\n      unload()\n    }\n  }\n  emitter.on(ev, cb)\n\n  return remove\n}\n\nmodule.exports.unload = unload\nfunction unload () {\n  if (!loaded) {\n    return\n  }\n  loaded = false\n\n  signals.forEach(function (sig) {\n    try {\n      process.removeListener(sig, sigListeners[sig])\n    } catch (er) {}\n  })\n  process.emit = originalProcessEmit\n  process.reallyExit = originalProcessReallyExit\n  emitter.count -= 1\n}\n\nfunction emit (event, code, signal) {\n  if (emitter.emitted[event]) {\n    return\n  }\n  emitter.emitted[event] = true\n  emitter.emit(event, code, signal)\n}\n\n// { <signal>: <listener fn>, ... }\nvar sigListeners = {}\nsignals.forEach(function (sig) {\n  sigListeners[sig] = function listener () {\n    // If there are no other listeners, an exit is coming!\n    // Simplest way: remove us and then re-send the signal.\n    // We know that this will kill the process, so we can\n    // safely emit now.\n    var listeners = process.listeners(sig)\n    if (listeners.length === emitter.count) {\n      unload()\n      emit('exit', null, sig)\n      /* istanbul ignore next */\n      emit('afterexit', null, sig)\n      /* istanbul ignore next */\n      if (isWin && sig === 'SIGHUP') {\n        // \"SIGHUP\" throws an `ENOSYS` error on Windows,\n        // so use a supported signal instead\n        sig = 'SIGINT'\n      }\n      process.kill(process.pid, sig)\n    }\n  }\n})\n\nmodule.exports.signals = function () {\n  return signals\n}\n\nmodule.exports.load = load\n\nvar loaded = false\n\nfunction load () {\n  if (loaded) {\n    return\n  }\n  loaded = true\n\n  // This is the number of onSignalExit's that are in play.\n  // It's important so that we can count the correct number of\n  // listeners on signals, and don't wait for the other one to\n  // handle it instead of us.\n  emitter.count += 1\n\n  signals = signals.filter(function (sig) {\n    try {\n      process.on(sig, sigListeners[sig])\n      return true\n    } catch (er) {\n      return false\n    }\n  })\n\n  process.emit = processEmit\n  process.reallyExit = processReallyExit\n}\n\nvar originalProcessReallyExit = process.reallyExit\nfunction processReallyExit (code) {\n  process.exitCode = code || 0\n  emit('exit', process.exitCode, null)\n  /* istanbul ignore next */\n  emit('afterexit', process.exitCode, null)\n  /* istanbul ignore next */\n  originalProcessReallyExit.call(process, process.exitCode)\n}\n\nvar originalProcessEmit = process.emit\nfunction processEmit (ev, arg) {\n  if (ev === 'exit') {\n    if (arg !== undefined) {\n      process.exitCode = arg\n    }\n    var ret = originalProcessEmit.apply(this, arguments)\n    emit('exit', process.exitCode, null)\n    /* istanbul ignore next */\n    emit('afterexit', process.exitCode, null)\n    return ret\n  } else {\n    return originalProcessEmit.apply(this, arguments)\n  }\n}\n","// This is not the set of all possible signals.\n//\n// It IS, however, the set of all signals that trigger\n// an exit on either Linux or BSD systems.  Linux is a\n// superset of the signal names supported on BSD, and\n// the unknown signals just fail to register, so we can\n// catch that easily enough.\n//\n// Don't bother with SIGKILL.  It's uncatchable, which\n// means that we can't fire any callbacks anyway.\n//\n// If a user does happen to register a handler on a non-\n// fatal signal like SIGWINCH or something, and then\n// exit, it'll end up firing `process.emit('exit')`, so\n// the handler will be fired anyway.\n//\n// SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised\n// artificially, inherently leave the process in a\n// state from which it is not safe to try and enter JS\n// listeners.\nmodule.exports = [\n  'SIGABRT',\n  'SIGALRM',\n  'SIGHUP',\n  'SIGINT',\n  'SIGTERM'\n]\n\nif (process.platform !== 'win32') {\n  module.exports.push(\n    'SIGVTALRM',\n    'SIGXCPU',\n    'SIGXFSZ',\n    'SIGUSR2',\n    'SIGTRAP',\n    'SIGSYS',\n    'SIGQUIT',\n    'SIGIOT'\n    // should detect profiler and enable/disable accordingly.\n    // see #21\n    // 'SIGPROF'\n  )\n}\n\nif (process.platform === 'linux') {\n  module.exports.push(\n    'SIGIO',\n    'SIGPOLL',\n    'SIGPWR',\n    'SIGSTKFLT',\n    'SIGUNUSED'\n  )\n}\n","// Copyright 2012 the V8 project authors. All rights reserved.\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n//       copyright notice, this list of conditions and the following\n//       disclaimer in the documentation and/or other materials provided\n//       with the distribution.\n//     * Neither the name of Google Inc. nor the names of its\n//       contributors may be used to endorse or promote products derived\n//       from this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nfunction FormatErrorString(error) {\n  try {\n    return Error.prototype.toString.call(error);\n  } catch (e) {\n    try {\n      return \"<error: \" + e + \">\";\n    } catch (ee) {\n      return \"<error>\";\n    }\n  }\n}\n\nmodule.exports = function FormatStackTrace(error, frames) {\n  var lines = [];\n  lines.push(FormatErrorString(error));\n  for (var i = 0; i < frames.length; i++) {\n    var frame = frames[i];\n    var line;\n    try {\n      line = frame.toString();\n    } catch (e) {\n      try {\n        line = \"<error: \" + e + \">\";\n      } catch (ee) {\n        // Any code that reaches this point is seriously nasty!\n        line = \"<error>\";\n      }\n    }\n    lines.push(\"    at \" + line);\n  }\n  return lines.join(\"\\n\");\n};\n","// If a another copy (same version or not) of stack-chain exists it will result\n// in wrong stack traces (most likely dublicate callSites).\nif (global._stackChain) {\n  // In case the version match, we can simply return the first initialized copy\n  if (global._stackChain.version === require('./package.json').version) {\n    module.exports = global._stackChain;\n  }\n  // The version don't match, this is really bad. Lets just throw\n  else {\n    throw new Error('Conflicting version of stack-chain found');\n  }\n}\n// Yay, no other stack-chain copy exists, yet :/\nelse {\n  module.exports = global._stackChain = require('./stack-chain');\n}\n","\n// use a already existing formater or fallback to the default v8 formater\nvar defaultFormater = require('./format.js');\n\n// public define API\nfunction stackChain() {\n  this.extend = new TraceModifier();\n  this.filter = new TraceModifier();\n  this.format = new StackFormater();\n  this.version = require('./package.json').version;\n}\n\n\nvar SHORTCIRCUIT_CALLSITE = false;\nstackChain.prototype.callSite = function collectCallSites(options) {\n  if (!options) options = {};\n\n  // Get CallSites\n  SHORTCIRCUIT_CALLSITE = true;\n  var obj = {};\n  Error.captureStackTrace(obj, collectCallSites);\n  var callSites = obj.stack;\n  SHORTCIRCUIT_CALLSITE = false;\n\n  // Slice\n  callSites = callSites.slice(options.slice || 0);\n\n  // Modify CallSites\n  if (options.extend) callSites = this.extend._modify(obj, callSites);\n  if (options.filter) callSites = this.filter._modify(obj, callSites);\n\n  // Done\n  return callSites;\n};\n\nvar chain = new stackChain();\n\nfunction TraceModifier() {\n  this._modifiers = [];\n}\n\nTraceModifier.prototype._modify = function (error, frames) {\n  for (var i = 0, l = this._modifiers.length; i < l; i++) {\n    frames = this._modifiers[i](error, frames);\n  }\n\n  return frames;\n};\n\nTraceModifier.prototype.attach = function (modifier) {\n  this._modifiers.push(modifier);\n};\n\nTraceModifier.prototype.deattach = function (modifier) {\n  var index = this._modifiers.indexOf(modifier);\n\n  if (index === -1) return false;\n\n  this._modifiers.splice(index, 1);\n  return true;\n};\n\nfunction StackFormater() {\n  this._formater = defaultFormater;\n  this._previous = undefined;\n}\n\nStackFormater.prototype.replace = function (formater) {\n  if (formater) {\n    this._formater = formater;\n  } else {\n    this.restore();\n  }\n};\n\nStackFormater.prototype.restore  = function () {\n  this._formater = defaultFormater;\n  this._previous = undefined;\n};\n\nStackFormater.prototype._backup = function () {\n  this._previous = this._formater;\n};\n\nStackFormater.prototype._roolback = function () {\n  if (this._previous === defaultFormater) {\n    this.replace(undefined);\n  } else {\n    this.replace(this._previous);\n  }\n\n  this._previous = undefined;\n};\n\n\n//\n// Set Error.prepareStackTrace thus allowing stack-chain\n// to take control of the Error().stack formating.\n//\n\n// If there already is a custom stack formater, then set\n// that as the stack-chain formater.\nif (Error.prepareStackTrace) {\n    chain.format.replace(Error.prepareStackTrace);\n}\n\nvar SHORTCIRCUIT_FORMATER = false;\nfunction prepareStackTrace(error, originalFrames) {\n  if (SHORTCIRCUIT_CALLSITE) return originalFrames;\n  if (SHORTCIRCUIT_FORMATER) return defaultFormater(error, originalFrames);\n\n  // Make a loss copy of originalFrames\n  var frames = originalFrames.concat();\n\n  // extend frames\n  frames = chain.extend._modify(error, frames);\n\n  // filter frames\n  frames = chain.filter._modify(error, frames);\n\n  // reduce frames to match Error.stackTraceLimit\n  frames = frames.slice(0, Error.stackTraceLimit);\n\n  // Set the callSite property\n  // But only if it hasn't been explicitly set, otherwise\n  // error.stack would have unintended side effects. Check also for\n  // non-extensible/sealed objects, such as those from Google's Closure Library\n  if (Object.isExtensible(error) &&\n      (Object.getOwnPropertyDescriptor(error, \"callSite\") === undefined)) {\n    error.callSite = {\n      original: originalFrames,\n      mutated: frames\n    };\n  }\n\n  // format frames\n  SHORTCIRCUIT_FORMATER = true;\n  var format = chain.format._formater(error, frames);\n  SHORTCIRCUIT_FORMATER = false;\n\n  return format;\n}\n\n// Replace the v8 stack trace creator\nObject.defineProperty(Error, 'prepareStackTrace', {\n  'get': function () {\n    return prepareStackTrace;\n  },\n\n  'set': function (formater) {\n    // If formater is prepareStackTrace it means that someone ran\n    // var old = Error.prepareStackTrace;\n    // Error.prepareStackTrace = custom\n    // new Error().stack\n    // Error.prepareStackTrace = old;\n    // The effect of this, should be that the old behaviour is restored.\n    if (formater === prepareStackTrace) {\n      chain.format._roolback();\n    }\n    // Error.prepareStackTrace was set, this means that someone is\n    // trying to take control of the Error().stack format. Make\n    // them belive they succeeded by setting them up as the stack-chain\n    // formater.\n    else {\n      chain.format._backup();\n      chain.format.replace(formater);\n    }\n  }\n});\n\n//\n// Manage call site storeage\n//\nfunction callSiteGetter() {\n  // calculate call site object\n  this.stack;\n\n  // return call site object\n  return this.callSite;\n}\n\nObject.defineProperty(Error.prototype, 'callSite', {\n  'get': callSiteGetter,\n\n  'set': function (frames) {\n    // In case callSite was set before [[getter]], just set\n    // the value\n    Object.defineProperty(this, 'callSite', {\n        value: frames,\n        writable: true,\n        configurable: true\n    });\n  },\n\n  configurable: true\n});\n\nmodule.exports = chain;\n","var Node = {\n  child: require('child_process'),\n  crypto: require('crypto'),\n  fs: require('fs'),\n  os: require('os'),\n  path: require('path'),\n  process: process,\n  util: require('util')\n};\n\nfunction Attempt(instance, end) {\n  var platform = Node.process.platform;\n  if (platform === 'darwin') return Mac(instance, end);\n  if (platform === 'linux') return Linux(instance, end);\n  if (platform === 'win32') return Windows(instance, end);\n  end(new Error('Platform not yet supported.'));\n}\n\nfunction EscapeDoubleQuotes(string) {\n  if (typeof string !== 'string') throw new Error('Expected a string.');\n  return string.replace(/\"/g, '\\\\\"');\n}\n\nfunction Exec() {\n  if (arguments.length < 1 || arguments.length > 3) {\n    throw new Error('Wrong number of arguments.');\n  }\n  var command = arguments[0];\n  var options = {};\n  var end = function() {};\n  if (typeof command !== 'string') {\n    throw new Error('Command should be a string.');\n  }\n  if (arguments.length === 2) {\n    if (Node.util.isObject(arguments[1])) {\n      options = arguments[1];\n    } else if (Node.util.isFunction(arguments[1])) {\n      end = arguments[1];\n    } else {\n      throw new Error('Expected options or callback.');\n    }\n  } else if (arguments.length === 3) {\n    if (Node.util.isObject(arguments[1])) {\n      options = arguments[1];\n    } else {\n      throw new Error('Expected options to be an object.');\n    }\n    if (Node.util.isFunction(arguments[2])) {\n      end = arguments[2];\n    } else {\n      throw new Error('Expected callback to be a function.');\n    }\n  }\n  if (/^sudo/i.test(command)) {\n    return end(new Error('Command should not be prefixed with \"sudo\".'));\n  }\n  if (typeof options.name === 'undefined') {\n    var title = Node.process.title;\n    if (ValidName(title)) {\n      options.name = title;\n    } else {\n      return end(new Error('process.title cannot be used as a valid name.'));\n    }\n  } else if (!ValidName(options.name)) {\n    var error = '';\n    error += 'options.name must be alphanumeric only ';\n    error += '(spaces are allowed) and <= 70 characters.';\n    return end(new Error(error));\n  }\n  if (typeof options.icns !== 'undefined') {\n    if (typeof options.icns !== 'string') {\n      return end(new Error('options.icns must be a string if provided.'));\n    } else if (options.icns.trim().length === 0) {\n      return end(new Error('options.icns must not be empty if provided.'));\n    }\n  }\n  if (typeof options.env !== 'undefined') {\n    if (typeof options.env !== 'object') {\n      return end(new Error('options.env must be an object if provided.'));\n    } else if (Object.keys(options.env).length === 0) {\n      return end(new Error('options.env must not be empty if provided.'));\n    } else {\n      for (var key in options.env) {\n        var value = options.env[key];\n        if (typeof key !== 'string' || typeof value !== 'string') {\n          return end(\n            new Error('options.env environment variables must be strings.')\n          );\n        }\n        // \"Environment variable names used by the utilities in the Shell and\n        // Utilities volume of IEEE Std 1003.1-2001 consist solely of uppercase\n        // letters, digits, and the '_' (underscore) from the characters defined\n        // in Portable Character Set and do not begin with a digit. Other\n        // characters may be permitted by an implementation; applications shall\n        // tolerate the presence of such names.\"\n        if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(key)) {\n          return end(\n            new Error(\n              'options.env has an invalid environment variable name: ' +\n              JSON.stringify(key)\n            )\n          );\n        }\n        if (/[\\r\\n]/.test(value)) {\n          return end(\n            new Error(\n              'options.env has an invalid environment variable value: ' +\n              JSON.stringify(value)\n            )\n          );\n        }\n      }\n    }\n  }\n  var platform = Node.process.platform;\n  if (platform !== 'darwin' && platform !== 'linux' && platform !== 'win32') {\n    return end(new Error('Platform not yet supported.'));\n  }\n  var instance = {\n    command: command,\n    options: options,\n    uuid: undefined,\n    path: undefined\n  };\n  Attempt(instance, end);\n}\n\nfunction Linux(instance, end) {\n  LinuxBinary(instance,\n    function(error, binary) {\n      if (error) return end(error);\n      var command = [];\n      // Preserve current working directory:\n      command.push('cd \"' + EscapeDoubleQuotes(Node.process.cwd()) + '\";');\n      // Export environment variables:\n      for (var key in instance.options.env) {\n        var value = instance.options.env[key];\n        command.push('export ' + key + '=\"' + EscapeDoubleQuotes(value) + '\";');\n      }\n      command.push('\"' + EscapeDoubleQuotes(binary) + '\"');\n      if (/kdesudo/i.test(binary)) {\n        command.push(\n          '--comment',\n          '\"' + instance.options.name + ' wants to make changes. ' +\n          'Enter your password to allow this.\"'\n        );\n        command.push('-d'); // Do not show the command to be run in the dialog.\n        command.push('--');\n      } else if (/pkexec/i.test(binary)) {\n        command.push('--disable-internal-agent');\n      }\n      var magic = 'SUDOPROMPT\\n';\n      command.push(\n        '/bin/bash -c \"echo ' + EscapeDoubleQuotes(magic.trim()) + '; ' +\n        EscapeDoubleQuotes(instance.command) +\n        '\"'\n      );\n      command = command.join(' ');\n      Node.child.exec(command, { encoding: 'utf-8', maxBuffer: MAX_BUFFER },\n        function(error, stdout, stderr) {\n          // ISSUE 88:\n          // We must distinguish between elevation errors and command errors.\n          //\n          // KDESUDO:\n          // kdesudo provides no way to do this. We add a magic marker to know\n          // if elevation succeeded. Any error thereafter is a command error.\n          //\n          // PKEXEC:\n          // \"Upon successful completion, the return value is the return value of\n          // PROGRAM. If the calling process is not authorized or an\n          // authorization could not be obtained through authentication or an\n          // error occured, pkexec exits with a return value of 127. If the\n          // authorization could not be obtained because the user dismissed the\n          // authentication dialog, pkexec exits with a return value of 126.\"\n          //\n          // However, we do not rely on pkexec's return of 127 since our magic\n          // marker is more reliable, and we already use it for kdesudo.\n          var elevated = stdout && stdout.slice(0, magic.length) === magic;\n          if (elevated) stdout = stdout.slice(magic.length);\n          // Only normalize the error if it is definitely not a command error:\n          // In other words, if we know that the command was never elevated.\n          // We do not inspect error messages beyond NO_POLKIT_AGENT.\n          // We cannot rely on English errors because of internationalization.\n          if (error && !elevated) {\n            if (/No authentication agent found/.test(stderr)) {\n              error.message = NO_POLKIT_AGENT;\n            } else {\n              error.message = PERMISSION_DENIED;\n            }\n          }\n          end(error, stdout, stderr);\n        }\n      );\n    }\n  );\n}\n\nfunction LinuxBinary(instance, end) {\n  var index = 0;\n  // We used to prefer gksudo over pkexec since it enabled a better prompt.\n  // However, gksudo cannot run multiple commands concurrently.\n  var paths = ['/usr/bin/kdesudo', '/usr/bin/pkexec'];\n  function test() {\n    if (index === paths.length) {\n      return end(new Error('Unable to find pkexec or kdesudo.'));\n    }\n    var path = paths[index++];\n    Node.fs.stat(path,\n      function(error) {\n        if (error) {\n          if (error.code === 'ENOTDIR') return test();\n          if (error.code === 'ENOENT') return test();\n          end(error);\n        } else {\n          end(undefined, path);\n        }\n      }\n    );\n  }\n  test();\n}\n\nfunction Mac(instance, callback) {\n  var temp = Node.os.tmpdir();\n  if (!temp) return callback(new Error('os.tmpdir() not defined.'));\n  var user = Node.process.env.USER; // Applet shell scripts require $USER.\n  if (!user) return callback(new Error('env[\\'USER\\'] not defined.'));\n  UUID(instance,\n    function(error, uuid) {\n      if (error) return callback(error);\n      instance.uuid = uuid;\n      instance.path = Node.path.join(\n        temp,\n        instance.uuid,\n        instance.options.name + '.app'\n      );\n      function end(error, stdout, stderr) {\n        Remove(Node.path.dirname(instance.path),\n          function(errorRemove) {\n            if (error) return callback(error);\n            if (errorRemove) return callback(errorRemove);\n            callback(undefined, stdout, stderr);\n          }\n        );\n      }\n      MacApplet(instance,\n        function(error, stdout, stderr) {\n          if (error) return end(error, stdout, stderr);\n          MacIcon(instance,\n            function(error) {\n              if (error) return end(error);\n              MacPropertyList(instance,\n                function(error, stdout, stderr) {\n                  if (error) return end(error, stdout, stderr);\n                  MacCommand(instance,\n                    function(error) {\n                      if (error) return end(error);\n                      MacOpen(instance,\n                        function(error, stdout, stderr) {\n                          if (error) return end(error, stdout, stderr);\n                          MacResult(instance, end);\n                        }\n                      );\n                    }\n                  );\n                }\n              );\n            }\n          );\n        }\n      );\n    }\n  );\n}\n\nfunction MacApplet(instance, end) {\n  var parent = Node.path.dirname(instance.path);\n  Node.fs.mkdir(parent,\n    function(error) {\n      if (error) return end(error);\n      var zip = Node.path.join(parent, 'sudo-prompt-applet.zip');\n      Node.fs.writeFile(zip, APPLET, 'base64',\n        function(error) {\n          if (error) return end(error);\n          var command = [];\n          command.push('/usr/bin/unzip');\n          command.push('-o'); // Overwrite any existing applet.\n          command.push('\"' + EscapeDoubleQuotes(zip) + '\"');\n          command.push('-d \"' + EscapeDoubleQuotes(instance.path) + '\"');\n          command = command.join(' ');\n          Node.child.exec(command, { encoding: 'utf-8' }, end);\n        }\n      );\n    }\n  );\n}\n\nfunction MacCommand(instance, end) {\n  var path = Node.path.join(\n    instance.path,\n    'Contents',\n    'MacOS',\n    'sudo-prompt-command'\n  );\n  var script = [];\n  // Preserve current working directory:\n  // We do this for commands that rely on relative paths.\n  // This runs in a subshell and will not change the cwd of sudo-prompt-script.\n  script.push('cd \"' + EscapeDoubleQuotes(Node.process.cwd()) + '\"');\n  // Export environment variables:\n  for (var key in instance.options.env) {\n    var value = instance.options.env[key];\n    script.push('export ' + key + '=\"' + EscapeDoubleQuotes(value) + '\"');\n  }\n  script.push(instance.command);\n  script = script.join('\\n');\n  Node.fs.writeFile(path, script, 'utf-8', end);\n}\n\nfunction MacIcon(instance, end) {\n  if (!instance.options.icns) return end();\n  Node.fs.readFile(instance.options.icns,\n    function(error, buffer) {\n      if (error) return end(error);\n      var icns = Node.path.join(\n        instance.path,\n        'Contents',\n        'Resources',\n        'applet.icns'\n      );\n      Node.fs.writeFile(icns, buffer, end);\n    }\n  );\n}\n\nfunction MacOpen(instance, end) {\n  // We must run the binary directly so that the cwd will apply.\n  var binary = Node.path.join(instance.path, 'Contents', 'MacOS', 'applet');\n  // We must set the cwd so that the AppleScript can find the shell scripts.\n  var options = {\n    cwd: Node.path.dirname(binary),\n    encoding: 'utf-8'\n  };\n  // We use the relative path rather than the absolute path. The instance.path\n  // may contain spaces which the cwd can handle, but which exec() cannot.\n  Node.child.exec('./' + Node.path.basename(binary), options, end);\n}\n\nfunction MacPropertyList(instance, end) {\n  // Value must be in single quotes (not double quotes) according to man entry.\n  // e.g. defaults write com.companyname.appname \"Default Color\" '(255, 0, 0)'\n  // The defaults command will be changed in an upcoming major release to only\n  // operate on preferences domains. General plist manipulation utilities will\n  // be folded into a different command-line program.\n  var plist = Node.path.join(instance.path, 'Contents', 'Info.plist');\n  var path = EscapeDoubleQuotes(plist);\n  var key = EscapeDoubleQuotes('CFBundleName');\n  var value = instance.options.name + ' Password Prompt';\n  if (/'/.test(value)) {\n    return end(new Error('Value should not contain single quotes.'));\n  }\n  var command = [];\n  command.push('/usr/bin/defaults');\n  command.push('write');\n  command.push('\"' + path + '\"');\n  command.push('\"' + key + '\"');\n  command.push(\"'\" + value + \"'\"); // We must use single quotes for value.\n  command = command.join(' ');\n  Node.child.exec(command, { encoding: 'utf-8' }, end);\n}\n\nfunction MacResult(instance, end) {\n  var cwd = Node.path.join(instance.path, 'Contents', 'MacOS');\n  Node.fs.readFile(Node.path.join(cwd, 'code'), 'utf-8',\n    function(error, code) {\n      if (error) {\n        if (error.code === 'ENOENT') return end(new Error(PERMISSION_DENIED));\n        end(error);\n      } else {\n        Node.fs.readFile(Node.path.join(cwd, 'stdout'), 'utf-8',\n          function(error, stdout) {\n            if (error) return end(error);\n            Node.fs.readFile(Node.path.join(cwd, 'stderr'), 'utf-8',\n              function(error, stderr) {\n                if (error) return end(error);\n                code = parseInt(code.trim(), 10); // Includes trailing newline.\n                if (code === 0) {\n                  end(undefined, stdout, stderr);\n                } else {\n                  error = new Error(\n                    'Command failed: ' + instance.command + '\\n' + stderr\n                  );\n                  error.code = code;\n                  end(error, stdout, stderr);\n                }\n              }\n            );\n          }\n        );\n      }\n    }\n  );\n}\n\nfunction Remove(path, end) {\n  if (typeof path !== 'string' || !path.trim()) {\n    return end(new Error('Argument path not defined.'));\n  }\n  var command = [];\n  if (Node.process.platform === 'win32') {\n    if (/\"/.test(path)) {\n      return end(new Error('Argument path cannot contain double-quotes.'));\n    }\n    command.push('rmdir /s /q \"' + path + '\"');\n  } else {\n    command.push('/bin/rm');\n    command.push('-rf');\n    command.push('\"' + EscapeDoubleQuotes(Node.path.normalize(path)) + '\"');\n  }\n  command = command.join(' ');\n  Node.child.exec(command, { encoding: 'utf-8' }, end);\n}\n\nfunction UUID(instance, end) {\n  Node.crypto.randomBytes(256,\n    function(error, random) {\n      if (error) random = Date.now() + '' + Math.random();\n      var hash = Node.crypto.createHash('SHA256');\n      hash.update('sudo-prompt-3');\n      hash.update(instance.options.name);\n      hash.update(instance.command);\n      hash.update(random);\n      var uuid = hash.digest('hex').slice(-32);\n      if (!uuid || typeof uuid !== 'string' || uuid.length !== 32) {\n        // This is critical to ensure we don't remove the wrong temp directory.\n        return end(new Error('Expected a valid UUID.'));\n      }\n      end(undefined, uuid);\n    }\n  );\n}\n\nfunction ValidName(string) {\n  // We use 70 characters as a limit to side-step any issues with Unicode\n  // normalization form causing a 255 character string to exceed the fs limit.\n  if (!/^[a-z0-9 ]+$/i.test(string)) return false;\n  if (string.trim().length === 0) return false;\n  if (string.length > 70) return false;\n  return true;\n}\n\nfunction Windows(instance, callback) {\n  var temp = Node.os.tmpdir();\n  if (!temp) return callback(new Error('os.tmpdir() not defined.'));\n  UUID(instance,\n    function(error, uuid) {\n      if (error) return callback(error);\n      instance.uuid = uuid;\n      instance.path = Node.path.join(temp, instance.uuid);\n      if (/\"/.test(instance.path)) {\n        // We expect double quotes to be reserved on Windows.\n        // Even so, we test for this and abort if they are present.\n        return callback(\n          new Error('instance.path cannot contain double-quotes.')\n        );\n      }\n      instance.pathElevate = Node.path.join(instance.path, 'elevate.vbs');\n      instance.pathExecute = Node.path.join(instance.path, 'execute.bat');\n      instance.pathCommand = Node.path.join(instance.path, 'command.bat');\n      instance.pathStdout = Node.path.join(instance.path, 'stdout');\n      instance.pathStderr = Node.path.join(instance.path, 'stderr');\n      instance.pathStatus = Node.path.join(instance.path, 'status');\n      Node.fs.mkdir(instance.path,\n        function(error) {\n          if (error) return callback(error);\n          function end(error, stdout, stderr) {\n            Remove(instance.path,\n              function(errorRemove) {\n                if (error) return callback(error);\n                if (errorRemove) return callback(errorRemove);\n                callback(undefined, stdout, stderr);\n              }\n            );\n          }\n          WindowsWriteExecuteScript(instance,\n            function(error) {\n              if (error) return end(error);\n              WindowsWriteCommandScript(instance,\n                function(error) {\n                  if (error) return end(error);\n                  WindowsElevate(instance,\n                    function(error, stdout, stderr) {\n                      if (error) return end(error, stdout, stderr);\n                      WindowsWaitForStatus(instance,\n                        function(error) {\n                          if (error) return end(error);\n                          WindowsResult(instance, end);\n                        }\n                      );\n                    }\n                  );\n                }\n              );\n            }\n          );\n        }\n      );\n    }\n  );\n}\n\nfunction WindowsElevate(instance, end) {\n  // We used to use this for executing elevate.vbs:\n  // var command = 'cscript.exe //NoLogo \"' + instance.pathElevate + '\"';\n  var command = [];\n  command.push('powershell.exe');\n  command.push('Start-Process');\n  command.push('-FilePath');\n  // Escape characters for cmd using double quotes:\n  // Escape characters for PowerShell using single quotes:\n  // Escape single quotes for PowerShell using backtick:\n  // See: https://ss64.com/ps/syntax-esc.html\n  command.push('\"\\'' + instance.pathExecute.replace(/'/g, \"`'\") + '\\'\"');\n  command.push('-WindowStyle hidden');\n  command.push('-Verb runAs');\n  command = command.join(' ');\n  var child = Node.child.exec(command, { encoding: 'utf-8' },\n    function(error, stdout, stderr) {\n      // We used to return PERMISSION_DENIED only for error messages containing\n      // the string 'canceled by the user'. However, Windows internationalizes\n      // error messages (issue 96) so now we must assume all errors here are\n      // permission errors. This seems reasonable, given that we already run the\n      // user's command in a subshell.\n      if (error) return end(new Error(PERMISSION_DENIED), stdout, stderr);\n      end();\n    }\n  );\n  child.stdin.end(); // Otherwise PowerShell waits indefinitely on Windows 7.\n}\n\nfunction WindowsResult(instance, end) {\n  Node.fs.readFile(instance.pathStatus, 'utf-8',\n    function(error, code) {\n      if (error) return end(error);\n      Node.fs.readFile(instance.pathStdout, 'utf-8',\n        function(error, stdout) {\n          if (error) return end(error);\n          Node.fs.readFile(instance.pathStderr, 'utf-8',\n            function(error, stderr) {\n              if (error) return end(error);\n              code = parseInt(code.trim(), 10);\n              if (code === 0) {\n                end(undefined, stdout, stderr);\n              } else {\n                error = new Error(\n                  'Command failed: ' + instance.command + '\\r\\n' + stderr\n                );\n                error.code = code;\n                end(error, stdout, stderr);\n              }\n            }\n          );\n        }\n      );\n    }\n  );\n}\n\nfunction WindowsWaitForStatus(instance, end) {\n  // VBScript cannot wait for the elevated process to finish so we have to poll.\n  // VBScript cannot return error code if user does not grant permission.\n  // PowerShell can be used to elevate and wait on Windows 10.\n  // PowerShell can be used to elevate on Windows 7 but it cannot wait.\n  // powershell.exe Start-Process cmd.exe -Verb runAs -Wait\n  Node.fs.stat(instance.pathStatus,\n    function(error, stats) {\n      if ((error && error.code === 'ENOENT') || stats.size < 2) {\n        // Retry if file does not exist or is not finished writing.\n        // We expect a file size of 2. That should cover at least \"0\\r\".\n        // We use a 1 second timeout to keep a light footprint for long-lived\n        // sudo-prompt processes.\n        setTimeout(\n          function() {\n            // If administrator has no password and user clicks Yes, then\n            // PowerShell returns no error and execute (and command) never runs.\n            // We check that command output has been redirected to stdout file:\n            Node.fs.stat(instance.pathStdout,\n              function(error) {\n                if (error) return end(new Error(PERMISSION_DENIED));\n                WindowsWaitForStatus(instance, end);\n              }\n            );\n          },\n          1000\n        );\n      } else if (error) {\n        end(error);\n      } else {\n        end();\n      }\n    }\n  );\n}\n\nfunction WindowsWriteCommandScript(instance, end) {\n  var cwd = Node.process.cwd();\n  if (/\"/.test(cwd)) {\n    // We expect double quotes to be reserved on Windows.\n    // Even so, we test for this and abort if they are present.\n    return end(new Error('process.cwd() cannot contain double-quotes.'));\n  }\n  var script = [];\n  script.push('@echo off');\n  // Set code page to UTF-8:\n  script.push('chcp 65001>nul');\n  // Preserve current working directory:\n  // We pass /d as an option in case the cwd is on another drive (issue 70).\n  script.push('cd /d \"' + cwd + '\"');\n  // Export environment variables:\n  for (var key in instance.options.env) {\n    // \"The characters <, >, |, &, ^ are special command shell characters, and\n    // they must be preceded by the escape character (^) or enclosed in\n    // quotation marks. If you use quotation marks to enclose a string that\n    // contains one of the special characters, the quotation marks are set as\n    // part of the environment variable value.\"\n    // In other words, Windows assigns everything that follows the equals sign\n    // to the value of the variable, whereas Unix systems ignore double quotes.\n    var value = instance.options.env[key];\n    script.push('set ' + key + '=' + value.replace(/([<>\\\\|&^])/g, '^$1'));\n  }\n  script.push(instance.command);\n  script = script.join('\\r\\n');\n  Node.fs.writeFile(instance.pathCommand, script, 'utf-8', end);\n}\n\nfunction WindowsWriteElevateScript(instance, end) {\n  // We do not use VBScript to elevate since it does not return an error if\n  // the user does not grant permission. This is here for reference.\n  // var script = [];\n  // script.push('Set objShell = CreateObject(\"Shell.Application\")');\n  // script.push(\n  // 'objShell.ShellExecute \"' + instance.pathExecute + '\", \"\", \"\", \"runas\", 0'\n  // );\n  // script = script.join('\\r\\n');\n  // Node.fs.writeFile(instance.pathElevate, script, 'utf-8', end);\n}\n\nfunction WindowsWriteExecuteScript(instance, end) {\n  var script = [];\n  script.push('@echo off');\n  script.push(\n    'call \"' + instance.pathCommand + '\"' +\n    ' > \"' + instance.pathStdout + '\" 2> \"' + instance.pathStderr + '\"'\n  );\n  script.push('(echo %ERRORLEVEL%) > \"' + instance.pathStatus + '\"');\n  script = script.join('\\r\\n');\n  Node.fs.writeFile(instance.pathExecute, script, 'utf-8', end);\n}\n\nmodule.exports.exec = Exec;\n\n// We used to expect that applet.app would be included with this module.\n// This could not be copied when sudo-prompt was packaged within an asar file.\n// We now store applet.app as a zip file in base64 within index.js instead.\n// To recreate: \"zip -r ../applet.zip Contents\" (with applet.app as CWD).\n// The zip file must not include applet.app as the root directory so that we\n// can extract it directly to the target app directory.\nvar APPLET = 'UEsDBAoAAAAAAO1YcEcAAAAAAAAAAAAAAAAJABwAQ29udGVudHMvVVQJAAPNnElWLZEQV3V4CwABBPUBAAAEFAAAAFBLAwQUAAAACACgeXBHlHaGqKEBAAC+AwAAEwAcAENvbnRlbnRzL0luZm8ucGxpc3RVVAkAA1zWSVYtkRBXdXgLAAEE9QEAAAQUAAAAfZNRb5swFIWfl1/BeA9OpSmqJkqVBCJFop1VyKQ9Ta59S6wa27NNCfv1M0naJWTsEXO+c8+9vo7v97UI3sBYruRdeBPNwgAkVYzL6i7cluvpbXifTOLP6bdV+QNngRbcugBvl/lmFYRThBZaC0AoLdMA55uiDLwHQtljGIQ75/RXhNq2jUiviqiqe6FF2CgNxnW5N5t6IGKOhb7M0f0ijj9lnLpk8il+hS5ZrZeNZAIWQqj2ge+B5YoSwX8T5xEbo17ktc40gIZQCm8glK5BuieovP5Dbp3xHSeZrHyCXYxO3wM+2wNtHHkWMAQP/bkxbkOVXPMxKuK0Dz6CMh+Wv3AwQ9gPM7INU1NtVK3Ha8sXlfoB+m6J6b4fRzv0mkezMf6R1Fe5MbG2VYYF+L+lMaGvpIKy01cOC4zzMazYKeNOQYuDYkjfjMcteCWJa8w/Zi2ugubFA5e8buqisw7qU81ltzB0xx3QC5/TFh7J/e385/zL+7+/wWbR/LwIOl/dvHiCXw03YFfEPJ9dwsWu5sV2kwnod3QoeLeL0eGdJJM/UEsDBAoAAAAAAHSBjkgAAAAAAAAAAAAAAAAPABwAQ29udGVudHMvTWFjT1MvVVQJAAMbpQ9XLZEQV3V4CwABBPUBAAAEFAAAAFBLAwQUAAAACABVHBdH7Dk4KTIIAADIYQAAFQAcAENvbnRlbnRzL01hY09TL2FwcGxldFVUCQADMiPZVVOlD1d1eAsAAQT1AQAABBQAAADtnG9sHEcVwGfti7M1/rONLNVtXHqpzsipis+pHOSWFOzEm25at3XrJI2ozbK+W/suuds79vaSuCKSpaOIxRy1+NSPRPAhlWj7AVRaQCWpTRz+CEo+RSKCCho4K67kVhUyAeV4b3fWt17fXZqKFgHvp8zO3/dmdmfPmtl5L7+8/uPXGWMNELZCaGRMgmjHIlxaBCibdcoGsewCljGCIAiCIAiCIAiCIP7r+M21d67zjb/zEaAdwr1bGHuWMQH2/2wAgqqODj0kf0F+8nGfoFRbJ8p9U0C5g/KRgwEZqZLGfrfwwJx+LP2kVWkelD9zJ2NfBr1nWt2xrhNisxWZ3Ex6MpNSc1Z+soqOO+5i7JMYt7vj9BC5jiZXBwirCT2V1c0qOgZAxwMYt9cbRyxnmUljusa9mKBjGON2tgG/PlXNGyeSRlxNGlOZKjpeBR0KxsFx+MB7VJy5GB46OOSrCLPKfEjrH3/gFry+4zOpuH8sm+VF5srW6ltVjZQ3HVnL3KRDDLsflMSADpyDyjuR0urp6AAdHRgHdOD9iOs6Ypl0OmPUupeecOW19OsQAmn3tzBy4LFH5OED3jz0MbYouM8D460BOdTXCaEF6tsgLkF8GeJPQBj16Rb4PTf5xl2NH4J8a5Vy1N3F3OcZzefMaCo5GeVTuJ2P4cUf/aH5qbbP73/utpfeevdbLzwfYfy+Q80woGan/1E+ljo/703g77IaOJY479t5rqFLDag9OjaTs/R0dCQ5aWrmTHS/qaX1ExnzWC66L2PqY7p5PBnTc71TXnn0sG7mkhkjFx3a0IL30e/rQxB+EXL68J4BBLe73r298DySk5tlGPtJY1BmOhZTc727PBH2Ke+ZhF35nTyP80oQBEEQBPFRcJTZVwpvrxZWpLmJkN0VKT4q2iORUGFBOPfnBuFX9nhELOG67f1D9pWxpw4XVrrmTklz+ZY5Wfwurm/t3ffi9cE+uM41vYbbj2fP5kNXt9sXiopwVRj6xhPlr160mttfuVi4Fs2vXv2rfc5u7UeZfxQ+y4pPh/JrpyUUBjmrofzmadGXKf0eui7KK/ZwJLQUiuRAe+mLUFQ+tFKUV3npd7AU9ytz8iqIiXYoUnoBsqdxDbXk3CXcRov9lYhoW5EQjBxb4NoSY9iQsvn5+QSuusrduAybL3eHIIIbLqyIS9CHlY3loB8rldVKuLfyOsE1+a6zhUVxYsFp3Amqz8tr7Lz8dza1JF8TmC3/syivYVtcfxcWOycWQDvuLcrdnc61y7mGnWsErgmsXDbK5TKkscnypJvGhsuH3TQ2X37YTaPQ8ucw7W6t1LR2TFfjekqb0SGTiedTOmz0klZSSyWf0U01pqVSufXGmThsjs20OpU3Yrjuxbnu4u+GP8b1LO6PcX2L4Q6+v8Q07u9aQFLy71Ckt54TIfjfNdzfDkMYhTAOIXHXh39vCYIgCIIgCIIgCIL4z3Nm+84/Ci1Nn8b0ryHsgbBX1rbgOXD7LZJzNtrC0/gFqYOn8csQ/GONguQchPXzcvy+9CBzvk84HxkO+tJH3bRz5Fb0pb/nS3/fl/6BL/2aL43faLzz3Wbmju8W5p6pttaoR9THjgyZ0zEeH2eqqmbNzLShpXVIpxOqflKP5S1dTehaXDeZqhvHk2bGYOo+LZXal0lnM4ZuWMPJXFazYgmmPp7VjWF9SsunrPVa1HpMn0lPm2r8hGZO3aea+nQyZ+mmmtNjFp5i4oG0lTChE+eDj2pm8lbSgDFoln4yCRp00zQyEDmZtBZLbGxnanHzgWh092d29e/uv+/f+DIQBEEQBEEQBEEQ/7P81rX/FxoZm/Xs/5UmtP8PO/W3M9fGvKoPAEfYXLQJ1HOpmk+AJx80OOb5m/URGG9z9c378rVs9F15tPXP1dS3wvVtC+Q9/H4DFX21fQcY9zvo9eXrj6++D0Af1zfqy9eyx3f16QnVMayufr+zXN+sL99YRx/O69er+RdIgXkNxJv9DfBTDIxLPa6Zudr6enz5euO6ke9Bj7TRzr0noK+JbczfyA9hgOvr9OX98t57XNFX3ydhlOsL+2T8+oK/ucrvNOCfEHbbXhAqeebLB/0V7oYp7+Pt8PsZWnl1+urRpAn7SUCcYBX/hkth95kd2cFYllX3bxB4+xCrzcCO6v4PbXzo1fwbEM/H4ds/f/nCgZH+8k+j0vNPv7Jlz7qPQ1PFx+FVPoZ76ozj42K87YP9/cT7xuf9UfpSeP0MsJvzp0A8/4g3w+78ef4R+F4QBEEQBPH/w1Gm2FeUwturytwpUSnmJfta4Q3h3J8aFeE9xf7d1ZBSOCcqhftZ/m+YKuG6wV4qaQzdGED0Z2jJ/zpa9ZcegjIF7fkVaIBrt11nJxYOOepXpPPyKjsvvytOLcnvCWxJfh87V+xTa0rx1Kpj0a8UFqWJhXL3fgHt9xXn+rCz7Bop3rkTEkNj5e7bIZ7HNRZb/ku5XE6g58HyZUzdj6mLjh1/Pbt7XMt5dvfvtLl1Fbv7BtbhrtyEPW6V038H1yE88yQTTkqC1LJVnIeaCNe7dr3sEPEe6lCb9LWGfa3efvNG8pe5fF8NeW8g3n7jCI+/xOOEVH19KvF9oudHH2n/YOtYgiAIgiAIgiAIgiA+fm69mx3aO8bYtkHn/xlwDq8nkwaavz9h9swzc+DWwRrm71A5CJVVjeChTtk26Fqwu0fxQjUL+9vqHVV/KC53OUd+bJxVfBkw7/gzCO5pr3dOK/g+WUQDeZlV/A2QRwJ5THjn1/xcd9BfhlT1KbgpVwLn+W2amGr2//8CUEsDBBQAAAAIAAVHj0ga7FYjfQEAAKoCAAAhABwAQ29udGVudHMvTWFjT1Mvc3Vkby1wcm9tcHQtc2NyaXB0VVQJAAOJkBBXipAQV3V4CwABBPUBAAAEFAAAAI1SO08cMRDu91cMHIKGxUB5xSGEUqTlFKWMvPYca+EXnjGXy6/PeNcg0qVay+PvObs5U5OLatI0DxvYIwNVm4BdQGIdMhxSkauJ8K1i7FOjvSdwB2A+/WJnXpEJdEGwjvTk0W6HhTW8WldgzKDedVF2Ug2tLn7svz3DDpTFdxWr93C/u7wbVKWyoDhVM/8XZAOPOXvcm+IyXxGcizeaUca0XJ1D0CfQnlEysE2VwbuII0br4gvdCMF37m9IoC39+oxTO2EpS8oZJdtRS0aIKY5/sCQoyLVEMMki6Ghl0BGN9SeuICkPIctXDHDDSB9oGEQi1yZWUAda8EZnIcR/eIOOVao+9TrbkpYFjLmkkHk0KYSGvdt12/e71cP6Hs2c4OJBemtsYusplVX+GLHQ7DKkQ098/ZF38dLEpRCeNUMlMW90BIseeQkWtuu2qKmIyDHCuqFuo1N11Ud/1Cf6CHb7Sfxld2ATklQoUGEDActfZ5326WU74G/HcDv8BVBLAwQKAAAAAADtWHBHqiAGewgAAAAIAAAAEAAcAENvbnRlbnRzL1BrZ0luZm9VVAkAA82cSVYqkRBXdXgLAAEE9QEAAAQUAAAAQVBQTGFwbHRQSwMECgAAAAAAm3lwRwAAAAAAAAAAAAAAABMAHABDb250ZW50cy9SZXNvdXJjZXMvVVQJAANW1klWLZEQV3V4CwABBPUBAAAEFAAAAFBLAwQUAAAACACAeXBHfrnysfYGAAAf3AAAHgAcAENvbnRlbnRzL1Jlc291cmNlcy9hcHBsZXQuaWNuc1VUCQADH9ZJVnGlD1d1eAsAAQT1AQAABBQAAADt3Xk81Hkcx/Hvb5yVo5bGsVlKbcpRRqFlGZGS5JikRBIdI0OZttMZloqiYwrVjD1UqJaUokTRubG72bZVjqR1VZNjp2XEGo9H+9gt+9h/9tHx8H7N4/fw5MHjYeaPz+P7+P7x/bL9griEPNBm+001J0S+ZbvL/NmKwzWHE0IUHebYuRFCEckjL9v/xSvk2EpCpBXZtrYuDra2Oi4hwSvZgSsIMU9MdPdePcZd1aqQu0p3fDkrcFrs+mPWihMU9y6clp5XEFFdbRrEczCtGtfkL3pWfvBGublJ4ct051kuocYtaaqll/IjdfR+V75vlTdl//AJVZU6elZ5f0S7NO3MaE2xMElhF+TUrHgW2nFYeGTrs/OrhDJN5zMX8ZJVKXrqSUM1Rj03bnf85/pJMXECNdl0D1ctfe/j82imziM2nllSa3t5q8+vP1f38k/k22uN1lmnvfz0b8dGxO+mnh91v7WB2tKdrG3d4vmJaHlTvjGzdMqWcw/9frnCtQpPZK9sMKi/Ey/jzgqIPzBy9/dlf9griI2/u+sjcApozWx6/NXytC+qBTlrhb69fE7J6tgOzpWjFSl8qxihr5dYf/qExoeupY6Ze/j2PfL1azhhZ8fU3eelJY+ylk16UJN6KmOU0M4r+75cZhH/mxNndowNb4wx7TCoN4yvMGu8ySq5l5W5t+xQyYbS/Ome7e0W0sXbC5aktl0LEXNYR9obH7dMT721dbNdT/eFzXNEYSH8GU+bQ5s6YniGcj3fHtgXPbo0Oj4i3d5G1Fjfm/Ng7kgpjQDNxw4RRnu+Vloy5ZE3J6OpwlFBzaxS25He2h3lJuizO70zJPLUYtks14RE5yrD8y2tXa5l5Wqh/NBY06yoiCLF08Nk9A5Ojbs43GmR1Ch/PaZsLf3e6uPRSrIM1ROqGjt80leqfdxYbNn+WV7K7ZKiy/t6r1/3ie46V5432T/Oahs9V7NnVzb9zoq2rFgvPxXrcAMzmvWnGjof/RpdsZThIEpex6DGbd5h6STaOyZXxV/YfW9u4KyllmZ3X15IMHHLSJtVPSOvULCsz2TyPC/WL9kGSme/1L01SSzjfbHnqk+OV7OBmevZeo3DBR7lXT5drT0MkX5PwDd1EQ0ebfkh1zy/L8ydd+VJ4CLuRndNjuwj+vMfU8q2l2l1rGtr8FC2D+fdSGk81eltuTjYSMk++4BMd0DXQo35iXbZndGdcXkGFyeG6b28evF22M2w22HlYSXetGSLW4cfFT00WqvN9bkqCujQ9KzdSt+snr+qmbcme+5Y3cDRn9BDLps+dPVltE9UkPeb6XovineiVUznTznyuZaSn/ZvR8VeRUYLqe3iHFqnU6+7+4LmtfsmaS0MdjIvslFJGG/rn7DPdMGLcx4d6eP2Oz92Y49kWbBUjudU2ijHnc7YIODQxD1aPx8PynVr+cmvJoy2+M5nQa2Kt0dvdPxp73LNU6aTeaktTfHH1L+8Pm/XalZcFcfzYxlhTefuzjRGobLKEqPZh8QKxUXWbU/ERvW78ghvTGTUNd0g9YqbcjUy5h0xVbn3S7SS54SOqKt88UR0qZuxKfxlZfODUm52o2HkGTOLw5dqhevvWjH7ssiqxAhKwA91d1nWG9w/GJIc7GwWbKKe/mAsGRqXBb87P10jH8/0LY6kpGQV1KcuAwAAeCt4LiVFWRJKs4DJ6p9GxGHWfLuTM5dt61/pzCCE7vLmSodGJM/ASqdzU2U3VjpY6WClg5XOICudUaI3VjocuWCsdAAAAAAAAAAAAAAAAD5o1Gmr054TSoqWxPvnfrLxVEIc29/cT5YmkmdgPzlCSz8a+8nYT8Z+MvaTB9lPZpJX+8lRktFyRdDF0m6IdcF2MgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC8ddD8G5oJkUuQnAXwnvxLAAAAADDkEFURRckVE6rIv+Tb1078MiZEetubJ34RHckzcOIXd8uWTpz4hRO/cOIXTvwa5MQvoidZ5S8a9h8nfl1QVhipQ6jyyWeuvTaBGP3D5fwgE4gpeQYmUCZ7XQ0mECYQJhAm0GATyOfVmYOU4sAdNi+cOUpm/9cdNv2Di8kkFN3mYOtrg8sE14xicGFwYXDhmlEAAD5w/Os1o8bTcM0oVjpY6WClg2tGAQAAAAAAAAAAAAAAgL/wb9eMBpow+r817yN/fwnJf33P5g78nWofEZNXD3u95GdSkh3o135/aL2i3vl/gHf/7t59oDlnDSHS8gQhNGQL8uWs6P+iwPYLDuIOzARqyM+E9QOfA3PIfw4IIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhND70J9QSwMEFAAAAAgA7VhwR/dYplZAAAAAagEAAB4AHABDb250ZW50cy9SZXNvdXJjZXMvYXBwbGV0LnJzcmNVVAkAA82cSVZTpQ9XdXgLAAEE9QEAAAQUAAAAY2BgZGBgYFQBEiDsxjDygJQDPlkmEIEaRpJAQg8kLAMML8bi5OIqIFuouKA4A0jLMTD8/w+S5AdrB7PlBIAEAFBLAwQKAAAAAADtWHBHAAAAAAAAAAAAAAAAJAAcAENvbnRlbnRzL1Jlc291cmNlcy9kZXNjcmlwdGlvbi5ydGZkL1VUCQADzZxJVi2REFd1eAsAAQT1AQAABBQAAABQSwMEFAAAAAgA7VhwRzPLNU9TAAAAZgAAACsAHABDb250ZW50cy9SZXNvdXJjZXMvZGVzY3JpcHRpb24ucnRmZC9UWFQucnRmVVQJAAPNnElWU6UPV3V4CwABBPUBAAAEFAAAACWJOw6AIBAFe08DCBVX2QbWhZgQ1vCpCHcXtHkzkzegtCDB5Xp/g0+UyihARnb70kL/UbvffYpjQODcmk9zKXListxCoUsZA7EQ5S0+dVq085gvUEsDBAoAAAAAAIeBjkgAAAAAAAAAAAAAAAAbABwAQ29udGVudHMvUmVzb3VyY2VzL1NjcmlwdHMvVVQJAAM9pQ9XLZEQV3V4CwABBPUBAAAEFAAAAFBLAwQUAAAACAAJgI5ICl5liTUBAADMAQAAJAAcAENvbnRlbnRzL1Jlc291cmNlcy9TY3JpcHRzL21haW4uc2NwdFVUCQADcaIPV1OlD1d1eAsAAQT1AQAABBQAAAB9UMtOAkEQrNldd9dhH3Dz6NGYiPIJHjTxLCZeF9iDcXEJC0RvfoI/4sEfIvoHPEQEhbIHvOok01U16emu7vOkaF2dXu7XqrUTcyMATkxCwYKthCAUbmciAQ8O11yFcGBfbF/4jR24WmCvWjwUeXqfNutn13XyEeYYHkqKam+kghdJGfUCvwIfB6jiGAX6aCHHETroCrYFe6IKNEXfGOXChc0v7HKpBRzdSFrtELvbumKVC80F/FIjzwe9bj91uZRuXJuwAiLjNi7DlsxPaJSUAMrCFOeac3GfpINennQ6d/0sA4z7JxzKiVCCV+YHAs74LuuIONUi//4RIoC63czrIbYQS3PFicWJcTMTv1JHmocmROLJ45gjzfHvXJqjf7ZZ4RT+61uaBbDipGh2ZanBcjh8/gFQSwECHgMKAAAAAADtWHBHAAAAAAAAAAAAAAAACQAYAAAAAAAAABAA7UEAAAAAQ29udGVudHMvVVQFAAPNnElWdXgLAAEE9QEAAAQUAAAAUEsBAh4DFAAAAAgAoHlwR5R2hqihAQAAvgMAABMAGAAAAAAAAQAAAKSBQwAAAENvbnRlbnRzL0luZm8ucGxpc3RVVAUAA1zWSVZ1eAsAAQT1AQAABBQAAABQSwECHgMKAAAAAAB0gY5IAAAAAAAAAAAAAAAADwAYAAAAAAAAABAA7UExAgAAQ29udGVudHMvTWFjT1MvVVQFAAMbpQ9XdXgLAAEE9QEAAAQUAAAAUEsBAh4DFAAAAAgAVRwXR+w5OCkyCAAAyGEAABUAGAAAAAAAAAAAAO2BegIAAENvbnRlbnRzL01hY09TL2FwcGxldFVUBQADMiPZVXV4CwABBPUBAAAEFAAAAFBLAQIeAxQAAAAIAAVHj0ga7FYjfQEAAKoCAAAhABgAAAAAAAEAAADtgfsKAABDb250ZW50cy9NYWNPUy9zdWRvLXByb21wdC1zY3JpcHRVVAUAA4mQEFd1eAsAAQT1AQAABBQAAABQSwECHgMKAAAAAADtWHBHqiAGewgAAAAIAAAAEAAYAAAAAAABAAAApIHTDAAAQ29udGVudHMvUGtnSW5mb1VUBQADzZxJVnV4CwABBPUBAAAEFAAAAFBLAQIeAwoAAAAAAJt5cEcAAAAAAAAAAAAAAAATABgAAAAAAAAAEADtQSUNAABDb250ZW50cy9SZXNvdXJjZXMvVVQFAANW1klWdXgLAAEE9QEAAAQUAAAAUEsBAh4DFAAAAAgAgHlwR3658rH2BgAAH9wAAB4AGAAAAAAAAAAAAKSBcg0AAENvbnRlbnRzL1Jlc291cmNlcy9hcHBsZXQuaWNuc1VUBQADH9ZJVnV4CwABBPUBAAAEFAAAAFBLAQIeAxQAAAAIAO1YcEf3WKZWQAAAAGoBAAAeABgAAAAAAAAAAACkgcAUAABDb250ZW50cy9SZXNvdXJjZXMvYXBwbGV0LnJzcmNVVAUAA82cSVZ1eAsAAQT1AQAABBQAAABQSwECHgMKAAAAAADtWHBHAAAAAAAAAAAAAAAAJAAYAAAAAAAAABAA7UFYFQAAQ29udGVudHMvUmVzb3VyY2VzL2Rlc2NyaXB0aW9uLnJ0ZmQvVVQFAAPNnElWdXgLAAEE9QEAAAQUAAAAUEsBAh4DFAAAAAgA7VhwRzPLNU9TAAAAZgAAACsAGAAAAAAAAQAAAKSBthUAAENvbnRlbnRzL1Jlc291cmNlcy9kZXNjcmlwdGlvbi5ydGZkL1RYVC5ydGZVVAUAA82cSVZ1eAsAAQT1AQAABBQAAABQSwECHgMKAAAAAACHgY5IAAAAAAAAAAAAAAAAGwAYAAAAAAAAABAA7UFuFgAAQ29udGVudHMvUmVzb3VyY2VzL1NjcmlwdHMvVVQFAAM9pQ9XdXgLAAEE9QEAAAQUAAAAUEsBAh4DFAAAAAgACYCOSApeZYk1AQAAzAEAACQAGAAAAAAAAAAAAKSBwxYAAENvbnRlbnRzL1Jlc291cmNlcy9TY3JpcHRzL21haW4uc2NwdFVUBQADcaIPV3V4CwABBPUBAAAEFAAAAFBLBQYAAAAADQANANwEAABWGAAAAAA=';\n\nvar PERMISSION_DENIED = 'User did not grant permission.';\nvar NO_POLKIT_AGENT = 'No polkit authentication agent found.';\n\n// See issue 66:\nvar MAX_BUFFER = 134217728;\n","'use strict';\nconst os = require('os');\nconst tty = require('tty');\nconst hasFlag = require('has-flag');\n\nconst {env} = process;\n\nlet forceColor;\nif (hasFlag('no-color') ||\n\thasFlag('no-colors') ||\n\thasFlag('color=false') ||\n\thasFlag('color=never')) {\n\tforceColor = 0;\n} else if (hasFlag('color') ||\n\thasFlag('colors') ||\n\thasFlag('color=true') ||\n\thasFlag('color=always')) {\n\tforceColor = 1;\n}\n\nif ('FORCE_COLOR' in env) {\n\tif (env.FORCE_COLOR === 'true') {\n\t\tforceColor = 1;\n\t} else if (env.FORCE_COLOR === 'false') {\n\t\tforceColor = 0;\n\t} else {\n\t\tforceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);\n\t}\n}\n\nfunction translateLevel(level) {\n\tif (level === 0) {\n\t\treturn false;\n\t}\n\n\treturn {\n\t\tlevel,\n\t\thasBasic: true,\n\t\thas256: level >= 2,\n\t\thas16m: level >= 3\n\t};\n}\n\nfunction supportsColor(haveStream, streamIsTTY) {\n\tif (forceColor === 0) {\n\t\treturn 0;\n\t}\n\n\tif (hasFlag('color=16m') ||\n\t\thasFlag('color=full') ||\n\t\thasFlag('color=truecolor')) {\n\t\treturn 3;\n\t}\n\n\tif (hasFlag('color=256')) {\n\t\treturn 2;\n\t}\n\n\tif (haveStream && !streamIsTTY && forceColor === undefined) {\n\t\treturn 0;\n\t}\n\n\tconst min = forceColor || 0;\n\n\tif (env.TERM === 'dumb') {\n\t\treturn min;\n\t}\n\n\tif (process.platform === 'win32') {\n\t\t// Windows 10 build 10586 is the first Windows release that supports 256 colors.\n\t\t// Windows 10 build 14931 is the first release that supports 16m/TrueColor.\n\t\tconst osRelease = os.release().split('.');\n\t\tif (\n\t\t\tNumber(osRelease[0]) >= 10 &&\n\t\t\tNumber(osRelease[2]) >= 10586\n\t\t) {\n\t\t\treturn Number(osRelease[2]) >= 14931 ? 3 : 2;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\tif ('CI' in env) {\n\t\tif (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn min;\n\t}\n\n\tif ('TEAMCITY_VERSION' in env) {\n\t\treturn /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;\n\t}\n\n\tif ('GITHUB_ACTIONS' in env) {\n\t\treturn 1;\n\t}\n\n\tif (env.COLORTERM === 'truecolor') {\n\t\treturn 3;\n\t}\n\n\tif ('TERM_PROGRAM' in env) {\n\t\tconst version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);\n\n\t\tswitch (env.TERM_PROGRAM) {\n\t\t\tcase 'iTerm.app':\n\t\t\t\treturn version >= 3 ? 3 : 2;\n\t\t\tcase 'Apple_Terminal':\n\t\t\t\treturn 2;\n\t\t\t// No default\n\t\t}\n\t}\n\n\tif (/-256(color)?$/i.test(env.TERM)) {\n\t\treturn 2;\n\t}\n\n\tif (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {\n\t\treturn 1;\n\t}\n\n\tif ('COLORTERM' in env) {\n\t\treturn 1;\n\t}\n\n\treturn min;\n}\n\nfunction getSupportLevel(stream) {\n\tconst level = supportsColor(stream, stream && stream.isTTY);\n\treturn translateLevel(level);\n}\n\nmodule.exports = {\n\tsupportsColor: getSupportLevel,\n\tstdout: translateLevel(supportsColor(true, tty.isatty(1))),\n\tstderr: translateLevel(supportsColor(true, tty.isatty(2)))\n};\n","'use strict';\n\nmodule.exports = (flag, argv = process.argv) => {\n\tconst prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');\n\tconst position = argv.indexOf(prefix + flag);\n\tconst terminatorPosition = argv.indexOf('--');\n\treturn position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);\n};\n","/**\n * Convert a typed array to a Buffer without a copy\n *\n * Author:   Feross Aboukhadijeh <https://feross.org>\n * License:  MIT\n *\n * `npm install typedarray-to-buffer`\n */\n\nvar isTypedArray = require('is-typedarray').strict\n\nmodule.exports = function typedarrayToBuffer (arr) {\n  if (isTypedArray(arr)) {\n    // To avoid a copy, use the typed array's underlying ArrayBuffer to back new Buffer\n    var buf = Buffer.from(arr.buffer)\n    if (arr.byteLength !== arr.buffer.byteLength) {\n      // Respect the \"view\", i.e. byteOffset and byteLength, without doing a copy\n      buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength)\n    }\n    return buf\n  } else {\n    // Pass through all other types to `Buffer.from`\n    return Buffer.from(arr)\n  }\n}\n","'use strict'\n\nexports.fromCallback = function (fn) {\n  return Object.defineProperty(function () {\n    if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)\n    else {\n      return new Promise((resolve, reject) => {\n        arguments[arguments.length] = (err, res) => {\n          if (err) return reject(err)\n          resolve(res)\n        }\n        arguments.length++\n        fn.apply(this, arguments)\n      })\n    }\n  }, 'name', { value: fn.name })\n}\n\nexports.fromPromise = function (fn) {\n  return Object.defineProperty(function () {\n    const cb = arguments[arguments.length - 1]\n    if (typeof cb !== 'function') return fn.apply(this, arguments)\n    else fn.apply(this, arguments).then(r => cb(null, r), cb)\n  }, 'name', { value: fn.name })\n}\n","'use strict';\n\n/**\n * Checks if a given buffer contains only correct UTF-8.\n * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by\n * Markus Kuhn.\n *\n * @param {Buffer} buf The buffer to check\n * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`\n * @public\n */\nfunction isValidUTF8(buf) {\n  const len = buf.length;\n  let i = 0;\n\n  while (i < len) {\n    if ((buf[i] & 0x80) === 0x00) {  // 0xxxxxxx\n      i++;\n    } else if ((buf[i] & 0xe0) === 0xc0) {  // 110xxxxx 10xxxxxx\n      if (\n        i + 1 === len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i] & 0xfe) === 0xc0  // overlong\n      ) {\n        return false;\n      }\n\n      i += 2;\n    } else if ((buf[i] & 0xf0) === 0xe0) {  // 1110xxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 2 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80 ||  // overlong\n        buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0  // surrogate (U+D800 - U+DFFF)\n      ) {\n        return false;\n      }\n\n      i += 3;\n    } else if ((buf[i] & 0xf8) === 0xf0) {  // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 3 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        (buf[i + 3] & 0xc0) !== 0x80 ||\n        buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80 ||  // overlong\n        buf[i] === 0xf4 && buf[i + 1] > 0x8f || buf[i] > 0xf4  // > U+10FFFF\n      ) {\n        return false;\n      }\n\n      i += 4;\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nmodule.exports = isValidUTF8;\n","'use strict';\n\ntry {\n  module.exports = require('node-gyp-build')(__dirname);\n} catch (e) {\n  module.exports = require('./fallback');\n}\n","var v1 = require('./v1');\nvar v4 = require('./v4');\n\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\n\nmodule.exports = uuid;\n","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  return ([\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]]\n  ]).join('');\n}\n\nmodule.exports = bytesToUuid;\n","// Unique ID creation requires a high quality random # generator.  In node.js\n// this is pretty straight-forward - we use the crypto API.\n\nvar crypto = require('crypto');\n\nmodule.exports = function nodeRNG() {\n  return crypto.randomBytes(16);\n};\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nvar _nodeId;\nvar _clockseq;\n\n// Previous uuid creation time\nvar _lastMSecs = 0;\nvar _lastNSecs = 0;\n\n// See https://github.com/uuidjs/uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n  if (node == null || clockseq == null) {\n    var seedBytes = rng();\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [\n        seedBytes[0] | 0x01,\n        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]\n      ];\n    }\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  }\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nmodule.exports = v1;\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n","/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n'use strict';\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst events_1 = require(\"./events\");\r\nconst Is = require(\"./is\");\r\nvar CancellationToken;\r\n(function (CancellationToken) {\r\n    CancellationToken.None = Object.freeze({\r\n        isCancellationRequested: false,\r\n        onCancellationRequested: events_1.Event.None\r\n    });\r\n    CancellationToken.Cancelled = Object.freeze({\r\n        isCancellationRequested: true,\r\n        onCancellationRequested: events_1.Event.None\r\n    });\r\n    function is(value) {\r\n        let candidate = value;\r\n        return candidate && (candidate === CancellationToken.None\r\n            || candidate === CancellationToken.Cancelled\r\n            || (Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested));\r\n    }\r\n    CancellationToken.is = is;\r\n})(CancellationToken = exports.CancellationToken || (exports.CancellationToken = {}));\r\nconst shortcutEvent = Object.freeze(function (callback, context) {\r\n    let handle = setTimeout(callback.bind(context), 0);\r\n    return { dispose() { clearTimeout(handle); } };\r\n});\r\nclass MutableToken {\r\n    constructor() {\r\n        this._isCancelled = false;\r\n    }\r\n    cancel() {\r\n        if (!this._isCancelled) {\r\n            this._isCancelled = true;\r\n            if (this._emitter) {\r\n                this._emitter.fire(undefined);\r\n                this._emitter = undefined;\r\n            }\r\n        }\r\n    }\r\n    get isCancellationRequested() {\r\n        return this._isCancelled;\r\n    }\r\n    get onCancellationRequested() {\r\n        if (this._isCancelled) {\r\n            return shortcutEvent;\r\n        }\r\n        if (!this._emitter) {\r\n            this._emitter = new events_1.Emitter();\r\n        }\r\n        return this._emitter.event;\r\n    }\r\n}\r\nclass CancellationTokenSource {\r\n    get token() {\r\n        if (!this._token) {\r\n            // be lazy and create the token only when\r\n            // actually needed\r\n            this._token = new MutableToken();\r\n        }\r\n        return this._token;\r\n    }\r\n    cancel() {\r\n        if (!this._token) {\r\n            // save an object by returning the default\r\n            // cancelled token when cancellation happens\r\n            // before someone asks for the token\r\n            this._token = CancellationToken.Cancelled;\r\n        }\r\n        else {\r\n            this._token.cancel();\r\n        }\r\n    }\r\n    dispose() {\r\n        this.cancel();\r\n    }\r\n}\r\nexports.CancellationTokenSource = CancellationTokenSource;\r\n","/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n'use strict';\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Disposable;\r\n(function (Disposable) {\r\n    function create(func) {\r\n        return {\r\n            dispose: func\r\n        };\r\n    }\r\n    Disposable.create = create;\r\n})(Disposable = exports.Disposable || (exports.Disposable = {}));\r\nvar Event;\r\n(function (Event) {\r\n    const _disposable = { dispose() { } };\r\n    Event.None = function () { return _disposable; };\r\n})(Event = exports.Event || (exports.Event = {}));\r\nclass CallbackList {\r\n    add(callback, context = null, bucket) {\r\n        if (!this._callbacks) {\r\n            this._callbacks = [];\r\n            this._contexts = [];\r\n        }\r\n        this._callbacks.push(callback);\r\n        this._contexts.push(context);\r\n        if (Array.isArray(bucket)) {\r\n            bucket.push({ dispose: () => this.remove(callback, context) });\r\n        }\r\n    }\r\n    remove(callback, context = null) {\r\n        if (!this._callbacks) {\r\n            return;\r\n        }\r\n        var foundCallbackWithDifferentContext = false;\r\n        for (var i = 0, len = this._callbacks.length; i < len; i++) {\r\n            if (this._callbacks[i] === callback) {\r\n                if (this._contexts[i] === context) {\r\n                    // callback & context match => remove it\r\n                    this._callbacks.splice(i, 1);\r\n                    this._contexts.splice(i, 1);\r\n                    return;\r\n                }\r\n                else {\r\n                    foundCallbackWithDifferentContext = true;\r\n                }\r\n            }\r\n        }\r\n        if (foundCallbackWithDifferentContext) {\r\n            throw new Error('When adding a listener with a context, you should remove it with the same context');\r\n        }\r\n    }\r\n    invoke(...args) {\r\n        if (!this._callbacks) {\r\n            return [];\r\n        }\r\n        var ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);\r\n        for (var i = 0, len = callbacks.length; i < len; i++) {\r\n            try {\r\n                ret.push(callbacks[i].apply(contexts[i], args));\r\n            }\r\n            catch (e) {\r\n                console.error(e);\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n    isEmpty() {\r\n        return !this._callbacks || this._callbacks.length === 0;\r\n    }\r\n    dispose() {\r\n        this._callbacks = undefined;\r\n        this._contexts = undefined;\r\n    }\r\n}\r\nclass Emitter {\r\n    constructor(_options) {\r\n        this._options = _options;\r\n    }\r\n    /**\r\n     * For the public to allow to subscribe\r\n     * to events from this Emitter\r\n     */\r\n    get event() {\r\n        if (!this._event) {\r\n            this._event = (listener, thisArgs, disposables) => {\r\n                if (!this._callbacks) {\r\n                    this._callbacks = new CallbackList();\r\n                }\r\n                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {\r\n                    this._options.onFirstListenerAdd(this);\r\n                }\r\n                this._callbacks.add(listener, thisArgs);\r\n                let result;\r\n                result = {\r\n                    dispose: () => {\r\n                        this._callbacks.remove(listener, thisArgs);\r\n                        result.dispose = Emitter._noop;\r\n                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {\r\n                            this._options.onLastListenerRemove(this);\r\n                        }\r\n                    }\r\n                };\r\n                if (Array.isArray(disposables)) {\r\n                    disposables.push(result);\r\n                }\r\n                return result;\r\n            };\r\n        }\r\n        return this._event;\r\n    }\r\n    /**\r\n     * To be kept private to fire an event to\r\n     * subscribers\r\n     */\r\n    fire(event) {\r\n        if (this._callbacks) {\r\n            this._callbacks.invoke.call(this._callbacks, event);\r\n        }\r\n    }\r\n    dispose() {\r\n        if (this._callbacks) {\r\n            this._callbacks.dispose();\r\n            this._callbacks = undefined;\r\n        }\r\n    }\r\n}\r\nEmitter._noop = function () { };\r\nexports.Emitter = Emitter;\r\n","/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n'use strict';\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction boolean(value) {\r\n    return value === true || value === false;\r\n}\r\nexports.boolean = boolean;\r\nfunction string(value) {\r\n    return typeof value === 'string' || value instanceof String;\r\n}\r\nexports.string = string;\r\nfunction number(value) {\r\n    return typeof value === 'number' || value instanceof Number;\r\n}\r\nexports.number = number;\r\nfunction error(value) {\r\n    return value instanceof Error;\r\n}\r\nexports.error = error;\r\nfunction func(value) {\r\n    return typeof value === 'function';\r\n}\r\nexports.func = func;\r\nfunction array(value) {\r\n    return Array.isArray(value);\r\n}\r\nexports.array = array;\r\nfunction stringArray(value) {\r\n    return array(value) && value.every(elem => string(elem));\r\n}\r\nexports.stringArray = stringArray;\r\n","\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Touch;\r\n(function (Touch) {\r\n    Touch.None = 0;\r\n    Touch.First = 1;\r\n    Touch.Last = 2;\r\n})(Touch = exports.Touch || (exports.Touch = {}));\r\nclass LinkedMap {\r\n    constructor() {\r\n        this._map = new Map();\r\n        this._head = undefined;\r\n        this._tail = undefined;\r\n        this._size = 0;\r\n    }\r\n    clear() {\r\n        this._map.clear();\r\n        this._head = undefined;\r\n        this._tail = undefined;\r\n        this._size = 0;\r\n    }\r\n    isEmpty() {\r\n        return !this._head && !this._tail;\r\n    }\r\n    get size() {\r\n        return this._size;\r\n    }\r\n    has(key) {\r\n        return this._map.has(key);\r\n    }\r\n    get(key) {\r\n        const item = this._map.get(key);\r\n        if (!item) {\r\n            return undefined;\r\n        }\r\n        return item.value;\r\n    }\r\n    set(key, value, touch = Touch.None) {\r\n        let item = this._map.get(key);\r\n        if (item) {\r\n            item.value = value;\r\n            if (touch !== Touch.None) {\r\n                this.touch(item, touch);\r\n            }\r\n        }\r\n        else {\r\n            item = { key, value, next: undefined, previous: undefined };\r\n            switch (touch) {\r\n                case Touch.None:\r\n                    this.addItemLast(item);\r\n                    break;\r\n                case Touch.First:\r\n                    this.addItemFirst(item);\r\n                    break;\r\n                case Touch.Last:\r\n                    this.addItemLast(item);\r\n                    break;\r\n                default:\r\n                    this.addItemLast(item);\r\n                    break;\r\n            }\r\n            this._map.set(key, item);\r\n            this._size++;\r\n        }\r\n    }\r\n    delete(key) {\r\n        const item = this._map.get(key);\r\n        if (!item) {\r\n            return false;\r\n        }\r\n        this._map.delete(key);\r\n        this.removeItem(item);\r\n        this._size--;\r\n        return true;\r\n    }\r\n    shift() {\r\n        if (!this._head && !this._tail) {\r\n            return undefined;\r\n        }\r\n        if (!this._head || !this._tail) {\r\n            throw new Error('Invalid list');\r\n        }\r\n        const item = this._head;\r\n        this._map.delete(item.key);\r\n        this.removeItem(item);\r\n        this._size--;\r\n        return item.value;\r\n    }\r\n    forEach(callbackfn, thisArg) {\r\n        let current = this._head;\r\n        while (current) {\r\n            if (thisArg) {\r\n                callbackfn.bind(thisArg)(current.value, current.key, this);\r\n            }\r\n            else {\r\n                callbackfn(current.value, current.key, this);\r\n            }\r\n            current = current.next;\r\n        }\r\n    }\r\n    forEachReverse(callbackfn, thisArg) {\r\n        let current = this._tail;\r\n        while (current) {\r\n            if (thisArg) {\r\n                callbackfn.bind(thisArg)(current.value, current.key, this);\r\n            }\r\n            else {\r\n                callbackfn(current.value, current.key, this);\r\n            }\r\n            current = current.previous;\r\n        }\r\n    }\r\n    values() {\r\n        let result = [];\r\n        let current = this._head;\r\n        while (current) {\r\n            result.push(current.value);\r\n            current = current.next;\r\n        }\r\n        return result;\r\n    }\r\n    keys() {\r\n        let result = [];\r\n        let current = this._head;\r\n        while (current) {\r\n            result.push(current.key);\r\n            current = current.next;\r\n        }\r\n        return result;\r\n    }\r\n    /* JSON RPC run on es5 which has no Symbol.iterator\r\n    public keys(): IterableIterator<K> {\r\n        let current = this._head;\r\n        let iterator: IterableIterator<K> = {\r\n            [Symbol.iterator]() {\r\n                return iterator;\r\n            },\r\n            next():IteratorResult<K> {\r\n                if (current) {\r\n                    let result = { value: current.key, done: false };\r\n                    current = current.next;\r\n                    return result;\r\n                } else {\r\n                    return { value: undefined, done: true };\r\n                }\r\n            }\r\n        };\r\n        return iterator;\r\n    }\r\n\r\n    public values(): IterableIterator<V> {\r\n        let current = this._head;\r\n        let iterator: IterableIterator<V> = {\r\n            [Symbol.iterator]() {\r\n                return iterator;\r\n            },\r\n            next():IteratorResult<V> {\r\n                if (current) {\r\n                    let result = { value: current.value, done: false };\r\n                    current = current.next;\r\n                    return result;\r\n                } else {\r\n                    return { value: undefined, done: true };\r\n                }\r\n            }\r\n        };\r\n        return iterator;\r\n    }\r\n    */\r\n    addItemFirst(item) {\r\n        // First time Insert\r\n        if (!this._head && !this._tail) {\r\n            this._tail = item;\r\n        }\r\n        else if (!this._head) {\r\n            throw new Error('Invalid list');\r\n        }\r\n        else {\r\n            item.next = this._head;\r\n            this._head.previous = item;\r\n        }\r\n        this._head = item;\r\n    }\r\n    addItemLast(item) {\r\n        // First time Insert\r\n        if (!this._head && !this._tail) {\r\n            this._head = item;\r\n        }\r\n        else if (!this._tail) {\r\n            throw new Error('Invalid list');\r\n        }\r\n        else {\r\n            item.previous = this._tail;\r\n            this._tail.next = item;\r\n        }\r\n        this._tail = item;\r\n    }\r\n    removeItem(item) {\r\n        if (item === this._head && item === this._tail) {\r\n            this._head = undefined;\r\n            this._tail = undefined;\r\n        }\r\n        else if (item === this._head) {\r\n            this._head = item.next;\r\n        }\r\n        else if (item === this._tail) {\r\n            this._tail = item.previous;\r\n        }\r\n        else {\r\n            const next = item.next;\r\n            const previous = item.previous;\r\n            if (!next || !previous) {\r\n                throw new Error('Invalid list');\r\n            }\r\n            next.previous = previous;\r\n            previous.next = next;\r\n        }\r\n    }\r\n    touch(item, touch) {\r\n        if (!this._head || !this._tail) {\r\n            throw new Error('Invalid list');\r\n        }\r\n        if ((touch !== Touch.First && touch !== Touch.Last)) {\r\n            return;\r\n        }\r\n        if (touch === Touch.First) {\r\n            if (item === this._head) {\r\n                return;\r\n            }\r\n            const next = item.next;\r\n            const previous = item.previous;\r\n            // Unlink the item\r\n            if (item === this._tail) {\r\n                // previous must be defined since item was not head but is tail\r\n                // So there are more than on item in the map\r\n                previous.next = undefined;\r\n                this._tail = previous;\r\n            }\r\n            else {\r\n                // Both next and previous are not undefined since item was neither head nor tail.\r\n                next.previous = previous;\r\n                previous.next = next;\r\n            }\r\n            // Insert the node at head\r\n            item.previous = undefined;\r\n            item.next = this._head;\r\n            this._head.previous = item;\r\n            this._head = item;\r\n        }\r\n        else if (touch === Touch.Last) {\r\n            if (item === this._tail) {\r\n                return;\r\n            }\r\n            const next = item.next;\r\n            const previous = item.previous;\r\n            // Unlink the item.\r\n            if (item === this._head) {\r\n                // next must be defined since item was not tail but is head\r\n                // So there are more than on item in the map\r\n                next.previous = undefined;\r\n                this._head = next;\r\n            }\r\n            else {\r\n                // Both next and previous are not undefined since item was neither head nor tail.\r\n                next.previous = previous;\r\n                previous.next = next;\r\n            }\r\n            item.next = undefined;\r\n            item.previous = this._tail;\r\n            this._tail.next = item;\r\n            this._tail = item;\r\n        }\r\n    }\r\n}\r\nexports.LinkedMap = LinkedMap;\r\n","/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n/// <reference path=\"./thenable.ts\" />\r\n'use strict';\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Is = require(\"./is\");\r\nconst messages_1 = require(\"./messages\");\r\nexports.RequestType = messages_1.RequestType;\r\nexports.RequestType0 = messages_1.RequestType0;\r\nexports.RequestType1 = messages_1.RequestType1;\r\nexports.RequestType2 = messages_1.RequestType2;\r\nexports.RequestType3 = messages_1.RequestType3;\r\nexports.RequestType4 = messages_1.RequestType4;\r\nexports.RequestType5 = messages_1.RequestType5;\r\nexports.RequestType6 = messages_1.RequestType6;\r\nexports.RequestType7 = messages_1.RequestType7;\r\nexports.RequestType8 = messages_1.RequestType8;\r\nexports.RequestType9 = messages_1.RequestType9;\r\nexports.ResponseError = messages_1.ResponseError;\r\nexports.ErrorCodes = messages_1.ErrorCodes;\r\nexports.NotificationType = messages_1.NotificationType;\r\nexports.NotificationType0 = messages_1.NotificationType0;\r\nexports.NotificationType1 = messages_1.NotificationType1;\r\nexports.NotificationType2 = messages_1.NotificationType2;\r\nexports.NotificationType3 = messages_1.NotificationType3;\r\nexports.NotificationType4 = messages_1.NotificationType4;\r\nexports.NotificationType5 = messages_1.NotificationType5;\r\nexports.NotificationType6 = messages_1.NotificationType6;\r\nexports.NotificationType7 = messages_1.NotificationType7;\r\nexports.NotificationType8 = messages_1.NotificationType8;\r\nexports.NotificationType9 = messages_1.NotificationType9;\r\nconst messageReader_1 = require(\"./messageReader\");\r\nexports.MessageReader = messageReader_1.MessageReader;\r\nexports.StreamMessageReader = messageReader_1.StreamMessageReader;\r\nexports.IPCMessageReader = messageReader_1.IPCMessageReader;\r\nexports.SocketMessageReader = messageReader_1.SocketMessageReader;\r\nconst messageWriter_1 = require(\"./messageWriter\");\r\nexports.MessageWriter = messageWriter_1.MessageWriter;\r\nexports.StreamMessageWriter = messageWriter_1.StreamMessageWriter;\r\nexports.IPCMessageWriter = messageWriter_1.IPCMessageWriter;\r\nexports.SocketMessageWriter = messageWriter_1.SocketMessageWriter;\r\nconst events_1 = require(\"./events\");\r\nexports.Disposable = events_1.Disposable;\r\nexports.Event = events_1.Event;\r\nexports.Emitter = events_1.Emitter;\r\nconst cancellation_1 = require(\"./cancellation\");\r\nexports.CancellationTokenSource = cancellation_1.CancellationTokenSource;\r\nexports.CancellationToken = cancellation_1.CancellationToken;\r\nconst linkedMap_1 = require(\"./linkedMap\");\r\n__export(require(\"./pipeSupport\"));\r\n__export(require(\"./socketSupport\"));\r\nvar CancelNotification;\r\n(function (CancelNotification) {\r\n    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');\r\n})(CancelNotification || (CancelNotification = {}));\r\nexports.NullLogger = Object.freeze({\r\n    error: () => { },\r\n    warn: () => { },\r\n    info: () => { },\r\n    log: () => { }\r\n});\r\nvar Trace;\r\n(function (Trace) {\r\n    Trace[Trace[\"Off\"] = 0] = \"Off\";\r\n    Trace[Trace[\"Messages\"] = 1] = \"Messages\";\r\n    Trace[Trace[\"Verbose\"] = 2] = \"Verbose\";\r\n})(Trace = exports.Trace || (exports.Trace = {}));\r\n(function (Trace) {\r\n    function fromString(value) {\r\n        value = value.toLowerCase();\r\n        switch (value) {\r\n            case 'off':\r\n                return Trace.Off;\r\n            case 'messages':\r\n                return Trace.Messages;\r\n            case 'verbose':\r\n                return Trace.Verbose;\r\n            default:\r\n                return Trace.Off;\r\n        }\r\n    }\r\n    Trace.fromString = fromString;\r\n    function toString(value) {\r\n        switch (value) {\r\n            case Trace.Off:\r\n                return 'off';\r\n            case Trace.Messages:\r\n                return 'messages';\r\n            case Trace.Verbose:\r\n                return 'verbose';\r\n            default:\r\n                return 'off';\r\n        }\r\n    }\r\n    Trace.toString = toString;\r\n})(Trace = exports.Trace || (exports.Trace = {}));\r\nvar TraceFormat;\r\n(function (TraceFormat) {\r\n    TraceFormat[\"Text\"] = \"text\";\r\n    TraceFormat[\"JSON\"] = \"json\";\r\n})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));\r\n(function (TraceFormat) {\r\n    function fromString(value) {\r\n        value = value.toLowerCase();\r\n        if (value === 'json') {\r\n            return TraceFormat.JSON;\r\n        }\r\n        else {\r\n            return TraceFormat.Text;\r\n        }\r\n    }\r\n    TraceFormat.fromString = fromString;\r\n})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));\r\nvar SetTraceNotification;\r\n(function (SetTraceNotification) {\r\n    SetTraceNotification.type = new messages_1.NotificationType('$/setTraceNotification');\r\n})(SetTraceNotification = exports.SetTraceNotification || (exports.SetTraceNotification = {}));\r\nvar LogTraceNotification;\r\n(function (LogTraceNotification) {\r\n    LogTraceNotification.type = new messages_1.NotificationType('$/logTraceNotification');\r\n})(LogTraceNotification = exports.LogTraceNotification || (exports.LogTraceNotification = {}));\r\nvar ConnectionErrors;\r\n(function (ConnectionErrors) {\r\n    /**\r\n     * The connection is closed.\r\n     */\r\n    ConnectionErrors[ConnectionErrors[\"Closed\"] = 1] = \"Closed\";\r\n    /**\r\n     * The connection got disposed.\r\n     */\r\n    ConnectionErrors[ConnectionErrors[\"Disposed\"] = 2] = \"Disposed\";\r\n    /**\r\n     * The connection is already in listening mode.\r\n     */\r\n    ConnectionErrors[ConnectionErrors[\"AlreadyListening\"] = 3] = \"AlreadyListening\";\r\n})(ConnectionErrors = exports.ConnectionErrors || (exports.ConnectionErrors = {}));\r\nclass ConnectionError extends Error {\r\n    constructor(code, message) {\r\n        super(message);\r\n        this.code = code;\r\n        Object.setPrototypeOf(this, ConnectionError.prototype);\r\n    }\r\n}\r\nexports.ConnectionError = ConnectionError;\r\nvar ConnectionStrategy;\r\n(function (ConnectionStrategy) {\r\n    function is(value) {\r\n        let candidate = value;\r\n        return candidate && Is.func(candidate.cancelUndispatched);\r\n    }\r\n    ConnectionStrategy.is = is;\r\n})(ConnectionStrategy = exports.ConnectionStrategy || (exports.ConnectionStrategy = {}));\r\nvar ConnectionState;\r\n(function (ConnectionState) {\r\n    ConnectionState[ConnectionState[\"New\"] = 1] = \"New\";\r\n    ConnectionState[ConnectionState[\"Listening\"] = 2] = \"Listening\";\r\n    ConnectionState[ConnectionState[\"Closed\"] = 3] = \"Closed\";\r\n    ConnectionState[ConnectionState[\"Disposed\"] = 4] = \"Disposed\";\r\n})(ConnectionState || (ConnectionState = {}));\r\nfunction _createMessageConnection(messageReader, messageWriter, logger, strategy) {\r\n    let sequenceNumber = 0;\r\n    let notificationSquenceNumber = 0;\r\n    let unknownResponseSquenceNumber = 0;\r\n    const version = '2.0';\r\n    let starRequestHandler = undefined;\r\n    let requestHandlers = Object.create(null);\r\n    let starNotificationHandler = undefined;\r\n    let notificationHandlers = Object.create(null);\r\n    let timer;\r\n    let messageQueue = new linkedMap_1.LinkedMap();\r\n    let responsePromises = Object.create(null);\r\n    let requestTokens = Object.create(null);\r\n    let trace = Trace.Off;\r\n    let traceFormat = TraceFormat.Text;\r\n    let tracer;\r\n    let state = ConnectionState.New;\r\n    let errorEmitter = new events_1.Emitter();\r\n    let closeEmitter = new events_1.Emitter();\r\n    let unhandledNotificationEmitter = new events_1.Emitter();\r\n    let disposeEmitter = new events_1.Emitter();\r\n    function createRequestQueueKey(id) {\r\n        return 'req-' + id.toString();\r\n    }\r\n    function createResponseQueueKey(id) {\r\n        if (id === null) {\r\n            return 'res-unknown-' + (++unknownResponseSquenceNumber).toString();\r\n        }\r\n        else {\r\n            return 'res-' + id.toString();\r\n        }\r\n    }\r\n    function createNotificationQueueKey() {\r\n        return 'not-' + (++notificationSquenceNumber).toString();\r\n    }\r\n    function addMessageToQueue(queue, message) {\r\n        if (messages_1.isRequestMessage(message)) {\r\n            queue.set(createRequestQueueKey(message.id), message);\r\n        }\r\n        else if (messages_1.isResponseMessage(message)) {\r\n            queue.set(createResponseQueueKey(message.id), message);\r\n        }\r\n        else {\r\n            queue.set(createNotificationQueueKey(), message);\r\n        }\r\n    }\r\n    function cancelUndispatched(_message) {\r\n        return undefined;\r\n    }\r\n    function isListening() {\r\n        return state === ConnectionState.Listening;\r\n    }\r\n    function isClosed() {\r\n        return state === ConnectionState.Closed;\r\n    }\r\n    function isDisposed() {\r\n        return state === ConnectionState.Disposed;\r\n    }\r\n    function closeHandler() {\r\n        if (state === ConnectionState.New || state === ConnectionState.Listening) {\r\n            state = ConnectionState.Closed;\r\n            closeEmitter.fire(undefined);\r\n        }\r\n        // If the connection is disposed don't sent close events.\r\n    }\r\n    ;\r\n    function readErrorHandler(error) {\r\n        errorEmitter.fire([error, undefined, undefined]);\r\n    }\r\n    function writeErrorHandler(data) {\r\n        errorEmitter.fire(data);\r\n    }\r\n    messageReader.onClose(closeHandler);\r\n    messageReader.onError(readErrorHandler);\r\n    messageWriter.onClose(closeHandler);\r\n    messageWriter.onError(writeErrorHandler);\r\n    function triggerMessageQueue() {\r\n        if (timer || messageQueue.size === 0) {\r\n            return;\r\n        }\r\n        timer = setImmediate(() => {\r\n            timer = undefined;\r\n            processMessageQueue();\r\n        });\r\n    }\r\n    function processMessageQueue() {\r\n        if (messageQueue.size === 0) {\r\n            return;\r\n        }\r\n        let message = messageQueue.shift();\r\n        try {\r\n            if (messages_1.isRequestMessage(message)) {\r\n                handleRequest(message);\r\n            }\r\n            else if (messages_1.isNotificationMessage(message)) {\r\n                handleNotification(message);\r\n            }\r\n            else if (messages_1.isResponseMessage(message)) {\r\n                handleResponse(message);\r\n            }\r\n            else {\r\n                handleInvalidMessage(message);\r\n            }\r\n        }\r\n        finally {\r\n            triggerMessageQueue();\r\n        }\r\n    }\r\n    let callback = (message) => {\r\n        try {\r\n            // We have received a cancellation message. Check if the message is still in the queue\r\n            // and cancel it if allowed to do so.\r\n            if (messages_1.isNotificationMessage(message) && message.method === CancelNotification.type.method) {\r\n                let key = createRequestQueueKey(message.params.id);\r\n                let toCancel = messageQueue.get(key);\r\n                if (messages_1.isRequestMessage(toCancel)) {\r\n                    let response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);\r\n                    if (response && (response.error !== void 0 || response.result !== void 0)) {\r\n                        messageQueue.delete(key);\r\n                        response.id = toCancel.id;\r\n                        traceSendingResponse(response, message.method, Date.now());\r\n                        messageWriter.write(response);\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            addMessageToQueue(messageQueue, message);\r\n        }\r\n        finally {\r\n            triggerMessageQueue();\r\n        }\r\n    };\r\n    function handleRequest(requestMessage) {\r\n        if (isDisposed()) {\r\n            // we return here silently since we fired an event when the\r\n            // connection got disposed.\r\n            return;\r\n        }\r\n        function reply(resultOrError, method, startTime) {\r\n            let message = {\r\n                jsonrpc: version,\r\n                id: requestMessage.id\r\n            };\r\n            if (resultOrError instanceof messages_1.ResponseError) {\r\n                message.error = resultOrError.toJson();\r\n            }\r\n            else {\r\n                message.result = resultOrError === void 0 ? null : resultOrError;\r\n            }\r\n            traceSendingResponse(message, method, startTime);\r\n            messageWriter.write(message);\r\n        }\r\n        function replyError(error, method, startTime) {\r\n            let message = {\r\n                jsonrpc: version,\r\n                id: requestMessage.id,\r\n                error: error.toJson()\r\n            };\r\n            traceSendingResponse(message, method, startTime);\r\n            messageWriter.write(message);\r\n        }\r\n        function replySuccess(result, method, startTime) {\r\n            // The JSON RPC defines that a response must either have a result or an error\r\n            // So we can't treat undefined as a valid response result.\r\n            if (result === void 0) {\r\n                result = null;\r\n            }\r\n            let message = {\r\n                jsonrpc: version,\r\n                id: requestMessage.id,\r\n                result: result\r\n            };\r\n            traceSendingResponse(message, method, startTime);\r\n            messageWriter.write(message);\r\n        }\r\n        traceReceivedRequest(requestMessage);\r\n        let element = requestHandlers[requestMessage.method];\r\n        let type;\r\n        let requestHandler;\r\n        if (element) {\r\n            type = element.type;\r\n            requestHandler = element.handler;\r\n        }\r\n        let startTime = Date.now();\r\n        if (requestHandler || starRequestHandler) {\r\n            let cancellationSource = new cancellation_1.CancellationTokenSource();\r\n            let tokenKey = String(requestMessage.id);\r\n            requestTokens[tokenKey] = cancellationSource;\r\n            try {\r\n                let handlerResult;\r\n                if (requestMessage.params === void 0 || (type !== void 0 && type.numberOfParams === 0)) {\r\n                    handlerResult = requestHandler\r\n                        ? requestHandler(cancellationSource.token)\r\n                        : starRequestHandler(requestMessage.method, cancellationSource.token);\r\n                }\r\n                else if (Is.array(requestMessage.params) && (type === void 0 || type.numberOfParams > 1)) {\r\n                    handlerResult = requestHandler\r\n                        ? requestHandler(...requestMessage.params, cancellationSource.token)\r\n                        : starRequestHandler(requestMessage.method, ...requestMessage.params, cancellationSource.token);\r\n                }\r\n                else {\r\n                    handlerResult = requestHandler\r\n                        ? requestHandler(requestMessage.params, cancellationSource.token)\r\n                        : starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);\r\n                }\r\n                let promise = handlerResult;\r\n                if (!handlerResult) {\r\n                    delete requestTokens[tokenKey];\r\n                    replySuccess(handlerResult, requestMessage.method, startTime);\r\n                }\r\n                else if (promise.then) {\r\n                    promise.then((resultOrError) => {\r\n                        delete requestTokens[tokenKey];\r\n                        reply(resultOrError, requestMessage.method, startTime);\r\n                    }, error => {\r\n                        delete requestTokens[tokenKey];\r\n                        if (error instanceof messages_1.ResponseError) {\r\n                            replyError(error, requestMessage.method, startTime);\r\n                        }\r\n                        else if (error && Is.string(error.message)) {\r\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);\r\n                        }\r\n                        else {\r\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);\r\n                        }\r\n                    });\r\n                }\r\n                else {\r\n                    delete requestTokens[tokenKey];\r\n                    reply(handlerResult, requestMessage.method, startTime);\r\n                }\r\n            }\r\n            catch (error) {\r\n                delete requestTokens[tokenKey];\r\n                if (error instanceof messages_1.ResponseError) {\r\n                    reply(error, requestMessage.method, startTime);\r\n                }\r\n                else if (error && Is.string(error.message)) {\r\n                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);\r\n                }\r\n                else {\r\n                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);\r\n        }\r\n    }\r\n    function handleResponse(responseMessage) {\r\n        if (isDisposed()) {\r\n            // See handle request.\r\n            return;\r\n        }\r\n        if (responseMessage.id === null) {\r\n            if (responseMessage.error) {\r\n                logger.error(`Received response message without id: Error is: \\n${JSON.stringify(responseMessage.error, undefined, 4)}`);\r\n            }\r\n            else {\r\n                logger.error(`Received response message without id. No further error information provided.`);\r\n            }\r\n        }\r\n        else {\r\n            let key = String(responseMessage.id);\r\n            let responsePromise = responsePromises[key];\r\n            traceReceivedResponse(responseMessage, responsePromise);\r\n            if (responsePromise) {\r\n                delete responsePromises[key];\r\n                try {\r\n                    if (responseMessage.error) {\r\n                        let error = responseMessage.error;\r\n                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));\r\n                    }\r\n                    else if (responseMessage.result !== void 0) {\r\n                        responsePromise.resolve(responseMessage.result);\r\n                    }\r\n                    else {\r\n                        throw new Error('Should never happen.');\r\n                    }\r\n                }\r\n                catch (error) {\r\n                    if (error.message) {\r\n                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);\r\n                    }\r\n                    else {\r\n                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function handleNotification(message) {\r\n        if (isDisposed()) {\r\n            // See handle request.\r\n            return;\r\n        }\r\n        let type = undefined;\r\n        let notificationHandler;\r\n        if (message.method === CancelNotification.type.method) {\r\n            notificationHandler = (params) => {\r\n                let id = params.id;\r\n                let source = requestTokens[String(id)];\r\n                if (source) {\r\n                    source.cancel();\r\n                }\r\n            };\r\n        }\r\n        else {\r\n            let element = notificationHandlers[message.method];\r\n            if (element) {\r\n                notificationHandler = element.handler;\r\n                type = element.type;\r\n            }\r\n        }\r\n        if (notificationHandler || starNotificationHandler) {\r\n            try {\r\n                traceReceivedNotification(message);\r\n                if (message.params === void 0 || (type !== void 0 && type.numberOfParams === 0)) {\r\n                    notificationHandler ? notificationHandler() : starNotificationHandler(message.method);\r\n                }\r\n                else if (Is.array(message.params) && (type === void 0 || type.numberOfParams > 1)) {\r\n                    notificationHandler ? notificationHandler(...message.params) : starNotificationHandler(message.method, ...message.params);\r\n                }\r\n                else {\r\n                    notificationHandler ? notificationHandler(message.params) : starNotificationHandler(message.method, message.params);\r\n                }\r\n            }\r\n            catch (error) {\r\n                if (error.message) {\r\n                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);\r\n                }\r\n                else {\r\n                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            unhandledNotificationEmitter.fire(message);\r\n        }\r\n    }\r\n    function handleInvalidMessage(message) {\r\n        if (!message) {\r\n            logger.error('Received empty message.');\r\n            return;\r\n        }\r\n        logger.error(`Received message which is neither a response nor a notification message:\\n${JSON.stringify(message, null, 4)}`);\r\n        // Test whether we find an id to reject the promise\r\n        let responseMessage = message;\r\n        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {\r\n            let key = String(responseMessage.id);\r\n            let responseHandler = responsePromises[key];\r\n            if (responseHandler) {\r\n                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));\r\n            }\r\n        }\r\n    }\r\n    function traceSendingRequest(message) {\r\n        if (trace === Trace.Off || !tracer) {\r\n            return;\r\n        }\r\n        if (traceFormat === TraceFormat.Text) {\r\n            let data = undefined;\r\n            if (trace === Trace.Verbose && message.params) {\r\n                data = `Params: ${JSON.stringify(message.params, null, 4)}\\n\\n`;\r\n            }\r\n            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);\r\n        }\r\n        else {\r\n            logLSPMessage('send-request', message);\r\n        }\r\n    }\r\n    function traceSendingNotification(message) {\r\n        if (trace === Trace.Off || !tracer) {\r\n            return;\r\n        }\r\n        if (traceFormat === TraceFormat.Text) {\r\n            let data = undefined;\r\n            if (trace === Trace.Verbose) {\r\n                if (message.params) {\r\n                    data = `Params: ${JSON.stringify(message.params, null, 4)}\\n\\n`;\r\n                }\r\n                else {\r\n                    data = 'No parameters provided.\\n\\n';\r\n                }\r\n            }\r\n            tracer.log(`Sending notification '${message.method}'.`, data);\r\n        }\r\n        else {\r\n            logLSPMessage('send-notification', message);\r\n        }\r\n    }\r\n    function traceSendingResponse(message, method, startTime) {\r\n        if (trace === Trace.Off || !tracer) {\r\n            return;\r\n        }\r\n        if (traceFormat === TraceFormat.Text) {\r\n            let data = undefined;\r\n            if (trace === Trace.Verbose) {\r\n                if (message.error && message.error.data) {\r\n                    data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\\n\\n`;\r\n                }\r\n                else {\r\n                    if (message.result) {\r\n                        data = `Result: ${JSON.stringify(message.result, null, 4)}\\n\\n`;\r\n                    }\r\n                    else if (message.error === void 0) {\r\n                        data = 'No result returned.\\n\\n';\r\n                    }\r\n                }\r\n            }\r\n            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);\r\n        }\r\n        else {\r\n            logLSPMessage('send-response', message);\r\n        }\r\n    }\r\n    function traceReceivedRequest(message) {\r\n        if (trace === Trace.Off || !tracer) {\r\n            return;\r\n        }\r\n        if (traceFormat === TraceFormat.Text) {\r\n            let data = undefined;\r\n            if (trace === Trace.Verbose && message.params) {\r\n                data = `Params: ${JSON.stringify(message.params, null, 4)}\\n\\n`;\r\n            }\r\n            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);\r\n        }\r\n        else {\r\n            logLSPMessage('receive-request', message);\r\n        }\r\n    }\r\n    function traceReceivedNotification(message) {\r\n        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {\r\n            return;\r\n        }\r\n        if (traceFormat === TraceFormat.Text) {\r\n            let data = undefined;\r\n            if (trace === Trace.Verbose) {\r\n                if (message.params) {\r\n                    data = `Params: ${JSON.stringify(message.params, null, 4)}\\n\\n`;\r\n                }\r\n                else {\r\n                    data = 'No parameters provided.\\n\\n';\r\n                }\r\n            }\r\n            tracer.log(`Received notification '${message.method}'.`, data);\r\n        }\r\n        else {\r\n            logLSPMessage('receive-notification', message);\r\n        }\r\n    }\r\n    function traceReceivedResponse(message, responsePromise) {\r\n        if (trace === Trace.Off || !tracer) {\r\n            return;\r\n        }\r\n        if (traceFormat === TraceFormat.Text) {\r\n            let data = undefined;\r\n            if (trace === Trace.Verbose) {\r\n                if (message.error && message.error.data) {\r\n                    data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\\n\\n`;\r\n                }\r\n                else {\r\n                    if (message.result) {\r\n                        data = `Result: ${JSON.stringify(message.result, null, 4)}\\n\\n`;\r\n                    }\r\n                    else if (message.error === void 0) {\r\n                        data = 'No result returned.\\n\\n';\r\n                    }\r\n                }\r\n            }\r\n            if (responsePromise) {\r\n                let error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';\r\n                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);\r\n            }\r\n            else {\r\n                tracer.log(`Received response ${message.id} without active response promise.`, data);\r\n            }\r\n        }\r\n        else {\r\n            logLSPMessage('receive-response', message);\r\n        }\r\n    }\r\n    function logLSPMessage(type, message) {\r\n        if (!tracer || trace === Trace.Off) {\r\n            return;\r\n        }\r\n        const lspMessage = {\r\n            isLSPMessage: true,\r\n            type,\r\n            message,\r\n            timestamp: Date.now()\r\n        };\r\n        tracer.log(lspMessage);\r\n    }\r\n    function throwIfClosedOrDisposed() {\r\n        if (isClosed()) {\r\n            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');\r\n        }\r\n        if (isDisposed()) {\r\n            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');\r\n        }\r\n    }\r\n    function throwIfListening() {\r\n        if (isListening()) {\r\n            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');\r\n        }\r\n    }\r\n    function throwIfNotListening() {\r\n        if (!isListening()) {\r\n            throw new Error('Call listen() first.');\r\n        }\r\n    }\r\n    function undefinedToNull(param) {\r\n        if (param === void 0) {\r\n            return null;\r\n        }\r\n        else {\r\n            return param;\r\n        }\r\n    }\r\n    function computeMessageParams(type, params) {\r\n        let result;\r\n        let numberOfParams = type.numberOfParams;\r\n        switch (numberOfParams) {\r\n            case 0:\r\n                result = null;\r\n                break;\r\n            case 1:\r\n                result = undefinedToNull(params[0]);\r\n                break;\r\n            default:\r\n                result = [];\r\n                for (let i = 0; i < params.length && i < numberOfParams; i++) {\r\n                    result.push(undefinedToNull(params[i]));\r\n                }\r\n                if (params.length < numberOfParams) {\r\n                    for (let i = params.length; i < numberOfParams; i++) {\r\n                        result.push(null);\r\n                    }\r\n                }\r\n                break;\r\n        }\r\n        return result;\r\n    }\r\n    let connection = {\r\n        sendNotification: (type, ...params) => {\r\n            throwIfClosedOrDisposed();\r\n            let method;\r\n            let messageParams;\r\n            if (Is.string(type)) {\r\n                method = type;\r\n                switch (params.length) {\r\n                    case 0:\r\n                        messageParams = null;\r\n                        break;\r\n                    case 1:\r\n                        messageParams = params[0];\r\n                        break;\r\n                    default:\r\n                        messageParams = params;\r\n                        break;\r\n                }\r\n            }\r\n            else {\r\n                method = type.method;\r\n                messageParams = computeMessageParams(type, params);\r\n            }\r\n            let notificationMessage = {\r\n                jsonrpc: version,\r\n                method: method,\r\n                params: messageParams\r\n            };\r\n            traceSendingNotification(notificationMessage);\r\n            messageWriter.write(notificationMessage);\r\n        },\r\n        onNotification: (type, handler) => {\r\n            throwIfClosedOrDisposed();\r\n            if (Is.func(type)) {\r\n                starNotificationHandler = type;\r\n            }\r\n            else if (handler) {\r\n                if (Is.string(type)) {\r\n                    notificationHandlers[type] = { type: undefined, handler };\r\n                }\r\n                else {\r\n                    notificationHandlers[type.method] = { type, handler };\r\n                }\r\n            }\r\n        },\r\n        sendRequest: (type, ...params) => {\r\n            throwIfClosedOrDisposed();\r\n            throwIfNotListening();\r\n            let method;\r\n            let messageParams;\r\n            let token = undefined;\r\n            if (Is.string(type)) {\r\n                method = type;\r\n                switch (params.length) {\r\n                    case 0:\r\n                        messageParams = null;\r\n                        break;\r\n                    case 1:\r\n                        // The cancellation token is optional so it can also be undefined.\r\n                        if (cancellation_1.CancellationToken.is(params[0])) {\r\n                            messageParams = null;\r\n                            token = params[0];\r\n                        }\r\n                        else {\r\n                            messageParams = undefinedToNull(params[0]);\r\n                        }\r\n                        break;\r\n                    default:\r\n                        const last = params.length - 1;\r\n                        if (cancellation_1.CancellationToken.is(params[last])) {\r\n                            token = params[last];\r\n                            if (params.length === 2) {\r\n                                messageParams = undefinedToNull(params[0]);\r\n                            }\r\n                            else {\r\n                                messageParams = params.slice(0, last).map(value => undefinedToNull(value));\r\n                            }\r\n                        }\r\n                        else {\r\n                            messageParams = params.map(value => undefinedToNull(value));\r\n                        }\r\n                        break;\r\n                }\r\n            }\r\n            else {\r\n                method = type.method;\r\n                messageParams = computeMessageParams(type, params);\r\n                let numberOfParams = type.numberOfParams;\r\n                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;\r\n            }\r\n            let id = sequenceNumber++;\r\n            let result = new Promise((resolve, reject) => {\r\n                let requestMessage = {\r\n                    jsonrpc: version,\r\n                    id: id,\r\n                    method: method,\r\n                    params: messageParams\r\n                };\r\n                let responsePromise = { method: method, timerStart: Date.now(), resolve, reject };\r\n                traceSendingRequest(requestMessage);\r\n                try {\r\n                    messageWriter.write(requestMessage);\r\n                }\r\n                catch (e) {\r\n                    // Writing the message failed. So we need to reject the promise.\r\n                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : 'Unknown reason'));\r\n                    responsePromise = null;\r\n                }\r\n                if (responsePromise) {\r\n                    responsePromises[String(id)] = responsePromise;\r\n                }\r\n            });\r\n            if (token) {\r\n                token.onCancellationRequested(() => {\r\n                    connection.sendNotification(CancelNotification.type, { id });\r\n                });\r\n            }\r\n            return result;\r\n        },\r\n        onRequest: (type, handler) => {\r\n            throwIfClosedOrDisposed();\r\n            if (Is.func(type)) {\r\n                starRequestHandler = type;\r\n            }\r\n            else if (handler) {\r\n                if (Is.string(type)) {\r\n                    requestHandlers[type] = { type: undefined, handler };\r\n                }\r\n                else {\r\n                    requestHandlers[type.method] = { type, handler };\r\n                }\r\n            }\r\n        },\r\n        trace: (_value, _tracer, sendNotificationOrTraceOptions) => {\r\n            let _sendNotification = false;\r\n            let _traceFormat = TraceFormat.Text;\r\n            if (sendNotificationOrTraceOptions !== void 0) {\r\n                if (Is.boolean(sendNotificationOrTraceOptions)) {\r\n                    _sendNotification = sendNotificationOrTraceOptions;\r\n                }\r\n                else {\r\n                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;\r\n                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;\r\n                }\r\n            }\r\n            trace = _value;\r\n            traceFormat = _traceFormat;\r\n            if (trace === Trace.Off) {\r\n                tracer = undefined;\r\n            }\r\n            else {\r\n                tracer = _tracer;\r\n            }\r\n            if (_sendNotification && !isClosed() && !isDisposed()) {\r\n                connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });\r\n            }\r\n        },\r\n        onError: errorEmitter.event,\r\n        onClose: closeEmitter.event,\r\n        onUnhandledNotification: unhandledNotificationEmitter.event,\r\n        onDispose: disposeEmitter.event,\r\n        dispose: () => {\r\n            if (isDisposed()) {\r\n                return;\r\n            }\r\n            state = ConnectionState.Disposed;\r\n            disposeEmitter.fire(undefined);\r\n            let error = new Error('Connection got disposed.');\r\n            Object.keys(responsePromises).forEach((key) => {\r\n                responsePromises[key].reject(error);\r\n            });\r\n            responsePromises = Object.create(null);\r\n            requestTokens = Object.create(null);\r\n            messageQueue = new linkedMap_1.LinkedMap();\r\n            // Test for backwards compatibility\r\n            if (Is.func(messageWriter.dispose)) {\r\n                messageWriter.dispose();\r\n            }\r\n            if (Is.func(messageReader.dispose)) {\r\n                messageReader.dispose();\r\n            }\r\n        },\r\n        listen: () => {\r\n            throwIfClosedOrDisposed();\r\n            throwIfListening();\r\n            state = ConnectionState.Listening;\r\n            messageReader.listen(callback);\r\n        },\r\n        inspect: () => {\r\n            console.log(\"inspect\");\r\n        }\r\n    };\r\n    connection.onNotification(LogTraceNotification.type, (params) => {\r\n        if (trace === Trace.Off || !tracer) {\r\n            return;\r\n        }\r\n        tracer.log(params.message, trace === Trace.Verbose ? params.verbose : undefined);\r\n    });\r\n    return connection;\r\n}\r\nfunction isMessageReader(value) {\r\n    return value.listen !== void 0 && value.read === void 0;\r\n}\r\nfunction isMessageWriter(value) {\r\n    return value.write !== void 0 && value.end === void 0;\r\n}\r\nfunction createMessageConnection(input, output, logger, strategy) {\r\n    if (!logger) {\r\n        logger = exports.NullLogger;\r\n    }\r\n    let reader = isMessageReader(input) ? input : new messageReader_1.StreamMessageReader(input);\r\n    let writer = isMessageWriter(output) ? output : new messageWriter_1.StreamMessageWriter(output);\r\n    return _createMessageConnection(reader, writer, logger, strategy);\r\n}\r\nexports.createMessageConnection = createMessageConnection;\r\n","/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n'use strict';\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst events_1 = require(\"./events\");\r\nconst Is = require(\"./is\");\r\nlet DefaultSize = 8192;\r\nlet CR = Buffer.from('\\r', 'ascii')[0];\r\nlet LF = Buffer.from('\\n', 'ascii')[0];\r\nlet CRLF = '\\r\\n';\r\nclass MessageBuffer {\r\n    constructor(encoding = 'utf8') {\r\n        this.encoding = encoding;\r\n        this.index = 0;\r\n        this.buffer = Buffer.allocUnsafe(DefaultSize);\r\n    }\r\n    append(chunk) {\r\n        var toAppend = chunk;\r\n        if (typeof (chunk) === 'string') {\r\n            var str = chunk;\r\n            var bufferLen = Buffer.byteLength(str, this.encoding);\r\n            toAppend = Buffer.allocUnsafe(bufferLen);\r\n            toAppend.write(str, 0, bufferLen, this.encoding);\r\n        }\r\n        if (this.buffer.length - this.index >= toAppend.length) {\r\n            toAppend.copy(this.buffer, this.index, 0, toAppend.length);\r\n        }\r\n        else {\r\n            var newSize = (Math.ceil((this.index + toAppend.length) / DefaultSize) + 1) * DefaultSize;\r\n            if (this.index === 0) {\r\n                this.buffer = Buffer.allocUnsafe(newSize);\r\n                toAppend.copy(this.buffer, 0, 0, toAppend.length);\r\n            }\r\n            else {\r\n                this.buffer = Buffer.concat([this.buffer.slice(0, this.index), toAppend], newSize);\r\n            }\r\n        }\r\n        this.index += toAppend.length;\r\n    }\r\n    tryReadHeaders() {\r\n        let result = undefined;\r\n        let current = 0;\r\n        while (current + 3 < this.index && (this.buffer[current] !== CR || this.buffer[current + 1] !== LF || this.buffer[current + 2] !== CR || this.buffer[current + 3] !== LF)) {\r\n            current++;\r\n        }\r\n        // No header / body separator found (e.g CRLFCRLF)\r\n        if (current + 3 >= this.index) {\r\n            return result;\r\n        }\r\n        result = Object.create(null);\r\n        let headers = this.buffer.toString('ascii', 0, current).split(CRLF);\r\n        headers.forEach((header) => {\r\n            let index = header.indexOf(':');\r\n            if (index === -1) {\r\n                throw new Error('Message header must separate key and value using :');\r\n            }\r\n            let key = header.substr(0, index);\r\n            let value = header.substr(index + 1).trim();\r\n            result[key] = value;\r\n        });\r\n        let nextStart = current + 4;\r\n        this.buffer = this.buffer.slice(nextStart);\r\n        this.index = this.index - nextStart;\r\n        return result;\r\n    }\r\n    tryReadContent(length) {\r\n        if (this.index < length) {\r\n            return null;\r\n        }\r\n        let result = this.buffer.toString(this.encoding, 0, length);\r\n        let nextStart = length;\r\n        this.buffer.copy(this.buffer, 0, nextStart);\r\n        this.index = this.index - nextStart;\r\n        return result;\r\n    }\r\n    get numberOfBytes() {\r\n        return this.index;\r\n    }\r\n}\r\nvar MessageReader;\r\n(function (MessageReader) {\r\n    function is(value) {\r\n        let candidate = value;\r\n        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) &&\r\n            Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);\r\n    }\r\n    MessageReader.is = is;\r\n})(MessageReader = exports.MessageReader || (exports.MessageReader = {}));\r\nclass AbstractMessageReader {\r\n    constructor() {\r\n        this.errorEmitter = new events_1.Emitter();\r\n        this.closeEmitter = new events_1.Emitter();\r\n        this.partialMessageEmitter = new events_1.Emitter();\r\n    }\r\n    dispose() {\r\n        this.errorEmitter.dispose();\r\n        this.closeEmitter.dispose();\r\n    }\r\n    get onError() {\r\n        return this.errorEmitter.event;\r\n    }\r\n    fireError(error) {\r\n        this.errorEmitter.fire(this.asError(error));\r\n    }\r\n    get onClose() {\r\n        return this.closeEmitter.event;\r\n    }\r\n    fireClose() {\r\n        this.closeEmitter.fire(undefined);\r\n    }\r\n    get onPartialMessage() {\r\n        return this.partialMessageEmitter.event;\r\n    }\r\n    firePartialMessage(info) {\r\n        this.partialMessageEmitter.fire(info);\r\n    }\r\n    asError(error) {\r\n        if (error instanceof Error) {\r\n            return error;\r\n        }\r\n        else {\r\n            return new Error(`Reader recevied error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);\r\n        }\r\n    }\r\n}\r\nexports.AbstractMessageReader = AbstractMessageReader;\r\nclass StreamMessageReader extends AbstractMessageReader {\r\n    constructor(readable, encoding = 'utf8') {\r\n        super();\r\n        this.readable = readable;\r\n        this.buffer = new MessageBuffer(encoding);\r\n        this._partialMessageTimeout = 10000;\r\n    }\r\n    set partialMessageTimeout(timeout) {\r\n        this._partialMessageTimeout = timeout;\r\n    }\r\n    get partialMessageTimeout() {\r\n        return this._partialMessageTimeout;\r\n    }\r\n    listen(callback) {\r\n        this.nextMessageLength = -1;\r\n        this.messageToken = 0;\r\n        this.partialMessageTimer = undefined;\r\n        this.callback = callback;\r\n        this.readable.on('data', (data) => {\r\n            this.onData(data);\r\n        });\r\n        this.readable.on('error', (error) => this.fireError(error));\r\n        this.readable.on('close', () => this.fireClose());\r\n    }\r\n    onData(data) {\r\n        this.buffer.append(data);\r\n        while (true) {\r\n            if (this.nextMessageLength === -1) {\r\n                let headers = this.buffer.tryReadHeaders();\r\n                if (!headers) {\r\n                    return;\r\n                }\r\n                let contentLength = headers['Content-Length'];\r\n                if (!contentLength) {\r\n                    throw new Error('Header must provide a Content-Length property.');\r\n                }\r\n                let length = parseInt(contentLength);\r\n                if (isNaN(length)) {\r\n                    throw new Error('Content-Length value must be a number.');\r\n                }\r\n                this.nextMessageLength = length;\r\n                // Take the encoding form the header. For compatibility\r\n                // treat both utf-8 and utf8 as node utf8\r\n            }\r\n            var msg = this.buffer.tryReadContent(this.nextMessageLength);\r\n            if (msg === null) {\r\n                /** We haven't recevied the full message yet. */\r\n                this.setPartialMessageTimer();\r\n                return;\r\n            }\r\n            this.clearPartialMessageTimer();\r\n            this.nextMessageLength = -1;\r\n            this.messageToken++;\r\n            var json = JSON.parse(msg);\r\n            this.callback(json);\r\n        }\r\n    }\r\n    clearPartialMessageTimer() {\r\n        if (this.partialMessageTimer) {\r\n            clearTimeout(this.partialMessageTimer);\r\n            this.partialMessageTimer = undefined;\r\n        }\r\n    }\r\n    setPartialMessageTimer() {\r\n        this.clearPartialMessageTimer();\r\n        if (this._partialMessageTimeout <= 0) {\r\n            return;\r\n        }\r\n        this.partialMessageTimer = setTimeout((token, timeout) => {\r\n            this.partialMessageTimer = undefined;\r\n            if (token === this.messageToken) {\r\n                this.firePartialMessage({ messageToken: token, waitingTime: timeout });\r\n                this.setPartialMessageTimer();\r\n            }\r\n        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);\r\n    }\r\n}\r\nexports.StreamMessageReader = StreamMessageReader;\r\nclass IPCMessageReader extends AbstractMessageReader {\r\n    constructor(process) {\r\n        super();\r\n        this.process = process;\r\n        let eventEmitter = this.process;\r\n        eventEmitter.on('error', (error) => this.fireError(error));\r\n        eventEmitter.on('close', () => this.fireClose());\r\n    }\r\n    listen(callback) {\r\n        this.process.on('message', callback);\r\n    }\r\n}\r\nexports.IPCMessageReader = IPCMessageReader;\r\nclass SocketMessageReader extends StreamMessageReader {\r\n    constructor(socket, encoding = 'utf-8') {\r\n        super(socket, encoding);\r\n    }\r\n}\r\nexports.SocketMessageReader = SocketMessageReader;\r\n","/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n'use strict';\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst events_1 = require(\"./events\");\r\nconst Is = require(\"./is\");\r\nlet ContentLength = 'Content-Length: ';\r\nlet CRLF = '\\r\\n';\r\nvar MessageWriter;\r\n(function (MessageWriter) {\r\n    function is(value) {\r\n        let candidate = value;\r\n        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) &&\r\n            Is.func(candidate.onError) && Is.func(candidate.write);\r\n    }\r\n    MessageWriter.is = is;\r\n})(MessageWriter = exports.MessageWriter || (exports.MessageWriter = {}));\r\nclass AbstractMessageWriter {\r\n    constructor() {\r\n        this.errorEmitter = new events_1.Emitter();\r\n        this.closeEmitter = new events_1.Emitter();\r\n    }\r\n    dispose() {\r\n        this.errorEmitter.dispose();\r\n        this.closeEmitter.dispose();\r\n    }\r\n    get onError() {\r\n        return this.errorEmitter.event;\r\n    }\r\n    fireError(error, message, count) {\r\n        this.errorEmitter.fire([this.asError(error), message, count]);\r\n    }\r\n    get onClose() {\r\n        return this.closeEmitter.event;\r\n    }\r\n    fireClose() {\r\n        this.closeEmitter.fire(undefined);\r\n    }\r\n    asError(error) {\r\n        if (error instanceof Error) {\r\n            return error;\r\n        }\r\n        else {\r\n            return new Error(`Writer recevied error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);\r\n        }\r\n    }\r\n}\r\nexports.AbstractMessageWriter = AbstractMessageWriter;\r\nclass StreamMessageWriter extends AbstractMessageWriter {\r\n    constructor(writable, encoding = 'utf8') {\r\n        super();\r\n        this.writable = writable;\r\n        this.encoding = encoding;\r\n        this.errorCount = 0;\r\n        this.writable.on('error', (error) => this.fireError(error));\r\n        this.writable.on('close', () => this.fireClose());\r\n    }\r\n    write(msg) {\r\n        let json = JSON.stringify(msg);\r\n        let contentLength = Buffer.byteLength(json, this.encoding);\r\n        let headers = [\r\n            ContentLength, contentLength.toString(), CRLF,\r\n            CRLF\r\n        ];\r\n        try {\r\n            // Header must be written in ASCII encoding\r\n            this.writable.write(headers.join(''), 'ascii');\r\n            // Now write the content. This can be written in any encoding\r\n            this.writable.write(json, this.encoding);\r\n            this.errorCount = 0;\r\n        }\r\n        catch (error) {\r\n            this.errorCount++;\r\n            this.fireError(error, msg, this.errorCount);\r\n        }\r\n    }\r\n}\r\nexports.StreamMessageWriter = StreamMessageWriter;\r\nclass IPCMessageWriter extends AbstractMessageWriter {\r\n    constructor(process) {\r\n        super();\r\n        this.process = process;\r\n        this.errorCount = 0;\r\n        this.queue = [];\r\n        this.sending = false;\r\n        let eventEmitter = this.process;\r\n        eventEmitter.on('error', (error) => this.fireError(error));\r\n        eventEmitter.on('close', () => this.fireClose);\r\n    }\r\n    write(msg) {\r\n        if (!this.sending && this.queue.length === 0) {\r\n            // See https://github.com/nodejs/node/issues/7657\r\n            this.doWriteMessage(msg);\r\n        }\r\n        else {\r\n            this.queue.push(msg);\r\n        }\r\n    }\r\n    doWriteMessage(msg) {\r\n        try {\r\n            if (this.process.send) {\r\n                this.sending = true;\r\n                this.process.send(msg, undefined, undefined, (error) => {\r\n                    this.sending = false;\r\n                    if (error) {\r\n                        this.errorCount++;\r\n                        this.fireError(error, msg, this.errorCount);\r\n                    }\r\n                    else {\r\n                        this.errorCount = 0;\r\n                    }\r\n                    if (this.queue.length > 0) {\r\n                        this.doWriteMessage(this.queue.shift());\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        catch (error) {\r\n            this.errorCount++;\r\n            this.fireError(error, msg, this.errorCount);\r\n        }\r\n    }\r\n}\r\nexports.IPCMessageWriter = IPCMessageWriter;\r\nclass SocketMessageWriter extends AbstractMessageWriter {\r\n    constructor(socket, encoding = 'utf8') {\r\n        super();\r\n        this.socket = socket;\r\n        this.queue = [];\r\n        this.sending = false;\r\n        this.encoding = encoding;\r\n        this.errorCount = 0;\r\n        this.socket.on('error', (error) => this.fireError(error));\r\n        this.socket.on('close', () => this.fireClose());\r\n    }\r\n    write(msg) {\r\n        if (!this.sending && this.queue.length === 0) {\r\n            // See https://github.com/nodejs/node/issues/7657\r\n            this.doWriteMessage(msg);\r\n        }\r\n        else {\r\n            this.queue.push(msg);\r\n        }\r\n    }\r\n    doWriteMessage(msg) {\r\n        let json = JSON.stringify(msg);\r\n        let contentLength = Buffer.byteLength(json, this.encoding);\r\n        let headers = [\r\n            ContentLength, contentLength.toString(), CRLF,\r\n            CRLF\r\n        ];\r\n        try {\r\n            // Header must be written in ASCII encoding\r\n            this.sending = true;\r\n            this.socket.write(headers.join(''), 'ascii', (error) => {\r\n                if (error) {\r\n                    this.handleError(error, msg);\r\n                }\r\n                try {\r\n                    // Now write the content. This can be written in any encoding\r\n                    this.socket.write(json, this.encoding, (error) => {\r\n                        this.sending = false;\r\n                        if (error) {\r\n                            this.handleError(error, msg);\r\n                        }\r\n                        else {\r\n                            this.errorCount = 0;\r\n                        }\r\n                        if (this.queue.length > 0) {\r\n                            this.doWriteMessage(this.queue.shift());\r\n                        }\r\n                    });\r\n                }\r\n                catch (error) {\r\n                    this.handleError(error, msg);\r\n                }\r\n            });\r\n        }\r\n        catch (error) {\r\n            this.handleError(error, msg);\r\n        }\r\n    }\r\n    handleError(error, msg) {\r\n        this.errorCount++;\r\n        this.fireError(error, msg, this.errorCount);\r\n    }\r\n}\r\nexports.SocketMessageWriter = SocketMessageWriter;\r\n","/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n'use strict';\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst is = require(\"./is\");\r\n/**\r\n * Predefined error codes.\r\n */\r\nvar ErrorCodes;\r\n(function (ErrorCodes) {\r\n    // Defined by JSON RPC\r\n    ErrorCodes.ParseError = -32700;\r\n    ErrorCodes.InvalidRequest = -32600;\r\n    ErrorCodes.MethodNotFound = -32601;\r\n    ErrorCodes.InvalidParams = -32602;\r\n    ErrorCodes.InternalError = -32603;\r\n    ErrorCodes.serverErrorStart = -32099;\r\n    ErrorCodes.serverErrorEnd = -32000;\r\n    ErrorCodes.ServerNotInitialized = -32002;\r\n    ErrorCodes.UnknownErrorCode = -32001;\r\n    // Defined by the protocol.\r\n    ErrorCodes.RequestCancelled = -32800;\r\n    // Defined by VSCode library.\r\n    ErrorCodes.MessageWriteError = 1;\r\n    ErrorCodes.MessageReadError = 2;\r\n})(ErrorCodes = exports.ErrorCodes || (exports.ErrorCodes = {}));\r\n/**\r\n * An error object return in a response in case a request\r\n * has failed.\r\n */\r\nclass ResponseError extends Error {\r\n    constructor(code, message, data) {\r\n        super(message);\r\n        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;\r\n        this.data = data;\r\n        Object.setPrototypeOf(this, ResponseError.prototype);\r\n    }\r\n    toJson() {\r\n        return {\r\n            code: this.code,\r\n            message: this.message,\r\n            data: this.data,\r\n        };\r\n    }\r\n}\r\nexports.ResponseError = ResponseError;\r\n/**\r\n * An abstract implementation of a MessageType.\r\n */\r\nclass AbstractMessageType {\r\n    constructor(_method, _numberOfParams) {\r\n        this._method = _method;\r\n        this._numberOfParams = _numberOfParams;\r\n    }\r\n    get method() {\r\n        return this._method;\r\n    }\r\n    get numberOfParams() {\r\n        return this._numberOfParams;\r\n    }\r\n}\r\nexports.AbstractMessageType = AbstractMessageType;\r\n/**\r\n * Classes to type request response pairs\r\n */\r\nclass RequestType0 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 0);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.RequestType0 = RequestType0;\r\nclass RequestType extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 1);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.RequestType = RequestType;\r\nclass RequestType1 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 1);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.RequestType1 = RequestType1;\r\nclass RequestType2 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 2);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.RequestType2 = RequestType2;\r\nclass RequestType3 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 3);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.RequestType3 = RequestType3;\r\nclass RequestType4 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 4);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.RequestType4 = RequestType4;\r\nclass RequestType5 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 5);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.RequestType5 = RequestType5;\r\nclass RequestType6 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 6);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.RequestType6 = RequestType6;\r\nclass RequestType7 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 7);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.RequestType7 = RequestType7;\r\nclass RequestType8 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 8);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.RequestType8 = RequestType8;\r\nclass RequestType9 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 9);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.RequestType9 = RequestType9;\r\nclass NotificationType extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 1);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.NotificationType = NotificationType;\r\nclass NotificationType0 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 0);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.NotificationType0 = NotificationType0;\r\nclass NotificationType1 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 1);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.NotificationType1 = NotificationType1;\r\nclass NotificationType2 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 2);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.NotificationType2 = NotificationType2;\r\nclass NotificationType3 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 3);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.NotificationType3 = NotificationType3;\r\nclass NotificationType4 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 4);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.NotificationType4 = NotificationType4;\r\nclass NotificationType5 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 5);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.NotificationType5 = NotificationType5;\r\nclass NotificationType6 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 6);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.NotificationType6 = NotificationType6;\r\nclass NotificationType7 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 7);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.NotificationType7 = NotificationType7;\r\nclass NotificationType8 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 8);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.NotificationType8 = NotificationType8;\r\nclass NotificationType9 extends AbstractMessageType {\r\n    constructor(method) {\r\n        super(method, 9);\r\n        this._ = undefined;\r\n    }\r\n}\r\nexports.NotificationType9 = NotificationType9;\r\n/**\r\n * Tests if the given message is a request message\r\n */\r\nfunction isRequestMessage(message) {\r\n    let candidate = message;\r\n    return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));\r\n}\r\nexports.isRequestMessage = isRequestMessage;\r\n/**\r\n * Tests if the given message is a notification message\r\n */\r\nfunction isNotificationMessage(message) {\r\n    let candidate = message;\r\n    return candidate && is.string(candidate.method) && message.id === void 0;\r\n}\r\nexports.isNotificationMessage = isNotificationMessage;\r\n/**\r\n * Tests if the given message is a response message\r\n */\r\nfunction isResponseMessage(message) {\r\n    let candidate = message;\r\n    return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);\r\n}\r\nexports.isResponseMessage = isResponseMessage;\r\n","/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n'use strict';\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst path_1 = require(\"path\");\r\nconst os_1 = require(\"os\");\r\nconst crypto_1 = require(\"crypto\");\r\nconst net_1 = require(\"net\");\r\nconst messageReader_1 = require(\"./messageReader\");\r\nconst messageWriter_1 = require(\"./messageWriter\");\r\nfunction generateRandomPipeName() {\r\n    const randomSuffix = crypto_1.randomBytes(21).toString('hex');\r\n    if (process.platform === 'win32') {\r\n        return `\\\\\\\\.\\\\pipe\\\\vscode-jsonrpc-${randomSuffix}-sock`;\r\n    }\r\n    else {\r\n        // Mac/Unix: use socket file\r\n        return path_1.join(os_1.tmpdir(), `vscode-${randomSuffix}.sock`);\r\n    }\r\n}\r\nexports.generateRandomPipeName = generateRandomPipeName;\r\nfunction createClientPipeTransport(pipeName, encoding = 'utf-8') {\r\n    let connectResolve;\r\n    let connected = new Promise((resolve, _reject) => {\r\n        connectResolve = resolve;\r\n    });\r\n    return new Promise((resolve, reject) => {\r\n        let server = net_1.createServer((socket) => {\r\n            server.close();\r\n            connectResolve([\r\n                new messageReader_1.SocketMessageReader(socket, encoding),\r\n                new messageWriter_1.SocketMessageWriter(socket, encoding)\r\n            ]);\r\n        });\r\n        server.on('error', reject);\r\n        server.listen(pipeName, () => {\r\n            server.removeListener('error', reject);\r\n            resolve({\r\n                onConnected: () => { return connected; }\r\n            });\r\n        });\r\n    });\r\n}\r\nexports.createClientPipeTransport = createClientPipeTransport;\r\nfunction createServerPipeTransport(pipeName, encoding = 'utf-8') {\r\n    const socket = net_1.createConnection(pipeName);\r\n    return [\r\n        new messageReader_1.SocketMessageReader(socket, encoding),\r\n        new messageWriter_1.SocketMessageWriter(socket, encoding)\r\n    ];\r\n}\r\nexports.createServerPipeTransport = createServerPipeTransport;\r\n","/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n'use strict';\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst net_1 = require(\"net\");\r\nconst messageReader_1 = require(\"./messageReader\");\r\nconst messageWriter_1 = require(\"./messageWriter\");\r\nfunction createClientSocketTransport(port, encoding = 'utf-8') {\r\n    let connectResolve;\r\n    let connected = new Promise((resolve, _reject) => {\r\n        connectResolve = resolve;\r\n    });\r\n    return new Promise((resolve, reject) => {\r\n        let server = net_1.createServer((socket) => {\r\n            server.close();\r\n            connectResolve([\r\n                new messageReader_1.SocketMessageReader(socket, encoding),\r\n                new messageWriter_1.SocketMessageWriter(socket, encoding)\r\n            ]);\r\n        });\r\n        server.on('error', reject);\r\n        server.listen(port, '127.0.0.1', () => {\r\n            server.removeListener('error', reject);\r\n            resolve({\r\n                onConnected: () => { return connected; }\r\n            });\r\n        });\r\n    });\r\n}\r\nexports.createClientSocketTransport = createClientSocketTransport;\r\nfunction createServerSocketTransport(port, encoding = 'utf-8') {\r\n    const socket = net_1.createConnection(port, '127.0.0.1');\r\n    return [\r\n        new messageReader_1.SocketMessageReader(socket, encoding),\r\n        new messageWriter_1.SocketMessageWriter(socket, encoding)\r\n    ];\r\n}\r\nexports.createServerSocketTransport = createServerSocketTransport;\r\n","/* globals __webpack_amd_options__ */\nmodule.exports = __webpack_amd_options__;\n","module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","module.exports = require('./lib/websocket');","/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\n\nvar Deprecation = {\n    disableWarnings: false,\n\n    deprecationWarningMap: {\n\n    },\n\n    warn: function(deprecationName) {\n        if (!this.disableWarnings && this.deprecationWarningMap[deprecationName]) {\n            console.warn('DEPRECATION WARNING: ' + this.deprecationWarningMap[deprecationName]);\n            this.deprecationWarningMap[deprecationName] = false;\n        }\n    }\n};\n\nmodule.exports = Deprecation;\n","/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\n\nvar WebSocketClient = require('./WebSocketClient');\nvar toBuffer = require('typedarray-to-buffer');\nvar yaeti = require('yaeti');\n\n\nconst CONNECTING = 0;\nconst OPEN = 1;\nconst CLOSING = 2;\nconst CLOSED = 3;\n\n\nmodule.exports = W3CWebSocket;\n\n\nfunction W3CWebSocket(url, protocols, origin, headers, requestOptions, clientConfig) {\n    // Make this an EventTarget.\n    yaeti.EventTarget.call(this);\n\n    // Sanitize clientConfig.\n    clientConfig = clientConfig || {};\n    clientConfig.assembleFragments = true;  // Required in the W3C API.\n\n    var self = this;\n\n    this._url = url;\n    this._readyState = CONNECTING;\n    this._protocol = undefined;\n    this._extensions = '';\n    this._bufferedAmount = 0;  // Hack, always 0.\n    this._binaryType = 'arraybuffer';  // TODO: Should be 'blob' by default, but Node has no Blob.\n\n    // The WebSocketConnection instance.\n    this._connection = undefined;\n\n    // WebSocketClient instance.\n    this._client = new WebSocketClient(clientConfig);\n\n    this._client.on('connect', function(connection) {\n        onConnect.call(self, connection);\n    });\n\n    this._client.on('connectFailed', function() {\n        onConnectFailed.call(self);\n    });\n\n    this._client.connect(url, protocols, origin, headers, requestOptions);\n}\n\n\n// Expose W3C read only attributes.\nObject.defineProperties(W3CWebSocket.prototype, {\n    url:            { get: function() { return this._url;            } },\n    readyState:     { get: function() { return this._readyState;     } },\n    protocol:       { get: function() { return this._protocol;       } },\n    extensions:     { get: function() { return this._extensions;     } },\n    bufferedAmount: { get: function() { return this._bufferedAmount; } }\n});\n\n\n// Expose W3C write/read attributes.\nObject.defineProperties(W3CWebSocket.prototype, {\n    binaryType: {\n        get: function() {\n            return this._binaryType;\n        },\n        set: function(type) {\n            // TODO: Just 'arraybuffer' supported.\n            if (type !== 'arraybuffer') {\n                throw new SyntaxError('just \"arraybuffer\" type allowed for \"binaryType\" attribute');\n            }\n            this._binaryType = type;\n        }\n    }\n});\n\n\n// Expose W3C readyState constants into the WebSocket instance as W3C states.\n[['CONNECTING',CONNECTING], ['OPEN',OPEN], ['CLOSING',CLOSING], ['CLOSED',CLOSED]].forEach(function(property) {\n    Object.defineProperty(W3CWebSocket.prototype, property[0], {\n        get: function() { return property[1]; }\n    });\n});\n\n// Also expose W3C readyState constants into the WebSocket class (not defined by the W3C,\n// but there are so many libs relying on them).\n[['CONNECTING',CONNECTING], ['OPEN',OPEN], ['CLOSING',CLOSING], ['CLOSED',CLOSED]].forEach(function(property) {\n    Object.defineProperty(W3CWebSocket, property[0], {\n        get: function() { return property[1]; }\n    });\n});\n\n\nW3CWebSocket.prototype.send = function(data) {\n    if (this._readyState !== OPEN) {\n        throw new Error('cannot call send() while not connected');\n    }\n\n    // Text.\n    if (typeof data === 'string' || data instanceof String) {\n        this._connection.sendUTF(data);\n    }\n    // Binary.\n    else {\n        // Node Buffer.\n        if (data instanceof Buffer) {\n            this._connection.sendBytes(data);\n        }\n        // If ArrayBuffer or ArrayBufferView convert it to Node Buffer.\n        else if (data.byteLength || data.byteLength === 0) {\n            data = toBuffer(data);\n            this._connection.sendBytes(data);\n        }\n        else {\n            throw new Error('unknown binary data:', data);\n        }\n    }\n};\n\n\nW3CWebSocket.prototype.close = function(code, reason) {\n    switch(this._readyState) {\n        case CONNECTING:\n            // NOTE: We don't have the WebSocketConnection instance yet so no\n            // way to close the TCP connection.\n            // Artificially invoke the onConnectFailed event.\n            onConnectFailed.call(this);\n            // And close if it connects after a while.\n            this._client.on('connect', function(connection) {\n                if (code) {\n                    connection.close(code, reason);\n                } else {\n                    connection.close();\n                }\n            });\n            break;\n        case OPEN:\n            this._readyState = CLOSING;\n            if (code) {\n                this._connection.close(code, reason);\n            } else {\n                this._connection.close();\n            }\n            break;\n        case CLOSING:\n        case CLOSED:\n            break;\n    }\n};\n\n\n/**\n * Private API.\n */\n\n\nfunction createCloseEvent(code, reason) {\n    var event = new yaeti.Event('close');\n\n    event.code = code;\n    event.reason = reason;\n    event.wasClean = (typeof code === 'undefined' || code === 1000);\n\n    return event;\n}\n\n\nfunction createMessageEvent(data) {\n    var event = new yaeti.Event('message');\n\n    event.data = data;\n\n    return event;\n}\n\n\nfunction onConnect(connection) {\n    var self = this;\n\n    this._readyState = OPEN;\n    this._connection = connection;\n    this._protocol = connection.protocol;\n    this._extensions = connection.extensions;\n\n    this._connection.on('close', function(code, reason) {\n        onClose.call(self, code, reason);\n    });\n\n    this._connection.on('message', function(msg) {\n        onMessage.call(self, msg);\n    });\n\n    this.dispatchEvent(new yaeti.Event('open'));\n}\n\n\nfunction onConnectFailed() {\n    destroy.call(this);\n    this._readyState = CLOSED;\n\n    try {\n        this.dispatchEvent(new yaeti.Event('error'));\n    } finally {\n        this.dispatchEvent(createCloseEvent(1006, 'connection failed'));\n    }\n}\n\n\nfunction onClose(code, reason) {\n    destroy.call(this);\n    this._readyState = CLOSED;\n\n    this.dispatchEvent(createCloseEvent(code, reason || ''));\n}\n\n\nfunction onMessage(message) {\n    if (message.utf8Data) {\n        this.dispatchEvent(createMessageEvent(message.utf8Data));\n    }\n    else if (message.binaryData) {\n        // Must convert from Node Buffer to ArrayBuffer.\n        // TODO: or to a Blob (which does not exist in Node!).\n        if (this.binaryType === 'arraybuffer') {\n            var buffer = message.binaryData;\n            var arraybuffer = new ArrayBuffer(buffer.length);\n            var view = new Uint8Array(arraybuffer);\n            for (var i=0, len=buffer.length; i<len; ++i) {\n                view[i] = buffer[i];\n            }\n            this.dispatchEvent(createMessageEvent(arraybuffer));\n        }\n    }\n}\n\n\nfunction destroy() {\n    this._client.removeAllListeners();\n    if (this._connection) {\n        this._connection.removeAllListeners();\n    }\n}\n","/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\n\nvar utils = require('./utils');\nvar extend = utils.extend;\nvar util = require('util');\nvar EventEmitter = require('events').EventEmitter;\nvar http = require('http');\nvar https = require('https');\nvar url = require('url');\nvar crypto = require('crypto');\nvar WebSocketConnection = require('./WebSocketConnection');\nvar bufferAllocUnsafe = utils.bufferAllocUnsafe;\n\nvar protocolSeparators = [\n    '(', ')', '<', '>', '@',\n    ',', ';', ':', '\\\\', '\\\"',\n    '/', '[', ']', '?', '=',\n    '{', '}', ' ', String.fromCharCode(9)\n];\n\nvar excludedTlsOptions = ['hostname','port','method','path','headers'];\n\nfunction WebSocketClient(config) {\n    // Superclass Constructor\n    EventEmitter.call(this);\n\n    // TODO: Implement extensions\n\n    this.config = {\n        // 1MiB max frame size.\n        maxReceivedFrameSize: 0x100000,\n\n        // 8MiB max message size, only applicable if\n        // assembleFragments is true\n        maxReceivedMessageSize: 0x800000,\n\n        // Outgoing messages larger than fragmentationThreshold will be\n        // split into multiple fragments.\n        fragmentOutgoingMessages: true,\n\n        // Outgoing frames are fragmented if they exceed this threshold.\n        // Default is 16KiB\n        fragmentationThreshold: 0x4000,\n\n        // Which version of the protocol to use for this session.  This\n        // option will be removed once the protocol is finalized by the IETF\n        // It is only available to ease the transition through the\n        // intermediate draft protocol versions.\n        // At present, it only affects the name of the Origin header.\n        webSocketVersion: 13,\n\n        // If true, fragmented messages will be automatically assembled\n        // and the full message will be emitted via a 'message' event.\n        // If false, each frame will be emitted via a 'frame' event and\n        // the application will be responsible for aggregating multiple\n        // fragmented frames.  Single-frame messages will emit a 'message'\n        // event in addition to the 'frame' event.\n        // Most users will want to leave this set to 'true'\n        assembleFragments: true,\n\n        // The Nagle Algorithm makes more efficient use of network resources\n        // by introducing a small delay before sending small packets so that\n        // multiple messages can be batched together before going onto the\n        // wire.  This however comes at the cost of latency, so the default\n        // is to disable it.  If you don't need low latency and are streaming\n        // lots of small messages, you can change this to 'false'\n        disableNagleAlgorithm: true,\n\n        // The number of milliseconds to wait after sending a close frame\n        // for an acknowledgement to come back before giving up and just\n        // closing the socket.\n        closeTimeout: 5000,\n\n        // Options to pass to https.connect if connecting via TLS\n        tlsOptions: {}\n    };\n\n    if (config) {\n        var tlsOptions;\n        if (config.tlsOptions) {\n          tlsOptions = config.tlsOptions;\n          delete config.tlsOptions;\n        }\n        else {\n          tlsOptions = {};\n        }\n        extend(this.config, config);\n        extend(this.config.tlsOptions, tlsOptions);\n    }\n\n    this._req = null;\n    \n    switch (this.config.webSocketVersion) {\n        case 8:\n        case 13:\n            break;\n        default:\n            throw new Error('Requested webSocketVersion is not supported. Allowed values are 8 and 13.');\n    }\n}\n\nutil.inherits(WebSocketClient, EventEmitter);\n\nWebSocketClient.prototype.connect = function(requestUrl, protocols, origin, headers, extraRequestOptions) {\n    var self = this;\n    \n    if (typeof(protocols) === 'string') {\n        if (protocols.length > 0) {\n            protocols = [protocols];\n        }\n        else {\n            protocols = [];\n        }\n    }\n    if (!(protocols instanceof Array)) {\n        protocols = [];\n    }\n    this.protocols = protocols;\n    this.origin = origin;\n\n    if (typeof(requestUrl) === 'string') {\n        this.url = url.parse(requestUrl);\n    }\n    else {\n        this.url = requestUrl; // in case an already parsed url is passed in.\n    }\n    if (!this.url.protocol) {\n        throw new Error('You must specify a full WebSocket URL, including protocol.');\n    }\n    if (!this.url.host) {\n        throw new Error('You must specify a full WebSocket URL, including hostname. Relative URLs are not supported.');\n    }\n\n    this.secure = (this.url.protocol === 'wss:');\n\n    // validate protocol characters:\n    this.protocols.forEach(function(protocol) {\n        for (var i=0; i < protocol.length; i ++) {\n            var charCode = protocol.charCodeAt(i);\n            var character = protocol.charAt(i);\n            if (charCode < 0x0021 || charCode > 0x007E || protocolSeparators.indexOf(character) !== -1) {\n                throw new Error('Protocol list contains invalid character \"' + String.fromCharCode(charCode) + '\"');\n            }\n        }\n    });\n\n    var defaultPorts = {\n        'ws:': '80',\n        'wss:': '443'\n    };\n\n    if (!this.url.port) {\n        this.url.port = defaultPorts[this.url.protocol];\n    }\n\n    var nonce = bufferAllocUnsafe(16);\n    for (var i=0; i < 16; i++) {\n        nonce[i] = Math.round(Math.random()*0xFF);\n    }\n    this.base64nonce = nonce.toString('base64');\n\n    var hostHeaderValue = this.url.hostname;\n    if ((this.url.protocol === 'ws:' && this.url.port !== '80') ||\n        (this.url.protocol === 'wss:' && this.url.port !== '443'))  {\n        hostHeaderValue += (':' + this.url.port);\n    }\n\n    var reqHeaders = {};\n    if (this.secure && this.config.tlsOptions.hasOwnProperty('headers')) {\n      // Allow for additional headers to be provided when connecting via HTTPS\n      extend(reqHeaders, this.config.tlsOptions.headers);\n    }\n    if (headers) {\n      // Explicitly provided headers take priority over any from tlsOptions\n      extend(reqHeaders, headers);\n    }\n    extend(reqHeaders, {\n        'Upgrade': 'websocket',\n        'Connection': 'Upgrade',\n        'Sec-WebSocket-Version': this.config.webSocketVersion.toString(10),\n        'Sec-WebSocket-Key': this.base64nonce,\n        'Host': reqHeaders.Host || hostHeaderValue\n    });\n\n    if (this.protocols.length > 0) {\n        reqHeaders['Sec-WebSocket-Protocol'] = this.protocols.join(', ');\n    }\n    if (this.origin) {\n        if (this.config.webSocketVersion === 13) {\n            reqHeaders['Origin'] = this.origin;\n        }\n        else if (this.config.webSocketVersion === 8) {\n            reqHeaders['Sec-WebSocket-Origin'] = this.origin;\n        }\n    }\n\n    // TODO: Implement extensions\n\n    var pathAndQuery;\n    // Ensure it begins with '/'.\n    if (this.url.pathname) {\n        pathAndQuery = this.url.path;\n    }\n    else if (this.url.path) {\n        pathAndQuery = '/' + this.url.path;\n    }\n    else {\n        pathAndQuery = '/';\n    }\n\n    function handleRequestError(error) {\n        self._req = null;\n        self.emit('connectFailed', error);\n    }\n\n    var requestOptions = {\n        agent: false\n    };\n    if (extraRequestOptions) {\n        extend(requestOptions, extraRequestOptions);\n    }\n    // These options are always overridden by the library.  The user is not\n    // allowed to specify these directly.\n    extend(requestOptions, {\n        hostname: this.url.hostname,\n        port: this.url.port,\n        method: 'GET',\n        path: pathAndQuery,\n        headers: reqHeaders\n    });\n    if (this.secure) {\n        var tlsOptions = this.config.tlsOptions;\n        for (var key in tlsOptions) {\n            if (tlsOptions.hasOwnProperty(key) && excludedTlsOptions.indexOf(key) === -1) {\n                requestOptions[key] = tlsOptions[key];\n            }\n        }\n    }\n\n    var req = this._req = (this.secure ? https : http).request(requestOptions);\n    req.on('upgrade', function handleRequestUpgrade(response, socket, head) {\n        self._req = null;\n        req.removeListener('error', handleRequestError);\n        self.socket = socket;\n        self.response = response;\n        self.firstDataChunk = head;\n        self.validateHandshake();\n    });\n    req.on('error', handleRequestError);\n\n    req.on('response', function(response) {\n        self._req = null;\n        if (utils.eventEmitterListenerCount(self, 'httpResponse') > 0) {\n            self.emit('httpResponse', response, self);\n            if (response.socket) {\n                response.socket.end();\n            }\n        }\n        else {\n            var headerDumpParts = [];\n            for (var headerName in response.headers) {\n                headerDumpParts.push(headerName + ': ' + response.headers[headerName]);\n            }\n            self.failHandshake(\n                'Server responded with a non-101 status: ' +\n                response.statusCode + ' ' + response.statusMessage +\n                '\\nResponse Headers Follow:\\n' +\n                headerDumpParts.join('\\n') + '\\n'\n            );\n        }\n    });\n    req.end();\n};\n\nWebSocketClient.prototype.validateHandshake = function() {\n    var headers = this.response.headers;\n\n    if (this.protocols.length > 0) {\n        this.protocol = headers['sec-websocket-protocol'];\n        if (this.protocol) {\n            if (this.protocols.indexOf(this.protocol) === -1) {\n                this.failHandshake('Server did not respond with a requested protocol.');\n                return;\n            }\n        }\n        else {\n            this.failHandshake('Expected a Sec-WebSocket-Protocol header.');\n            return;\n        }\n    }\n\n    if (!(headers['connection'] && headers['connection'].toLocaleLowerCase() === 'upgrade')) {\n        this.failHandshake('Expected a Connection: Upgrade header from the server');\n        return;\n    }\n\n    if (!(headers['upgrade'] && headers['upgrade'].toLocaleLowerCase() === 'websocket')) {\n        this.failHandshake('Expected an Upgrade: websocket header from the server');\n        return;\n    }\n\n    var sha1 = crypto.createHash('sha1');\n    sha1.update(this.base64nonce + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11');\n    var expectedKey = sha1.digest('base64');\n\n    if (!headers['sec-websocket-accept']) {\n        this.failHandshake('Expected Sec-WebSocket-Accept header from server');\n        return;\n    }\n\n    if (headers['sec-websocket-accept'] !== expectedKey) {\n        this.failHandshake('Sec-WebSocket-Accept header from server didn\\'t match expected value of ' + expectedKey);\n        return;\n    }\n\n    // TODO: Support extensions\n\n    this.succeedHandshake();\n};\n\nWebSocketClient.prototype.failHandshake = function(errorDescription) {\n    if (this.socket && this.socket.writable) {\n        this.socket.end();\n    }\n    this.emit('connectFailed', new Error(errorDescription));\n};\n\nWebSocketClient.prototype.succeedHandshake = function() {\n    var connection = new WebSocketConnection(this.socket, [], this.protocol, true, this.config);\n\n    connection.webSocketVersion = this.config.webSocketVersion;\n    connection._addSocketEventListeners();\n\n    this.emit('connect', connection);\n    if (this.firstDataChunk.length > 0) {\n        connection.handleSocketData(this.firstDataChunk);\n    }\n    this.firstDataChunk = null;\n};\n\nWebSocketClient.prototype.abort = function() {\n    if (this._req) {\n        this._req.abort();\n    }\n};\n\nmodule.exports = WebSocketClient;\n","/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\n\nvar util = require('util');\nvar utils = require('./utils');\nvar EventEmitter = require('events').EventEmitter;\nvar WebSocketFrame = require('./WebSocketFrame');\nvar BufferList = require('../vendor/FastBufferList');\nvar isValidUTF8 = require('utf-8-validate');\nvar bufferAllocUnsafe = utils.bufferAllocUnsafe;\nvar bufferFromString = utils.bufferFromString;\n\n// Connected, fully-open, ready to send and receive frames\nconst STATE_OPEN = 'open';\n// Received a close frame from the remote peer\nconst STATE_PEER_REQUESTED_CLOSE = 'peer_requested_close';\n// Sent close frame to remote peer.  No further data can be sent.\nconst STATE_ENDING = 'ending';\n// Connection is fully closed.  No further data can be sent or received.\nconst STATE_CLOSED = 'closed';\n\nvar setImmediateImpl = ('setImmediate' in global) ?\n                            global.setImmediate.bind(global) :\n                            process.nextTick.bind(process);\n\nvar idCounter = 0;\n\nfunction WebSocketConnection(socket, extensions, protocol, maskOutgoingPackets, config) {\n    this._debug = utils.BufferingLogger('websocket:connection', ++idCounter);\n    this._debug('constructor');\n    \n    if (this._debug.enabled) {\n        instrumentSocketForDebugging(this, socket);\n    }\n    \n    // Superclass Constructor\n    EventEmitter.call(this);\n\n    this._pingListenerCount = 0;\n    this.on('newListener', function(ev) {\n        if (ev === 'ping'){\n            this._pingListenerCount++;\n        }\n      }).on('removeListener', function(ev) {\n        if (ev === 'ping') {\n            this._pingListenerCount--;\n        }\n    });\n\n    this.config = config;\n    this.socket = socket;\n    this.protocol = protocol;\n    this.extensions = extensions;\n    this.remoteAddress = socket.remoteAddress;\n    this.closeReasonCode = -1;\n    this.closeDescription = null;\n    this.closeEventEmitted = false;\n\n    // We have to mask outgoing packets if we're acting as a WebSocket client.\n    this.maskOutgoingPackets = maskOutgoingPackets;\n\n    // We re-use the same buffers for the mask and frame header for all frames\n    // received on each connection to avoid a small memory allocation for each\n    // frame.\n    this.maskBytes = bufferAllocUnsafe(4);\n    this.frameHeader = bufferAllocUnsafe(10);\n\n    // the BufferList will handle the data streaming in\n    this.bufferList = new BufferList();\n\n    // Prepare for receiving first frame\n    this.currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    this.fragmentationSize = 0; // data received so far...\n    this.frameQueue = [];\n    \n    // Various bits of connection state\n    this.connected = true;\n    this.state = STATE_OPEN;\n    this.waitingForCloseResponse = false;\n    // Received TCP FIN, socket's readable stream is finished.\n    this.receivedEnd = false;\n\n    this.closeTimeout = this.config.closeTimeout;\n    this.assembleFragments = this.config.assembleFragments;\n    this.maxReceivedMessageSize = this.config.maxReceivedMessageSize;\n\n    this.outputBufferFull = false;\n    this.inputPaused = false;\n    this.receivedDataHandler = this.processReceivedData.bind(this);\n    this._closeTimerHandler = this.handleCloseTimer.bind(this);\n\n    // Disable nagle algorithm?\n    this.socket.setNoDelay(this.config.disableNagleAlgorithm);\n\n    // Make sure there is no socket inactivity timeout\n    this.socket.setTimeout(0);\n\n    if (this.config.keepalive && !this.config.useNativeKeepalive) {\n        if (typeof(this.config.keepaliveInterval) !== 'number') {\n            throw new Error('keepaliveInterval must be specified and numeric ' +\n                            'if keepalive is true.');\n        }\n        this._keepaliveTimerHandler = this.handleKeepaliveTimer.bind(this);\n        this.setKeepaliveTimer();\n\n        if (this.config.dropConnectionOnKeepaliveTimeout) {\n            if (typeof(this.config.keepaliveGracePeriod) !== 'number') {\n                throw new Error('keepaliveGracePeriod  must be specified and ' +\n                                'numeric if dropConnectionOnKeepaliveTimeout ' +\n                                'is true.');\n            }\n            this._gracePeriodTimerHandler = this.handleGracePeriodTimer.bind(this);\n        }\n    }\n    else if (this.config.keepalive && this.config.useNativeKeepalive) {\n        if (!('setKeepAlive' in this.socket)) {\n            throw new Error('Unable to use native keepalive: unsupported by ' +\n                            'this version of Node.');\n        }\n        this.socket.setKeepAlive(true, this.config.keepaliveInterval);\n    }\n    \n    // The HTTP Client seems to subscribe to socket error events\n    // and re-dispatch them in such a way that doesn't make sense\n    // for users of our client, so we want to make sure nobody\n    // else is listening for error events on the socket besides us.\n    this.socket.removeAllListeners('error');\n}\n\nWebSocketConnection.CLOSE_REASON_NORMAL = 1000;\nWebSocketConnection.CLOSE_REASON_GOING_AWAY = 1001;\nWebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR = 1002;\nWebSocketConnection.CLOSE_REASON_UNPROCESSABLE_INPUT = 1003;\nWebSocketConnection.CLOSE_REASON_RESERVED = 1004; // Reserved value.  Undefined meaning.\nWebSocketConnection.CLOSE_REASON_NOT_PROVIDED = 1005; // Not to be used on the wire\nWebSocketConnection.CLOSE_REASON_ABNORMAL = 1006; // Not to be used on the wire\nWebSocketConnection.CLOSE_REASON_INVALID_DATA = 1007;\nWebSocketConnection.CLOSE_REASON_POLICY_VIOLATION = 1008;\nWebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG = 1009;\nWebSocketConnection.CLOSE_REASON_EXTENSION_REQUIRED = 1010;\nWebSocketConnection.CLOSE_REASON_INTERNAL_SERVER_ERROR = 1011;\nWebSocketConnection.CLOSE_REASON_TLS_HANDSHAKE_FAILED = 1015; // Not to be used on the wire\n\nWebSocketConnection.CLOSE_DESCRIPTIONS = {\n    1000: 'Normal connection closure',\n    1001: 'Remote peer is going away',\n    1002: 'Protocol error',\n    1003: 'Unprocessable input',\n    1004: 'Reserved',\n    1005: 'Reason not provided',\n    1006: 'Abnormal closure, no further detail available',\n    1007: 'Invalid data received',\n    1008: 'Policy violation',\n    1009: 'Message too big',\n    1010: 'Extension requested by client is required',\n    1011: 'Internal Server Error',\n    1015: 'TLS Handshake Failed'\n};\n\nfunction validateCloseReason(code) {\n    if (code < 1000) {\n        // Status codes in the range 0-999 are not used\n        return false;\n    }\n    if (code >= 1000 && code <= 2999) {\n        // Codes from 1000 - 2999 are reserved for use by the protocol.  Only\n        // a few codes are defined, all others are currently illegal.\n        return [1000, 1001, 1002, 1003, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015].indexOf(code) !== -1;\n    }\n    if (code >= 3000 && code <= 3999) {\n        // Reserved for use by libraries, frameworks, and applications.\n        // Should be registered with IANA.  Interpretation of these codes is\n        // undefined by the WebSocket protocol.\n        return true;\n    }\n    if (code >= 4000 && code <= 4999) {\n        // Reserved for private use.  Interpretation of these codes is\n        // undefined by the WebSocket protocol.\n        return true;\n    }\n    if (code >= 5000) {\n        return false;\n    }\n}\n\nutil.inherits(WebSocketConnection, EventEmitter);\n\nWebSocketConnection.prototype._addSocketEventListeners = function() {\n    this.socket.on('error', this.handleSocketError.bind(this));\n    this.socket.on('end', this.handleSocketEnd.bind(this));\n    this.socket.on('close', this.handleSocketClose.bind(this));\n    this.socket.on('drain', this.handleSocketDrain.bind(this));\n    this.socket.on('pause', this.handleSocketPause.bind(this));\n    this.socket.on('resume', this.handleSocketResume.bind(this));\n    this.socket.on('data', this.handleSocketData.bind(this));\n};\n\n// set or reset the keepalive timer when data is received.\nWebSocketConnection.prototype.setKeepaliveTimer = function() {\n    this._debug('setKeepaliveTimer');\n    if (!this.config.keepalive  || this.config.useNativeKeepalive) { return; }\n    this.clearKeepaliveTimer();\n    this.clearGracePeriodTimer();\n    this._keepaliveTimeoutID = setTimeout(this._keepaliveTimerHandler, this.config.keepaliveInterval);\n};\n\nWebSocketConnection.prototype.clearKeepaliveTimer = function() {\n    if (this._keepaliveTimeoutID) {\n        clearTimeout(this._keepaliveTimeoutID);\n    }\n};\n\n// No data has been received within config.keepaliveTimeout ms.\nWebSocketConnection.prototype.handleKeepaliveTimer = function() {\n    this._debug('handleKeepaliveTimer');\n    this._keepaliveTimeoutID = null;\n    this.ping();\n\n    // If we are configured to drop connections if the client doesn't respond\n    // then set the grace period timer.\n    if (this.config.dropConnectionOnKeepaliveTimeout) {\n        this.setGracePeriodTimer();\n    }\n    else {\n        // Otherwise reset the keepalive timer to send the next ping.\n        this.setKeepaliveTimer();\n    }\n};\n\nWebSocketConnection.prototype.setGracePeriodTimer = function() {\n    this._debug('setGracePeriodTimer');\n    this.clearGracePeriodTimer();\n    this._gracePeriodTimeoutID = setTimeout(this._gracePeriodTimerHandler, this.config.keepaliveGracePeriod);\n};\n\nWebSocketConnection.prototype.clearGracePeriodTimer = function() {\n    if (this._gracePeriodTimeoutID) {\n        clearTimeout(this._gracePeriodTimeoutID);\n    }\n};\n\nWebSocketConnection.prototype.handleGracePeriodTimer = function() {\n    this._debug('handleGracePeriodTimer');\n    // If this is called, the client has not responded and is assumed dead.\n    this._gracePeriodTimeoutID = null;\n    this.drop(WebSocketConnection.CLOSE_REASON_ABNORMAL, 'Peer not responding.', true);\n};\n\nWebSocketConnection.prototype.handleSocketData = function(data) {\n    this._debug('handleSocketData');\n    // Reset the keepalive timer when receiving data of any kind.\n    this.setKeepaliveTimer();\n\n    // Add received data to our bufferList, which efficiently holds received\n    // data chunks in a linked list of Buffer objects.\n    this.bufferList.write(data);\n\n    this.processReceivedData();\n};\n\nWebSocketConnection.prototype.processReceivedData = function() {\n    this._debug('processReceivedData');\n    // If we're not connected, we should ignore any data remaining on the buffer.\n    if (!this.connected) { return; }\n\n    // Receiving/parsing is expected to be halted when paused.\n    if (this.inputPaused) { return; }\n\n    var frame = this.currentFrame;\n\n    // WebSocketFrame.prototype.addData returns true if all data necessary to\n    // parse the frame was available.  It returns false if we are waiting for\n    // more data to come in on the wire.\n    if (!frame.addData(this.bufferList)) { this._debug('-- insufficient data for frame'); return; }\n\n    var self = this;\n\n    // Handle possible parsing errors\n    if (frame.protocolError) {\n        // Something bad happened.. get rid of this client.\n        this._debug('-- protocol error');\n        process.nextTick(function() {\n            self.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, frame.dropReason);\n        });\n        return;\n    }\n    else if (frame.frameTooLarge) {\n        this._debug('-- frame too large');\n        process.nextTick(function() {\n            self.drop(WebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG, frame.dropReason);\n        });\n        return;\n    }\n\n    // For now since we don't support extensions, all RSV bits are illegal\n    if (frame.rsv1 || frame.rsv2 || frame.rsv3) {\n        this._debug('-- illegal rsv flag');\n        process.nextTick(function() {\n            self.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,\n              'Unsupported usage of rsv bits without negotiated extension.');\n        });\n        return;\n    }\n\n    if (!this.assembleFragments) {\n        this._debug('-- emitting frame');\n        process.nextTick(function() { self.emit('frame', frame); });\n    }\n\n    process.nextTick(function() { self.processFrame(frame); });\n    \n    this.currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n\n    // If there's data remaining, schedule additional processing, but yield\n    // for now so that other connections have a chance to have their data\n    // processed.  We use setImmediate here instead of process.nextTick to\n    // explicitly indicate that we wish for other I/O to be handled first.\n    if (this.bufferList.length > 0) {\n        setImmediateImpl(this.receivedDataHandler);\n    }\n};\n\nWebSocketConnection.prototype.handleSocketError = function(error) {\n    this._debug('handleSocketError: %j', error);\n    if (this.state === STATE_CLOSED) {\n\t\t// See https://github.com/theturtle32/WebSocket-Node/issues/288\n        this._debug('  --- Socket \\'error\\' after \\'close\\'');\n        return;\n    }\n    this.closeReasonCode = WebSocketConnection.CLOSE_REASON_ABNORMAL;\n    this.closeDescription = 'Socket Error: ' + error.syscall + ' ' + error.code;\n    this.connected = false;\n    this.state = STATE_CLOSED;\n    this.fragmentationSize = 0;\n    if (utils.eventEmitterListenerCount(this, 'error') > 0) {\n        this.emit('error', error);\n    }\n    this.socket.destroy();\n    this._debug.printOutput();\n};\n\nWebSocketConnection.prototype.handleSocketEnd = function() {\n    this._debug('handleSocketEnd: received socket end.  state = %s', this.state);\n    this.receivedEnd = true;\n    if (this.state === STATE_CLOSED) {\n        // When using the TLS module, sometimes the socket will emit 'end'\n        // after it emits 'close'.  I don't think that's correct behavior,\n        // but we should deal with it gracefully by ignoring it.\n        this._debug('  --- Socket \\'end\\' after \\'close\\'');\n        return;\n    }\n    if (this.state !== STATE_PEER_REQUESTED_CLOSE &&\n        this.state !== STATE_ENDING) {\n      this._debug('  --- UNEXPECTED socket end.');\n      this.socket.end();\n    }\n};\n\nWebSocketConnection.prototype.handleSocketClose = function(hadError) {\n    this._debug('handleSocketClose: received socket close');\n    this.socketHadError = hadError;\n    this.connected = false;\n    this.state = STATE_CLOSED;\n    // If closeReasonCode is still set to -1 at this point then we must\n    // not have received a close frame!!\n    if (this.closeReasonCode === -1) {\n        this.closeReasonCode = WebSocketConnection.CLOSE_REASON_ABNORMAL;\n        this.closeDescription = 'Connection dropped by remote peer.';\n    }\n    this.clearCloseTimer();\n    this.clearKeepaliveTimer();\n    this.clearGracePeriodTimer();\n    if (!this.closeEventEmitted) {\n        this.closeEventEmitted = true;\n        this._debug('-- Emitting WebSocketConnection close event');\n        this.emit('close', this.closeReasonCode, this.closeDescription);\n    }\n};\n\nWebSocketConnection.prototype.handleSocketDrain = function() {\n    this._debug('handleSocketDrain: socket drain event');\n    this.outputBufferFull = false;\n    this.emit('drain');\n};\n\nWebSocketConnection.prototype.handleSocketPause = function() {\n    this._debug('handleSocketPause: socket pause event');\n    this.inputPaused = true;\n    this.emit('pause');\n};\n\nWebSocketConnection.prototype.handleSocketResume = function() {\n    this._debug('handleSocketResume: socket resume event');\n    this.inputPaused = false;\n    this.emit('resume');\n    this.processReceivedData();\n};\n\nWebSocketConnection.prototype.pause = function() {\n    this._debug('pause: pause requested');\n    this.socket.pause();\n};\n\nWebSocketConnection.prototype.resume = function() {\n    this._debug('resume: resume requested');\n    this.socket.resume();\n};\n\nWebSocketConnection.prototype.close = function(reasonCode, description) {\n    if (this.connected) {\n        this._debug('close: Initating clean WebSocket close sequence.');\n        if ('number' !== typeof reasonCode) {\n            reasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;\n        }\n        if (!validateCloseReason(reasonCode)) {\n            throw new Error('Close code ' + reasonCode + ' is not valid.');\n        }\n        if ('string' !== typeof description) {\n            description = WebSocketConnection.CLOSE_DESCRIPTIONS[reasonCode];\n        }\n        this.closeReasonCode = reasonCode;\n        this.closeDescription = description;\n        this.setCloseTimer();\n        this.sendCloseFrame(this.closeReasonCode, this.closeDescription);\n        this.state = STATE_ENDING;\n        this.connected = false;\n    }\n};\n\nWebSocketConnection.prototype.drop = function(reasonCode, description, skipCloseFrame) {\n    this._debug('drop');\n    if (typeof(reasonCode) !== 'number') {\n        reasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;\n    }\n\n    if (typeof(description) !== 'string') {\n        // If no description is provided, try to look one up based on the\n        // specified reasonCode.\n        description = WebSocketConnection.CLOSE_DESCRIPTIONS[reasonCode];\n    }\n\n    this._debug('Forcefully dropping connection. skipCloseFrame: %s, code: %d, description: %s',\n        skipCloseFrame, reasonCode, description\n    );\n\n    this.closeReasonCode = reasonCode;\n    this.closeDescription = description;\n    this.frameQueue = [];\n    this.fragmentationSize = 0;\n    if (!skipCloseFrame) {\n        this.sendCloseFrame(reasonCode, description);\n    }\n    this.connected = false;\n    this.state = STATE_CLOSED;\n    this.clearCloseTimer();\n    this.clearKeepaliveTimer();\n    this.clearGracePeriodTimer();\n\n    if (!this.closeEventEmitted) {\n        this.closeEventEmitted = true;\n        this._debug('Emitting WebSocketConnection close event');\n        this.emit('close', this.closeReasonCode, this.closeDescription);\n    }\n    \n    this._debug('Drop: destroying socket');\n    this.socket.destroy();\n};\n\nWebSocketConnection.prototype.setCloseTimer = function() {\n    this._debug('setCloseTimer');\n    this.clearCloseTimer();\n    this._debug('Setting close timer');\n    this.waitingForCloseResponse = true;\n    this.closeTimer = setTimeout(this._closeTimerHandler, this.closeTimeout);\n};\n\nWebSocketConnection.prototype.clearCloseTimer = function() {\n    this._debug('clearCloseTimer');\n    if (this.closeTimer) {\n        this._debug('Clearing close timer');\n        clearTimeout(this.closeTimer);\n        this.waitingForCloseResponse = false;\n        this.closeTimer = null;\n    }\n};\n\nWebSocketConnection.prototype.handleCloseTimer = function() {\n    this._debug('handleCloseTimer');\n    this.closeTimer = null;\n    if (this.waitingForCloseResponse) {\n        this._debug('Close response not received from client.  Forcing socket end.');\n        this.waitingForCloseResponse = false;\n        this.state = STATE_CLOSED;\n        this.socket.end();\n    }\n};\n\nWebSocketConnection.prototype.processFrame = function(frame) {\n    this._debug('processFrame');\n    this._debug(' -- frame: %s', frame);\n    \n    // Any non-control opcode besides 0x00 (continuation) received in the\n    // middle of a fragmented message is illegal.\n    if (this.frameQueue.length !== 0 && (frame.opcode > 0x00 && frame.opcode < 0x08)) {\n        this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,\n          'Illegal frame opcode 0x' + frame.opcode.toString(16) + ' ' +\n          'received in middle of fragmented message.');\n        return;\n    }\n\n    switch(frame.opcode) {\n        case 0x02: // WebSocketFrame.BINARY_FRAME\n            this._debug('-- Binary Frame');\n            if (this.assembleFragments) {\n                if (frame.fin) {\n                    // Complete single-frame message received\n                    this._debug('---- Emitting \\'message\\' event');\n                    this.emit('message', {\n                        type: 'binary',\n                        binaryData: frame.binaryPayload\n                    });\n                }\n                else {\n                    // beginning of a fragmented message\n                    this.frameQueue.push(frame);\n                    this.fragmentationSize = frame.length;\n                }\n            }\n            break;\n        case 0x01: // WebSocketFrame.TEXT_FRAME\n            this._debug('-- Text Frame');\n            if (this.assembleFragments) {\n                if (frame.fin) {\n                    if (!isValidUTF8(frame.binaryPayload)) {\n                        this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA,\n                          'Invalid UTF-8 Data Received');\n                        return;\n                    }\n                    // Complete single-frame message received\n                    this._debug('---- Emitting \\'message\\' event');\n                    this.emit('message', {\n                        type: 'utf8',\n                        utf8Data: frame.binaryPayload.toString('utf8')\n                    });\n                }\n                else {\n                    // beginning of a fragmented message\n                    this.frameQueue.push(frame);\n                    this.fragmentationSize = frame.length;\n                }\n            }\n            break;\n        case 0x00: // WebSocketFrame.CONTINUATION\n            this._debug('-- Continuation Frame');\n            if (this.assembleFragments) {\n                if (this.frameQueue.length === 0) {\n                    this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,\n                      'Unexpected Continuation Frame');\n                    return;\n                }\n\n                this.fragmentationSize += frame.length;\n\n                if (this.fragmentationSize > this.maxReceivedMessageSize) {\n                    this.drop(WebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG,\n                      'Maximum message size exceeded.');\n                    return;\n                }\n\n                this.frameQueue.push(frame);\n\n                if (frame.fin) {\n                    // end of fragmented message, so we process the whole\n                    // message now.  We also have to decode the utf-8 data\n                    // for text frames after combining all the fragments.\n                    var bytesCopied = 0;\n                    var binaryPayload = bufferAllocUnsafe(this.fragmentationSize);\n                    var opcode = this.frameQueue[0].opcode;\n                    this.frameQueue.forEach(function (currentFrame) {\n                        currentFrame.binaryPayload.copy(binaryPayload, bytesCopied);\n                        bytesCopied += currentFrame.binaryPayload.length;\n                    });\n                    this.frameQueue = [];\n                    this.fragmentationSize = 0;\n\n                    switch (opcode) {\n                        case 0x02: // WebSocketOpcode.BINARY_FRAME\n                            this.emit('message', {\n                                type: 'binary',\n                                binaryData: binaryPayload\n                            });\n                            break;\n                        case 0x01: // WebSocketOpcode.TEXT_FRAME\n                            if (!isValidUTF8(binaryPayload)) {\n                                this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA,\n                                  'Invalid UTF-8 Data Received');\n                                return;\n                            }\n                            this.emit('message', {\n                                type: 'utf8',\n                                utf8Data: binaryPayload.toString('utf8')\n                            });\n                            break;\n                        default:\n                            this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,\n                              'Unexpected first opcode in fragmentation sequence: 0x' + opcode.toString(16));\n                            return;\n                    }\n                }\n            }\n            break;\n        case 0x09: // WebSocketFrame.PING\n            this._debug('-- Ping Frame');\n\n            if (this._pingListenerCount > 0) {\n                // logic to emit the ping frame: this is only done when a listener is known to exist\n                // Expose a function allowing the user to override the default ping() behavior\n                var cancelled = false;\n                var cancel = function() { \n                  cancelled = true; \n                };\n                this.emit('ping', cancel, frame.binaryPayload);\n\n                // Only send a pong if the client did not indicate that he would like to cancel\n                if (!cancelled) {\n                    this.pong(frame.binaryPayload);\n                }\n            }\n            else {\n                this.pong(frame.binaryPayload);\n            }\n\n            break;\n        case 0x0A: // WebSocketFrame.PONG\n            this._debug('-- Pong Frame');\n            this.emit('pong', frame.binaryPayload);\n            break;\n        case 0x08: // WebSocketFrame.CONNECTION_CLOSE\n            this._debug('-- Close Frame');\n            if (this.waitingForCloseResponse) {\n                // Got response to our request to close the connection.\n                // Close is complete, so we just hang up.\n                this._debug('---- Got close response from peer.  Completing closing handshake.');\n                this.clearCloseTimer();\n                this.waitingForCloseResponse = false;\n                this.state = STATE_CLOSED;\n                this.socket.end();\n                return;\n            }\n            \n            this._debug('---- Closing handshake initiated by peer.');\n            // Got request from other party to close connection.\n            // Send back acknowledgement and then hang up.\n            this.state = STATE_PEER_REQUESTED_CLOSE;\n            var respondCloseReasonCode;\n\n            // Make sure the close reason provided is legal according to\n            // the protocol spec.  Providing no close status is legal.\n            // WebSocketFrame sets closeStatus to -1 by default, so if it\n            // is still -1, then no status was provided.\n            if (frame.invalidCloseFrameLength) {\n                this.closeReasonCode = 1005; // 1005 = No reason provided.\n                respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;\n            }\n            else if (frame.closeStatus === -1 || validateCloseReason(frame.closeStatus)) {\n                this.closeReasonCode = frame.closeStatus;\n                respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;\n            }\n            else {\n                this.closeReasonCode = frame.closeStatus;\n                respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;\n            }\n            \n            // If there is a textual description in the close frame, extract it.\n            if (frame.binaryPayload.length > 1) {\n                if (!isValidUTF8(frame.binaryPayload)) {\n                    this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA,\n                      'Invalid UTF-8 Data Received');\n                    return;\n                }\n                this.closeDescription = frame.binaryPayload.toString('utf8');\n            }\n            else {\n                this.closeDescription = WebSocketConnection.CLOSE_DESCRIPTIONS[this.closeReasonCode];\n            }\n            this._debug(\n                '------ Remote peer %s - code: %d - %s - close frame payload length: %d',\n                this.remoteAddress, this.closeReasonCode,\n                this.closeDescription, frame.length\n            );\n            this._debug('------ responding to remote peer\\'s close request.');\n            this.sendCloseFrame(respondCloseReasonCode, null);\n            this.connected = false;\n            break;\n        default:\n            this._debug('-- Unrecognized Opcode %d', frame.opcode);\n            this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,\n              'Unrecognized Opcode: 0x' + frame.opcode.toString(16));\n            break;\n    }\n};\n\nWebSocketConnection.prototype.send = function(data, cb) {\n    this._debug('send');\n    if (Buffer.isBuffer(data)) {\n        this.sendBytes(data, cb);\n    }\n    else if (typeof(data['toString']) === 'function') {\n        this.sendUTF(data, cb);\n    }\n    else {\n        throw new Error('Data provided must either be a Node Buffer or implement toString()');\n    }\n};\n\nWebSocketConnection.prototype.sendUTF = function(data, cb) {\n    data = bufferFromString(data.toString(), 'utf8');\n    this._debug('sendUTF: %d bytes', data.length);\n    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    frame.opcode = 0x01; // WebSocketOpcode.TEXT_FRAME\n    frame.binaryPayload = data;\n    this.fragmentAndSend(frame, cb);\n};\n\nWebSocketConnection.prototype.sendBytes = function(data, cb) {\n    this._debug('sendBytes');\n    if (!Buffer.isBuffer(data)) {\n        throw new Error('You must pass a Node Buffer object to WebSocketConnection.prototype.sendBytes()');\n    }\n    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    frame.opcode = 0x02; // WebSocketOpcode.BINARY_FRAME\n    frame.binaryPayload = data;\n    this.fragmentAndSend(frame, cb);\n};\n\nWebSocketConnection.prototype.ping = function(data) {\n    this._debug('ping');\n    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    frame.opcode = 0x09; // WebSocketOpcode.PING\n    frame.fin = true;\n    if (data) {\n        if (!Buffer.isBuffer(data)) {\n            data = bufferFromString(data.toString(), 'utf8');\n        }\n        if (data.length > 125) {\n            this._debug('WebSocket: Data for ping is longer than 125 bytes.  Truncating.');\n            data = data.slice(0,124);\n        }\n        frame.binaryPayload = data;\n    }\n    this.sendFrame(frame);\n};\n\n// Pong frames have to echo back the contents of the data portion of the\n// ping frame exactly, byte for byte.\nWebSocketConnection.prototype.pong = function(binaryPayload) {\n    this._debug('pong');\n    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    frame.opcode = 0x0A; // WebSocketOpcode.PONG\n    if (Buffer.isBuffer(binaryPayload) && binaryPayload.length > 125) {\n        this._debug('WebSocket: Data for pong is longer than 125 bytes.  Truncating.');\n        binaryPayload = binaryPayload.slice(0,124);\n    }\n    frame.binaryPayload = binaryPayload;\n    frame.fin = true;\n    this.sendFrame(frame);\n};\n\nWebSocketConnection.prototype.fragmentAndSend = function(frame, cb) {\n    this._debug('fragmentAndSend');\n    if (frame.opcode > 0x07) {\n        throw new Error('You cannot fragment control frames.');\n    }\n\n    var threshold = this.config.fragmentationThreshold;\n    var length = frame.binaryPayload.length;\n\n    // Send immediately if fragmentation is disabled or the message is not\n    // larger than the fragmentation threshold.\n    if (!this.config.fragmentOutgoingMessages || (frame.binaryPayload && length <= threshold)) {\n        frame.fin = true;\n        this.sendFrame(frame, cb);\n        return;\n    }\n    \n    var numFragments = Math.ceil(length / threshold);\n    var sentFragments = 0;\n    var sentCallback = function fragmentSentCallback(err) {\n        if (err) {\n            if (typeof cb === 'function') {\n                // pass only the first error\n                cb(err);\n                cb = null;\n            }\n            return;\n        }\n        ++sentFragments;\n        if ((sentFragments === numFragments) && (typeof cb === 'function')) {\n            cb();\n        }\n    };\n    for (var i=1; i <= numFragments; i++) {\n        var currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n        \n        // continuation opcode except for first frame.\n        currentFrame.opcode = (i === 1) ? frame.opcode : 0x00;\n        \n        // fin set on last frame only\n        currentFrame.fin = (i === numFragments);\n        \n        // length is likely to be shorter on the last fragment\n        var currentLength = (i === numFragments) ? length - (threshold * (i-1)) : threshold;\n        var sliceStart = threshold * (i-1);\n        \n        // Slice the right portion of the original payload\n        currentFrame.binaryPayload = frame.binaryPayload.slice(sliceStart, sliceStart + currentLength);\n        \n        this.sendFrame(currentFrame, sentCallback);\n    }\n};\n\nWebSocketConnection.prototype.sendCloseFrame = function(reasonCode, description, cb) {\n    if (typeof(reasonCode) !== 'number') {\n        reasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;\n    }\n    \n    this._debug('sendCloseFrame state: %s, reasonCode: %d, description: %s', this.state, reasonCode, description);\n    \n    if (this.state !== STATE_OPEN && this.state !== STATE_PEER_REQUESTED_CLOSE) { return; }\n    \n    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    frame.fin = true;\n    frame.opcode = 0x08; // WebSocketOpcode.CONNECTION_CLOSE\n    frame.closeStatus = reasonCode;\n    if (typeof(description) === 'string') {\n        frame.binaryPayload = bufferFromString(description, 'utf8');\n    }\n    \n    this.sendFrame(frame, cb);\n    this.socket.end();\n};\n\nWebSocketConnection.prototype.sendFrame = function(frame, cb) {\n    this._debug('sendFrame');\n    frame.mask = this.maskOutgoingPackets;\n    var flushed = this.socket.write(frame.toBuffer(), cb);\n    this.outputBufferFull = !flushed;\n    return flushed;\n};\n\nmodule.exports = WebSocketConnection;\n\n\n\nfunction instrumentSocketForDebugging(connection, socket) {\n    /* jshint loopfunc: true */\n    if (!connection._debug.enabled) { return; }\n    \n    var originalSocketEmit = socket.emit;\n    socket.emit = function(event) {\n        connection._debug('||| Socket Event  \\'%s\\'', event);\n        originalSocketEmit.apply(this, arguments);\n    };\n    \n    for (var key in socket) {\n        if ('function' !== typeof(socket[key])) { continue; }\n        if (['emit'].indexOf(key) !== -1) { continue; }\n        (function(key) {\n            var original = socket[key];\n            if (key === 'on') {\n                socket[key] = function proxyMethod__EventEmitter__On() {\n                    connection._debug('||| Socket method called:  %s (%s)', key, arguments[0]);\n                    return original.apply(this, arguments);\n                };\n                return;\n            }\n            socket[key] = function proxyMethod() {\n                connection._debug('||| Socket method called:  %s', key);\n                return original.apply(this, arguments);\n            };\n        })(key);\n    }\n}\n","/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\n\nvar bufferUtil = require('bufferutil');\nvar bufferAllocUnsafe = require('./utils').bufferAllocUnsafe;\n\nconst DECODE_HEADER = 1;\nconst WAITING_FOR_16_BIT_LENGTH = 2;\nconst WAITING_FOR_64_BIT_LENGTH = 3;\nconst WAITING_FOR_MASK_KEY = 4;\nconst WAITING_FOR_PAYLOAD = 5;\nconst COMPLETE = 6;\n\n// WebSocketConnection will pass shared buffer objects for maskBytes and\n// frameHeader into the constructor to avoid tons of small memory allocations\n// for each frame we have to parse.  This is only used for parsing frames\n// we receive off the wire.\nfunction WebSocketFrame(maskBytes, frameHeader, config) {\n    this.maskBytes = maskBytes;\n    this.frameHeader = frameHeader;\n    this.config = config;\n    this.maxReceivedFrameSize = config.maxReceivedFrameSize;\n    this.protocolError = false;\n    this.frameTooLarge = false;\n    this.invalidCloseFrameLength = false;\n    this.parseState = DECODE_HEADER;\n    this.closeStatus = -1;\n}\n\nWebSocketFrame.prototype.addData = function(bufferList) {\n    if (this.parseState === DECODE_HEADER) {\n        if (bufferList.length >= 2) {\n            bufferList.joinInto(this.frameHeader, 0, 0, 2);\n            bufferList.advance(2);\n            var firstByte = this.frameHeader[0];\n            var secondByte = this.frameHeader[1];\n\n            this.fin     = Boolean(firstByte  & 0x80);\n            this.rsv1    = Boolean(firstByte  & 0x40);\n            this.rsv2    = Boolean(firstByte  & 0x20);\n            this.rsv3    = Boolean(firstByte  & 0x10);\n            this.mask    = Boolean(secondByte & 0x80);\n\n            this.opcode  = firstByte  & 0x0F;\n            this.length = secondByte & 0x7F;\n\n            // Control frame sanity check\n            if (this.opcode >= 0x08) {\n                if (this.length > 125) {\n                    this.protocolError = true;\n                    this.dropReason = 'Illegal control frame longer than 125 bytes.';\n                    return true;\n                }\n                if (!this.fin) {\n                    this.protocolError = true;\n                    this.dropReason = 'Control frames must not be fragmented.';\n                    return true;\n                }\n            }\n\n            if (this.length === 126) {\n                this.parseState = WAITING_FOR_16_BIT_LENGTH;\n            }\n            else if (this.length === 127) {\n                this.parseState = WAITING_FOR_64_BIT_LENGTH;\n            }\n            else {\n                this.parseState = WAITING_FOR_MASK_KEY;\n            }\n        }\n    }\n    if (this.parseState === WAITING_FOR_16_BIT_LENGTH) {\n        if (bufferList.length >= 2) {\n            bufferList.joinInto(this.frameHeader, 2, 0, 2);\n            bufferList.advance(2);\n            this.length = this.frameHeader.readUInt16BE(2);\n            this.parseState = WAITING_FOR_MASK_KEY;\n        }\n    }\n    else if (this.parseState === WAITING_FOR_64_BIT_LENGTH) {\n        if (bufferList.length >= 8) {\n            bufferList.joinInto(this.frameHeader, 2, 0, 8);\n            bufferList.advance(8);\n            var lengthPair = [\n              this.frameHeader.readUInt32BE(2),\n              this.frameHeader.readUInt32BE(2+4)\n            ];\n\n            if (lengthPair[0] !== 0) {\n                this.protocolError = true;\n                this.dropReason = 'Unsupported 64-bit length frame received';\n                return true;\n            }\n            this.length = lengthPair[1];\n            this.parseState = WAITING_FOR_MASK_KEY;\n        }\n    }\n\n    if (this.parseState === WAITING_FOR_MASK_KEY) {\n        if (this.mask) {\n            if (bufferList.length >= 4) {\n                bufferList.joinInto(this.maskBytes, 0, 0, 4);\n                bufferList.advance(4);\n                this.parseState = WAITING_FOR_PAYLOAD;\n            }\n        }\n        else {\n            this.parseState = WAITING_FOR_PAYLOAD;\n        }\n    }\n\n    if (this.parseState === WAITING_FOR_PAYLOAD) {\n        if (this.length > this.maxReceivedFrameSize) {\n            this.frameTooLarge = true;\n            this.dropReason = 'Frame size of ' + this.length.toString(10) +\n                              ' bytes exceeds maximum accepted frame size';\n            return true;\n        }\n\n        if (this.length === 0) {\n            this.binaryPayload = bufferAllocUnsafe(0);\n            this.parseState = COMPLETE;\n            return true;\n        }\n        if (bufferList.length >= this.length) {\n            this.binaryPayload = bufferList.take(this.length);\n            bufferList.advance(this.length);\n            if (this.mask) {\n                bufferUtil.unmask(this.binaryPayload, this.maskBytes);\n                // xor(this.binaryPayload, this.maskBytes, 0);\n            }\n\n            if (this.opcode === 0x08) { // WebSocketOpcode.CONNECTION_CLOSE\n                if (this.length === 1) {\n                    // Invalid length for a close frame.  Must be zero or at least two.\n                    this.binaryPayload = bufferAllocUnsafe(0);\n                    this.invalidCloseFrameLength = true;\n                }\n                if (this.length >= 2) {\n                    this.closeStatus = this.binaryPayload.readUInt16BE(0);\n                    this.binaryPayload = this.binaryPayload.slice(2);\n                }\n            }\n\n            this.parseState = COMPLETE;\n            return true;\n        }\n    }\n    return false;\n};\n\nWebSocketFrame.prototype.throwAwayPayload = function(bufferList) {\n    if (bufferList.length >= this.length) {\n        bufferList.advance(this.length);\n        this.parseState = COMPLETE;\n        return true;\n    }\n    return false;\n};\n\nWebSocketFrame.prototype.toBuffer = function(nullMask) {\n    var maskKey;\n    var headerLength = 2;\n    var data;\n    var outputPos;\n    var firstByte = 0x00;\n    var secondByte = 0x00;\n\n    if (this.fin) {\n        firstByte |= 0x80;\n    }\n    if (this.rsv1) {\n        firstByte |= 0x40;\n    }\n    if (this.rsv2) {\n        firstByte |= 0x20;\n    }\n    if (this.rsv3) {\n        firstByte |= 0x10;\n    }\n    if (this.mask) {\n        secondByte |= 0x80;\n    }\n\n    firstByte |= (this.opcode & 0x0F);\n\n    // the close frame is a special case because the close reason is\n    // prepended to the payload data.\n    if (this.opcode === 0x08) {\n        this.length = 2;\n        if (this.binaryPayload) {\n            this.length += this.binaryPayload.length;\n        }\n        data = bufferAllocUnsafe(this.length);\n        data.writeUInt16BE(this.closeStatus, 0);\n        if (this.length > 2) {\n            this.binaryPayload.copy(data, 2);\n        }\n    }\n    else if (this.binaryPayload) {\n        data = this.binaryPayload;\n        this.length = data.length;\n    }\n    else {\n        this.length = 0;\n    }\n\n    if (this.length <= 125) {\n        // encode the length directly into the two-byte frame header\n        secondByte |= (this.length & 0x7F);\n    }\n    else if (this.length > 125 && this.length <= 0xFFFF) {\n        // Use 16-bit length\n        secondByte |= 126;\n        headerLength += 2;\n    }\n    else if (this.length > 0xFFFF) {\n        // Use 64-bit length\n        secondByte |= 127;\n        headerLength += 8;\n    }\n\n    var output = bufferAllocUnsafe(this.length + headerLength + (this.mask ? 4 : 0));\n\n    // write the frame header\n    output[0] = firstByte;\n    output[1] = secondByte;\n\n    outputPos = 2;\n\n    if (this.length > 125 && this.length <= 0xFFFF) {\n        // write 16-bit length\n        output.writeUInt16BE(this.length, outputPos);\n        outputPos += 2;\n    }\n    else if (this.length > 0xFFFF) {\n        // write 64-bit length\n        output.writeUInt32BE(0x00000000, outputPos);\n        output.writeUInt32BE(this.length, outputPos + 4);\n        outputPos += 8;\n    }\n\n    if (this.mask) {\n        maskKey = nullMask ? 0 : ((Math.random() * 0xFFFFFFFF) >>> 0);\n        this.maskBytes.writeUInt32BE(maskKey, 0);\n\n        // write the mask key\n        this.maskBytes.copy(output, outputPos);\n        outputPos += 4;\n\n        if (data) {\n          bufferUtil.mask(data, this.maskBytes, output, outputPos, this.length);\n        }\n    }\n    else if (data) {\n        data.copy(output, outputPos);\n    }\n\n    return output;\n};\n\nWebSocketFrame.prototype.toString = function() {\n    return 'Opcode: ' + this.opcode + ', fin: ' + this.fin + ', length: ' + this.length + ', hasPayload: ' + Boolean(this.binaryPayload) + ', masked: ' + this.mask;\n};\n\n\nmodule.exports = WebSocketFrame;\n","/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\n\nvar crypto = require('crypto');\nvar util = require('util');\nvar url = require('url');\nvar EventEmitter = require('events').EventEmitter;\nvar WebSocketConnection = require('./WebSocketConnection');\n\nvar headerValueSplitRegExp = /,\\s*/;\nvar headerParamSplitRegExp = /;\\s*/;\nvar headerSanitizeRegExp = /[\\r\\n]/g;\nvar xForwardedForSeparatorRegExp = /,\\s*/;\nvar separators = [\n    '(', ')', '<', '>', '@',\n    ',', ';', ':', '\\\\', '\\\"',\n    '/', '[', ']', '?', '=',\n    '{', '}', ' ', String.fromCharCode(9)\n];\nvar controlChars = [String.fromCharCode(127) /* DEL */];\nfor (var i=0; i < 31; i ++) {\n    /* US-ASCII Control Characters */\n    controlChars.push(String.fromCharCode(i));\n}\n\nvar cookieNameValidateRegEx = /([\\x00-\\x20\\x22\\x28\\x29\\x2c\\x2f\\x3a-\\x3f\\x40\\x5b-\\x5e\\x7b\\x7d\\x7f])/;\nvar cookieValueValidateRegEx = /[^\\x21\\x23-\\x2b\\x2d-\\x3a\\x3c-\\x5b\\x5d-\\x7e]/;\nvar cookieValueDQuoteValidateRegEx = /^\"[^\"]*\"$/;\nvar controlCharsAndSemicolonRegEx = /[\\x00-\\x20\\x3b]/g;\n\nvar cookieSeparatorRegEx = /[;,] */;\n\nvar httpStatusDescriptions = {\n    100: 'Continue',\n    101: 'Switching Protocols',\n    200: 'OK',\n    201: 'Created',\n    203: 'Non-Authoritative Information',\n    204: 'No Content',\n    205: 'Reset Content',\n    206: 'Partial Content',\n    300: 'Multiple Choices',\n    301: 'Moved Permanently',\n    302: 'Found',\n    303: 'See Other',\n    304: 'Not Modified',\n    305: 'Use Proxy',\n    307: 'Temporary Redirect',\n    400: 'Bad Request',\n    401: 'Unauthorized',\n    402: 'Payment Required',\n    403: 'Forbidden',\n    404: 'Not Found',\n    406: 'Not Acceptable',\n    407: 'Proxy Authorization Required',\n    408: 'Request Timeout',\n    409: 'Conflict',\n    410: 'Gone',\n    411: 'Length Required',\n    412: 'Precondition Failed',\n    413: 'Request Entity Too Long',\n    414: 'Request-URI Too Long',\n    415: 'Unsupported Media Type',\n    416: 'Requested Range Not Satisfiable',\n    417: 'Expectation Failed',\n    426: 'Upgrade Required',\n    500: 'Internal Server Error',\n    501: 'Not Implemented',\n    502: 'Bad Gateway',\n    503: 'Service Unavailable',\n    504: 'Gateway Timeout',\n    505: 'HTTP Version Not Supported'\n};\n\nfunction WebSocketRequest(socket, httpRequest, serverConfig) {\n    // Superclass Constructor\n    EventEmitter.call(this);\n\n    this.socket = socket;\n    this.httpRequest = httpRequest;\n    this.resource = httpRequest.url;\n    this.remoteAddress = socket.remoteAddress;\n    this.remoteAddresses = [this.remoteAddress];\n    this.serverConfig = serverConfig;\n\n    // Watch for the underlying TCP socket closing before we call accept\n    this._socketIsClosing = false;\n    this._socketCloseHandler = this._handleSocketCloseBeforeAccept.bind(this);\n    this.socket.on('end', this._socketCloseHandler);\n    this.socket.on('close', this._socketCloseHandler);\n\n    this._resolved = false;\n}\n\nutil.inherits(WebSocketRequest, EventEmitter);\n\nWebSocketRequest.prototype.readHandshake = function() {\n    var self = this;\n    var request = this.httpRequest;\n\n    // Decode URL\n    this.resourceURL = url.parse(this.resource, true);\n\n    this.host = request.headers['host'];\n    if (!this.host) {\n        throw new Error('Client must provide a Host header.');\n    }\n\n    this.key = request.headers['sec-websocket-key'];\n    if (!this.key) {\n        throw new Error('Client must provide a value for Sec-WebSocket-Key.');\n    }\n\n    this.webSocketVersion = parseInt(request.headers['sec-websocket-version'], 10);\n\n    if (!this.webSocketVersion || isNaN(this.webSocketVersion)) {\n        throw new Error('Client must provide a value for Sec-WebSocket-Version.');\n    }\n\n    switch (this.webSocketVersion) {\n        case 8:\n        case 13:\n            break;\n        default:\n            var e = new Error('Unsupported websocket client version: ' + this.webSocketVersion +\n                              'Only versions 8 and 13 are supported.');\n            e.httpCode = 426;\n            e.headers = {\n                'Sec-WebSocket-Version': '13'\n            };\n            throw e;\n    }\n\n    if (this.webSocketVersion === 13) {\n        this.origin = request.headers['origin'];\n    }\n    else if (this.webSocketVersion === 8) {\n        this.origin = request.headers['sec-websocket-origin'];\n    }\n\n    // Protocol is optional.\n    var protocolString = request.headers['sec-websocket-protocol'];\n    this.protocolFullCaseMap = {};\n    this.requestedProtocols = [];\n    if (protocolString) {\n        var requestedProtocolsFullCase = protocolString.split(headerValueSplitRegExp);\n        requestedProtocolsFullCase.forEach(function(protocol) {\n            var lcProtocol = protocol.toLocaleLowerCase();\n            self.requestedProtocols.push(lcProtocol);\n            self.protocolFullCaseMap[lcProtocol] = protocol;\n        });\n    }\n\n    if (!this.serverConfig.ignoreXForwardedFor &&\n        request.headers['x-forwarded-for']) {\n        var immediatePeerIP = this.remoteAddress;\n        this.remoteAddresses = request.headers['x-forwarded-for']\n            .split(xForwardedForSeparatorRegExp);\n        this.remoteAddresses.push(immediatePeerIP);\n        this.remoteAddress = this.remoteAddresses[0];\n    }\n\n    // Extensions are optional.\n    if (this.serverConfig.parseExtensions) {\n        var extensionsString = request.headers['sec-websocket-extensions'];\n        this.requestedExtensions = this.parseExtensions(extensionsString);\n    } else {\n        this.requestedExtensions = [];\n    }\n\n    // Cookies are optional\n    if (this.serverConfig.parseCookies) {\n        var cookieString = request.headers['cookie'];\n        this.cookies = this.parseCookies(cookieString);\n    } else {\n        this.cookies = [];\n    }\n};\n\nWebSocketRequest.prototype.parseExtensions = function(extensionsString) {\n    if (!extensionsString || extensionsString.length === 0) {\n        return [];\n    }\n    var extensions = extensionsString.toLocaleLowerCase().split(headerValueSplitRegExp);\n    extensions.forEach(function(extension, index, array) {\n        var params = extension.split(headerParamSplitRegExp);\n        var extensionName = params[0];\n        var extensionParams = params.slice(1);\n        extensionParams.forEach(function(rawParam, index, array) {\n            var arr = rawParam.split('=');\n            var obj = {\n                name: arr[0],\n                value: arr[1]\n            };\n            array.splice(index, 1, obj);\n        });\n        var obj = {\n            name: extensionName,\n            params: extensionParams\n        };\n        array.splice(index, 1, obj);\n    });\n    return extensions;\n};\n\n// This function adapted from node-cookie\n// https://github.com/shtylman/node-cookie\nWebSocketRequest.prototype.parseCookies = function(str) {\n    // Sanity Check\n    if (!str || typeof(str) !== 'string') {\n        return [];\n    }\n\n    var cookies = [];\n    var pairs = str.split(cookieSeparatorRegEx);\n\n    pairs.forEach(function(pair) {\n        var eq_idx = pair.indexOf('=');\n        if (eq_idx === -1) {\n            cookies.push({\n                name: pair,\n                value: null\n            });\n            return;\n        }\n\n        var key = pair.substr(0, eq_idx).trim();\n        var val = pair.substr(++eq_idx, pair.length).trim();\n\n        // quoted values\n        if ('\"' === val[0]) {\n            val = val.slice(1, -1);\n        }\n\n        cookies.push({\n            name: key,\n            value: decodeURIComponent(val)\n        });\n    });\n\n    return cookies;\n};\n\nWebSocketRequest.prototype.accept = function(acceptedProtocol, allowedOrigin, cookies) {\n    this._verifyResolution();\n\n    // TODO: Handle extensions\n\n    var protocolFullCase;\n\n    if (acceptedProtocol) {\n        protocolFullCase = this.protocolFullCaseMap[acceptedProtocol.toLocaleLowerCase()];\n        if (typeof(protocolFullCase) === 'undefined') {\n            protocolFullCase = acceptedProtocol;\n        }\n    }\n    else {\n        protocolFullCase = acceptedProtocol;\n    }\n    this.protocolFullCaseMap = null;\n\n    // Create key validation hash\n    var sha1 = crypto.createHash('sha1');\n    sha1.update(this.key + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11');\n    var acceptKey = sha1.digest('base64');\n\n    var response = 'HTTP/1.1 101 Switching Protocols\\r\\n' +\n                   'Upgrade: websocket\\r\\n' +\n                   'Connection: Upgrade\\r\\n' +\n                   'Sec-WebSocket-Accept: ' + acceptKey + '\\r\\n';\n\n    if (protocolFullCase) {\n        // validate protocol\n        for (var i=0; i < protocolFullCase.length; i++) {\n            var charCode = protocolFullCase.charCodeAt(i);\n            var character = protocolFullCase.charAt(i);\n            if (charCode < 0x21 || charCode > 0x7E || separators.indexOf(character) !== -1) {\n                this.reject(500);\n                throw new Error('Illegal character \"' + String.fromCharCode(character) + '\" in subprotocol.');\n            }\n        }\n        if (this.requestedProtocols.indexOf(acceptedProtocol) === -1) {\n            this.reject(500);\n            throw new Error('Specified protocol was not requested by the client.');\n        }\n\n        protocolFullCase = protocolFullCase.replace(headerSanitizeRegExp, '');\n        response += 'Sec-WebSocket-Protocol: ' + protocolFullCase + '\\r\\n';\n    }\n    this.requestedProtocols = null;\n\n    if (allowedOrigin) {\n        allowedOrigin = allowedOrigin.replace(headerSanitizeRegExp, '');\n        if (this.webSocketVersion === 13) {\n            response += 'Origin: ' + allowedOrigin + '\\r\\n';\n        }\n        else if (this.webSocketVersion === 8) {\n            response += 'Sec-WebSocket-Origin: ' + allowedOrigin + '\\r\\n';\n        }\n    }\n\n    if (cookies) {\n        if (!Array.isArray(cookies)) {\n            this.reject(500);\n            throw new Error('Value supplied for \"cookies\" argument must be an array.');\n        }\n        var seenCookies = {};\n        cookies.forEach(function(cookie) {\n            if (!cookie.name || !cookie.value) {\n                this.reject(500);\n                throw new Error('Each cookie to set must at least provide a \"name\" and \"value\"');\n            }\n\n            // Make sure there are no \\r\\n sequences inserted\n            cookie.name = cookie.name.replace(controlCharsAndSemicolonRegEx, '');\n            cookie.value = cookie.value.replace(controlCharsAndSemicolonRegEx, '');\n\n            if (seenCookies[cookie.name]) {\n                this.reject(500);\n                throw new Error('You may not specify the same cookie name twice.');\n            }\n            seenCookies[cookie.name] = true;\n\n            // token (RFC 2616, Section 2.2)\n            var invalidChar = cookie.name.match(cookieNameValidateRegEx);\n            if (invalidChar) {\n                this.reject(500);\n                throw new Error('Illegal character ' + invalidChar[0] + ' in cookie name');\n            }\n\n            // RFC 6265, Section 4.1.1\n            // *cookie-octet / ( DQUOTE *cookie-octet DQUOTE ) | %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E\n            if (cookie.value.match(cookieValueDQuoteValidateRegEx)) {\n                invalidChar = cookie.value.slice(1, -1).match(cookieValueValidateRegEx);\n            } else {\n                invalidChar = cookie.value.match(cookieValueValidateRegEx);\n            }\n            if (invalidChar) {\n                this.reject(500);\n                throw new Error('Illegal character ' + invalidChar[0] + ' in cookie value');\n            }\n\n            var cookieParts = [cookie.name + '=' + cookie.value];\n\n            // RFC 6265, Section 4.1.1\n            // 'Path=' path-value | <any CHAR except CTLs or ';'>\n            if(cookie.path){\n                invalidChar = cookie.path.match(controlCharsAndSemicolonRegEx);\n                if (invalidChar) {\n                    this.reject(500);\n                    throw new Error('Illegal character ' + invalidChar[0] + ' in cookie path');\n                }\n                cookieParts.push('Path=' + cookie.path);\n            }\n\n            // RFC 6265, Section 4.1.2.3\n            // 'Domain=' subdomain\n            if (cookie.domain) {\n                if (typeof(cookie.domain) !== 'string') {\n                    this.reject(500);\n                    throw new Error('Domain must be specified and must be a string.');\n                }\n                invalidChar = cookie.domain.match(controlCharsAndSemicolonRegEx);\n                if (invalidChar) {\n                    this.reject(500);\n                    throw new Error('Illegal character ' + invalidChar[0] + ' in cookie domain');\n                }\n                cookieParts.push('Domain=' + cookie.domain.toLowerCase());\n            }\n\n            // RFC 6265, Section 4.1.1\n            //'Expires=' sane-cookie-date | Force Date object requirement by using only epoch\n            if (cookie.expires) {\n                if (!(cookie.expires instanceof Date)){\n                    this.reject(500);\n                    throw new Error('Value supplied for cookie \"expires\" must be a vaild date object');\n                }\n                cookieParts.push('Expires=' + cookie.expires.toGMTString());\n            }\n\n            // RFC 6265, Section 4.1.1\n            //'Max-Age=' non-zero-digit *DIGIT\n            if (cookie.maxage) {\n                var maxage = cookie.maxage;\n                if (typeof(maxage) === 'string') {\n                    maxage = parseInt(maxage, 10);\n                }\n                if (isNaN(maxage) || maxage <= 0 ) {\n                    this.reject(500);\n                    throw new Error('Value supplied for cookie \"maxage\" must be a non-zero number');\n                }\n                maxage = Math.round(maxage);\n                cookieParts.push('Max-Age=' + maxage.toString(10));\n            }\n\n            // RFC 6265, Section 4.1.1\n            //'Secure;'\n            if (cookie.secure) {\n                if (typeof(cookie.secure) !== 'boolean') {\n                    this.reject(500);\n                    throw new Error('Value supplied for cookie \"secure\" must be of type boolean');\n                }\n                cookieParts.push('Secure');\n            }\n\n            // RFC 6265, Section 4.1.1\n            //'HttpOnly;'\n            if (cookie.httponly) {\n                if (typeof(cookie.httponly) !== 'boolean') {\n                    this.reject(500);\n                    throw new Error('Value supplied for cookie \"httponly\" must be of type boolean');\n                }\n                cookieParts.push('HttpOnly');\n            }\n\n            response += ('Set-Cookie: ' + cookieParts.join(';') + '\\r\\n');\n        }.bind(this));\n    }\n\n    // TODO: handle negotiated extensions\n    // if (negotiatedExtensions) {\n    //     response += 'Sec-WebSocket-Extensions: ' + negotiatedExtensions.join(', ') + '\\r\\n';\n    // }\n\n    // Mark the request resolved now so that the user can't call accept or\n    // reject a second time.\n    this._resolved = true;\n    this.emit('requestResolved', this);\n\n    response += '\\r\\n';\n\n    var connection = new WebSocketConnection(this.socket, [], acceptedProtocol, false, this.serverConfig);\n    connection.webSocketVersion = this.webSocketVersion;\n    connection.remoteAddress = this.remoteAddress;\n    connection.remoteAddresses = this.remoteAddresses;\n\n    var self = this;\n\n    if (this._socketIsClosing) {\n        // Handle case when the client hangs up before we get a chance to\n        // accept the connection and send our side of the opening handshake.\n        cleanupFailedConnection(connection);\n    }\n    else {\n        this.socket.write(response, 'ascii', function(error) {\n            if (error) {\n                cleanupFailedConnection(connection);\n                return;\n            }\n\n            self._removeSocketCloseListeners();\n            connection._addSocketEventListeners();\n        });\n    }\n\n    this.emit('requestAccepted', connection);\n    return connection;\n};\n\nWebSocketRequest.prototype.reject = function(status, reason, extraHeaders) {\n    this._verifyResolution();\n\n    // Mark the request resolved now so that the user can't call accept or\n    // reject a second time.\n    this._resolved = true;\n    this.emit('requestResolved', this);\n\n    if (typeof(status) !== 'number') {\n        status = 403;\n    }\n    var response = 'HTTP/1.1 ' + status + ' ' + httpStatusDescriptions[status] + '\\r\\n' +\n                   'Connection: close\\r\\n';\n    if (reason) {\n        reason = reason.replace(headerSanitizeRegExp, '');\n        response += 'X-WebSocket-Reject-Reason: ' + reason + '\\r\\n';\n    }\n\n    if (extraHeaders) {\n        for (var key in extraHeaders) {\n            var sanitizedValue = extraHeaders[key].toString().replace(headerSanitizeRegExp, '');\n            var sanitizedKey = key.replace(headerSanitizeRegExp, '');\n            response += (sanitizedKey + ': ' + sanitizedValue + '\\r\\n');\n        }\n    }\n\n    response += '\\r\\n';\n    this.socket.end(response, 'ascii');\n\n    this.emit('requestRejected', this);\n};\n\nWebSocketRequest.prototype._handleSocketCloseBeforeAccept = function() {\n    this._socketIsClosing = true;\n    this._removeSocketCloseListeners();\n};\n\nWebSocketRequest.prototype._removeSocketCloseListeners = function() {\n    this.socket.removeListener('end', this._socketCloseHandler);\n    this.socket.removeListener('close', this._socketCloseHandler);\n};\n\nWebSocketRequest.prototype._verifyResolution = function() {\n    if (this._resolved) {\n        throw new Error('WebSocketRequest may only be accepted or rejected one time.');\n    }\n};\n\nfunction cleanupFailedConnection(connection) {\n    // Since we have to return a connection object even if the socket is\n    // already dead in order not to break the API, we schedule a 'close'\n    // event on the connection object to occur immediately.\n    process.nextTick(function() {\n        // WebSocketConnection.CLOSE_REASON_ABNORMAL = 1006\n        // Third param: Skip sending the close frame to a dead socket\n        connection.drop(1006, 'TCP connection lost before handshake completed.', true);\n    });\n}\n\nmodule.exports = WebSocketRequest;\n","/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\n\nvar extend = require('./utils').extend;\nvar util = require('util');\nvar EventEmitter = require('events').EventEmitter;\nvar WebSocketRouterRequest = require('./WebSocketRouterRequest');\n\nfunction WebSocketRouter(config) {\n    // Superclass Constructor\n    EventEmitter.call(this);\n\n    this.config = {\n        // The WebSocketServer instance to attach to.\n        server: null\n    };\n    if (config) {\n        extend(this.config, config);\n    }\n    this.handlers = [];\n\n    this._requestHandler = this.handleRequest.bind(this);\n    if (this.config.server) {\n        this.attachServer(this.config.server);\n    }\n}\n\nutil.inherits(WebSocketRouter, EventEmitter);\n\nWebSocketRouter.prototype.attachServer = function(server) {\n    if (server) {\n        this.server = server;\n        this.server.on('request', this._requestHandler);\n    }\n    else {\n        throw new Error('You must specify a WebSocketServer instance to attach to.');\n    }\n};\n\nWebSocketRouter.prototype.detachServer = function() {\n    if (this.server) {\n        this.server.removeListener('request', this._requestHandler);\n        this.server = null;\n    }\n    else {\n        throw new Error('Cannot detach from server: not attached.');\n    }\n};\n\nWebSocketRouter.prototype.mount = function(path, protocol, callback) {\n    if (!path) {\n        throw new Error('You must specify a path for this handler.');\n    }\n    if (!protocol) {\n        protocol = '____no_protocol____';\n    }\n    if (!callback) {\n        throw new Error('You must specify a callback for this handler.');\n    }\n\n    path = this.pathToRegExp(path);\n    if (!(path instanceof RegExp)) {\n        throw new Error('Path must be specified as either a string or a RegExp.');\n    }\n    var pathString = path.toString();\n\n    // normalize protocol to lower-case\n    protocol = protocol.toLocaleLowerCase();\n\n    if (this.findHandlerIndex(pathString, protocol) !== -1) {\n        throw new Error('You may only mount one handler per path/protocol combination.');\n    }\n\n    this.handlers.push({\n        'path': path,\n        'pathString': pathString,\n        'protocol': protocol,\n        'callback': callback\n    });\n};\nWebSocketRouter.prototype.unmount = function(path, protocol) {\n    var index = this.findHandlerIndex(this.pathToRegExp(path).toString(), protocol);\n    if (index !== -1) {\n        this.handlers.splice(index, 1);\n    }\n    else {\n        throw new Error('Unable to find a route matching the specified path and protocol.');\n    }\n};\n\nWebSocketRouter.prototype.findHandlerIndex = function(pathString, protocol) {\n    protocol = protocol.toLocaleLowerCase();\n    for (var i=0, len=this.handlers.length; i < len; i++) {\n        var handler = this.handlers[i];\n        if (handler.pathString === pathString && handler.protocol === protocol) {\n            return i;\n        }\n    }\n    return -1;\n};\n\nWebSocketRouter.prototype.pathToRegExp = function(path) {\n    if (typeof(path) === 'string') {\n        if (path === '*') {\n            path = /^.*$/;\n        }\n        else {\n            path = path.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n            path = new RegExp('^' + path + '$');\n        }\n    }\n    return path;\n};\n\nWebSocketRouter.prototype.handleRequest = function(request) {\n    var requestedProtocols = request.requestedProtocols;\n    if (requestedProtocols.length === 0) {\n        requestedProtocols = ['____no_protocol____'];\n    }\n\n    // Find a handler with the first requested protocol first\n    for (var i=0; i < requestedProtocols.length; i++) {\n        var requestedProtocol = requestedProtocols[i].toLocaleLowerCase();\n\n        // find the first handler that can process this request\n        for (var j=0, len=this.handlers.length; j < len; j++) {\n            var handler = this.handlers[j];\n            if (handler.path.test(request.resourceURL.pathname)) {\n                if (requestedProtocol === handler.protocol ||\n                    handler.protocol === '*')\n                {\n                    var routerRequest = new WebSocketRouterRequest(request, requestedProtocol);\n                    handler.callback(routerRequest);\n                    return;\n                }\n            }\n        }\n    }\n\n    // If we get here we were unable to find a suitable handler.\n    request.reject(404, 'No handler is available for the given request.');\n};\n\nmodule.exports = WebSocketRouter;\n","/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\n\nvar util = require('util');\nvar EventEmitter = require('events').EventEmitter;\n\nfunction WebSocketRouterRequest(webSocketRequest, resolvedProtocol) {\n    // Superclass Constructor\n    EventEmitter.call(this);\n\n    this.webSocketRequest = webSocketRequest;\n    if (resolvedProtocol === '____no_protocol____') {\n        this.protocol = null;\n    }\n    else {\n        this.protocol = resolvedProtocol;\n    }\n    this.origin = webSocketRequest.origin;\n    this.resource = webSocketRequest.resource;\n    this.resourceURL = webSocketRequest.resourceURL;\n    this.httpRequest = webSocketRequest.httpRequest;\n    this.remoteAddress = webSocketRequest.remoteAddress;\n    this.webSocketVersion = webSocketRequest.webSocketVersion;\n    this.requestedExtensions = webSocketRequest.requestedExtensions;\n    this.cookies = webSocketRequest.cookies;\n}\n\nutil.inherits(WebSocketRouterRequest, EventEmitter);\n\nWebSocketRouterRequest.prototype.accept = function(origin, cookies) {\n    var connection = this.webSocketRequest.accept(this.protocol, origin, cookies);\n    this.emit('requestAccepted', connection);\n    return connection;\n};\n\nWebSocketRouterRequest.prototype.reject = function(status, reason, extraHeaders) {\n    this.webSocketRequest.reject(status, reason, extraHeaders);\n    this.emit('requestRejected', this);\n};\n\nmodule.exports = WebSocketRouterRequest;\n","/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\n\nvar extend = require('./utils').extend;\nvar utils = require('./utils');\nvar util = require('util');\nvar debug = require('debug')('websocket:server');\nvar EventEmitter = require('events').EventEmitter;\nvar WebSocketRequest = require('./WebSocketRequest');\n\nvar WebSocketServer = function WebSocketServer(config) {\n    // Superclass Constructor\n    EventEmitter.call(this);\n\n    this._handlers = {\n        upgrade: this.handleUpgrade.bind(this),\n        requestAccepted: this.handleRequestAccepted.bind(this),\n        requestResolved: this.handleRequestResolved.bind(this)\n    };\n    this.connections = [];\n    this.pendingRequests = [];\n    if (config) {\n        this.mount(config);\n    }\n};\n\nutil.inherits(WebSocketServer, EventEmitter);\n\nWebSocketServer.prototype.mount = function(config) {\n    this.config = {\n        // The http server instance to attach to.  Required.\n        httpServer: null,\n\n        // 64KiB max frame size.\n        maxReceivedFrameSize: 0x10000,\n\n        // 1MiB max message size, only applicable if\n        // assembleFragments is true\n        maxReceivedMessageSize: 0x100000,\n\n        // Outgoing messages larger than fragmentationThreshold will be\n        // split into multiple fragments.\n        fragmentOutgoingMessages: true,\n\n        // Outgoing frames are fragmented if they exceed this threshold.\n        // Default is 16KiB\n        fragmentationThreshold: 0x4000,\n\n        // If true, the server will automatically send a ping to all\n        // clients every 'keepaliveInterval' milliseconds.  The timer is\n        // reset on any received data from the client.\n        keepalive: true,\n\n        // The interval to send keepalive pings to connected clients if the\n        // connection is idle.  Any received data will reset the counter.\n        keepaliveInterval: 20000,\n\n        // If true, the server will consider any connection that has not\n        // received any data within the amount of time specified by\n        // 'keepaliveGracePeriod' after a keepalive ping has been sent to\n        // be dead, and will drop the connection.\n        // Ignored if keepalive is false.\n        dropConnectionOnKeepaliveTimeout: true,\n\n        // The amount of time to wait after sending a keepalive ping before\n        // closing the connection if the connected peer does not respond.\n        // Ignored if keepalive is false.\n        keepaliveGracePeriod: 10000,\n\n        // Whether to use native TCP keep-alive instead of WebSockets ping\n        // and pong packets.  Native TCP keep-alive sends smaller packets\n        // on the wire and so uses bandwidth more efficiently.  This may\n        // be more important when talking to mobile devices.\n        // If this value is set to true, then these values will be ignored:\n        //   keepaliveGracePeriod\n        //   dropConnectionOnKeepaliveTimeout\n        useNativeKeepalive: false,\n\n        // If true, fragmented messages will be automatically assembled\n        // and the full message will be emitted via a 'message' event.\n        // If false, each frame will be emitted via a 'frame' event and\n        // the application will be responsible for aggregating multiple\n        // fragmented frames.  Single-frame messages will emit a 'message'\n        // event in addition to the 'frame' event.\n        // Most users will want to leave this set to 'true'\n        assembleFragments: true,\n\n        // If this is true, websocket connections will be accepted\n        // regardless of the path and protocol specified by the client.\n        // The protocol accepted will be the first that was requested\n        // by the client.  Clients from any origin will be accepted.\n        // This should only be used in the simplest of cases.  You should\n        // probably leave this set to 'false' and inspect the request\n        // object to make sure it's acceptable before accepting it.\n        autoAcceptConnections: false,\n\n        // Whether or not the X-Forwarded-For header should be respected.\n        // It's important to set this to 'true' when accepting connections\n        // from untrusted clients, as a malicious client could spoof its\n        // IP address by simply setting this header.  It's meant to be added\n        // by a trusted proxy or other intermediary within your own\n        // infrastructure.\n        // See:  http://en.wikipedia.org/wiki/X-Forwarded-For\n        ignoreXForwardedFor: false,\n\n        // If this is true, 'cookie' headers are parsed and exposed as WebSocketRequest.cookies\n        parseCookies: true,\n\n        // If this is true, 'sec-websocket-extensions' headers are parsed and exposed as WebSocketRequest.requestedExtensions\n        parseExtensions: true,\n\n        // The Nagle Algorithm makes more efficient use of network resources\n        // by introducing a small delay before sending small packets so that\n        // multiple messages can be batched together before going onto the\n        // wire.  This however comes at the cost of latency, so the default\n        // is to disable it.  If you don't need low latency and are streaming\n        // lots of small messages, you can change this to 'false'\n        disableNagleAlgorithm: true,\n\n        // The number of milliseconds to wait after sending a close frame\n        // for an acknowledgement to come back before giving up and just\n        // closing the socket.\n        closeTimeout: 5000\n    };\n    extend(this.config, config);\n\n    if (this.config.httpServer) {\n        if (!Array.isArray(this.config.httpServer)) {\n            this.config.httpServer = [this.config.httpServer];\n        }\n        var upgradeHandler = this._handlers.upgrade;\n        this.config.httpServer.forEach(function(httpServer) {\n            httpServer.on('upgrade', upgradeHandler);\n        });\n    }\n    else {\n        throw new Error('You must specify an httpServer on which to mount the WebSocket server.');\n    }\n};\n\nWebSocketServer.prototype.unmount = function() {\n    var upgradeHandler = this._handlers.upgrade;\n    this.config.httpServer.forEach(function(httpServer) {\n        httpServer.removeListener('upgrade', upgradeHandler);\n    });\n};\n\nWebSocketServer.prototype.closeAllConnections = function() {\n    this.connections.forEach(function(connection) {\n        connection.close();\n    });\n    this.pendingRequests.forEach(function(request) {\n        process.nextTick(function() {\n          request.reject(503); // HTTP 503 Service Unavailable\n        });\n    });\n};\n\nWebSocketServer.prototype.broadcast = function(data) {\n    if (Buffer.isBuffer(data)) {\n        this.broadcastBytes(data);\n    }\n    else if (typeof(data.toString) === 'function') {\n        this.broadcastUTF(data);\n    }\n};\n\nWebSocketServer.prototype.broadcastUTF = function(utfData) {\n    this.connections.forEach(function(connection) {\n        connection.sendUTF(utfData);\n    });\n};\n\nWebSocketServer.prototype.broadcastBytes = function(binaryData) {\n    this.connections.forEach(function(connection) {\n        connection.sendBytes(binaryData);\n    });\n};\n\nWebSocketServer.prototype.shutDown = function() {\n    this.unmount();\n    this.closeAllConnections();\n};\n\nWebSocketServer.prototype.handleUpgrade = function(request, socket) {\n    var self = this;\n    var wsRequest = new WebSocketRequest(socket, request, this.config);\n    try {\n        wsRequest.readHandshake();\n    }\n    catch(e) {\n        wsRequest.reject(\n            e.httpCode ? e.httpCode : 400,\n            e.message,\n            e.headers\n        );\n        debug('Invalid handshake: %s', e.message);\n        this.emit('upgradeError', e);\n        return;\n    }\n\n    this.pendingRequests.push(wsRequest);\n\n    wsRequest.once('requestAccepted', this._handlers.requestAccepted);\n    wsRequest.once('requestResolved', this._handlers.requestResolved);\n    socket.once('close', function () {\n        self._handlers.requestResolved(wsRequest);\n    });\n\n    if (!this.config.autoAcceptConnections && utils.eventEmitterListenerCount(this, 'request') > 0) {\n        this.emit('request', wsRequest);\n    }\n    else if (this.config.autoAcceptConnections) {\n        wsRequest.accept(wsRequest.requestedProtocols[0], wsRequest.origin);\n    }\n    else {\n        wsRequest.reject(404, 'No handler is configured to accept the connection.');\n    }\n};\n\nWebSocketServer.prototype.handleRequestAccepted = function(connection) {\n    var self = this;\n    connection.once('close', function(closeReason, description) {\n        self.handleConnectionClose(connection, closeReason, description);\n    });\n    this.connections.push(connection);\n    this.emit('connect', connection);\n};\n\nWebSocketServer.prototype.handleConnectionClose = function(connection, closeReason, description) {\n    var index = this.connections.indexOf(connection);\n    if (index !== -1) {\n        this.connections.splice(index, 1);\n    }\n    this.emit('close', connection, closeReason, description);\n};\n\nWebSocketServer.prototype.handleRequestResolved = function(request) {\n    var index = this.pendingRequests.indexOf(request);\n    if (index !== -1) { this.pendingRequests.splice(index, 1); }\n};\n\nmodule.exports = WebSocketServer;\n","var noop = exports.noop = function(){};\n\nexports.extend = function extend(dest, source) {\n    for (var prop in source) {\n        dest[prop] = source[prop];\n    }\n};\n\nexports.eventEmitterListenerCount =\n    require('events').EventEmitter.listenerCount ||\n    function(emitter, type) { return emitter.listeners(type).length; };\n\nexports.bufferAllocUnsafe = Buffer.allocUnsafe ?\n    Buffer.allocUnsafe :\n    function oldBufferAllocUnsafe(size) { return new Buffer(size); };\n\nexports.bufferFromString = Buffer.from ?\n    Buffer.from :\n    function oldBufferFromString(string, encoding) {\n      return new Buffer(string, encoding);\n    };\n\nexports.BufferingLogger = function createBufferingLogger(identifier, uniqueID) {\n    var logFunction = require('debug')(identifier);\n    if (logFunction.enabled) {\n        var logger = new BufferingLogger(identifier, uniqueID, logFunction);\n        var debug = logger.log.bind(logger);\n        debug.printOutput = logger.printOutput.bind(logger);\n        debug.enabled = logFunction.enabled;\n        return debug;\n    }\n    logFunction.printOutput = noop;\n    return logFunction;\n};\n\nfunction BufferingLogger(identifier, uniqueID, logFunction) {\n    this.logFunction = logFunction;\n    this.identifier = identifier;\n    this.uniqueID = uniqueID;\n    this.buffer = [];\n}\n\nBufferingLogger.prototype.log = function() {\n  this.buffer.push([ new Date(), Array.prototype.slice.call(arguments) ]);\n  return this;\n};\n\nBufferingLogger.prototype.clear = function() {\n  this.buffer = [];\n  return this;\n};\n\nBufferingLogger.prototype.printOutput = function(logFunction) {\n    if (!logFunction) { logFunction = this.logFunction; }\n    var uniqueID = this.uniqueID;\n    this.buffer.forEach(function(entry) {\n        var date = entry[0].toLocaleString();\n        var args = entry[1].slice();\n        var formatString = args[0];\n        if (formatString !== (void 0) && formatString !== null) {\n            formatString = '%s - %s - ' + formatString.toString();\n            args.splice(0, 1, formatString, date, uniqueID);\n            logFunction.apply(global, args);\n        }\n    });\n};\n","module.exports = require('../package.json').version;\n","module.exports = {\n    'server'       : require('./WebSocketServer'),\n    'client'       : require('./WebSocketClient'),\n    'router'       : require('./WebSocketRouter'),\n    'frame'        : require('./WebSocketFrame'),\n    'request'      : require('./WebSocketRequest'),\n    'connection'   : require('./WebSocketConnection'),\n    'w3cwebsocket' : require('./W3CWebSocket'),\n    'deprecation'  : require('./Deprecation'),\n    'version'      : require('./version')\n};\n","/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n","/**\n * Detect Electron renderer process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process !== 'undefined' && process.type === 'renderer') {\n  module.exports = require('./browser.js');\n} else {\n  module.exports = require('./node.js');\n}\n","/**\n * Module dependencies.\n */\n\nvar tty = require('tty');\nvar util = require('util');\n\n/**\n * This is the Node.js implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(function (key) {\n  return /^debug_/i.test(key);\n}).reduce(function (obj, key) {\n  // camel-case\n  var prop = key\n    .substring(6)\n    .toLowerCase()\n    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });\n\n  // coerce string value into JS value\n  var val = process.env[key];\n  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;\n  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;\n  else if (val === 'null') val = null;\n  else val = Number(val);\n\n  obj[prop] = val;\n  return obj;\n}, {});\n\n/**\n * The file descriptor to write the `debug()` calls to.\n * Set the `DEBUG_FD` env variable to override with another value. i.e.:\n *\n *   $ DEBUG_FD=3 node script.js 3>debug.log\n */\n\nvar fd = parseInt(process.env.DEBUG_FD, 10) || 2;\n\nif (1 !== fd && 2 !== fd) {\n  util.deprecate(function(){}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')()\n}\n\nvar stream = 1 === fd ? process.stdout :\n             2 === fd ? process.stderr :\n             createWritableStdioStream(fd);\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n  return 'colors' in exports.inspectOpts\n    ? Boolean(exports.inspectOpts.colors)\n    : tty.isatty(fd);\n}\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nexports.formatters.o = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts)\n    .split('\\n').map(function(str) {\n      return str.trim()\n    }).join(' ');\n};\n\n/**\n * Map %o to `util.inspect()`, allowing multiple lines if needed.\n */\n\nexports.formatters.O = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts);\n};\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var name = this.namespace;\n  var useColors = this.useColors;\n\n  if (useColors) {\n    var c = this.color;\n    var prefix = '  \\u001b[3' + c + ';1m' + name + ' ' + '\\u001b[0m';\n\n    args[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n    args.push('\\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\\u001b[0m');\n  } else {\n    args[0] = new Date().toUTCString()\n      + ' ' + name + ' ' + args[0];\n  }\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to `stream`.\n */\n\nfunction log() {\n  return stream.write(util.format.apply(util, arguments) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  if (null == namespaces) {\n    // If you set a process.env field to null or undefined, it gets cast to the\n    // string 'null' or 'undefined'. Just delete instead.\n    delete process.env.DEBUG;\n  } else {\n    process.env.DEBUG = namespaces;\n  }\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  return process.env.DEBUG;\n}\n\n/**\n * Copied from `node/src/node.js`.\n *\n * XXX: It's lame that node doesn't expose this API out-of-the-box. It also\n * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.\n */\n\nfunction createWritableStdioStream (fd) {\n  var stream;\n  var tty_wrap = process.binding('tty_wrap');\n\n  // Note stream._type is used for test-module-load-list.js\n\n  switch (tty_wrap.guessHandleType(fd)) {\n    case 'TTY':\n      stream = new tty.WriteStream(fd);\n      stream._type = 'tty';\n\n      // Hack to have stream not keep the event loop alive.\n      // See https://github.com/joyent/node/issues/1726\n      if (stream._handle && stream._handle.unref) {\n        stream._handle.unref();\n      }\n      break;\n\n    case 'FILE':\n      var fs = require('fs');\n      stream = new fs.SyncWriteStream(fd, { autoClose: false });\n      stream._type = 'fs';\n      break;\n\n    case 'PIPE':\n    case 'TCP':\n      var net = require('net');\n      stream = new net.Socket({\n        fd: fd,\n        readable: false,\n        writable: true\n      });\n\n      // FIXME Should probably have an option in net.Socket to create a\n      // stream from an existing fd which is writable only. But for now\n      // we'll just add this hack and set the `readable` member to false.\n      // Test: ./node test/fixtures/echo.js < /etc/passwd\n      stream.readable = false;\n      stream.read = null;\n      stream._type = 'pipe';\n\n      // FIXME Hack to have stream not keep the event loop alive.\n      // See https://github.com/joyent/node/issues/1726\n      if (stream._handle && stream._handle.unref) {\n        stream._handle.unref();\n      }\n      break;\n\n    default:\n      // Probably an error on in uv_guess_handle()\n      throw new Error('Implement me. Unknown stream file type!');\n  }\n\n  // For supporting legacy API we put the FD here.\n  stream.fd = fd;\n\n  stream._isStdio = true;\n\n  return stream;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init (debug) {\n  debug.inspectOpts = {};\n\n  var keys = Object.keys(exports.inspectOpts);\n  for (var i = 0; i < keys.length; i++) {\n    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n  }\n}\n\n/**\n * Enable namespaces listed in `process.env.DEBUG` initially.\n */\n\nexports.enable(load());\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n","// This file was copied from https://github.com/substack/node-bufferlist\n// and modified to be able to copy bytes from the bufferlist directly into\n// a pre-existing fixed-size buffer without an additional memory allocation.\n\n// bufferlist.js\n// Treat a linked list of buffers as a single variable-size buffer.\nvar Buffer = require('buffer').Buffer;\nvar EventEmitter = require('events').EventEmitter;\nvar bufferAllocUnsafe = require('../lib/utils').bufferAllocUnsafe;\n\nmodule.exports = BufferList;\nmodule.exports.BufferList = BufferList; // backwards compatibility\n\nfunction BufferList(opts) {\n    if (!(this instanceof BufferList)) return new BufferList(opts);\n    EventEmitter.call(this);\n    var self = this;\n    \n    if (typeof(opts) == 'undefined') opts = {};\n    \n    // default encoding to use for take(). Leaving as 'undefined'\n    // makes take() return a Buffer instead.\n    self.encoding = opts.encoding;\n    \n    var head = { next : null, buffer : null };\n    var last = { next : null, buffer : null };\n    \n    // length can get negative when advanced past the end\n    // and this is the desired behavior\n    var length = 0;\n    self.__defineGetter__('length', function () {\n        return length;\n    });\n    \n    // keep an offset of the head to decide when to head = head.next\n    var offset = 0;\n    \n    // Write to the bufferlist. Emits 'write'. Always returns true.\n    self.write = function (buf) {\n        if (!head.buffer) {\n            head.buffer = buf;\n            last = head;\n        }\n        else {\n            last.next = { next : null, buffer : buf };\n            last = last.next;\n        }\n        length += buf.length;\n        self.emit('write', buf);\n        return true;\n    };\n    \n    self.end = function (buf) {\n        if (Buffer.isBuffer(buf)) self.write(buf);\n    };\n    \n    // Push buffers to the end of the linked list. (deprecated)\n    // Return this (self).\n    self.push = function () {\n        var args = [].concat.apply([], arguments);\n        args.forEach(self.write);\n        return self;\n    };\n    \n    // For each buffer, perform some action.\n    // If fn's result is a true value, cut out early.\n    // Returns this (self).\n    self.forEach = function (fn) {\n        if (!head.buffer) return bufferAllocUnsafe(0);\n        \n        if (head.buffer.length - offset <= 0) return self;\n        var firstBuf = head.buffer.slice(offset);\n        \n        var b = { buffer : firstBuf, next : head.next };\n        \n        while (b && b.buffer) {\n            var r = fn(b.buffer);\n            if (r) break;\n            b = b.next;\n        }\n        \n        return self;\n    };\n    \n    // Create a single Buffer out of all the chunks or some subset specified by\n    // start and one-past the end (like slice) in bytes.\n    self.join = function (start, end) {\n        if (!head.buffer) return bufferAllocUnsafe(0);\n        if (start == undefined) start = 0;\n        if (end == undefined) end = self.length;\n        \n        var big = bufferAllocUnsafe(end - start);\n        var ix = 0;\n        self.forEach(function (buffer) {\n            if (start < (ix + buffer.length) && ix < end) {\n                // at least partially contained in the range\n                buffer.copy(\n                    big,\n                    Math.max(0, ix - start),\n                    Math.max(0, start - ix),\n                    Math.min(buffer.length, end - ix)\n                );\n            }\n            ix += buffer.length;\n            if (ix > end) return true; // stop processing past end\n        });\n        \n        return big;\n    };\n    \n    self.joinInto = function (targetBuffer, targetStart, sourceStart, sourceEnd) {\n        if (!head.buffer) return new bufferAllocUnsafe(0);\n        if (sourceStart == undefined) sourceStart = 0;\n        if (sourceEnd == undefined) sourceEnd = self.length;\n        \n        var big = targetBuffer;\n        if (big.length - targetStart < sourceEnd - sourceStart) {\n            throw new Error(\"Insufficient space available in target Buffer.\");\n        }\n        var ix = 0;\n        self.forEach(function (buffer) {\n            if (sourceStart < (ix + buffer.length) && ix < sourceEnd) {\n                // at least partially contained in the range\n                buffer.copy(\n                    big,\n                    Math.max(targetStart, targetStart + ix - sourceStart),\n                    Math.max(0, sourceStart - ix),\n                    Math.min(buffer.length, sourceEnd - ix)\n                );\n            }\n            ix += buffer.length;\n            if (ix > sourceEnd) return true; // stop processing past end\n        });\n        \n        return big;\n    };\n    \n    // Advance the buffer stream by n bytes.\n    // If n the aggregate advance offset passes the end of the buffer list,\n    // operations such as .take() will return empty strings until enough data is\n    // pushed.\n    // Returns this (self).\n    self.advance = function (n) {\n        offset += n;\n        length -= n;\n        while (head.buffer && offset >= head.buffer.length) {\n            offset -= head.buffer.length;\n            head = head.next\n                ? head.next\n                : { buffer : null, next : null }\n            ;\n        }\n        if (head.buffer === null) last = { next : null, buffer : null };\n        self.emit('advance', n);\n        return self;\n    };\n    \n    // Take n bytes from the start of the buffers.\n    // Returns a string.\n    // If there are less than n bytes in all the buffers or n is undefined,\n    // returns the entire concatenated buffer string.\n    self.take = function (n, encoding) {\n        if (n == undefined) n = self.length;\n        else if (typeof n !== 'number') {\n            encoding = n;\n            n = self.length;\n        }\n        var b = head;\n        if (!encoding) encoding = self.encoding;\n        if (encoding) {\n            var acc = '';\n            self.forEach(function (buffer) {\n                if (n <= 0) return true;\n                acc += buffer.toString(\n                    encoding, 0, Math.min(n,buffer.length)\n                );\n                n -= buffer.length;\n            });\n            return acc;\n        } else {\n            // If no 'encoding' is specified, then return a Buffer.\n            return self.join(0, n);\n        }\n    };\n    \n    // The entire concatenated buffer as a string.\n    self.toString = function () {\n        return self.take('binary');\n    };\n}\nrequire('util').inherits(BufferList, EventEmitter);\n","'use strict'\n\nmodule.exports = function whichModule (exported) {\n  for (var i = 0, files = Object.keys(require.cache), mod; i < files.length; i++) {\n    mod = require.cache[files[i]]\n    if (mod.exports === exported) return mod\n  }\n  return null\n}\n","var fs = require('fs')\nvar path = require('path')\nvar util = require('util')\n\nfunction Y18N (opts) {\n  // configurable options.\n  opts = opts || {}\n  this.directory = opts.directory || './locales'\n  this.updateFiles = typeof opts.updateFiles === 'boolean' ? opts.updateFiles : true\n  this.locale = opts.locale || 'en'\n  this.fallbackToLanguage = typeof opts.fallbackToLanguage === 'boolean' ? opts.fallbackToLanguage : true\n\n  // internal stuff.\n  this.cache = Object.create(null)\n  this.writeQueue = []\n}\n\nY18N.prototype.__ = function () {\n  if (typeof arguments[0] !== 'string') {\n    return this._taggedLiteral.apply(this, arguments)\n  }\n  var args = Array.prototype.slice.call(arguments)\n  var str = args.shift()\n  var cb = function () {} // start with noop.\n\n  if (typeof args[args.length - 1] === 'function') cb = args.pop()\n  cb = cb || function () {} // noop.\n\n  if (!this.cache[this.locale]) this._readLocaleFile()\n\n  // we've observed a new string, update the language file.\n  if (!this.cache[this.locale][str] && this.updateFiles) {\n    this.cache[this.locale][str] = str\n\n    // include the current directory and locale,\n    // since these values could change before the\n    // write is performed.\n    this._enqueueWrite([this.directory, this.locale, cb])\n  } else {\n    cb()\n  }\n\n  return util.format.apply(util, [this.cache[this.locale][str] || str].concat(args))\n}\n\nY18N.prototype._taggedLiteral = function (parts) {\n  var args = arguments\n  var str = ''\n  parts.forEach(function (part, i) {\n    var arg = args[i + 1]\n    str += part\n    if (typeof arg !== 'undefined') {\n      str += '%s'\n    }\n  })\n  return this.__.apply(null, [str].concat([].slice.call(arguments, 1)))\n}\n\nY18N.prototype._enqueueWrite = function (work) {\n  this.writeQueue.push(work)\n  if (this.writeQueue.length === 1) this._processWriteQueue()\n}\n\nY18N.prototype._processWriteQueue = function () {\n  var _this = this\n  var work = this.writeQueue[0]\n\n  // destructure the enqueued work.\n  var directory = work[0]\n  var locale = work[1]\n  var cb = work[2]\n\n  var languageFile = this._resolveLocaleFile(directory, locale)\n  var serializedLocale = JSON.stringify(this.cache[locale], null, 2)\n\n  fs.writeFile(languageFile, serializedLocale, 'utf-8', function (err) {\n    _this.writeQueue.shift()\n    if (_this.writeQueue.length > 0) _this._processWriteQueue()\n    cb(err)\n  })\n}\n\nY18N.prototype._readLocaleFile = function () {\n  var localeLookup = {}\n  var languageFile = this._resolveLocaleFile(this.directory, this.locale)\n\n  try {\n    localeLookup = JSON.parse(fs.readFileSync(languageFile, 'utf-8'))\n  } catch (err) {\n    if (err instanceof SyntaxError) {\n      err.message = 'syntax error in ' + languageFile\n    }\n\n    if (err.code === 'ENOENT') localeLookup = {}\n    else throw err\n  }\n\n  this.cache[this.locale] = localeLookup\n}\n\nY18N.prototype._resolveLocaleFile = function (directory, locale) {\n  var file = path.resolve(directory, './', locale + '.json')\n  if (this.fallbackToLanguage && !this._fileExistsSync(file) && ~locale.lastIndexOf('_')) {\n    // attempt fallback to language only\n    var languageFile = path.resolve(directory, './', locale.split('_')[0] + '.json')\n    if (this._fileExistsSync(languageFile)) file = languageFile\n  }\n  return file\n}\n\n// this only exists because fs.existsSync() \"will be deprecated\"\n// see https://nodejs.org/api/fs.html#fs_fs_existssync_path\nY18N.prototype._fileExistsSync = function (file) {\n  try {\n    return fs.statSync(file).isFile()\n  } catch (err) {\n    return false\n  }\n}\n\nY18N.prototype.__n = function () {\n  var args = Array.prototype.slice.call(arguments)\n  var singular = args.shift()\n  var plural = args.shift()\n  var quantity = args.shift()\n\n  var cb = function () {} // start with noop.\n  if (typeof args[args.length - 1] === 'function') cb = args.pop()\n\n  if (!this.cache[this.locale]) this._readLocaleFile()\n\n  var str = quantity === 1 ? singular : plural\n  if (this.cache[this.locale][singular]) {\n    str = this.cache[this.locale][singular][quantity === 1 ? 'one' : 'other']\n  }\n\n  // we've observed a new string, update the language file.\n  if (!this.cache[this.locale][singular] && this.updateFiles) {\n    this.cache[this.locale][singular] = {\n      one: singular,\n      other: plural\n    }\n\n    // include the current directory and locale,\n    // since these values could change before the\n    // write is performed.\n    this._enqueueWrite([this.directory, this.locale, cb])\n  } else {\n    cb()\n  }\n\n  // if a %d placeholder is provided, add quantity\n  // to the arguments expanded by util.format.\n  var values = [str]\n  if (~str.indexOf('%d')) values.push(quantity)\n\n  return util.format.apply(util, values.concat(args))\n}\n\nY18N.prototype.setLocale = function (locale) {\n  this.locale = locale\n}\n\nY18N.prototype.getLocale = function () {\n  return this.locale\n}\n\nY18N.prototype.updateLocale = function (obj) {\n  if (!this.cache[this.locale]) this._readLocaleFile()\n\n  for (var key in obj) {\n    this.cache[this.locale][key] = obj[key]\n  }\n}\n\nmodule.exports = function (opts) {\n  var y18n = new Y18N(opts)\n\n  // bind all functions to y18n, so that\n  // they can be used in isolation.\n  for (var key in y18n) {\n    if (typeof y18n[key] === 'function') {\n      y18n[key] = y18n[key].bind(y18n)\n    }\n  }\n\n  return y18n\n}\n","module.exports = {\n\tEventTarget : require('./lib/EventTarget'),\n\tEvent       : require('./lib/Event')\n};\n","/**\n * Expose the Event class.\n */\nmodule.exports = _Event;\n\n\nfunction _Event(type) {\n\tthis.type = type;\n\tthis.isTrusted = false;\n\n\t// Set a flag indicating this is not a DOM Event object\n\tthis._yaeti = true;\n}\n","/**\n * Expose the _EventTarget class.\n */\nmodule.exports = _EventTarget;\n\nfunction _EventTarget() {\n\t// Do nothing if called for a native EventTarget object..\n\tif (typeof this.addEventListener === 'function') {\n\t\treturn;\n\t}\n\n\tthis._listeners = {};\n\n\tthis.addEventListener = _addEventListener;\n\tthis.removeEventListener = _removeEventListener;\n\tthis.dispatchEvent = _dispatchEvent;\n}\n\nObject.defineProperties(_EventTarget.prototype, {\n\tlisteners: {\n\t\tget: function () {\n\t\t\treturn this._listeners;\n\t\t}\n\t}\n});\n\nfunction _addEventListener(type, newListener) {\n\tvar\n\t\tlistenersType,\n\t\ti, listener;\n\n\tif (!type || !newListener) {\n\t\treturn;\n\t}\n\n\tlistenersType = this._listeners[type];\n\tif (listenersType === undefined) {\n\t\tthis._listeners[type] = listenersType = [];\n\t}\n\n\tfor (i = 0; !!(listener = listenersType[i]); i++) {\n\t\tif (listener === newListener) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlistenersType.push(newListener);\n}\n\nfunction _removeEventListener(type, oldListener) {\n\tvar\n\t\tlistenersType,\n\t\ti, listener;\n\n\tif (!type || !oldListener) {\n\t\treturn;\n\t}\n\n\tlistenersType = this._listeners[type];\n\tif (listenersType === undefined) {\n\t\treturn;\n\t}\n\n\tfor (i = 0; !!(listener = listenersType[i]); i++) {\n\t\tif (listener === oldListener) {\n\t\t\tlistenersType.splice(i, 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (listenersType.length === 0) {\n\t\tdelete this._listeners[type];\n\t}\n}\n\nfunction _dispatchEvent(event) {\n\tvar\n\t\ttype,\n\t\tlistenersType,\n\t\tdummyListener,\n\t\tstopImmediatePropagation = false,\n\t\ti, listener;\n\n\tif (!event || typeof event.type !== 'string') {\n\t\tthrow new Error('`event` must have a valid `type` property');\n\t}\n\n\t// Do some stuff to emulate DOM Event behavior (just if this is not a\n\t// DOM Event object)\n\tif (event._yaeti) {\n\t\tevent.target = this;\n\t\tevent.cancelable = true;\n\t}\n\n\t// Attempt to override the stopImmediatePropagation() method\n\ttry {\n\t\tevent.stopImmediatePropagation = function () {\n\t\t\tstopImmediatePropagation = true;\n\t\t};\n\t} catch (error) {}\n\n\ttype = event.type;\n\tlistenersType = (this._listeners[type] || []);\n\n\tdummyListener = this['on' + type];\n\tif (typeof dummyListener === 'function') {\n\t\tdummyListener.call(this, event);\n\t}\n\n\tfor (i = 0; !!(listener = listenersType[i]); i++) {\n\t\tif (stopImmediatePropagation) {\n\t\t\tbreak;\n\t\t}\n\n\t\tlistener.call(this, event);\n\t}\n\n\treturn !event.defaultPrevented;\n}\n","'use strict'\nmodule.exports = function (Yallist) {\n  Yallist.prototype[Symbol.iterator] = function* () {\n    for (let walker = this.head; walker; walker = walker.next) {\n      yield walker.value\n    }\n  }\n}\n","'use strict'\nmodule.exports = Yallist\n\nYallist.Node = Node\nYallist.create = Yallist\n\nfunction Yallist (list) {\n  var self = this\n  if (!(self instanceof Yallist)) {\n    self = new Yallist()\n  }\n\n  self.tail = null\n  self.head = null\n  self.length = 0\n\n  if (list && typeof list.forEach === 'function') {\n    list.forEach(function (item) {\n      self.push(item)\n    })\n  } else if (arguments.length > 0) {\n    for (var i = 0, l = arguments.length; i < l; i++) {\n      self.push(arguments[i])\n    }\n  }\n\n  return self\n}\n\nYallist.prototype.removeNode = function (node) {\n  if (node.list !== this) {\n    throw new Error('removing node which does not belong to this list')\n  }\n\n  var next = node.next\n  var prev = node.prev\n\n  if (next) {\n    next.prev = prev\n  }\n\n  if (prev) {\n    prev.next = next\n  }\n\n  if (node === this.head) {\n    this.head = next\n  }\n  if (node === this.tail) {\n    this.tail = prev\n  }\n\n  node.list.length--\n  node.next = null\n  node.prev = null\n  node.list = null\n\n  return next\n}\n\nYallist.prototype.unshiftNode = function (node) {\n  if (node === this.head) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var head = this.head\n  node.list = this\n  node.next = head\n  if (head) {\n    head.prev = node\n  }\n\n  this.head = node\n  if (!this.tail) {\n    this.tail = node\n  }\n  this.length++\n}\n\nYallist.prototype.pushNode = function (node) {\n  if (node === this.tail) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var tail = this.tail\n  node.list = this\n  node.prev = tail\n  if (tail) {\n    tail.next = node\n  }\n\n  this.tail = node\n  if (!this.head) {\n    this.head = node\n  }\n  this.length++\n}\n\nYallist.prototype.push = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    push(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.unshift = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    unshift(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.pop = function () {\n  if (!this.tail) {\n    return undefined\n  }\n\n  var res = this.tail.value\n  this.tail = this.tail.prev\n  if (this.tail) {\n    this.tail.next = null\n  } else {\n    this.head = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.shift = function () {\n  if (!this.head) {\n    return undefined\n  }\n\n  var res = this.head.value\n  this.head = this.head.next\n  if (this.head) {\n    this.head.prev = null\n  } else {\n    this.tail = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.head, i = 0; walker !== null; i++) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.next\n  }\n}\n\nYallist.prototype.forEachReverse = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.prev\n  }\n}\n\nYallist.prototype.get = function (n) {\n  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.next\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.getReverse = function (n) {\n  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.prev\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.map = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.head; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.next\n  }\n  return res\n}\n\nYallist.prototype.mapReverse = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.tail; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.prev\n  }\n  return res\n}\n\nYallist.prototype.reduce = function (fn, initial) {\n  var acc\n  var walker = this.head\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.head) {\n    walker = this.head.next\n    acc = this.head.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = 0; walker !== null; i++) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.next\n  }\n\n  return acc\n}\n\nYallist.prototype.reduceReverse = function (fn, initial) {\n  var acc\n  var walker = this.tail\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.tail) {\n    walker = this.tail.prev\n    acc = this.tail.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = this.length - 1; walker !== null; i--) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.prev\n  }\n\n  return acc\n}\n\nYallist.prototype.toArray = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.head; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.next\n  }\n  return arr\n}\n\nYallist.prototype.toArrayReverse = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.tail; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.prev\n  }\n  return arr\n}\n\nYallist.prototype.slice = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {\n    walker = walker.next\n  }\n  for (; walker !== null && i < to; i++, walker = walker.next) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.sliceReverse = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {\n    walker = walker.prev\n  }\n  for (; walker !== null && i > from; i--, walker = walker.prev) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.splice = function (start, deleteCount, ...nodes) {\n  if (start > this.length) {\n    start = this.length - 1\n  }\n  if (start < 0) {\n    start = this.length + start;\n  }\n\n  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {\n    walker = walker.next\n  }\n\n  var ret = []\n  for (var i = 0; walker && i < deleteCount; i++) {\n    ret.push(walker.value)\n    walker = this.removeNode(walker)\n  }\n  if (walker === null) {\n    walker = this.tail\n  }\n\n  if (walker !== this.head && walker !== this.tail) {\n    walker = walker.prev\n  }\n\n  for (var i = 0; i < nodes.length; i++) {\n    walker = insert(this, walker, nodes[i])\n  }\n  return ret;\n}\n\nYallist.prototype.reverse = function () {\n  var head = this.head\n  var tail = this.tail\n  for (var walker = head; walker !== null; walker = walker.prev) {\n    var p = walker.prev\n    walker.prev = walker.next\n    walker.next = p\n  }\n  this.head = tail\n  this.tail = head\n  return this\n}\n\nfunction insert (self, node, value) {\n  var inserted = node === self.head ?\n    new Node(value, null, node, self) :\n    new Node(value, node, node.next, self)\n\n  if (inserted.next === null) {\n    self.tail = inserted\n  }\n  if (inserted.prev === null) {\n    self.head = inserted\n  }\n\n  self.length++\n\n  return inserted\n}\n\nfunction push (self, item) {\n  self.tail = new Node(item, self.tail, null, self)\n  if (!self.head) {\n    self.head = self.tail\n  }\n  self.length++\n}\n\nfunction unshift (self, item) {\n  self.head = new Node(item, null, self.head, self)\n  if (!self.tail) {\n    self.tail = self.head\n  }\n  self.length++\n}\n\nfunction Node (value, prev, next, list) {\n  if (!(this instanceof Node)) {\n    return new Node(value, prev, next, list)\n  }\n\n  this.list = list\n  this.value = value\n\n  if (prev) {\n    prev.next = this\n    this.prev = prev\n  } else {\n    this.prev = null\n  }\n\n  if (next) {\n    next.prev = this\n    this.next = next\n  } else {\n    this.next = null\n  }\n}\n\ntry {\n  // add if support for Symbol.iterator is present\n  require('./iterator.js')(Yallist)\n} catch (er) {}\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = \"../../node_modules/yargs sync recursive\";","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = \"../../node_modules/yargs-parser sync recursive\";","var camelCase = require('camelcase')\nvar decamelize = require('decamelize')\nvar path = require('path')\nvar tokenizeArgString = require('./lib/tokenize-arg-string')\nvar util = require('util')\n\nfunction parse (args, opts) {\n  if (!opts) opts = {}\n  // allow a string argument to be passed in rather\n  // than an argv array.\n  args = tokenizeArgString(args)\n\n  // aliases might have transitive relationships, normalize this.\n  var aliases = combineAliases(opts.alias || {})\n  var configuration = Object.assign({\n    'short-option-groups': true,\n    'camel-case-expansion': true,\n    'dot-notation': true,\n    'parse-numbers': true,\n    'boolean-negation': true,\n    'negation-prefix': 'no-',\n    'duplicate-arguments-array': true,\n    'flatten-duplicate-arrays': true,\n    'populate--': false,\n    'combine-arrays': false,\n    'set-placeholder-key': false,\n    'halt-at-non-option': false,\n    'strip-aliased': false,\n    'strip-dashed': false\n  }, opts.configuration)\n  var defaults = opts.default || {}\n  var configObjects = opts.configObjects || []\n  var envPrefix = opts.envPrefix\n  var notFlagsOption = configuration['populate--']\n  var notFlagsArgv = notFlagsOption ? '--' : '_'\n  var newAliases = {}\n  // allow a i18n handler to be passed in, default to a fake one (util.format).\n  var __ = opts.__ || util.format\n  var error = null\n  var flags = {\n    aliases: {},\n    arrays: {},\n    bools: {},\n    strings: {},\n    numbers: {},\n    counts: {},\n    normalize: {},\n    configs: {},\n    defaulted: {},\n    nargs: {},\n    coercions: {},\n    keys: []\n  }\n  var negative = /^-[0-9]+(\\.[0-9]+)?/\n  var negatedBoolean = new RegExp('^--' + configuration['negation-prefix'] + '(.+)')\n\n  ;[].concat(opts.array).filter(Boolean).forEach(function (opt) {\n    var key = opt.key || opt\n\n    // assign to flags[bools|strings|numbers]\n    const assignment = Object.keys(opt).map(function (key) {\n      return ({\n        boolean: 'bools',\n        string: 'strings',\n        number: 'numbers'\n      })[key]\n    }).filter(Boolean).pop()\n\n    // assign key to be coerced\n    if (assignment) {\n      flags[assignment][key] = true\n    }\n\n    flags.arrays[key] = true\n    flags.keys.push(key)\n  })\n\n  ;[].concat(opts.boolean).filter(Boolean).forEach(function (key) {\n    flags.bools[key] = true\n    flags.keys.push(key)\n  })\n\n  ;[].concat(opts.string).filter(Boolean).forEach(function (key) {\n    flags.strings[key] = true\n    flags.keys.push(key)\n  })\n\n  ;[].concat(opts.number).filter(Boolean).forEach(function (key) {\n    flags.numbers[key] = true\n    flags.keys.push(key)\n  })\n\n  ;[].concat(opts.count).filter(Boolean).forEach(function (key) {\n    flags.counts[key] = true\n    flags.keys.push(key)\n  })\n\n  ;[].concat(opts.normalize).filter(Boolean).forEach(function (key) {\n    flags.normalize[key] = true\n    flags.keys.push(key)\n  })\n\n  Object.keys(opts.narg || {}).forEach(function (k) {\n    flags.nargs[k] = opts.narg[k]\n    flags.keys.push(k)\n  })\n\n  Object.keys(opts.coerce || {}).forEach(function (k) {\n    flags.coercions[k] = opts.coerce[k]\n    flags.keys.push(k)\n  })\n\n  if (Array.isArray(opts.config) || typeof opts.config === 'string') {\n    ;[].concat(opts.config).filter(Boolean).forEach(function (key) {\n      flags.configs[key] = true\n    })\n  } else {\n    Object.keys(opts.config || {}).forEach(function (k) {\n      flags.configs[k] = opts.config[k]\n    })\n  }\n\n  // create a lookup table that takes into account all\n  // combinations of aliases: {f: ['foo'], foo: ['f']}\n  extendAliases(opts.key, aliases, opts.default, flags.arrays)\n\n  // apply default values to all aliases.\n  Object.keys(defaults).forEach(function (key) {\n    (flags.aliases[key] || []).forEach(function (alias) {\n      defaults[alias] = defaults[key]\n    })\n  })\n\n  var argv = { _: [] }\n\n  Object.keys(flags.bools).forEach(function (key) {\n    if (Object.prototype.hasOwnProperty.call(defaults, key)) {\n      setArg(key, defaults[key])\n      setDefaulted(key)\n    }\n  })\n\n  var notFlags = []\n\n  for (var i = 0; i < args.length; i++) {\n    var arg = args[i]\n    var broken\n    var key\n    var letters\n    var m\n    var next\n    var value\n\n    // -- separated by =\n    if (arg.match(/^--.+=/) || (\n      !configuration['short-option-groups'] && arg.match(/^-.+=/)\n    )) {\n      // Using [\\s\\S] instead of . because js doesn't support the\n      // 'dotall' regex modifier. See:\n      // http://stackoverflow.com/a/1068308/13216\n      m = arg.match(/^--?([^=]+)=([\\s\\S]*)$/)\n\n      // nargs format = '--f=monkey washing cat'\n      if (checkAllAliases(m[1], flags.nargs)) {\n        args.splice(i + 1, 0, m[2])\n        i = eatNargs(i, m[1], args)\n      // arrays format = '--f=a b c'\n      } else if (checkAllAliases(m[1], flags.arrays) && args.length > i + 1) {\n        args.splice(i + 1, 0, m[2])\n        i = eatArray(i, m[1], args)\n      } else {\n        setArg(m[1], m[2])\n      }\n    } else if (arg.match(negatedBoolean) && configuration['boolean-negation']) {\n      key = arg.match(negatedBoolean)[1]\n      setArg(key, false)\n\n    // -- seperated by space.\n    } else if (arg.match(/^--.+/) || (\n      !configuration['short-option-groups'] && arg.match(/^-[^-]+/)\n    )) {\n      key = arg.match(/^--?(.+)/)[1]\n\n      // nargs format = '--foo a b c'\n      if (checkAllAliases(key, flags.nargs)) {\n        i = eatNargs(i, key, args)\n      // array format = '--foo a b c'\n      } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {\n        i = eatArray(i, key, args)\n      } else {\n        next = flags.nargs[key] === 0 ? undefined : args[i + 1]\n\n        if (next !== undefined && (!next.match(/^-/) ||\n          next.match(negative)) &&\n          !checkAllAliases(key, flags.bools) &&\n          !checkAllAliases(key, flags.counts)) {\n          setArg(key, next)\n          i++\n        } else if (/^(true|false)$/.test(next)) {\n          setArg(key, next)\n          i++\n        } else {\n          setArg(key, defaultValue(key))\n        }\n      }\n\n    // dot-notation flag seperated by '='.\n    } else if (arg.match(/^-.\\..+=/)) {\n      m = arg.match(/^-([^=]+)=([\\s\\S]*)$/)\n      setArg(m[1], m[2])\n\n    // dot-notation flag seperated by space.\n    } else if (arg.match(/^-.\\..+/)) {\n      next = args[i + 1]\n      key = arg.match(/^-(.\\..+)/)[1]\n\n      if (next !== undefined && !next.match(/^-/) &&\n        !checkAllAliases(key, flags.bools) &&\n        !checkAllAliases(key, flags.counts)) {\n        setArg(key, next)\n        i++\n      } else {\n        setArg(key, defaultValue(key))\n      }\n    } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {\n      letters = arg.slice(1, -1).split('')\n      broken = false\n\n      for (var j = 0; j < letters.length; j++) {\n        next = arg.slice(j + 2)\n\n        if (letters[j + 1] && letters[j + 1] === '=') {\n          value = arg.slice(j + 3)\n          key = letters[j]\n\n          // nargs format = '-f=monkey washing cat'\n          if (checkAllAliases(key, flags.nargs)) {\n            args.splice(i + 1, 0, value)\n            i = eatNargs(i, key, args)\n          // array format = '-f=a b c'\n          } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {\n            args.splice(i + 1, 0, value)\n            i = eatArray(i, key, args)\n          } else {\n            setArg(key, value)\n          }\n\n          broken = true\n          break\n        }\n\n        if (next === '-') {\n          setArg(letters[j], next)\n          continue\n        }\n\n        // current letter is an alphabetic character and next value is a number\n        if (/[A-Za-z]/.test(letters[j]) &&\n          /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next)) {\n          setArg(letters[j], next)\n          broken = true\n          break\n        }\n\n        if (letters[j + 1] && letters[j + 1].match(/\\W/)) {\n          setArg(letters[j], next)\n          broken = true\n          break\n        } else {\n          setArg(letters[j], defaultValue(letters[j]))\n        }\n      }\n\n      key = arg.slice(-1)[0]\n\n      if (!broken && key !== '-') {\n        // nargs format = '-f a b c'\n        if (checkAllAliases(key, flags.nargs)) {\n          i = eatNargs(i, key, args)\n        // array format = '-f a b c'\n        } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {\n          i = eatArray(i, key, args)\n        } else {\n          next = args[i + 1]\n\n          if (next !== undefined && (!/^(-|--)[^-]/.test(next) ||\n            next.match(negative)) &&\n            !checkAllAliases(key, flags.bools) &&\n            !checkAllAliases(key, flags.counts)) {\n            setArg(key, next)\n            i++\n          } else if (/^(true|false)$/.test(next)) {\n            setArg(key, next)\n            i++\n          } else {\n            setArg(key, defaultValue(key))\n          }\n        }\n      }\n    } else if (arg === '--') {\n      notFlags = args.slice(i + 1)\n      break\n    } else if (configuration['halt-at-non-option']) {\n      notFlags = args.slice(i)\n      break\n    } else {\n      argv._.push(maybeCoerceNumber('_', arg))\n    }\n  }\n\n  // order of precedence:\n  // 1. command line arg\n  // 2. value from env var\n  // 3. value from config file\n  // 4. value from config objects\n  // 5. configured default value\n  applyEnvVars(argv, true) // special case: check env vars that point to config file\n  applyEnvVars(argv, false)\n  setConfig(argv)\n  setConfigObjects()\n  applyDefaultsAndAliases(argv, flags.aliases, defaults)\n  applyCoercions(argv)\n  if (configuration['set-placeholder-key']) setPlaceholderKeys(argv)\n\n  // for any counts either not in args or without an explicit default, set to 0\n  Object.keys(flags.counts).forEach(function (key) {\n    if (!hasKey(argv, key.split('.'))) setArg(key, 0)\n  })\n\n  // '--' defaults to undefined.\n  if (notFlagsOption && notFlags.length) argv[notFlagsArgv] = []\n  notFlags.forEach(function (key) {\n    argv[notFlagsArgv].push(key)\n  })\n\n  if (configuration['camel-case-expansion'] && configuration['strip-dashed']) {\n    Object.keys(argv).filter(key => key !== '--' && key.includes('-')).forEach(key => {\n      delete argv[key]\n    })\n  }\n\n  if (configuration['strip-aliased']) {\n    // XXX Switch to [].concat(...Object.values(aliases)) once node.js 6 is dropped\n    ;[].concat(...Object.keys(aliases).map(k => aliases[k])).forEach(alias => {\n      if (configuration['camel-case-expansion']) {\n        delete argv[alias.split('.').map(prop => camelCase(prop)).join('.')]\n      }\n\n      delete argv[alias]\n    })\n  }\n\n  // how many arguments should we consume, based\n  // on the nargs option?\n  function eatNargs (i, key, args) {\n    var ii\n    const toEat = checkAllAliases(key, flags.nargs)\n\n    // nargs will not consume flag arguments, e.g., -abc, --foo,\n    // and terminates when one is observed.\n    var available = 0\n    for (ii = i + 1; ii < args.length; ii++) {\n      if (!args[ii].match(/^-[^0-9]/)) available++\n      else break\n    }\n\n    if (available < toEat) error = Error(__('Not enough arguments following: %s', key))\n\n    const consumed = Math.min(available, toEat)\n    for (ii = i + 1; ii < (consumed + i + 1); ii++) {\n      setArg(key, args[ii])\n    }\n\n    return (i + consumed)\n  }\n\n  // if an option is an array, eat all non-hyphenated arguments\n  // following it... YUM!\n  // e.g., --foo apple banana cat becomes [\"apple\", \"banana\", \"cat\"]\n  function eatArray (i, key, args) {\n    var start = i + 1\n    var argsToSet = []\n    var multipleArrayFlag = i > 0\n    for (var ii = i + 1; ii < args.length; ii++) {\n      if (/^-/.test(args[ii]) && !negative.test(args[ii])) {\n        if (ii === start) {\n          setArg(key, defaultForType('array'))\n        }\n        multipleArrayFlag = true\n        break\n      }\n      i = ii\n      argsToSet.push(args[ii])\n    }\n    if (multipleArrayFlag) {\n      setArg(key, argsToSet.map(function (arg) {\n        return processValue(key, arg)\n      }))\n    } else {\n      argsToSet.forEach(function (arg) {\n        setArg(key, arg)\n      })\n    }\n\n    return i\n  }\n\n  function setArg (key, val) {\n    unsetDefaulted(key)\n\n    if (/-/.test(key) && configuration['camel-case-expansion']) {\n      var alias = key.split('.').map(function (prop) {\n        return camelCase(prop)\n      }).join('.')\n      addNewAlias(key, alias)\n    }\n\n    var value = processValue(key, val)\n\n    var splitKey = key.split('.')\n    setKey(argv, splitKey, value)\n\n    // handle populating aliases of the full key\n    if (flags.aliases[key] && flags.aliases[key].forEach) {\n      flags.aliases[key].forEach(function (x) {\n        x = x.split('.')\n        setKey(argv, x, value)\n      })\n    }\n\n    // handle populating aliases of the first element of the dot-notation key\n    if (splitKey.length > 1 && configuration['dot-notation']) {\n      ;(flags.aliases[splitKey[0]] || []).forEach(function (x) {\n        x = x.split('.')\n\n        // expand alias with nested objects in key\n        var a = [].concat(splitKey)\n        a.shift() // nuke the old key.\n        x = x.concat(a)\n\n        setKey(argv, x, value)\n      })\n    }\n\n    // Set normalize getter and setter when key is in 'normalize' but isn't an array\n    if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {\n      var keys = [key].concat(flags.aliases[key] || [])\n      keys.forEach(function (key) {\n        argv.__defineSetter__(key, function (v) {\n          val = path.normalize(v)\n        })\n\n        argv.__defineGetter__(key, function () {\n          return typeof val === 'string' ? path.normalize(val) : val\n        })\n      })\n    }\n  }\n\n  function addNewAlias (key, alias) {\n    if (!(flags.aliases[key] && flags.aliases[key].length)) {\n      flags.aliases[key] = [alias]\n      newAliases[alias] = true\n    }\n    if (!(flags.aliases[alias] && flags.aliases[alias].length)) {\n      addNewAlias(alias, key)\n    }\n  }\n\n  function processValue (key, val) {\n    // strings may be quoted, clean this up as we assign values.\n    if (typeof val === 'string' &&\n      (val[0] === \"'\" || val[0] === '\"') &&\n      val[val.length - 1] === val[0]\n    ) {\n      val = val.substring(1, val.length - 1)\n    }\n\n    // handle parsing boolean arguments --foo=true --bar false.\n    if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {\n      if (typeof val === 'string') val = val === 'true'\n    }\n\n    var value = maybeCoerceNumber(key, val)\n\n    // increment a count given as arg (either no value or value parsed as boolean)\n    if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === 'boolean')) {\n      value = increment\n    }\n\n    // Set normalized value when key is in 'normalize' and in 'arrays'\n    if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {\n      if (Array.isArray(val)) value = val.map(path.normalize)\n      else value = path.normalize(val)\n    }\n    return value\n  }\n\n  function maybeCoerceNumber (key, value) {\n    if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.coercions)) {\n      const shouldCoerceNumber = isNumber(value) && configuration['parse-numbers'] && (\n        Number.isSafeInteger(Math.floor(value))\n      )\n      if (shouldCoerceNumber || (!isUndefined(value) && checkAllAliases(key, flags.numbers))) value = Number(value)\n    }\n    return value\n  }\n\n  // set args from config.json file, this should be\n  // applied last so that defaults can be applied.\n  function setConfig (argv) {\n    var configLookup = {}\n\n    // expand defaults/aliases, in-case any happen to reference\n    // the config.json file.\n    applyDefaultsAndAliases(configLookup, flags.aliases, defaults)\n\n    Object.keys(flags.configs).forEach(function (configKey) {\n      var configPath = argv[configKey] || configLookup[configKey]\n      if (configPath) {\n        try {\n          var config = null\n          var resolvedConfigPath = path.resolve(process.cwd(), configPath)\n\n          if (typeof flags.configs[configKey] === 'function') {\n            try {\n              config = flags.configs[configKey](resolvedConfigPath)\n            } catch (e) {\n              config = e\n            }\n            if (config instanceof Error) {\n              error = config\n              return\n            }\n          } else {\n            config = require(resolvedConfigPath)\n          }\n\n          setConfigObject(config)\n        } catch (ex) {\n          if (argv[configKey]) error = Error(__('Invalid JSON config file: %s', configPath))\n        }\n      }\n    })\n  }\n\n  // set args from config object.\n  // it recursively checks nested objects.\n  function setConfigObject (config, prev) {\n    Object.keys(config).forEach(function (key) {\n      var value = config[key]\n      var fullKey = prev ? prev + '.' + key : key\n\n      // if the value is an inner object and we have dot-notation\n      // enabled, treat inner objects in config the same as\n      // heavily nested dot notations (foo.bar.apple).\n      if (typeof value === 'object' && value !== null && !Array.isArray(value) && configuration['dot-notation']) {\n        // if the value is an object but not an array, check nested object\n        setConfigObject(value, fullKey)\n      } else {\n        // setting arguments via CLI takes precedence over\n        // values within the config file.\n        if (!hasKey(argv, fullKey.split('.')) || (flags.defaulted[fullKey]) || (flags.arrays[fullKey] && configuration['combine-arrays'])) {\n          setArg(fullKey, value)\n        }\n      }\n    })\n  }\n\n  // set all config objects passed in opts\n  function setConfigObjects () {\n    if (typeof configObjects === 'undefined') return\n    configObjects.forEach(function (configObject) {\n      setConfigObject(configObject)\n    })\n  }\n\n  function applyEnvVars (argv, configOnly) {\n    if (typeof envPrefix === 'undefined') return\n\n    var prefix = typeof envPrefix === 'string' ? envPrefix : ''\n    Object.keys(process.env).forEach(function (envVar) {\n      if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) {\n        // get array of nested keys and convert them to camel case\n        var keys = envVar.split('__').map(function (key, i) {\n          if (i === 0) {\n            key = key.substring(prefix.length)\n          }\n          return camelCase(key)\n        })\n\n        if (((configOnly && flags.configs[keys.join('.')]) || !configOnly) && (!hasKey(argv, keys) || flags.defaulted[keys.join('.')])) {\n          setArg(keys.join('.'), process.env[envVar])\n        }\n      }\n    })\n  }\n\n  function applyCoercions (argv) {\n    var coerce\n    var applied = {}\n    Object.keys(argv).forEach(function (key) {\n      if (!applied.hasOwnProperty(key)) { // If we haven't already coerced this option via one of its aliases\n        coerce = checkAllAliases(key, flags.coercions)\n        if (typeof coerce === 'function') {\n          try {\n            var value = coerce(argv[key])\n            ;([].concat(flags.aliases[key] || [], key)).forEach(ali => {\n              applied[ali] = argv[ali] = value\n            })\n          } catch (err) {\n            error = err\n          }\n        }\n      }\n    })\n  }\n\n  function setPlaceholderKeys (argv) {\n    flags.keys.forEach((key) => {\n      // don't set placeholder keys for dot notation options 'foo.bar'.\n      if (~key.indexOf('.')) return\n      if (typeof argv[key] === 'undefined') argv[key] = undefined\n    })\n    return argv\n  }\n\n  function applyDefaultsAndAliases (obj, aliases, defaults) {\n    Object.keys(defaults).forEach(function (key) {\n      if (!hasKey(obj, key.split('.'))) {\n        setKey(obj, key.split('.'), defaults[key])\n\n        ;(aliases[key] || []).forEach(function (x) {\n          if (hasKey(obj, x.split('.'))) return\n          setKey(obj, x.split('.'), defaults[key])\n        })\n      }\n    })\n  }\n\n  function hasKey (obj, keys) {\n    var o = obj\n\n    if (!configuration['dot-notation']) keys = [keys.join('.')]\n\n    keys.slice(0, -1).forEach(function (key) {\n      o = (o[key] || {})\n    })\n\n    var key = keys[keys.length - 1]\n\n    if (typeof o !== 'object') return false\n    else return key in o\n  }\n\n  function setKey (obj, keys, value) {\n    var o = obj\n\n    if (!configuration['dot-notation']) keys = [keys.join('.')]\n\n    keys.slice(0, -1).forEach(function (key, index) {\n      // TODO(bcoe): in the next major version of yargs, switch to\n      // Object.create(null) for dot notation:\n      key = sanitizeKey(key)\n\n      if (typeof o === 'object' && o[key] === undefined) {\n        o[key] = {}\n      }\n\n      if (typeof o[key] !== 'object' || Array.isArray(o[key])) {\n        // ensure that o[key] is an array, and that the last item is an empty object.\n        if (Array.isArray(o[key])) {\n          o[key].push({})\n        } else {\n          o[key] = [o[key], {}]\n        }\n\n        // we want to update the empty object at the end of the o[key] array, so set o to that object\n        o = o[key][o[key].length - 1]\n      } else {\n        o = o[key]\n      }\n    })\n\n    // TODO(bcoe): in the next major version of yargs, switch to\n    // Object.create(null) for dot notation:\n    const key = sanitizeKey(keys[keys.length - 1])\n\n    const isTypeArray = checkAllAliases(keys.join('.'), flags.arrays)\n    const isValueArray = Array.isArray(value)\n    let duplicate = configuration['duplicate-arguments-array']\n\n    // nargs has higher priority than duplicate\n    if (!duplicate && checkAllAliases(key, flags.nargs)) {\n      duplicate = true\n      if ((!isUndefined(o[key]) && flags.nargs[key] === 1) || (Array.isArray(o[key]) && o[key].length === flags.nargs[key])) {\n        o[key] = undefined\n      }\n    }\n\n    if (value === increment) {\n      o[key] = increment(o[key])\n    } else if (Array.isArray(o[key])) {\n      if (duplicate && isTypeArray && isValueArray) {\n        o[key] = configuration['flatten-duplicate-arrays'] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value])\n      } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {\n        o[key] = value\n      } else {\n        o[key] = o[key].concat([value])\n      }\n    } else if (o[key] === undefined && isTypeArray) {\n      o[key] = isValueArray ? value : [value]\n    } else if (duplicate && !(o[key] === undefined || checkAllAliases(key, flags.bools) || checkAllAliases(keys.join('.'), flags.bools) || checkAllAliases(key, flags.counts))) {\n      o[key] = [ o[key], value ]\n    } else {\n      o[key] = value\n    }\n  }\n\n  // extend the aliases list with inferred aliases.\n  function extendAliases (...args) {\n    args.forEach(function (obj) {\n      Object.keys(obj || {}).forEach(function (key) {\n        // short-circuit if we've already added a key\n        // to the aliases array, for example it might\n        // exist in both 'opts.default' and 'opts.key'.\n        if (flags.aliases[key]) return\n\n        flags.aliases[key] = [].concat(aliases[key] || [])\n        // For \"--option-name\", also set argv.optionName\n        flags.aliases[key].concat(key).forEach(function (x) {\n          if (/-/.test(x) && configuration['camel-case-expansion']) {\n            var c = camelCase(x)\n            if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n              flags.aliases[key].push(c)\n              newAliases[c] = true\n            }\n          }\n        })\n        // For \"--optionName\", also set argv['option-name']\n        flags.aliases[key].concat(key).forEach(function (x) {\n          if (x.length > 1 && /[A-Z]/.test(x) && configuration['camel-case-expansion']) {\n            var c = decamelize(x, '-')\n            if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n              flags.aliases[key].push(c)\n              newAliases[c] = true\n            }\n          }\n        })\n        flags.aliases[key].forEach(function (x) {\n          flags.aliases[x] = [key].concat(flags.aliases[key].filter(function (y) {\n            return x !== y\n          }))\n        })\n      })\n    })\n  }\n\n  // check if a flag is set for any of a key's aliases.\n  function checkAllAliases (key, flag) {\n    var isSet = false\n    var toCheck = [].concat(flags.aliases[key] || [], key)\n\n    toCheck.forEach(function (key) {\n      if (flag[key]) isSet = flag[key]\n    })\n\n    return isSet\n  }\n\n  function setDefaulted (key) {\n    [].concat(flags.aliases[key] || [], key).forEach(function (k) {\n      flags.defaulted[k] = true\n    })\n  }\n\n  function unsetDefaulted (key) {\n    [].concat(flags.aliases[key] || [], key).forEach(function (k) {\n      delete flags.defaulted[k]\n    })\n  }\n\n  // make a best effor to pick a default value\n  // for an option based on name and type.\n  function defaultValue (key) {\n    if (!checkAllAliases(key, flags.bools) &&\n        !checkAllAliases(key, flags.counts) &&\n        `${key}` in defaults) {\n      return defaults[key]\n    } else {\n      return defaultForType(guessType(key))\n    }\n  }\n\n  // return a default value, given the type of a flag.,\n  // e.g., key of type 'string' will default to '', rather than 'true'.\n  function defaultForType (type) {\n    var def = {\n      boolean: true,\n      string: '',\n      number: undefined,\n      array: []\n    }\n\n    return def[type]\n  }\n\n  // given a flag, enforce a default type.\n  function guessType (key) {\n    var type = 'boolean'\n\n    if (checkAllAliases(key, flags.strings)) type = 'string'\n    else if (checkAllAliases(key, flags.numbers)) type = 'number'\n    else if (checkAllAliases(key, flags.arrays)) type = 'array'\n\n    return type\n  }\n\n  function isNumber (x) {\n    if (x === null || x === undefined) return false\n    // if loaded from config, may already be a number.\n    if (typeof x === 'number') return true\n    // hexadecimal.\n    if (/^0x[0-9a-f]+$/i.test(x)) return true\n    // don't treat 0123 as a number; as it drops the leading '0'.\n    if (x.length > 1 && x[0] === '0') return false\n    return /^[-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(e[-+]?\\d+)?$/.test(x)\n  }\n\n  function isUndefined (num) {\n    return num === undefined\n  }\n\n  return {\n    argv: argv,\n    error: error,\n    aliases: flags.aliases,\n    newAliases: newAliases,\n    configuration: configuration\n  }\n}\n\n// if any aliases reference each other, we should\n// merge them together.\nfunction combineAliases (aliases) {\n  var aliasArrays = []\n  var change = true\n  var combined = {}\n\n  // turn alias lookup hash {key: ['alias1', 'alias2']} into\n  // a simple array ['key', 'alias1', 'alias2']\n  Object.keys(aliases).forEach(function (key) {\n    aliasArrays.push(\n      [].concat(aliases[key], key)\n    )\n  })\n\n  // combine arrays until zero changes are\n  // made in an iteration.\n  while (change) {\n    change = false\n    for (var i = 0; i < aliasArrays.length; i++) {\n      for (var ii = i + 1; ii < aliasArrays.length; ii++) {\n        var intersect = aliasArrays[i].filter(function (v) {\n          return aliasArrays[ii].indexOf(v) !== -1\n        })\n\n        if (intersect.length) {\n          aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii])\n          aliasArrays.splice(ii, 1)\n          change = true\n          break\n        }\n      }\n    }\n  }\n\n  // map arrays back to the hash-lookup (de-dupe while\n  // we're at it).\n  aliasArrays.forEach(function (aliasArray) {\n    aliasArray = aliasArray.filter(function (v, i, self) {\n      return self.indexOf(v) === i\n    })\n    combined[aliasArray.pop()] = aliasArray\n  })\n\n  return combined\n}\n\n// this function should only be called when a count is given as an arg\n// it is NOT called to set a default value\n// thus we can start the count at 1 instead of 0\nfunction increment (orig) {\n  return orig !== undefined ? orig + 1 : 1\n}\n\nfunction Parser (args, opts) {\n  var result = parse(args.slice(), opts)\n\n  return result.argv\n}\n\n// parse arguments and return detailed\n// meta information, aliases, etc.\nParser.detailed = function (args, opts) {\n  return parse(args.slice(), opts)\n}\n\n// TODO(bcoe): in the next major version of yargs, switch to\n// Object.create(null) for dot notation:\nfunction sanitizeKey (key) {\n  if (key === '__proto__') return '___proto___'\n  return key\n}\n\nmodule.exports = Parser\n","// take an un-split argv string and tokenize it.\nmodule.exports = function (argString) {\n  if (Array.isArray(argString)) {\n    return argString.map(e => typeof e !== 'string' ? e + '' : e)\n  }\n\n  argString = argString.trim()\n\n  var i = 0\n  var prevC = null\n  var c = null\n  var opening = null\n  var args = []\n\n  for (var ii = 0; ii < argString.length; ii++) {\n    prevC = c\n    c = argString.charAt(ii)\n\n    // split on spaces unless we're in quotes.\n    if (c === ' ' && !opening) {\n      if (!(prevC === ' ')) {\n        i++\n      }\n      continue\n    }\n\n    // don't split the string if we're in matching\n    // opening or closing single and double quotes.\n    if (c === opening) {\n      opening = null\n    } else if ((c === \"'\" || c === '\"') && !opening) {\n      opening = c\n    }\n\n    if (!args[i]) args[i] = ''\n    args[i] += c\n  }\n\n  return args\n}\n","'use strict';\n\nconst preserveCamelCase = string => {\n\tlet isLastCharLower = false;\n\tlet isLastCharUpper = false;\n\tlet isLastLastCharUpper = false;\n\n\tfor (let i = 0; i < string.length; i++) {\n\t\tconst character = string[i];\n\n\t\tif (isLastCharLower && /[a-zA-Z]/.test(character) && character.toUpperCase() === character) {\n\t\t\tstring = string.slice(0, i) + '-' + string.slice(i);\n\t\t\tisLastCharLower = false;\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper = true;\n\t\t\ti++;\n\t\t} else if (isLastCharUpper && isLastLastCharUpper && /[a-zA-Z]/.test(character) && character.toLowerCase() === character) {\n\t\t\tstring = string.slice(0, i - 1) + '-' + string.slice(i - 1);\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper = false;\n\t\t\tisLastCharLower = true;\n\t\t} else {\n\t\t\tisLastCharLower = character.toLowerCase() === character && character.toUpperCase() !== character;\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper = character.toUpperCase() === character && character.toLowerCase() !== character;\n\t\t}\n\t}\n\n\treturn string;\n};\n\nconst camelCase = (input, options) => {\n\tif (!(typeof input === 'string' || Array.isArray(input))) {\n\t\tthrow new TypeError('Expected the input to be `string | string[]`');\n\t}\n\n\toptions = Object.assign({\n\t\tpascalCase: false\n\t}, options);\n\n\tconst postProcess = x => options.pascalCase ? x.charAt(0).toUpperCase() + x.slice(1) : x;\n\n\tif (Array.isArray(input)) {\n\t\tinput = input.map(x => x.trim())\n\t\t\t.filter(x => x.length)\n\t\t\t.join('-');\n\t} else {\n\t\tinput = input.trim();\n\t}\n\n\tif (input.length === 0) {\n\t\treturn '';\n\t}\n\n\tif (input.length === 1) {\n\t\treturn options.pascalCase ? input.toUpperCase() : input.toLowerCase();\n\t}\n\n\tconst hasUpperCase = input !== input.toLowerCase();\n\n\tif (hasUpperCase) {\n\t\tinput = preserveCamelCase(input);\n\t}\n\n\tinput = input\n\t\t.replace(/^[_.\\- ]+/, '')\n\t\t.toLowerCase()\n\t\t.replace(/[_.\\- ]+(\\w|$)/g, (_, p1) => p1.toUpperCase())\n\t\t.replace(/\\d+(\\w|$)/g, m => m.toUpperCase());\n\n\treturn postProcess(input);\n};\n\nmodule.exports = camelCase;\n// TODO: Remove this for the next major release\nmodule.exports.default = camelCase;\n","'use strict'\n// classic singleton yargs API, to use yargs\n// without running as a singleton do:\n// require('yargs/yargs')(process.argv.slice(2))\nconst yargs = require('./yargs')\n\nArgv(process.argv.slice(2))\n\nmodule.exports = Argv\n\nfunction Argv (processArgs, cwd) {\n  const argv = yargs(processArgs, cwd, require)\n  singletonify(argv)\n  return argv\n}\n\n/*  Hack an instance of Argv with process.argv into Argv\n    so people can do\n    require('yargs')(['--beeble=1','-z','zizzle']).argv\n    to parse a list of args and\n    require('yargs').argv\n    to get a parsed version of process.argv.\n*/\nfunction singletonify (inst) {\n  Object.keys(inst).forEach((key) => {\n    if (key === 'argv') {\n      Argv.__defineGetter__(key, inst.__lookupGetter__(key))\n    } else {\n      Argv[key] = typeof inst[key] === 'function' ? inst[key].bind(inst) : inst[key]\n    }\n  })\n}\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = \"../../node_modules/yargs/lib sync recursive\";","\n'use strict'\nconst fs = require('fs')\nconst path = require('path')\nconst YError = require('./yerror')\n\nlet previouslyVisitedConfigs = []\n\nfunction checkForCircularExtends (cfgPath) {\n  if (previouslyVisitedConfigs.indexOf(cfgPath) > -1) {\n    throw new YError(`Circular extended configurations: '${cfgPath}'.`)\n  }\n}\n\nfunction getPathToDefaultConfig (cwd, pathToExtend) {\n  return path.resolve(cwd, pathToExtend)\n}\n\nfunction applyExtends (config, cwd) {\n  let defaultConfig = {}\n\n  if (config.hasOwnProperty('extends')) {\n    if (typeof config.extends !== 'string') return defaultConfig\n    const isPath = /\\.json|\\..*rc$/.test(config.extends)\n    let pathToDefault = null\n    if (!isPath) {\n      try {\n        pathToDefault = require.resolve(config.extends)\n      } catch (err) {\n        // most likely this simply isn't a module.\n      }\n    } else {\n      pathToDefault = getPathToDefaultConfig(cwd, config.extends)\n    }\n    // maybe the module uses key for some other reason,\n    // err on side of caution.\n    if (!pathToDefault && !isPath) return config\n\n    checkForCircularExtends(pathToDefault)\n\n    previouslyVisitedConfigs.push(pathToDefault)\n\n    defaultConfig = isPath ? JSON.parse(fs.readFileSync(pathToDefault, 'utf8')) : require(config.extends)\n    delete config.extends\n    defaultConfig = applyExtends(defaultConfig, path.dirname(pathToDefault))\n  }\n\n  previouslyVisitedConfigs = []\n\n  return Object.assign({}, defaultConfig, config)\n}\n\nmodule.exports = applyExtends\n","'use strict'\n\n// hoisted due to circular dependency on command.\nmodule.exports = argsert\nconst command = require('./command')()\nconst YError = require('./yerror')\n\nconst positionName = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth']\nfunction argsert (expected, callerArguments, length) {\n  // TODO: should this eventually raise an exception.\n  try {\n    // preface the argument description with \"cmd\", so\n    // that we can run it through yargs' command parser.\n    let position = 0\n    let parsed = { demanded: [], optional: [] }\n    if (typeof expected === 'object') {\n      length = callerArguments\n      callerArguments = expected\n    } else {\n      parsed = command.parseCommand(`cmd ${expected}`)\n    }\n    const args = [].slice.call(callerArguments)\n\n    while (args.length && args[args.length - 1] === undefined) args.pop()\n    length = length || args.length\n\n    if (length < parsed.demanded.length) {\n      throw new YError(`Not enough arguments provided. Expected ${parsed.demanded.length} but received ${args.length}.`)\n    }\n\n    const totalCommands = parsed.demanded.length + parsed.optional.length\n    if (length > totalCommands) {\n      throw new YError(`Too many arguments provided. Expected max ${totalCommands} but received ${length}.`)\n    }\n\n    parsed.demanded.forEach((demanded) => {\n      const arg = args.shift()\n      const observedType = guessType(arg)\n      const matchingTypes = demanded.cmd.filter(type => type === observedType || type === '*')\n      if (matchingTypes.length === 0) argumentTypeError(observedType, demanded.cmd, position, false)\n      position += 1\n    })\n\n    parsed.optional.forEach((optional) => {\n      if (args.length === 0) return\n      const arg = args.shift()\n      const observedType = guessType(arg)\n      const matchingTypes = optional.cmd.filter(type => type === observedType || type === '*')\n      if (matchingTypes.length === 0) argumentTypeError(observedType, optional.cmd, position, true)\n      position += 1\n    })\n  } catch (err) {\n    console.warn(err.stack)\n  }\n}\n\nfunction guessType (arg) {\n  if (Array.isArray(arg)) {\n    return 'array'\n  } else if (arg === null) {\n    return 'null'\n  }\n  return typeof arg\n}\n\nfunction argumentTypeError (observedType, allowedTypes, position, optional) {\n  throw new YError(`Invalid ${positionName[position] || 'manyith'} argument. Expected ${allowedTypes.join(' or ')} but received ${observedType}.`)\n}\n","'use strict'\n\nconst inspect = require('util').inspect\nconst isPromise = require('./is-promise')\nconst { applyMiddleware, commandMiddlewareFactory } = require('./middleware')\nconst path = require('path')\nconst Parser = require('yargs-parser')\n\nconst DEFAULT_MARKER = /(^\\*)|(^\\$0)/\n\n// handles parsing positional arguments,\n// and populating argv with said positional\n// arguments.\nmodule.exports = function command (yargs, usage, validation, globalMiddleware) {\n  const self = {}\n  let handlers = {}\n  let aliasMap = {}\n  let defaultCommand\n  globalMiddleware = globalMiddleware || []\n\n  self.addHandler = function addHandler (cmd, description, builder, handler, commandMiddleware) {\n    let aliases = []\n    const middlewares = commandMiddlewareFactory(commandMiddleware)\n    handler = handler || (() => {})\n\n    if (Array.isArray(cmd)) {\n      aliases = cmd.slice(1)\n      cmd = cmd[0]\n    } else if (typeof cmd === 'object') {\n      let command = (Array.isArray(cmd.command) || typeof cmd.command === 'string') ? cmd.command : moduleName(cmd)\n      if (cmd.aliases) command = [].concat(command).concat(cmd.aliases)\n      self.addHandler(command, extractDesc(cmd), cmd.builder, cmd.handler, cmd.middlewares)\n      return\n    }\n\n    // allow a module to be provided instead of separate builder and handler\n    if (typeof builder === 'object' && builder.builder && typeof builder.handler === 'function') {\n      self.addHandler([cmd].concat(aliases), description, builder.builder, builder.handler, builder.middlewares)\n      return\n    }\n\n    // parse positionals out of cmd string\n    const parsedCommand = self.parseCommand(cmd)\n\n    // remove positional args from aliases only\n    aliases = aliases.map(alias => self.parseCommand(alias).cmd)\n\n    // check for default and filter out '*''\n    let isDefault = false\n    const parsedAliases = [parsedCommand.cmd].concat(aliases).filter((c) => {\n      if (DEFAULT_MARKER.test(c)) {\n        isDefault = true\n        return false\n      }\n      return true\n    })\n\n    // standardize on $0 for default command.\n    if (parsedAliases.length === 0 && isDefault) parsedAliases.push('$0')\n\n    // shift cmd and aliases after filtering out '*'\n    if (isDefault) {\n      parsedCommand.cmd = parsedAliases[0]\n      aliases = parsedAliases.slice(1)\n      cmd = cmd.replace(DEFAULT_MARKER, parsedCommand.cmd)\n    }\n\n    // populate aliasMap\n    aliases.forEach((alias) => {\n      aliasMap[alias] = parsedCommand.cmd\n    })\n\n    if (description !== false) {\n      usage.command(cmd, description, isDefault, aliases)\n    }\n\n    handlers[parsedCommand.cmd] = {\n      original: cmd,\n      description: description,\n      handler,\n      builder: builder || {},\n      middlewares: middlewares || [],\n      demanded: parsedCommand.demanded,\n      optional: parsedCommand.optional\n    }\n\n    if (isDefault) defaultCommand = handlers[parsedCommand.cmd]\n  }\n\n  self.addDirectory = function addDirectory (dir, context, req, callerFile, opts) {\n    opts = opts || {}\n    // disable recursion to support nested directories of subcommands\n    if (typeof opts.recurse !== 'boolean') opts.recurse = false\n    // exclude 'json', 'coffee' from require-directory defaults\n    if (!Array.isArray(opts.extensions)) opts.extensions = ['js']\n    // allow consumer to define their own visitor function\n    const parentVisit = typeof opts.visit === 'function' ? opts.visit : o => o\n    // call addHandler via visitor function\n    opts.visit = function visit (obj, joined, filename) {\n      const visited = parentVisit(obj, joined, filename)\n      // allow consumer to skip modules with their own visitor\n      if (visited) {\n        // check for cyclic reference\n        // each command file path should only be seen once per execution\n        if (~context.files.indexOf(joined)) return visited\n        // keep track of visited files in context.files\n        context.files.push(joined)\n        self.addHandler(visited)\n      }\n      return visited\n    }\n    require('require-directory')({ require: req, filename: callerFile }, dir, opts)\n  }\n\n  // lookup module object from require()d command and derive name\n  // if module was not require()d and no name given, throw error\n  function moduleName (obj) {\n    const mod = require('which-module')(obj)\n    if (!mod) throw new Error(`No command name given for module: ${inspect(obj)}`)\n    return commandFromFilename(mod.filename)\n  }\n\n  // derive command name from filename\n  function commandFromFilename (filename) {\n    return path.basename(filename, path.extname(filename))\n  }\n\n  function extractDesc (obj) {\n    for (let keys = ['describe', 'description', 'desc'], i = 0, l = keys.length, test; i < l; i++) {\n      test = obj[keys[i]]\n      if (typeof test === 'string' || typeof test === 'boolean') return test\n    }\n    return false\n  }\n\n  self.parseCommand = function parseCommand (cmd) {\n    const extraSpacesStrippedCommand = cmd.replace(/\\s{2,}/g, ' ')\n    const splitCommand = extraSpacesStrippedCommand.split(/\\s+(?![^[]*]|[^<]*>)/)\n    const bregex = /\\.*[\\][<>]/g\n    const parsedCommand = {\n      cmd: (splitCommand.shift()).replace(bregex, ''),\n      demanded: [],\n      optional: []\n    }\n    splitCommand.forEach((cmd, i) => {\n      let variadic = false\n      cmd = cmd.replace(/\\s/g, '')\n      if (/\\.+[\\]>]/.test(cmd) && i === splitCommand.length - 1) variadic = true\n      if (/^\\[/.test(cmd)) {\n        parsedCommand.optional.push({\n          cmd: cmd.replace(bregex, '').split('|'),\n          variadic\n        })\n      } else {\n        parsedCommand.demanded.push({\n          cmd: cmd.replace(bregex, '').split('|'),\n          variadic\n        })\n      }\n    })\n    return parsedCommand\n  }\n\n  self.getCommands = () => Object.keys(handlers).concat(Object.keys(aliasMap))\n\n  self.getCommandHandlers = () => handlers\n\n  self.hasDefaultCommand = () => !!defaultCommand\n\n  self.runCommand = function runCommand (command, yargs, parsed, commandIndex) {\n    let aliases = parsed.aliases\n    const commandHandler = handlers[command] || handlers[aliasMap[command]] || defaultCommand\n    const currentContext = yargs.getContext()\n    let numFiles = currentContext.files.length\n    const parentCommands = currentContext.commands.slice()\n\n    // what does yargs look like after the buidler is run?\n    let innerArgv = parsed.argv\n    let innerYargs = null\n    let positionalMap = {}\n    if (command) {\n      currentContext.commands.push(command)\n      currentContext.fullCommands.push(commandHandler.original)\n    }\n    if (typeof commandHandler.builder === 'function') {\n      // a function can be provided, which builds\n      // up a yargs chain and possibly returns it.\n      innerYargs = commandHandler.builder(yargs.reset(parsed.aliases))\n      // if the builder function did not yet parse argv with reset yargs\n      // and did not explicitly set a usage() string, then apply the\n      // original command string as usage() for consistent behavior with\n      // options object below.\n      if (yargs.parsed === false) {\n        if (shouldUpdateUsage(yargs)) {\n          yargs.getUsageInstance().usage(\n            usageFromParentCommandsCommandHandler(parentCommands, commandHandler),\n            commandHandler.description\n          )\n        }\n        innerArgv = innerYargs ? innerYargs._parseArgs(null, null, true, commandIndex) : yargs._parseArgs(null, null, true, commandIndex)\n      } else {\n        innerArgv = yargs.parsed.argv\n      }\n\n      if (innerYargs && yargs.parsed === false) aliases = innerYargs.parsed.aliases\n      else aliases = yargs.parsed.aliases\n    } else if (typeof commandHandler.builder === 'object') {\n      // as a short hand, an object can instead be provided, specifying\n      // the options that a command takes.\n      innerYargs = yargs.reset(parsed.aliases)\n      if (shouldUpdateUsage(innerYargs)) {\n        innerYargs.getUsageInstance().usage(\n          usageFromParentCommandsCommandHandler(parentCommands, commandHandler),\n          commandHandler.description\n        )\n      }\n      Object.keys(commandHandler.builder).forEach((key) => {\n        innerYargs.option(key, commandHandler.builder[key])\n      })\n      innerArgv = innerYargs._parseArgs(null, null, true, commandIndex)\n      aliases = innerYargs.parsed.aliases\n    }\n\n    if (!yargs._hasOutput()) {\n      positionalMap = populatePositionals(commandHandler, innerArgv, currentContext, yargs)\n    }\n\n    const middlewares = globalMiddleware.slice(0).concat(commandHandler.middlewares || [])\n    applyMiddleware(innerArgv, yargs, middlewares, true)\n\n    // we apply validation post-hoc, so that custom\n    // checks get passed populated positional arguments.\n    if (!yargs._hasOutput()) yargs._runValidation(innerArgv, aliases, positionalMap, yargs.parsed.error)\n\n    if (commandHandler.handler && !yargs._hasOutput()) {\n      yargs._setHasOutput()\n\n      innerArgv = applyMiddleware(innerArgv, yargs, middlewares, false)\n\n      const handlerResult = isPromise(innerArgv)\n        ? innerArgv.then(argv => commandHandler.handler(argv))\n        : commandHandler.handler(innerArgv)\n\n      if (isPromise(handlerResult)) {\n        handlerResult.catch(error =>\n          yargs.getUsageInstance().fail(null, error)\n        )\n      }\n    }\n\n    if (command) {\n      currentContext.commands.pop()\n      currentContext.fullCommands.pop()\n    }\n    numFiles = currentContext.files.length - numFiles\n    if (numFiles > 0) currentContext.files.splice(numFiles * -1, numFiles)\n\n    return innerArgv\n  }\n\n  function shouldUpdateUsage (yargs) {\n    return !yargs.getUsageInstance().getUsageDisabled() &&\n      yargs.getUsageInstance().getUsage().length === 0\n  }\n\n  function usageFromParentCommandsCommandHandler (parentCommands, commandHandler) {\n    const c = DEFAULT_MARKER.test(commandHandler.original) ? commandHandler.original.replace(DEFAULT_MARKER, '').trim() : commandHandler.original\n    const pc = parentCommands.filter((c) => { return !DEFAULT_MARKER.test(c) })\n    pc.push(c)\n    return `$0 ${pc.join(' ')}`\n  }\n\n  self.runDefaultBuilderOn = function (yargs) {\n    if (shouldUpdateUsage(yargs)) {\n      // build the root-level command string from the default string.\n      const commandString = DEFAULT_MARKER.test(defaultCommand.original)\n        ? defaultCommand.original : defaultCommand.original.replace(/^[^[\\]<>]*/, '$0 ')\n      yargs.getUsageInstance().usage(\n        commandString,\n        defaultCommand.description\n      )\n    }\n    const builder = defaultCommand.builder\n    if (typeof builder === 'function') {\n      builder(yargs)\n    } else {\n      Object.keys(builder).forEach((key) => {\n        yargs.option(key, builder[key])\n      })\n    }\n  }\n\n  // transcribe all positional arguments \"command <foo> <bar> [apple]\"\n  // onto argv.\n  function populatePositionals (commandHandler, argv, context, yargs) {\n    argv._ = argv._.slice(context.commands.length) // nuke the current commands\n    const demanded = commandHandler.demanded.slice(0)\n    const optional = commandHandler.optional.slice(0)\n    const positionalMap = {}\n\n    validation.positionalCount(demanded.length, argv._.length)\n\n    while (demanded.length) {\n      const demand = demanded.shift()\n      populatePositional(demand, argv, positionalMap)\n    }\n\n    while (optional.length) {\n      const maybe = optional.shift()\n      populatePositional(maybe, argv, positionalMap)\n    }\n\n    argv._ = context.commands.concat(argv._)\n\n    postProcessPositionals(argv, positionalMap, self.cmdToParseOptions(commandHandler.original))\n\n    return positionalMap\n  }\n\n  function populatePositional (positional, argv, positionalMap, parseOptions) {\n    const cmd = positional.cmd[0]\n    if (positional.variadic) {\n      positionalMap[cmd] = argv._.splice(0).map(String)\n    } else {\n      if (argv._.length) positionalMap[cmd] = [String(argv._.shift())]\n    }\n  }\n\n  // we run yargs-parser against the positional arguments\n  // applying the same parsing logic used for flags.\n  function postProcessPositionals (argv, positionalMap, parseOptions) {\n    // combine the parsing hints we've inferred from the command\n    // string with explicitly configured parsing hints.\n    const options = Object.assign({}, yargs.getOptions())\n    options.default = Object.assign(parseOptions.default, options.default)\n    options.alias = Object.assign(parseOptions.alias, options.alias)\n    options.array = options.array.concat(parseOptions.array)\n    delete options.config //  don't load config when processing positionals.\n\n    const unparsed = []\n    Object.keys(positionalMap).forEach((key) => {\n      positionalMap[key].map((value) => {\n        unparsed.push(`--${key}`)\n        unparsed.push(value)\n      })\n    })\n\n    // short-circuit parse.\n    if (!unparsed.length) return\n\n    const parsed = Parser.detailed(unparsed, options)\n\n    if (parsed.error) {\n      yargs.getUsageInstance().fail(parsed.error.message, parsed.error)\n    } else {\n      // only copy over positional keys (don't overwrite\n      // flag arguments that were already parsed).\n      const positionalKeys = Object.keys(positionalMap)\n      Object.keys(positionalMap).forEach((key) => {\n        [].push.apply(positionalKeys, parsed.aliases[key])\n      })\n\n      Object.keys(parsed.argv).forEach((key) => {\n        if (positionalKeys.indexOf(key) !== -1) {\n          // any new aliases need to be placed in positionalMap, which\n          // is used for validation.\n          if (!positionalMap[key]) positionalMap[key] = parsed.argv[key]\n          argv[key] = parsed.argv[key]\n        }\n      })\n    }\n  }\n\n  self.cmdToParseOptions = function (cmdString) {\n    const parseOptions = {\n      array: [],\n      default: {},\n      alias: {},\n      demand: {}\n    }\n\n    const parsed = self.parseCommand(cmdString)\n    parsed.demanded.forEach((d) => {\n      const cmds = d.cmd.slice(0)\n      const cmd = cmds.shift()\n      if (d.variadic) {\n        parseOptions.array.push(cmd)\n        parseOptions.default[cmd] = []\n      }\n      cmds.forEach((c) => {\n        parseOptions.alias[cmd] = c\n      })\n      parseOptions.demand[cmd] = true\n    })\n\n    parsed.optional.forEach((o) => {\n      const cmds = o.cmd.slice(0)\n      const cmd = cmds.shift()\n      if (o.variadic) {\n        parseOptions.array.push(cmd)\n        parseOptions.default[cmd] = []\n      }\n      cmds.forEach((c) => {\n        parseOptions.alias[cmd] = c\n      })\n    })\n\n    return parseOptions\n  }\n\n  self.reset = () => {\n    handlers = {}\n    aliasMap = {}\n    defaultCommand = undefined\n    return self\n  }\n\n  // used by yargs.parse() to freeze\n  // the state of commands such that\n  // we can apply .parse() multiple times\n  // with the same yargs instance.\n  let frozen\n  self.freeze = () => {\n    frozen = {}\n    frozen.handlers = handlers\n    frozen.aliasMap = aliasMap\n    frozen.defaultCommand = defaultCommand\n  }\n  self.unfreeze = () => {\n    handlers = frozen.handlers\n    aliasMap = frozen.aliasMap\n    defaultCommand = frozen.defaultCommand\n    frozen = undefined\n  }\n\n  return self\n}\n","exports.completionShTemplate =\n`###-begin-{{app_name}}-completions-###\n#\n# yargs command completion script\n#\n# Installation: {{app_path}} {{completion_command}} >> ~/.bashrc\n#    or {{app_path}} {{completion_command}} >> ~/.bash_profile on OSX.\n#\n_yargs_completions()\n{\n    local cur_word args type_list\n\n    cur_word=\"\\${COMP_WORDS[COMP_CWORD]}\"\n    args=(\"\\${COMP_WORDS[@]}\")\n\n    # ask yargs to generate completions.\n    type_list=$({{app_path}} --get-yargs-completions \"\\${args[@]}\")\n\n    COMPREPLY=( $(compgen -W \"\\${type_list}\" -- \\${cur_word}) )\n\n    # if no match was found, fall back to filename completion\n    if [ \\${#COMPREPLY[@]} -eq 0 ]; then\n      COMPREPLY=()\n    fi\n\n    return 0\n}\ncomplete -o default -F _yargs_completions {{app_name}}\n###-end-{{app_name}}-completions-###\n`\n\nexports.completionZshTemplate = `###-begin-{{app_name}}-completions-###\n#\n# yargs command completion script\n#\n# Installation: {{app_path}} {{completion_command}} >> ~/.zshrc\n#    or {{app_path}} {{completion_command}} >> ~/.zsh_profile on OSX.\n#\n_{{app_name}}_yargs_completions()\n{\n  local reply\n  local si=$IFS\n  IFS=$'\\n' reply=($(COMP_CWORD=\"$((CURRENT-1))\" COMP_LINE=\"$BUFFER\" COMP_POINT=\"$CURSOR\" {{app_path}} --get-yargs-completions \"\\${words[@]}\"))\n  IFS=$si\n  _describe 'values' reply\n}\ncompdef _{{app_name}}_yargs_completions {{app_name}}\n###-end-{{app_name}}-completions-###\n`\n","'use strict'\nconst path = require('path')\n\n// add bash completions to your\n//  yargs-powered applications.\nmodule.exports = function completion (yargs, usage, command) {\n  const self = {\n    completionKey: 'get-yargs-completions'\n  }\n\n  const zshShell = process.env.SHELL && process.env.SHELL.indexOf('zsh') !== -1\n  // get a list of completion commands.\n  // 'args' is the array of strings from the line to be completed\n  self.getCompletion = function getCompletion (args, done) {\n    const completions = []\n    const current = args.length ? args[args.length - 1] : ''\n    const argv = yargs.parse(args, true)\n    const aliases = yargs.parsed.aliases\n    const parentCommands = yargs.getContext().commands\n\n    // a custom completion function can be provided\n    // to completion().\n    if (completionFunction) {\n      if (completionFunction.length < 3) {\n        const result = completionFunction(current, argv)\n\n        // promise based completion function.\n        if (typeof result.then === 'function') {\n          return result.then((list) => {\n            process.nextTick(() => { done(list) })\n          }).catch((err) => {\n            process.nextTick(() => { throw err })\n          })\n        }\n\n        // synchronous completion function.\n        return done(result)\n      } else {\n        // asynchronous completion function\n        return completionFunction(current, argv, (completions) => {\n          done(completions)\n        })\n      }\n    }\n\n    const handlers = command.getCommandHandlers()\n    for (let i = 0, ii = args.length; i < ii; ++i) {\n      if (handlers[args[i]] && handlers[args[i]].builder) {\n        const builder = handlers[args[i]].builder\n        if (typeof builder === 'function') {\n          const y = yargs.reset()\n          builder(y)\n          return y.argv\n        }\n      }\n    }\n\n    if (!current.match(/^-/) && parentCommands[parentCommands.length - 1] !== current) {\n      usage.getCommands().forEach((usageCommand) => {\n        const commandName = command.parseCommand(usageCommand[0]).cmd\n        if (args.indexOf(commandName) === -1) {\n          if (!zshShell) {\n            completions.push(commandName)\n          } else {\n            const desc = usageCommand[1] || ''\n            completions.push(commandName.replace(/:/g, '\\\\:') + ':' + desc)\n          }\n        }\n      })\n    }\n\n    if (current.match(/^-/) || (current === '' && completions.length === 0)) {\n      const descs = usage.getDescriptions()\n      Object.keys(yargs.getOptions().key).forEach((key) => {\n        // If the key and its aliases aren't in 'args', add the key to 'completions'\n        const keyAndAliases = [key].concat(aliases[key] || [])\n        const notInArgs = keyAndAliases.every(val => args.indexOf(`--${val}`) === -1)\n        if (notInArgs) {\n          if (!zshShell) {\n            completions.push(`--${key}`)\n          } else {\n            const desc = descs[key] || ''\n            completions.push(`--${key.replace(/:/g, '\\\\:')}:${desc.replace('__yargsString__:', '')}`)\n          }\n        }\n      })\n    }\n\n    done(completions)\n  }\n\n  // generate the completion script to add to your .bashrc.\n  self.generateCompletionScript = function generateCompletionScript ($0, cmd) {\n    const templates = require('./completion-templates')\n    let script = zshShell ? templates.completionZshTemplate : templates.completionShTemplate\n    const name = path.basename($0)\n\n    // add ./to applications not yet installed as bin.\n    if ($0.match(/\\.js$/)) $0 = `./${$0}`\n\n    script = script.replace(/{{app_name}}/g, name)\n    script = script.replace(/{{completion_command}}/g, cmd)\n    return script.replace(/{{app_path}}/g, $0)\n  }\n\n  // register a function to perform your own custom\n  // completions., this function can be either\n  // synchrnous or asynchronous.\n  let completionFunction = null\n  self.registerFunction = (fn) => {\n    completionFunction = fn\n  }\n\n  return self\n}\n","/*\nMIT License\n\nCopyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n'use strict'\n\nmodule.exports = (text, separator) => {\n  separator = typeof separator === 'undefined' ? '_' : separator\n\n  return text\n    .replace(/([a-z\\d])([A-Z])/g, `$1${separator}$2`)\n    .replace(/([A-Z]+)([A-Z][a-z\\d]+)/g, `$1${separator}$2`)\n    .toLowerCase()\n}\n","module.exports = function isPromise (maybePromise) {\n  return maybePromise instanceof Promise\n}\n","/*\nCopyright (c) 2011 Andrei Mackenzie\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n// levenshtein distance algorithm, pulled from Andrei Mackenzie's MIT licensed.\n// gist, which can be found here: https://gist.github.com/andrei-m/982927\n'use strict'\n// Compute the edit distance between the two given strings\nmodule.exports = function levenshtein (a, b) {\n  if (a.length === 0) return b.length\n  if (b.length === 0) return a.length\n\n  const matrix = []\n\n  // increment along the first column of each row\n  let i\n  for (i = 0; i <= b.length; i++) {\n    matrix[i] = [i]\n  }\n\n  // increment each column in the first row\n  let j\n  for (j = 0; j <= a.length; j++) {\n    matrix[0][j] = j\n  }\n\n  // Fill in the rest of the matrix\n  for (i = 1; i <= b.length; i++) {\n    for (j = 1; j <= a.length; j++) {\n      if (b.charAt(i - 1) === a.charAt(j - 1)) {\n        matrix[i][j] = matrix[i - 1][j - 1]\n      } else {\n        matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, // substitution\n          Math.min(matrix[i][j - 1] + 1, // insertion\n            matrix[i - 1][j] + 1)) // deletion\n      }\n    }\n  }\n\n  return matrix[b.length][a.length]\n}\n","'use strict'\n\n// hoisted due to circular dependency on command.\nmodule.exports = {\n  applyMiddleware,\n  commandMiddlewareFactory,\n  globalMiddlewareFactory\n}\nconst isPromise = require('./is-promise')\nconst argsert = require('./argsert')\n\nfunction globalMiddlewareFactory (globalMiddleware, context) {\n  return function (callback, applyBeforeValidation = false) {\n    argsert('<array|function> [boolean]', [callback, applyBeforeValidation], arguments.length)\n    if (Array.isArray(callback)) {\n      for (let i = 0; i < callback.length; i++) {\n        if (typeof callback[i] !== 'function') {\n          throw Error('middleware must be a function')\n        }\n        callback[i].applyBeforeValidation = applyBeforeValidation\n      }\n      Array.prototype.push.apply(globalMiddleware, callback)\n    } else if (typeof callback === 'function') {\n      callback.applyBeforeValidation = applyBeforeValidation\n      globalMiddleware.push(callback)\n    }\n    return context\n  }\n}\n\nfunction commandMiddlewareFactory (commandMiddleware) {\n  if (!commandMiddleware) return []\n  return commandMiddleware.map(middleware => {\n    middleware.applyBeforeValidation = false\n    return middleware\n  })\n}\n\nfunction applyMiddleware (argv, yargs, middlewares, beforeValidation) {\n  const beforeValidationError = new Error('middleware cannot return a promise when applyBeforeValidation is true')\n  return middlewares\n    .reduce((accumulation, middleware) => {\n      if (middleware.applyBeforeValidation !== beforeValidation &&\n          !isPromise(accumulation)) {\n        return accumulation\n      }\n\n      if (isPromise(accumulation)) {\n        return accumulation\n          .then(initialObj =>\n            Promise.all([initialObj, middleware(initialObj, yargs)])\n          )\n          .then(([initialObj, middlewareObj]) =>\n            Object.assign(initialObj, middlewareObj)\n          )\n      } else {\n        const result = middleware(argv, yargs)\n        if (beforeValidation && isPromise(result)) throw beforeValidationError\n\n        return isPromise(result)\n          ? result.then(middlewareObj => Object.assign(accumulation, middlewareObj))\n          : Object.assign(accumulation, result)\n      }\n    }, argv)\n}\n","'use strict'\nmodule.exports = function objFilter (original, filter) {\n  const obj = {}\n  filter = filter || ((k, v) => true)\n  Object.keys(original || {}).forEach((key) => {\n    if (filter(key, original[key])) {\n      obj[key] = original[key]\n    }\n  })\n  return obj\n}\n","'use strict'\n// this file handles outputting usage instructions,\n// failures, etc. keeps logging in one place.\nconst decamelize = require('./decamelize')\nconst stringWidth = require('string-width')\nconst objFilter = require('./obj-filter')\nconst path = require('path')\nconst setBlocking = require('set-blocking')\nconst YError = require('./yerror')\n\nmodule.exports = function usage (yargs, y18n) {\n  const __ = y18n.__\n  const self = {}\n\n  // methods for ouputting/building failure message.\n  const fails = []\n  self.failFn = function failFn (f) {\n    fails.push(f)\n  }\n\n  let failMessage = null\n  let showHelpOnFail = true\n  self.showHelpOnFail = function showHelpOnFailFn (enabled, message) {\n    if (typeof enabled === 'string') {\n      message = enabled\n      enabled = true\n    } else if (typeof enabled === 'undefined') {\n      enabled = true\n    }\n    failMessage = message\n    showHelpOnFail = enabled\n    return self\n  }\n\n  let failureOutput = false\n  self.fail = function fail (msg, err) {\n    const logger = yargs._getLoggerInstance()\n\n    if (fails.length) {\n      for (let i = fails.length - 1; i >= 0; --i) {\n        fails[i](msg, err, self)\n      }\n    } else {\n      if (yargs.getExitProcess()) setBlocking(true)\n\n      // don't output failure message more than once\n      if (!failureOutput) {\n        failureOutput = true\n        if (showHelpOnFail) {\n          yargs.showHelp('error')\n          logger.error()\n        }\n        if (msg || err) logger.error(msg || err)\n        if (failMessage) {\n          if (msg || err) logger.error('')\n          logger.error(failMessage)\n        }\n      }\n\n      err = err || new YError(msg)\n      if (yargs.getExitProcess()) {\n        return yargs.exit(1)\n      } else if (yargs._hasParseCallback()) {\n        return yargs.exit(1, err)\n      } else {\n        throw err\n      }\n    }\n  }\n\n  // methods for ouputting/building help (usage) message.\n  let usages = []\n  let usageDisabled = false\n  self.usage = (msg, description) => {\n    if (msg === null) {\n      usageDisabled = true\n      usages = []\n      return\n    }\n    usageDisabled = false\n    usages.push([msg, description || ''])\n    return self\n  }\n  self.getUsage = () => {\n    return usages\n  }\n  self.getUsageDisabled = () => {\n    return usageDisabled\n  }\n\n  self.getPositionalGroupName = () => {\n    return __('Positionals:')\n  }\n\n  let examples = []\n  self.example = (cmd, description) => {\n    examples.push([cmd, description || ''])\n  }\n\n  let commands = []\n  self.command = function command (cmd, description, isDefault, aliases) {\n    // the last default wins, so cancel out any previously set default\n    if (isDefault) {\n      commands = commands.map((cmdArray) => {\n        cmdArray[2] = false\n        return cmdArray\n      })\n    }\n    commands.push([cmd, description || '', isDefault, aliases])\n  }\n  self.getCommands = () => commands\n\n  let descriptions = {}\n  self.describe = function describe (key, desc) {\n    if (typeof key === 'object') {\n      Object.keys(key).forEach((k) => {\n        self.describe(k, key[k])\n      })\n    } else {\n      descriptions[key] = desc\n    }\n  }\n  self.getDescriptions = () => descriptions\n\n  let epilog\n  self.epilog = (msg) => {\n    epilog = msg\n  }\n\n  let wrapSet = false\n  let wrap\n  self.wrap = (cols) => {\n    wrapSet = true\n    wrap = cols\n  }\n\n  function getWrap () {\n    if (!wrapSet) {\n      wrap = windowWidth()\n      wrapSet = true\n    }\n\n    return wrap\n  }\n\n  const deferY18nLookupPrefix = '__yargsString__:'\n  self.deferY18nLookup = str => deferY18nLookupPrefix + str\n\n  const defaultGroup = 'Options:'\n  self.help = function help () {\n    normalizeAliases()\n\n    // handle old demanded API\n    const base$0 = path.basename(yargs.$0)\n    const demandedOptions = yargs.getDemandedOptions()\n    const demandedCommands = yargs.getDemandedCommands()\n    const groups = yargs.getGroups()\n    const options = yargs.getOptions()\n\n    let keys = []\n    keys = keys.concat(Object.keys(descriptions))\n    keys = keys.concat(Object.keys(demandedOptions))\n    keys = keys.concat(Object.keys(demandedCommands))\n    keys = keys.concat(Object.keys(options.default))\n    keys = keys.filter(filterHiddenOptions)\n    keys = Object.keys(keys.reduce((acc, key) => {\n      if (key !== '_') acc[key] = true\n      return acc\n    }, {}))\n\n    const theWrap = getWrap()\n    const ui = require('cliui')({\n      width: theWrap,\n      wrap: !!theWrap\n    })\n\n    // the usage string.\n    if (!usageDisabled) {\n      if (usages.length) {\n        // user-defined usage.\n        usages.forEach((usage) => {\n          ui.div(`${usage[0].replace(/\\$0/g, base$0)}`)\n          if (usage[1]) {\n            ui.div({ text: `${usage[1]}`, padding: [1, 0, 0, 0] })\n          }\n        })\n        ui.div()\n      } else if (commands.length) {\n        let u = null\n        // demonstrate how commands are used.\n        if (demandedCommands._) {\n          u = `${base$0} <${__('command')}>\\n`\n        } else {\n          u = `${base$0} [${__('command')}]\\n`\n        }\n        ui.div(`${u}`)\n      }\n    }\n\n    // your application's commands, i.e., non-option\n    // arguments populated in '_'.\n    if (commands.length) {\n      ui.div(__('Commands:'))\n\n      const context = yargs.getContext()\n      const parentCommands = context.commands.length ? `${context.commands.join(' ')} ` : ''\n\n      if (yargs.getParserConfiguration()['sort-commands'] === true) {\n        commands = commands.sort((a, b) => a[0].localeCompare(b[0]))\n      }\n\n      commands.forEach((command) => {\n        const commandString = `${base$0} ${parentCommands}${command[0].replace(/^\\$0 ?/, '')}` // drop $0 from default commands.\n        ui.span(\n          {\n            text: commandString,\n            padding: [0, 2, 0, 2],\n            width: maxWidth(commands, theWrap, `${base$0}${parentCommands}`) + 4\n          },\n          { text: command[1] }\n        )\n        const hints = []\n        if (command[2]) hints.push(`[${__('default:').slice(0, -1)}]`) // TODO hacking around i18n here\n        if (command[3] && command[3].length) {\n          hints.push(`[${__('aliases:')} ${command[3].join(', ')}]`)\n        }\n        if (hints.length) {\n          ui.div({ text: hints.join(' '), padding: [0, 0, 0, 2], align: 'right' })\n        } else {\n          ui.div()\n        }\n      })\n\n      ui.div()\n    }\n\n    // perform some cleanup on the keys array, making it\n    // only include top-level keys not their aliases.\n    const aliasKeys = (Object.keys(options.alias) || [])\n      .concat(Object.keys(yargs.parsed.newAliases) || [])\n\n    keys = keys.filter(key => !yargs.parsed.newAliases[key] && aliasKeys.every(alias => (options.alias[alias] || []).indexOf(key) === -1))\n\n    // populate 'Options:' group with any keys that have not\n    // explicitly had a group set.\n    if (!groups[defaultGroup]) groups[defaultGroup] = []\n    addUngroupedKeys(keys, options.alias, groups)\n\n    // display 'Options:' table along with any custom tables:\n    Object.keys(groups).forEach((groupName) => {\n      if (!groups[groupName].length) return\n\n      // if we've grouped the key 'f', but 'f' aliases 'foobar',\n      // normalizedKeys should contain only 'foobar'.\n      const normalizedKeys = groups[groupName].filter(filterHiddenOptions).map((key) => {\n        if (~aliasKeys.indexOf(key)) return key\n        for (let i = 0, aliasKey; (aliasKey = aliasKeys[i]) !== undefined; i++) {\n          if (~(options.alias[aliasKey] || []).indexOf(key)) return aliasKey\n        }\n        return key\n      })\n\n      if (normalizedKeys.length < 1) return\n\n      ui.div(__(groupName))\n\n      // actually generate the switches string --foo, -f, --bar.\n      const switches = normalizedKeys.reduce((acc, key) => {\n        acc[key] = [ key ].concat(options.alias[key] || [])\n          .map(sw => {\n            // for the special positional group don't\n            // add '--' or '-' prefix.\n            if (groupName === self.getPositionalGroupName()) return sw\n            else return (sw.length > 1 ? '--' : '-') + sw\n          })\n          .join(', ')\n\n        return acc\n      }, {})\n\n      normalizedKeys.forEach((key) => {\n        const kswitch = switches[key]\n        let desc = descriptions[key] || ''\n        let type = null\n\n        if (~desc.lastIndexOf(deferY18nLookupPrefix)) desc = __(desc.substring(deferY18nLookupPrefix.length))\n\n        if (~options.boolean.indexOf(key)) type = `[${__('boolean')}]`\n        if (~options.count.indexOf(key)) type = `[${__('count')}]`\n        if (~options.string.indexOf(key)) type = `[${__('string')}]`\n        if (~options.normalize.indexOf(key)) type = `[${__('string')}]`\n        if (~options.array.indexOf(key)) type = `[${__('array')}]`\n        if (~options.number.indexOf(key)) type = `[${__('number')}]`\n\n        const extra = [\n          type,\n          (key in demandedOptions) ? `[${__('required')}]` : null,\n          options.choices && options.choices[key] ? `[${__('choices:')} ${\n            self.stringifiedValues(options.choices[key])}]` : null,\n          defaultString(options.default[key], options.defaultDescription[key])\n        ].filter(Boolean).join(' ')\n\n        ui.span(\n          { text: kswitch, padding: [0, 2, 0, 2], width: maxWidth(switches, theWrap) + 4 },\n          desc\n        )\n\n        if (extra) ui.div({ text: extra, padding: [0, 0, 0, 2], align: 'right' })\n        else ui.div()\n      })\n\n      ui.div()\n    })\n\n    // describe some common use-cases for your application.\n    if (examples.length) {\n      ui.div(__('Examples:'))\n\n      examples.forEach((example) => {\n        example[0] = example[0].replace(/\\$0/g, base$0)\n      })\n\n      examples.forEach((example) => {\n        if (example[1] === '') {\n          ui.div(\n            {\n              text: example[0],\n              padding: [0, 2, 0, 2]\n            }\n          )\n        } else {\n          ui.div(\n            {\n              text: example[0],\n              padding: [0, 2, 0, 2],\n              width: maxWidth(examples, theWrap) + 4\n            }, {\n              text: example[1]\n            }\n          )\n        }\n      })\n\n      ui.div()\n    }\n\n    // the usage string.\n    if (epilog) {\n      const e = epilog.replace(/\\$0/g, base$0)\n      ui.div(`${e}\\n`)\n    }\n\n    // Remove the trailing white spaces\n    return ui.toString().replace(/\\s*$/, '')\n  }\n\n  // return the maximum width of a string\n  // in the left-hand column of a table.\n  function maxWidth (table, theWrap, modifier) {\n    let width = 0\n\n    // table might be of the form [leftColumn],\n    // or {key: leftColumn}\n    if (!Array.isArray(table)) {\n      table = Object.keys(table).map(key => [table[key]])\n    }\n\n    table.forEach((v) => {\n      width = Math.max(\n        stringWidth(modifier ? `${modifier} ${v[0]}` : v[0]),\n        width\n      )\n    })\n\n    // if we've enabled 'wrap' we should limit\n    // the max-width of the left-column.\n    if (theWrap) width = Math.min(width, parseInt(theWrap * 0.5, 10))\n\n    return width\n  }\n\n  // make sure any options set for aliases,\n  // are copied to the keys being aliased.\n  function normalizeAliases () {\n    // handle old demanded API\n    const demandedOptions = yargs.getDemandedOptions()\n    const options = yargs.getOptions()\n\n    ;(Object.keys(options.alias) || []).forEach((key) => {\n      options.alias[key].forEach((alias) => {\n        // copy descriptions.\n        if (descriptions[alias]) self.describe(key, descriptions[alias])\n        // copy demanded.\n        if (alias in demandedOptions) yargs.demandOption(key, demandedOptions[alias])\n        // type messages.\n        if (~options.boolean.indexOf(alias)) yargs.boolean(key)\n        if (~options.count.indexOf(alias)) yargs.count(key)\n        if (~options.string.indexOf(alias)) yargs.string(key)\n        if (~options.normalize.indexOf(alias)) yargs.normalize(key)\n        if (~options.array.indexOf(alias)) yargs.array(key)\n        if (~options.number.indexOf(alias)) yargs.number(key)\n      })\n    })\n  }\n\n  // given a set of keys, place any keys that are\n  // ungrouped under the 'Options:' grouping.\n  function addUngroupedKeys (keys, aliases, groups) {\n    let groupedKeys = []\n    let toCheck = null\n    Object.keys(groups).forEach((group) => {\n      groupedKeys = groupedKeys.concat(groups[group])\n    })\n\n    keys.forEach((key) => {\n      toCheck = [key].concat(aliases[key])\n      if (!toCheck.some(k => groupedKeys.indexOf(k) !== -1)) {\n        groups[defaultGroup].push(key)\n      }\n    })\n    return groupedKeys\n  }\n\n  function filterHiddenOptions (key) {\n    return yargs.getOptions().hiddenOptions.indexOf(key) < 0 || yargs.parsed.argv[yargs.getOptions().showHiddenOpt]\n  }\n\n  self.showHelp = (level) => {\n    const logger = yargs._getLoggerInstance()\n    if (!level) level = 'error'\n    const emit = typeof level === 'function' ? level : logger[level]\n    emit(self.help())\n  }\n\n  self.functionDescription = (fn) => {\n    const description = fn.name ? decamelize(fn.name, '-') : __('generated-value')\n    return ['(', description, ')'].join('')\n  }\n\n  self.stringifiedValues = function stringifiedValues (values, separator) {\n    let string = ''\n    const sep = separator || ', '\n    const array = [].concat(values)\n\n    if (!values || !array.length) return string\n\n    array.forEach((value) => {\n      if (string.length) string += sep\n      string += JSON.stringify(value)\n    })\n\n    return string\n  }\n\n  // format the default-value-string displayed in\n  // the right-hand column.\n  function defaultString (value, defaultDescription) {\n    let string = `[${__('default:')} `\n\n    if (value === undefined && !defaultDescription) return null\n\n    if (defaultDescription) {\n      string += defaultDescription\n    } else {\n      switch (typeof value) {\n        case 'string':\n          string += `\"${value}\"`\n          break\n        case 'object':\n          string += JSON.stringify(value)\n          break\n        default:\n          string += value\n      }\n    }\n\n    return `${string}]`\n  }\n\n  // guess the width of the console window, max-width 80.\n  function windowWidth () {\n    const maxWidth = 80\n    if (typeof process === 'object' && process.stdout && process.stdout.columns) {\n      return Math.min(maxWidth, process.stdout.columns)\n    } else {\n      return maxWidth\n    }\n  }\n\n  // logic for displaying application version.\n  let version = null\n  self.version = (ver) => {\n    version = ver\n  }\n\n  self.showVersion = () => {\n    const logger = yargs._getLoggerInstance()\n    logger.log(version)\n  }\n\n  self.reset = function reset (localLookup) {\n    // do not reset wrap here\n    // do not reset fails here\n    failMessage = null\n    failureOutput = false\n    usages = []\n    usageDisabled = false\n    epilog = undefined\n    examples = []\n    commands = []\n    descriptions = objFilter(descriptions, (k, v) => !localLookup[k])\n    return self\n  }\n\n  let frozen\n  self.freeze = function freeze () {\n    frozen = {}\n    frozen.failMessage = failMessage\n    frozen.failureOutput = failureOutput\n    frozen.usages = usages\n    frozen.usageDisabled = usageDisabled\n    frozen.epilog = epilog\n    frozen.examples = examples\n    frozen.commands = commands\n    frozen.descriptions = descriptions\n  }\n  self.unfreeze = function unfreeze () {\n    failMessage = frozen.failMessage\n    failureOutput = frozen.failureOutput\n    usages = frozen.usages\n    usageDisabled = frozen.usageDisabled\n    epilog = frozen.epilog\n    examples = frozen.examples\n    commands = frozen.commands\n    descriptions = frozen.descriptions\n    frozen = undefined\n  }\n\n  return self\n}\n","'use strict'\nconst argsert = require('./argsert')\nconst objFilter = require('./obj-filter')\nconst specialKeys = ['$0', '--', '_']\n\n// validation-type-stuff, missing params,\n// bad implications, custom checks.\nmodule.exports = function validation (yargs, usage, y18n) {\n  const __ = y18n.__\n  const __n = y18n.__n\n  const self = {}\n\n  // validate appropriate # of non-option\n  // arguments were provided, i.e., '_'.\n  self.nonOptionCount = function nonOptionCount (argv) {\n    const demandedCommands = yargs.getDemandedCommands()\n    // don't count currently executing commands\n    const _s = argv._.length - yargs.getContext().commands.length\n\n    if (demandedCommands._ && (_s < demandedCommands._.min || _s > demandedCommands._.max)) {\n      if (_s < demandedCommands._.min) {\n        if (demandedCommands._.minMsg !== undefined) {\n          usage.fail(\n            // replace $0 with observed, $1 with expected.\n            demandedCommands._.minMsg ? demandedCommands._.minMsg.replace(/\\$0/g, _s).replace(/\\$1/, demandedCommands._.min) : null\n          )\n        } else {\n          usage.fail(\n            __('Not enough non-option arguments: got %s, need at least %s', _s, demandedCommands._.min)\n          )\n        }\n      } else if (_s > demandedCommands._.max) {\n        if (demandedCommands._.maxMsg !== undefined) {\n          usage.fail(\n            // replace $0 with observed, $1 with expected.\n            demandedCommands._.maxMsg ? demandedCommands._.maxMsg.replace(/\\$0/g, _s).replace(/\\$1/, demandedCommands._.max) : null\n          )\n        } else {\n          usage.fail(\n            __('Too many non-option arguments: got %s, maximum of %s', _s, demandedCommands._.max)\n          )\n        }\n      }\n    }\n  }\n\n  // validate the appropriate # of <required>\n  // positional arguments were provided:\n  self.positionalCount = function positionalCount (required, observed) {\n    if (observed < required) {\n      usage.fail(\n        __('Not enough non-option arguments: got %s, need at least %s', observed, required)\n      )\n    }\n  }\n\n  // make sure all the required arguments are present.\n  self.requiredArguments = function requiredArguments (argv) {\n    const demandedOptions = yargs.getDemandedOptions()\n    let missing = null\n\n    Object.keys(demandedOptions).forEach((key) => {\n      if (!argv.hasOwnProperty(key) || typeof argv[key] === 'undefined') {\n        missing = missing || {}\n        missing[key] = demandedOptions[key]\n      }\n    })\n\n    if (missing) {\n      const customMsgs = []\n      Object.keys(missing).forEach((key) => {\n        const msg = missing[key]\n        if (msg && customMsgs.indexOf(msg) < 0) {\n          customMsgs.push(msg)\n        }\n      })\n\n      const customMsg = customMsgs.length ? `\\n${customMsgs.join('\\n')}` : ''\n\n      usage.fail(__n(\n        'Missing required argument: %s',\n        'Missing required arguments: %s',\n        Object.keys(missing).length,\n        Object.keys(missing).join(', ') + customMsg\n      ))\n    }\n  }\n\n  // check for unknown arguments (strict-mode).\n  self.unknownArguments = function unknownArguments (argv, aliases, positionalMap) {\n    const commandKeys = yargs.getCommandInstance().getCommands()\n    const unknown = []\n    const currentContext = yargs.getContext()\n\n    Object.keys(argv).forEach((key) => {\n      if (specialKeys.indexOf(key) === -1 &&\n        !positionalMap.hasOwnProperty(key) &&\n        !yargs._getParseContext().hasOwnProperty(key) &&\n        !aliases.hasOwnProperty(key)\n      ) {\n        unknown.push(key)\n      }\n    })\n\n    if (commandKeys.length > 0) {\n      argv._.slice(currentContext.commands.length).forEach((key) => {\n        if (commandKeys.indexOf(key) === -1) {\n          unknown.push(key)\n        }\n      })\n    }\n\n    if (unknown.length > 0) {\n      usage.fail(__n(\n        'Unknown argument: %s',\n        'Unknown arguments: %s',\n        unknown.length,\n        unknown.join(', ')\n      ))\n    }\n  }\n\n  // validate arguments limited to enumerated choices\n  self.limitedChoices = function limitedChoices (argv) {\n    const options = yargs.getOptions()\n    const invalid = {}\n\n    if (!Object.keys(options.choices).length) return\n\n    Object.keys(argv).forEach((key) => {\n      if (specialKeys.indexOf(key) === -1 &&\n        options.choices.hasOwnProperty(key)) {\n        [].concat(argv[key]).forEach((value) => {\n          // TODO case-insensitive configurability\n          if (options.choices[key].indexOf(value) === -1 &&\n              value !== undefined) {\n            invalid[key] = (invalid[key] || []).concat(value)\n          }\n        })\n      }\n    })\n\n    const invalidKeys = Object.keys(invalid)\n\n    if (!invalidKeys.length) return\n\n    let msg = __('Invalid values:')\n    invalidKeys.forEach((key) => {\n      msg += `\\n  ${__(\n        'Argument: %s, Given: %s, Choices: %s',\n        key,\n        usage.stringifiedValues(invalid[key]),\n        usage.stringifiedValues(options.choices[key])\n      )}`\n    })\n    usage.fail(msg)\n  }\n\n  // custom checks, added using the `check` option on yargs.\n  let checks = []\n  self.check = function check (f, global) {\n    checks.push({\n      func: f,\n      global\n    })\n  }\n\n  self.customChecks = function customChecks (argv, aliases) {\n    for (let i = 0, f; (f = checks[i]) !== undefined; i++) {\n      const func = f.func\n      let result = null\n      try {\n        result = func(argv, aliases)\n      } catch (err) {\n        usage.fail(err.message ? err.message : err, err)\n        continue\n      }\n\n      if (!result) {\n        usage.fail(__('Argument check failed: %s', func.toString()))\n      } else if (typeof result === 'string' || result instanceof Error) {\n        usage.fail(result.toString(), result)\n      }\n    }\n  }\n\n  // check implications, argument foo implies => argument bar.\n  let implied = {}\n  self.implies = function implies (key, value) {\n    argsert('<string|object> [array|number|string]', [key, value], arguments.length)\n\n    if (typeof key === 'object') {\n      Object.keys(key).forEach((k) => {\n        self.implies(k, key[k])\n      })\n    } else {\n      yargs.global(key)\n      if (!implied[key]) {\n        implied[key] = []\n      }\n      if (Array.isArray(value)) {\n        value.forEach((i) => self.implies(key, i))\n      } else {\n        implied[key].push(value)\n      }\n    }\n  }\n  self.getImplied = function getImplied () {\n    return implied\n  }\n\n  self.implications = function implications (argv) {\n    const implyFail = []\n\n    Object.keys(implied).forEach((key) => {\n      const origKey = key\n      ;(implied[key] || []).forEach((value) => {\n        let num\n        let key = origKey\n        const origValue = value\n\n        // convert string '1' to number 1\n        num = Number(key)\n        key = isNaN(num) ? key : num\n\n        if (typeof key === 'number') {\n          // check length of argv._\n          key = argv._.length >= key\n        } else if (key.match(/^--no-.+/)) {\n          // check if key doesn't exist\n          key = key.match(/^--no-(.+)/)[1]\n          key = !argv[key]\n        } else {\n          // check if key exists\n          key = argv[key]\n        }\n\n        num = Number(value)\n        value = isNaN(num) ? value : num\n\n        if (typeof value === 'number') {\n          value = argv._.length >= value\n        } else if (value.match(/^--no-.+/)) {\n          value = value.match(/^--no-(.+)/)[1]\n          value = !argv[value]\n        } else {\n          value = argv[value]\n        }\n        if (key && !value) {\n          implyFail.push(` ${origKey} -> ${origValue}`)\n        }\n      })\n    })\n\n    if (implyFail.length) {\n      let msg = `${__('Implications failed:')}\\n`\n\n      implyFail.forEach((value) => {\n        msg += (value)\n      })\n\n      usage.fail(msg)\n    }\n  }\n\n  let conflicting = {}\n  self.conflicts = function conflicts (key, value) {\n    argsert('<string|object> [array|string]', [key, value], arguments.length)\n\n    if (typeof key === 'object') {\n      Object.keys(key).forEach((k) => {\n        self.conflicts(k, key[k])\n      })\n    } else {\n      yargs.global(key)\n      if (!conflicting[key]) {\n        conflicting[key] = []\n      }\n      if (Array.isArray(value)) {\n        value.forEach((i) => self.conflicts(key, i))\n      } else {\n        conflicting[key].push(value)\n      }\n    }\n  }\n  self.getConflicting = () => conflicting\n\n  self.conflicting = function conflictingFn (argv) {\n    Object.keys(argv).forEach((key) => {\n      if (conflicting[key]) {\n        conflicting[key].forEach((value) => {\n          // we default keys to 'undefined' that have been configured, we should not\n          // apply conflicting check unless they are a value other than 'undefined'.\n          if (value && argv[key] !== undefined && argv[value] !== undefined) {\n            usage.fail(__('Arguments %s and %s are mutually exclusive', key, value))\n          }\n        })\n      }\n    })\n  }\n\n  self.recommendCommands = function recommendCommands (cmd, potentialCommands) {\n    const distance = require('./levenshtein')\n    const threshold = 3 // if it takes more than three edits, let's move on.\n    potentialCommands = potentialCommands.sort((a, b) => b.length - a.length)\n\n    let recommended = null\n    let bestDistance = Infinity\n    for (let i = 0, candidate; (candidate = potentialCommands[i]) !== undefined; i++) {\n      const d = distance(cmd, candidate)\n      if (d <= threshold && d < bestDistance) {\n        bestDistance = d\n        recommended = candidate\n      }\n    }\n    if (recommended) usage.fail(__('Did you mean %s?', recommended))\n  }\n\n  self.reset = function reset (localLookup) {\n    implied = objFilter(implied, (k, v) => !localLookup[k])\n    conflicting = objFilter(conflicting, (k, v) => !localLookup[k])\n    checks = checks.filter(c => c.global)\n    return self\n  }\n\n  let frozen\n  self.freeze = function freeze () {\n    frozen = {}\n    frozen.implied = implied\n    frozen.checks = checks\n    frozen.conflicting = conflicting\n  }\n  self.unfreeze = function unfreeze () {\n    implied = frozen.implied\n    checks = frozen.checks\n    conflicting = frozen.conflicting\n    frozen = undefined\n  }\n\n  return self\n}\n","'use strict'\nfunction YError (msg) {\n  this.name = 'YError'\n  this.message = msg || 'yargs error'\n  Error.captureStackTrace(this, YError)\n}\n\nYError.prototype = Object.create(Error.prototype)\nYError.prototype.constructor = YError\n\nmodule.exports = YError\n","'use strict';\nconst colorConvert = require('color-convert');\n\nconst wrapAnsi16 = (fn, offset) => function () {\n\tconst code = fn.apply(colorConvert, arguments);\n\treturn `\\u001B[${code + offset}m`;\n};\n\nconst wrapAnsi256 = (fn, offset) => function () {\n\tconst code = fn.apply(colorConvert, arguments);\n\treturn `\\u001B[${38 + offset};5;${code}m`;\n};\n\nconst wrapAnsi16m = (fn, offset) => function () {\n\tconst rgb = fn.apply(colorConvert, arguments);\n\treturn `\\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;\n};\n\nfunction assembleStyles() {\n\tconst codes = new Map();\n\tconst styles = {\n\t\tmodifier: {\n\t\t\treset: [0, 0],\n\t\t\t// 21 isn't widely supported and 22 does the same thing\n\t\t\tbold: [1, 22],\n\t\t\tdim: [2, 22],\n\t\t\titalic: [3, 23],\n\t\t\tunderline: [4, 24],\n\t\t\tinverse: [7, 27],\n\t\t\thidden: [8, 28],\n\t\t\tstrikethrough: [9, 29]\n\t\t},\n\t\tcolor: {\n\t\t\tblack: [30, 39],\n\t\t\tred: [31, 39],\n\t\t\tgreen: [32, 39],\n\t\t\tyellow: [33, 39],\n\t\t\tblue: [34, 39],\n\t\t\tmagenta: [35, 39],\n\t\t\tcyan: [36, 39],\n\t\t\twhite: [37, 39],\n\t\t\tgray: [90, 39],\n\n\t\t\t// Bright color\n\t\t\tredBright: [91, 39],\n\t\t\tgreenBright: [92, 39],\n\t\t\tyellowBright: [93, 39],\n\t\t\tblueBright: [94, 39],\n\t\t\tmagentaBright: [95, 39],\n\t\t\tcyanBright: [96, 39],\n\t\t\twhiteBright: [97, 39]\n\t\t},\n\t\tbgColor: {\n\t\t\tbgBlack: [40, 49],\n\t\t\tbgRed: [41, 49],\n\t\t\tbgGreen: [42, 49],\n\t\t\tbgYellow: [43, 49],\n\t\t\tbgBlue: [44, 49],\n\t\t\tbgMagenta: [45, 49],\n\t\t\tbgCyan: [46, 49],\n\t\t\tbgWhite: [47, 49],\n\n\t\t\t// Bright color\n\t\t\tbgBlackBright: [100, 49],\n\t\t\tbgRedBright: [101, 49],\n\t\t\tbgGreenBright: [102, 49],\n\t\t\tbgYellowBright: [103, 49],\n\t\t\tbgBlueBright: [104, 49],\n\t\t\tbgMagentaBright: [105, 49],\n\t\t\tbgCyanBright: [106, 49],\n\t\t\tbgWhiteBright: [107, 49]\n\t\t}\n\t};\n\n\t// Fix humans\n\tstyles.color.grey = styles.color.gray;\n\n\tfor (const groupName of Object.keys(styles)) {\n\t\tconst group = styles[groupName];\n\n\t\tfor (const styleName of Object.keys(group)) {\n\t\t\tconst style = group[styleName];\n\n\t\t\tstyles[styleName] = {\n\t\t\t\topen: `\\u001B[${style[0]}m`,\n\t\t\t\tclose: `\\u001B[${style[1]}m`\n\t\t\t};\n\n\t\t\tgroup[styleName] = styles[styleName];\n\n\t\t\tcodes.set(style[0], style[1]);\n\t\t}\n\n\t\tObject.defineProperty(styles, groupName, {\n\t\t\tvalue: group,\n\t\t\tenumerable: false\n\t\t});\n\n\t\tObject.defineProperty(styles, 'codes', {\n\t\t\tvalue: codes,\n\t\t\tenumerable: false\n\t\t});\n\t}\n\n\tconst ansi2ansi = n => n;\n\tconst rgb2rgb = (r, g, b) => [r, g, b];\n\n\tstyles.color.close = '\\u001B[39m';\n\tstyles.bgColor.close = '\\u001B[49m';\n\n\tstyles.color.ansi = {\n\t\tansi: wrapAnsi16(ansi2ansi, 0)\n\t};\n\tstyles.color.ansi256 = {\n\t\tansi256: wrapAnsi256(ansi2ansi, 0)\n\t};\n\tstyles.color.ansi16m = {\n\t\trgb: wrapAnsi16m(rgb2rgb, 0)\n\t};\n\n\tstyles.bgColor.ansi = {\n\t\tansi: wrapAnsi16(ansi2ansi, 10)\n\t};\n\tstyles.bgColor.ansi256 = {\n\t\tansi256: wrapAnsi256(ansi2ansi, 10)\n\t};\n\tstyles.bgColor.ansi16m = {\n\t\trgb: wrapAnsi16m(rgb2rgb, 10)\n\t};\n\n\tfor (let key of Object.keys(colorConvert)) {\n\t\tif (typeof colorConvert[key] !== 'object') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst suite = colorConvert[key];\n\n\t\tif (key === 'ansi16') {\n\t\t\tkey = 'ansi';\n\t\t}\n\n\t\tif ('ansi16' in suite) {\n\t\t\tstyles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);\n\t\t\tstyles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);\n\t\t}\n\n\t\tif ('ansi256' in suite) {\n\t\t\tstyles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);\n\t\t\tstyles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);\n\t\t}\n\n\t\tif ('rgb' in suite) {\n\t\t\tstyles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);\n\t\t\tstyles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);\n\t\t}\n\t}\n\n\treturn styles;\n}\n\n// Make the export immutable\nObject.defineProperty(module, 'exports', {\n\tenumerable: true,\n\tget: assembleStyles\n});\n","var stringWidth = require('string-width')\nvar stripAnsi = require('strip-ansi')\nvar wrap = require('wrap-ansi')\nvar align = {\n  right: alignRight,\n  center: alignCenter\n}\nvar top = 0\nvar right = 1\nvar bottom = 2\nvar left = 3\n\nfunction UI (opts) {\n  this.width = opts.width\n  this.wrap = opts.wrap\n  this.rows = []\n}\n\nUI.prototype.span = function () {\n  var cols = this.div.apply(this, arguments)\n  cols.span = true\n}\n\nUI.prototype.resetOutput = function () {\n  this.rows = []\n}\n\nUI.prototype.div = function () {\n  if (arguments.length === 0) this.div('')\n  if (this.wrap && this._shouldApplyLayoutDSL.apply(this, arguments)) {\n    return this._applyLayoutDSL(arguments[0])\n  }\n\n  var cols = []\n\n  for (var i = 0, arg; (arg = arguments[i]) !== undefined; i++) {\n    if (typeof arg === 'string') cols.push(this._colFromString(arg))\n    else cols.push(arg)\n  }\n\n  this.rows.push(cols)\n  return cols\n}\n\nUI.prototype._shouldApplyLayoutDSL = function () {\n  return arguments.length === 1 && typeof arguments[0] === 'string' &&\n    /[\\t\\n]/.test(arguments[0])\n}\n\nUI.prototype._applyLayoutDSL = function (str) {\n  var _this = this\n  var rows = str.split('\\n')\n  var leftColumnWidth = 0\n\n  // simple heuristic for layout, make sure the\n  // second column lines up along the left-hand.\n  // don't allow the first column to take up more\n  // than 50% of the screen.\n  rows.forEach(function (row) {\n    var columns = row.split('\\t')\n    if (columns.length > 1 && stringWidth(columns[0]) > leftColumnWidth) {\n      leftColumnWidth = Math.min(\n        Math.floor(_this.width * 0.5),\n        stringWidth(columns[0])\n      )\n    }\n  })\n\n  // generate a table:\n  //  replacing ' ' with padding calculations.\n  //  using the algorithmically generated width.\n  rows.forEach(function (row) {\n    var columns = row.split('\\t')\n    _this.div.apply(_this, columns.map(function (r, i) {\n      return {\n        text: r.trim(),\n        padding: _this._measurePadding(r),\n        width: (i === 0 && columns.length > 1) ? leftColumnWidth : undefined\n      }\n    }))\n  })\n\n  return this.rows[this.rows.length - 1]\n}\n\nUI.prototype._colFromString = function (str) {\n  return {\n    text: str,\n    padding: this._measurePadding(str)\n  }\n}\n\nUI.prototype._measurePadding = function (str) {\n  // measure padding without ansi escape codes\n  var noAnsi = stripAnsi(str)\n  return [0, noAnsi.match(/\\s*$/)[0].length, 0, noAnsi.match(/^\\s*/)[0].length]\n}\n\nUI.prototype.toString = function () {\n  var _this = this\n  var lines = []\n\n  _this.rows.forEach(function (row, i) {\n    _this.rowToString(row, lines)\n  })\n\n  // don't display any lines with the\n  // hidden flag set.\n  lines = lines.filter(function (line) {\n    return !line.hidden\n  })\n\n  return lines.map(function (line) {\n    return line.text\n  }).join('\\n')\n}\n\nUI.prototype.rowToString = function (row, lines) {\n  var _this = this\n  var padding\n  var rrows = this._rasterize(row)\n  var str = ''\n  var ts\n  var width\n  var wrapWidth\n\n  rrows.forEach(function (rrow, r) {\n    str = ''\n    rrow.forEach(function (col, c) {\n      ts = '' // temporary string used during alignment/padding.\n      width = row[c].width // the width with padding.\n      wrapWidth = _this._negatePadding(row[c]) // the width without padding.\n\n      ts += col\n\n      for (var i = 0; i < wrapWidth - stringWidth(col); i++) {\n        ts += ' '\n      }\n\n      // align the string within its column.\n      if (row[c].align && row[c].align !== 'left' && _this.wrap) {\n        ts = align[row[c].align](ts, wrapWidth)\n        if (stringWidth(ts) < wrapWidth) ts += new Array(width - stringWidth(ts)).join(' ')\n      }\n\n      // apply border and padding to string.\n      padding = row[c].padding || [0, 0, 0, 0]\n      if (padding[left]) str += new Array(padding[left] + 1).join(' ')\n      str += addBorder(row[c], ts, '| ')\n      str += ts\n      str += addBorder(row[c], ts, ' |')\n      if (padding[right]) str += new Array(padding[right] + 1).join(' ')\n\n      // if prior row is span, try to render the\n      // current row on the prior line.\n      if (r === 0 && lines.length > 0) {\n        str = _this._renderInline(str, lines[lines.length - 1])\n      }\n    })\n\n    // remove trailing whitespace.\n    lines.push({\n      text: str.replace(/ +$/, ''),\n      span: row.span\n    })\n  })\n\n  return lines\n}\n\nfunction addBorder (col, ts, style) {\n  if (col.border) {\n    if (/[.']-+[.']/.test(ts)) return ''\n    else if (ts.trim().length) return style\n    else return '  '\n  }\n  return ''\n}\n\n// if the full 'source' can render in\n// the target line, do so.\nUI.prototype._renderInline = function (source, previousLine) {\n  var leadingWhitespace = source.match(/^ */)[0].length\n  var target = previousLine.text\n  var targetTextWidth = stringWidth(target.trimRight())\n\n  if (!previousLine.span) return source\n\n  // if we're not applying wrapping logic,\n  // just always append to the span.\n  if (!this.wrap) {\n    previousLine.hidden = true\n    return target + source\n  }\n\n  if (leadingWhitespace < targetTextWidth) return source\n\n  previousLine.hidden = true\n\n  return target.trimRight() + new Array(leadingWhitespace - targetTextWidth + 1).join(' ') + source.trimLeft()\n}\n\nUI.prototype._rasterize = function (row) {\n  var _this = this\n  var i\n  var rrow\n  var rrows = []\n  var widths = this._columnWidths(row)\n  var wrapped\n\n  // word wrap all columns, and create\n  // a data-structure that is easy to rasterize.\n  row.forEach(function (col, c) {\n    // leave room for left and right padding.\n    col.width = widths[c]\n    if (_this.wrap) wrapped = wrap(col.text, _this._negatePadding(col), { hard: true }).split('\\n')\n    else wrapped = col.text.split('\\n')\n\n    if (col.border) {\n      wrapped.unshift('.' + new Array(_this._negatePadding(col) + 3).join('-') + '.')\n      wrapped.push(\"'\" + new Array(_this._negatePadding(col) + 3).join('-') + \"'\")\n    }\n\n    // add top and bottom padding.\n    if (col.padding) {\n      for (i = 0; i < (col.padding[top] || 0); i++) wrapped.unshift('')\n      for (i = 0; i < (col.padding[bottom] || 0); i++) wrapped.push('')\n    }\n\n    wrapped.forEach(function (str, r) {\n      if (!rrows[r]) rrows.push([])\n\n      rrow = rrows[r]\n\n      for (var i = 0; i < c; i++) {\n        if (rrow[i] === undefined) rrow.push('')\n      }\n      rrow.push(str)\n    })\n  })\n\n  return rrows\n}\n\nUI.prototype._negatePadding = function (col) {\n  var wrapWidth = col.width\n  if (col.padding) wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0)\n  if (col.border) wrapWidth -= 4\n  return wrapWidth\n}\n\nUI.prototype._columnWidths = function (row) {\n  var _this = this\n  var widths = []\n  var unset = row.length\n  var unsetWidth\n  var remainingWidth = this.width\n\n  // column widths can be set in config.\n  row.forEach(function (col, i) {\n    if (col.width) {\n      unset--\n      widths[i] = col.width\n      remainingWidth -= col.width\n    } else {\n      widths[i] = undefined\n    }\n  })\n\n  // any unset widths should be calculated.\n  if (unset) unsetWidth = Math.floor(remainingWidth / unset)\n  widths.forEach(function (w, i) {\n    if (!_this.wrap) widths[i] = row[i].width || stringWidth(row[i].text)\n    else if (w === undefined) widths[i] = Math.max(unsetWidth, _minWidth(row[i]))\n  })\n\n  return widths\n}\n\n// calculates the minimum width of\n// a column, based on padding preferences.\nfunction _minWidth (col) {\n  var padding = col.padding || []\n  var minWidth = 1 + (padding[left] || 0) + (padding[right] || 0)\n  if (col.border) minWidth += 4\n  return minWidth\n}\n\nfunction getWindowWidth () {\n  if (typeof process === 'object' && process.stdout && process.stdout.columns) return process.stdout.columns\n}\n\nfunction alignRight (str, width) {\n  str = str.trim()\n  var padding = ''\n  var strWidth = stringWidth(str)\n\n  if (strWidth < width) {\n    padding = new Array(width - strWidth + 1).join(' ')\n  }\n\n  return padding + str\n}\n\nfunction alignCenter (str, width) {\n  str = str.trim()\n  var padding = ''\n  var strWidth = stringWidth(str.trim())\n\n  if (strWidth < width) {\n    padding = new Array(parseInt((width - strWidth) / 2, 10) + 1).join(' ')\n  }\n\n  return padding + str\n}\n\nmodule.exports = function (opts) {\n  opts = opts || {}\n\n  return new UI({\n    width: (opts || {}).width || getWindowWidth() || 80,\n    wrap: typeof opts.wrap === 'boolean' ? opts.wrap : true\n  })\n}\n","'use strict';\nconst path = require('path');\nconst locatePath = require('locate-path');\n\nmodule.exports = (filename, opts = {}) => {\n\tconst startDir = path.resolve(opts.cwd || '');\n\tconst {root} = path.parse(startDir);\n\n\tconst filenames = [].concat(filename);\n\n\treturn new Promise(resolve => {\n\t\t(function find(dir) {\n\t\t\tlocatePath(filenames, {cwd: dir}).then(file => {\n\t\t\t\tif (file) {\n\t\t\t\t\tresolve(path.join(dir, file));\n\t\t\t\t} else if (dir === root) {\n\t\t\t\t\tresolve(null);\n\t\t\t\t} else {\n\t\t\t\t\tfind(path.dirname(dir));\n\t\t\t\t}\n\t\t\t});\n\t\t})(startDir);\n\t});\n};\n\nmodule.exports.sync = (filename, opts = {}) => {\n\tlet dir = path.resolve(opts.cwd || '');\n\tconst {root} = path.parse(dir);\n\n\tconst filenames = [].concat(filename);\n\n\t// eslint-disable-next-line no-constant-condition\n\twhile (true) {\n\t\tconst file = locatePath.sync(filenames, {cwd: dir});\n\n\t\tif (file) {\n\t\t\treturn path.join(dir, file);\n\t\t}\n\n\t\tif (dir === root) {\n\t\t\treturn null;\n\t\t}\n\n\t\tdir = path.dirname(dir);\n\t}\n};\n","\"use strict\";\n// Call this function in a another function to find out the file from\n// which that function was called from. (Inspects the v8 stack trace)\n//\n// Inspired by http://stackoverflow.com/questions/13227489\nmodule.exports = function getCallerFile(position) {\n    if (position === void 0) { position = 2; }\n    if (position >= Error.stackTraceLimit) {\n        throw new TypeError('getCallerFile(position) requires position be less then Error.stackTraceLimit but position was: `' + position + '` and Error.stackTraceLimit was: `' + Error.stackTraceLimit + '`');\n    }\n    var oldPrepareStackTrace = Error.prepareStackTrace;\n    Error.prepareStackTrace = function (_, stack) { return stack; };\n    var stack = new Error().stack;\n    Error.prepareStackTrace = oldPrepareStackTrace;\n    if (stack !== null && typeof stack === 'object') {\n        // stack[0] holds this file\n        // stack[1] holds where this function was called\n        // stack[2] holds the file we're interested in\n        return stack[position] ? stack[position].getFileName() : undefined;\n    }\n};\n//# sourceMappingURL=index.js.map","'use strict';\nconst path = require('path');\nconst pathExists = require('path-exists');\nconst pLocate = require('p-locate');\n\nmodule.exports = (iterable, options) => {\n\toptions = Object.assign({\n\t\tcwd: process.cwd()\n\t}, options);\n\n\treturn pLocate(iterable, el => pathExists(path.resolve(options.cwd, el)), options);\n};\n\nmodule.exports.sync = (iterable, options) => {\n\toptions = Object.assign({\n\t\tcwd: process.cwd()\n\t}, options);\n\n\tfor (const el of iterable) {\n\t\tif (pathExists.sync(path.resolve(options.cwd, el))) {\n\t\t\treturn el;\n\t\t}\n\t}\n};\n","'use strict';\nconst pLimit = require('p-limit');\n\nclass EndError extends Error {\n\tconstructor(value) {\n\t\tsuper();\n\t\tthis.value = value;\n\t}\n}\n\n// The input can also be a promise, so we `Promise.resolve()` it\nconst testElement = (el, tester) => Promise.resolve(el).then(tester);\n\n// The input can also be a promise, so we `Promise.all()` them both\nconst finder = el => Promise.all(el).then(val => val[1] === true && Promise.reject(new EndError(val[0])));\n\nmodule.exports = (iterable, tester, opts) => {\n\topts = Object.assign({\n\t\tconcurrency: Infinity,\n\t\tpreserveOrder: true\n\t}, opts);\n\n\tconst limit = pLimit(opts.concurrency);\n\n\t// Start all the promises concurrently with optional limit\n\tconst items = [...iterable].map(el => [el, limit(testElement, el, tester)]);\n\n\t// Check the promises either serially or concurrently\n\tconst checkLimit = pLimit(opts.preserveOrder ? 1 : Infinity);\n\n\treturn Promise.all(items.map(el => checkLimit(finder, el)))\n\t\t.then(() => {})\n\t\t.catch(err => err instanceof EndError ? err.value : Promise.reject(err));\n};\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = \"../../node_modules/yargs/node_modules/require-main-filename sync recursive\";","module.exports = function (_require) {\n  _require = _require || require\n  var main = _require.main\n  if (main && isIISNode(main)) return handleIISNode(main)\n  else return main ? main.filename : process.cwd()\n}\n\nfunction isIISNode (main) {\n  return /\\\\iisnode\\\\/.test(main.filename)\n}\n\nfunction handleIISNode (main) {\n  if (!main.children.length) {\n    return main.filename\n  } else {\n    return main.children[0].filename\n  }\n}\n","'use strict';\nconst stripAnsi = require('strip-ansi');\nconst isFullwidthCodePoint = require('is-fullwidth-code-point');\nconst emojiRegex = require('emoji-regex')();\n\nmodule.exports = input => {\n\tinput = input.replace(emojiRegex, '  ');\n\n\tif (typeof input !== 'string' || input.length === 0) {\n\t\treturn 0;\n\t}\n\n\tinput = stripAnsi(input);\n\n\tlet width = 0;\n\n\tfor (let i = 0; i < input.length; i++) {\n\t\tconst code = input.codePointAt(i);\n\n\t\t// Ignore control characters\n\t\tif (code <= 0x1F || (code >= 0x7F && code <= 0x9F)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Ignore combining characters\n\t\tif (code >= 0x300 && code <= 0x36F) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Surrogates\n\t\tif (code > 0xFFFF) {\n\t\t\ti++;\n\t\t}\n\n\t\twidth += isFullwidthCodePoint(code) ? 2 : 1;\n\t}\n\n\treturn width;\n};\n","'use strict';\nconst ansiRegex = require('ansi-regex');\n\nconst stripAnsi = string => typeof string === 'string' ? string.replace(ansiRegex(), '') : string;\n\nmodule.exports = stripAnsi;\nmodule.exports.default = stripAnsi;\n","'use strict';\nconst stringWidth = require('string-width');\nconst stripAnsi = require('strip-ansi');\nconst ansiStyles = require('ansi-styles');\n\nconst ESCAPES = new Set([\n\t'\\u001B',\n\t'\\u009B'\n]);\n\nconst END_CODE = 39;\n\nconst wrapAnsi = code => `${ESCAPES.values().next().value}[${code}m`;\n\n// Calculate the length of words split on ' ', ignoring\n// the extra characters added by ansi escape codes\nconst wordLengths = string => string.split(' ').map(character => stringWidth(character));\n\n// Wrap a long word across multiple rows\n// Ansi escape codes do not count towards length\nconst wrapWord = (rows, word, columns) => {\n\tconst characters = [...word];\n\n\tlet insideEscape = false;\n\tlet visible = stringWidth(stripAnsi(rows[rows.length - 1]));\n\n\tfor (const [index, character] of characters.entries()) {\n\t\tconst characterLength = stringWidth(character);\n\n\t\tif (visible + characterLength <= columns) {\n\t\t\trows[rows.length - 1] += character;\n\t\t} else {\n\t\t\trows.push(character);\n\t\t\tvisible = 0;\n\t\t}\n\n\t\tif (ESCAPES.has(character)) {\n\t\t\tinsideEscape = true;\n\t\t} else if (insideEscape && character === 'm') {\n\t\t\tinsideEscape = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insideEscape) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tvisible += characterLength;\n\n\t\tif (visible === columns && index < characters.length - 1) {\n\t\t\trows.push('');\n\t\t\tvisible = 0;\n\t\t}\n\t}\n\n\t// It's possible that the last row we copy over is only\n\t// ansi escape characters, handle this edge-case\n\tif (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {\n\t\trows[rows.length - 2] += rows.pop();\n\t}\n};\n\n// Trims spaces from a string ignoring invisible sequences\nconst stringVisibleTrimSpacesRight = str => {\n\tconst words = str.split(' ');\n\tlet last = words.length;\n\n\twhile (last > 0) {\n\t\tif (stringWidth(words[last - 1]) > 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tlast--;\n\t}\n\n\tif (last === words.length) {\n\t\treturn str;\n\t}\n\n\treturn words.slice(0, last).join(' ') + words.slice(last).join('');\n};\n\n// The wrap-ansi module can be invoked\n// in either 'hard' or 'soft' wrap mode\n//\n// 'hard' will never allow a string to take up more\n// than columns characters\n//\n// 'soft' allows long words to expand past the column length\nconst exec = (string, columns, options = {}) => {\n\tif (options.trim !== false && string.trim() === '') {\n\t\treturn '';\n\t}\n\n\tlet pre = '';\n\tlet ret = '';\n\tlet escapeCode;\n\n\tconst lengths = wordLengths(string);\n\tlet rows = [''];\n\n\tfor (const [index, word] of string.split(' ').entries()) {\n\t\tif (options.trim !== false) {\n\t\t\trows[rows.length - 1] = rows[rows.length - 1].trimLeft();\n\t\t}\n\n\t\tlet rowLength = stringWidth(rows[rows.length - 1]);\n\n\t\tif (index !== 0) {\n\t\t\tif (rowLength >= columns && (options.wordWrap === false || options.trim === false)) {\n\t\t\t\t// If we start with a new word but the current row length equals the length of the columns, add a new row\n\t\t\t\trows.push('');\n\t\t\t\trowLength = 0;\n\t\t\t}\n\n\t\t\tif (rowLength > 0 || options.trim === false) {\n\t\t\t\trows[rows.length - 1] += ' ';\n\t\t\t\trowLength++;\n\t\t\t}\n\t\t}\n\n\t\t// In 'hard' wrap mode, the length of a line is\n\t\t// never allowed to extend past 'columns'\n\t\tif (options.hard && lengths[index] > columns) {\n\t\t\tconst remainingColumns = (columns - rowLength);\n\t\t\tconst breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);\n\t\t\tconst breaksStartingNextLine = Math.floor((lengths[index] - 1) / columns);\n\t\t\tif (breaksStartingNextLine < breaksStartingThisLine) {\n\t\t\t\trows.push('');\n\t\t\t}\n\n\t\t\twrapWord(rows, word, columns);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) {\n\t\t\tif (options.wordWrap === false && rowLength < columns) {\n\t\t\t\twrapWord(rows, word, columns);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\trows.push('');\n\t\t}\n\n\t\tif (rowLength + lengths[index] > columns && options.wordWrap === false) {\n\t\t\twrapWord(rows, word, columns);\n\t\t\tcontinue;\n\t\t}\n\n\t\trows[rows.length - 1] += word;\n\t}\n\n\tif (options.trim !== false) {\n\t\trows = rows.map(stringVisibleTrimSpacesRight);\n\t}\n\n\tpre = rows.join('\\n');\n\n\tfor (const [index, character] of [...pre].entries()) {\n\t\tret += character;\n\n\t\tif (ESCAPES.has(character)) {\n\t\t\tconst code = parseFloat(/\\d[^m]*/.exec(pre.slice(index, index + 4)));\n\t\t\tescapeCode = code === END_CODE ? null : code;\n\t\t}\n\n\t\tconst code = ansiStyles.codes.get(Number(escapeCode));\n\n\t\tif (escapeCode && code) {\n\t\t\tif (pre[index + 1] === '\\n') {\n\t\t\t\tret += wrapAnsi(code);\n\t\t\t} else if (character === '\\n') {\n\t\t\t\tret += wrapAnsi(escapeCode);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n};\n\n// For each newline, invoke the method separately\nmodule.exports = (string, columns, options) => {\n\treturn String(string)\n\t\t.normalize()\n\t\t.split('\\n')\n\t\t.map(line => exec(line, columns, options))\n\t\t.join('\\n');\n};\n","'use strict'\nconst argsert = require('./lib/argsert')\nconst fs = require('fs')\nconst Command = require('./lib/command')\nconst Completion = require('./lib/completion')\nconst Parser = require('yargs-parser')\nconst path = require('path')\nconst Usage = require('./lib/usage')\nconst Validation = require('./lib/validation')\nconst Y18n = require('y18n')\nconst objFilter = require('./lib/obj-filter')\nconst setBlocking = require('set-blocking')\nconst applyExtends = require('./lib/apply-extends')\nconst { globalMiddlewareFactory } = require('./lib/middleware')\nconst YError = require('./lib/yerror')\n\nexports = module.exports = Yargs\nfunction Yargs (processArgs, cwd, parentRequire) {\n  processArgs = processArgs || [] // handle calling yargs().\n\n  const self = {}\n  let command = null\n  let completion = null\n  let groups = {}\n  let globalMiddleware = []\n  let output = ''\n  let preservedGroups = {}\n  let usage = null\n  let validation = null\n\n  const y18n = Y18n({\n    directory: path.resolve(__dirname, './locales'),\n    updateFiles: false\n  })\n\n  self.middleware = globalMiddlewareFactory(globalMiddleware, self)\n\n  if (!cwd) cwd = process.cwd()\n\n  self.scriptName = function scriptName (scriptName) {\n    self.$0 = scriptName\n    return self\n  }\n\n  // ignore the node bin, specify this in your\n  // bin file with #!/usr/bin/env node\n  if (/\\b(node|iojs|electron)(\\.exe)?$/.test(process.argv[0])) {\n    self.$0 = process.argv.slice(1, 2)\n  } else {\n    self.$0 = process.argv.slice(0, 1)\n  }\n\n  self.$0 = self.$0\n    .map((x, i) => {\n      const b = rebase(cwd, x)\n      return x.match(/^(\\/|([a-zA-Z]:)?\\\\)/) && b.length < x.length ? b : x\n    })\n    .join(' ').trim()\n\n  if (process.env._ !== undefined && process.argv[1] === process.env._) {\n    self.$0 = process.env._.replace(\n      `${path.dirname(process.execPath)}/`, ''\n    )\n  }\n\n  // use context object to keep track of resets, subcommand execution, etc\n  // submodules should modify and check the state of context as necessary\n  const context = { resets: -1, commands: [], fullCommands: [], files: [] }\n  self.getContext = () => context\n\n  // puts yargs back into an initial state. any keys\n  // that have been set to \"global\" will not be reset\n  // by this action.\n  let options\n  self.resetOptions = self.reset = function resetOptions (aliases) {\n    context.resets++\n    aliases = aliases || {}\n    options = options || {}\n    // put yargs back into an initial state, this\n    // logic is used to build a nested command\n    // hierarchy.\n    const tmpOptions = {}\n    tmpOptions.local = options.local ? options.local : []\n    tmpOptions.configObjects = options.configObjects ? options.configObjects : []\n\n    // if a key has been explicitly set as local,\n    // we should reset it before passing options to command.\n    const localLookup = {}\n    tmpOptions.local.forEach((l) => {\n      localLookup[l] = true\n      ;(aliases[l] || []).forEach((a) => {\n        localLookup[a] = true\n      })\n    })\n\n    // preserve all groups not set to local.\n    preservedGroups = Object.keys(groups).reduce((acc, groupName) => {\n      const keys = groups[groupName].filter(key => !(key in localLookup))\n      if (keys.length > 0) {\n        acc[groupName] = keys\n      }\n      return acc\n    }, {})\n    // groups can now be reset\n    groups = {}\n\n    const arrayOptions = [\n      'array', 'boolean', 'string', 'skipValidation',\n      'count', 'normalize', 'number',\n      'hiddenOptions'\n    ]\n\n    const objectOptions = [\n      'narg', 'key', 'alias', 'default', 'defaultDescription',\n      'config', 'choices', 'demandedOptions', 'demandedCommands', 'coerce'\n    ]\n\n    arrayOptions.forEach((k) => {\n      tmpOptions[k] = (options[k] || []).filter(k => !localLookup[k])\n    })\n\n    objectOptions.forEach((k) => {\n      tmpOptions[k] = objFilter(options[k], (k, v) => !localLookup[k])\n    })\n\n    tmpOptions.envPrefix = options.envPrefix\n    options = tmpOptions\n\n    // if this is the first time being executed, create\n    // instances of all our helpers -- otherwise just reset.\n    usage = usage ? usage.reset(localLookup) : Usage(self, y18n)\n    validation = validation ? validation.reset(localLookup) : Validation(self, usage, y18n)\n    command = command ? command.reset() : Command(self, usage, validation, globalMiddleware)\n    if (!completion) completion = Completion(self, usage, command)\n\n    completionCommand = null\n    output = ''\n    exitError = null\n    hasOutput = false\n    self.parsed = false\n\n    return self\n  }\n  self.resetOptions()\n\n  // temporary hack: allow \"freezing\" of reset-able state for parse(msg, cb)\n  let frozen\n  function freeze () {\n    frozen = {}\n    frozen.options = options\n    frozen.configObjects = options.configObjects.slice(0)\n    frozen.exitProcess = exitProcess\n    frozen.groups = groups\n    usage.freeze()\n    validation.freeze()\n    command.freeze()\n    frozen.strict = strict\n    frozen.completionCommand = completionCommand\n    frozen.output = output\n    frozen.exitError = exitError\n    frozen.hasOutput = hasOutput\n    frozen.parsed = self.parsed\n  }\n  function unfreeze () {\n    options = frozen.options\n    options.configObjects = frozen.configObjects\n    exitProcess = frozen.exitProcess\n    groups = frozen.groups\n    output = frozen.output\n    exitError = frozen.exitError\n    hasOutput = frozen.hasOutput\n    self.parsed = frozen.parsed\n    usage.unfreeze()\n    validation.unfreeze()\n    command.unfreeze()\n    strict = frozen.strict\n    completionCommand = frozen.completionCommand\n    parseFn = null\n    parseContext = null\n    frozen = undefined\n  }\n\n  self.boolean = function (keys) {\n    argsert('<array|string>', [keys], arguments.length)\n    populateParserHintArray('boolean', keys)\n    return self\n  }\n\n  self.array = function (keys) {\n    argsert('<array|string>', [keys], arguments.length)\n    populateParserHintArray('array', keys)\n    return self\n  }\n\n  self.number = function (keys) {\n    argsert('<array|string>', [keys], arguments.length)\n    populateParserHintArray('number', keys)\n    return self\n  }\n\n  self.normalize = function (keys) {\n    argsert('<array|string>', [keys], arguments.length)\n    populateParserHintArray('normalize', keys)\n    return self\n  }\n\n  self.count = function (keys) {\n    argsert('<array|string>', [keys], arguments.length)\n    populateParserHintArray('count', keys)\n    return self\n  }\n\n  self.string = function (keys) {\n    argsert('<array|string>', [keys], arguments.length)\n    populateParserHintArray('string', keys)\n    return self\n  }\n\n  self.requiresArg = function (keys) {\n    argsert('<array|string>', [keys], arguments.length)\n    populateParserHintObject(self.nargs, false, 'narg', keys, 1)\n    return self\n  }\n\n  self.skipValidation = function (keys) {\n    argsert('<array|string>', [keys], arguments.length)\n    populateParserHintArray('skipValidation', keys)\n    return self\n  }\n\n  function populateParserHintArray (type, keys, value) {\n    keys = [].concat(keys)\n    keys.forEach((key) => {\n      key = sanitizeKey(key)\n      options[type].push(key)\n    })\n  }\n\n  self.nargs = function (key, value) {\n    argsert('<string|object|array> [number]', [key, value], arguments.length)\n    populateParserHintObject(self.nargs, false, 'narg', key, value)\n    return self\n  }\n\n  self.choices = function (key, value) {\n    argsert('<object|string|array> [string|array]', [key, value], arguments.length)\n    populateParserHintObject(self.choices, true, 'choices', key, value)\n    return self\n  }\n\n  self.alias = function (key, value) {\n    argsert('<object|string|array> [string|array]', [key, value], arguments.length)\n    populateParserHintObject(self.alias, true, 'alias', key, value)\n    return self\n  }\n\n  // TODO: actually deprecate self.defaults.\n  self.default = self.defaults = function (key, value, defaultDescription) {\n    argsert('<object|string|array> [*] [string]', [key, value, defaultDescription], arguments.length)\n    if (defaultDescription) options.defaultDescription[key] = defaultDescription\n    if (typeof value === 'function') {\n      if (!options.defaultDescription[key]) options.defaultDescription[key] = usage.functionDescription(value)\n      value = value.call()\n    }\n    populateParserHintObject(self.default, false, 'default', key, value)\n    return self\n  }\n\n  self.describe = function (key, desc) {\n    argsert('<object|string|array> [string]', [key, desc], arguments.length)\n    populateParserHintObject(self.describe, false, 'key', key, true)\n    usage.describe(key, desc)\n    return self\n  }\n\n  self.demandOption = function (keys, msg) {\n    argsert('<object|string|array> [string]', [keys, msg], arguments.length)\n    populateParserHintObject(self.demandOption, false, 'demandedOptions', keys, msg)\n    return self\n  }\n\n  self.coerce = function (keys, value) {\n    argsert('<object|string|array> [function]', [keys, value], arguments.length)\n    populateParserHintObject(self.coerce, false, 'coerce', keys, value)\n    return self\n  }\n\n  function populateParserHintObject (builder, isArray, type, key, value) {\n    if (Array.isArray(key)) {\n      const temp = Object.create(null)\n      // an array of keys with one value ['x', 'y', 'z'], function parse () {}\n      key.forEach((k) => {\n        temp[k] = value\n      })\n      builder(temp)\n    } else if (typeof key === 'object') {\n      // an object of key value pairs: {'x': parse () {}, 'y': parse() {}}\n      Object.keys(key).forEach((k) => {\n        builder(k, key[k])\n      })\n    } else {\n      key = sanitizeKey(key)\n      // a single key value pair 'x', parse() {}\n      if (isArray) {\n        options[type][key] = (options[type][key] || []).concat(value)\n      } else {\n        options[type][key] = value\n      }\n    }\n  }\n\n  // TODO(bcoe): in future major versions move more objects towards\n  // Object.create(null):\n  function sanitizeKey (key) {\n    if (key === '__proto__') return '___proto___'\n    return key\n  }\n\n  function deleteFromParserHintObject (optionKey) {\n    // delete from all parsing hints:\n    // boolean, array, key, alias, etc.\n    Object.keys(options).forEach((hintKey) => {\n      const hint = options[hintKey]\n      if (Array.isArray(hint)) {\n        if (~hint.indexOf(optionKey)) hint.splice(hint.indexOf(optionKey), 1)\n      } else if (typeof hint === 'object') {\n        delete hint[optionKey]\n      }\n    })\n    // now delete the description from usage.js.\n    delete usage.getDescriptions()[optionKey]\n  }\n\n  self.config = function config (key, msg, parseFn) {\n    argsert('[object|string] [string|function] [function]', [key, msg, parseFn], arguments.length)\n    // allow a config object to be provided directly.\n    if (typeof key === 'object') {\n      key = applyExtends(key, cwd)\n      options.configObjects = (options.configObjects || []).concat(key)\n      return self\n    }\n\n    // allow for a custom parsing function.\n    if (typeof msg === 'function') {\n      parseFn = msg\n      msg = null\n    }\n\n    key = key || 'config'\n    self.describe(key, msg || usage.deferY18nLookup('Path to JSON config file'))\n    ;(Array.isArray(key) ? key : [key]).forEach((k) => {\n      options.config[k] = parseFn || true\n    })\n\n    return self\n  }\n\n  self.example = function (cmd, description) {\n    argsert('<string> [string]', [cmd, description], arguments.length)\n    usage.example(cmd, description)\n    return self\n  }\n\n  self.command = function (cmd, description, builder, handler, middlewares) {\n    argsert('<string|array|object> [string|boolean] [function|object] [function] [array]', [cmd, description, builder, handler, middlewares], arguments.length)\n    command.addHandler(cmd, description, builder, handler, middlewares)\n    return self\n  }\n\n  self.commandDir = function (dir, opts) {\n    argsert('<string> [object]', [dir, opts], arguments.length)\n    const req = parentRequire || require\n    command.addDirectory(dir, self.getContext(), req, require('get-caller-file')(), opts)\n    return self\n  }\n\n  // TODO: deprecate self.demand in favor of\n  // .demandCommand() .demandOption().\n  self.demand = self.required = self.require = function demand (keys, max, msg) {\n    // you can optionally provide a 'max' key,\n    // which will raise an exception if too many '_'\n    // options are provided.\n    if (Array.isArray(max)) {\n      max.forEach((key) => {\n        self.demandOption(key, msg)\n      })\n      max = Infinity\n    } else if (typeof max !== 'number') {\n      msg = max\n      max = Infinity\n    }\n\n    if (typeof keys === 'number') {\n      self.demandCommand(keys, max, msg, msg)\n    } else if (Array.isArray(keys)) {\n      keys.forEach((key) => {\n        self.demandOption(key, msg)\n      })\n    } else {\n      if (typeof msg === 'string') {\n        self.demandOption(keys, msg)\n      } else if (msg === true || typeof msg === 'undefined') {\n        self.demandOption(keys)\n      }\n    }\n\n    return self\n  }\n\n  self.demandCommand = function demandCommand (min, max, minMsg, maxMsg) {\n    argsert('[number] [number|string] [string|null|undefined] [string|null|undefined]', [min, max, minMsg, maxMsg], arguments.length)\n\n    if (typeof min === 'undefined') min = 1\n\n    if (typeof max !== 'number') {\n      minMsg = max\n      max = Infinity\n    }\n\n    self.global('_', false)\n\n    options.demandedCommands._ = {\n      min,\n      max,\n      minMsg,\n      maxMsg\n    }\n\n    return self\n  }\n\n  self.getDemandedOptions = () => {\n    argsert([], 0)\n    return options.demandedOptions\n  }\n\n  self.getDemandedCommands = () => {\n    argsert([], 0)\n    return options.demandedCommands\n  }\n\n  self.implies = function (key, value) {\n    argsert('<string|object> [number|string|array]', [key, value], arguments.length)\n    validation.implies(key, value)\n    return self\n  }\n\n  self.conflicts = function (key1, key2) {\n    argsert('<string|object> [string|array]', [key1, key2], arguments.length)\n    validation.conflicts(key1, key2)\n    return self\n  }\n\n  self.usage = function (msg, description, builder, handler) {\n    argsert('<string|null|undefined> [string|boolean] [function|object] [function]', [msg, description, builder, handler], arguments.length)\n\n    if (description !== undefined) {\n      // .usage() can be used as an alias for defining\n      // a default command.\n      if ((msg || '').match(/^\\$0( |$)/)) {\n        return self.command(msg, description, builder, handler)\n      } else {\n        throw new YError('.usage() description must start with $0 if being used as alias for .command()')\n      }\n    } else {\n      usage.usage(msg)\n      return self\n    }\n  }\n\n  self.epilogue = self.epilog = function (msg) {\n    argsert('<string>', [msg], arguments.length)\n    usage.epilog(msg)\n    return self\n  }\n\n  self.fail = function (f) {\n    argsert('<function>', [f], arguments.length)\n    usage.failFn(f)\n    return self\n  }\n\n  self.check = function (f, _global) {\n    argsert('<function> [boolean]', [f, _global], arguments.length)\n    validation.check(f, _global !== false)\n    return self\n  }\n\n  self.global = function global (globals, global) {\n    argsert('<string|array> [boolean]', [globals, global], arguments.length)\n    globals = [].concat(globals)\n    if (global !== false) {\n      options.local = options.local.filter(l => globals.indexOf(l) === -1)\n    } else {\n      globals.forEach((g) => {\n        if (options.local.indexOf(g) === -1) options.local.push(g)\n      })\n    }\n    return self\n  }\n\n  self.pkgConf = function pkgConf (key, rootPath) {\n    argsert('<string> [string]', [key, rootPath], arguments.length)\n    let conf = null\n    // prefer cwd to require-main-filename in this method\n    // since we're looking for e.g. \"nyc\" config in nyc consumer\n    // rather than \"yargs\" config in nyc (where nyc is the main filename)\n    const obj = pkgUp(rootPath || cwd)\n\n    // If an object exists in the key, add it to options.configObjects\n    if (obj[key] && typeof obj[key] === 'object') {\n      conf = applyExtends(obj[key], rootPath || cwd)\n      options.configObjects = (options.configObjects || []).concat(conf)\n    }\n\n    return self\n  }\n\n  const pkgs = {}\n  function pkgUp (rootPath) {\n    const npath = rootPath || '*'\n    if (pkgs[npath]) return pkgs[npath]\n    const findUp = require('find-up')\n\n    let obj = {}\n    try {\n      let startDir = rootPath || require('require-main-filename')(parentRequire || require)\n\n      // When called in an environment that lacks require.main.filename, such as a jest test runner,\n      // startDir is already process.cwd(), and should not be shortened.\n      // Whether or not it is _actually_ a directory (e.g., extensionless bin) is irrelevant, find-up handles it.\n      if (!rootPath && path.extname(startDir)) {\n        startDir = path.dirname(startDir)\n      }\n\n      const pkgJsonPath = findUp.sync('package.json', {\n        cwd: startDir\n      })\n      obj = JSON.parse(fs.readFileSync(pkgJsonPath))\n    } catch (noop) {}\n\n    pkgs[npath] = obj || {}\n    return pkgs[npath]\n  }\n\n  let parseFn = null\n  let parseContext = null\n  self.parse = function parse (args, shortCircuit, _parseFn) {\n    argsert('[string|array] [function|boolean|object] [function]', [args, shortCircuit, _parseFn], arguments.length)\n    if (typeof args === 'undefined') {\n      return self._parseArgs(processArgs)\n    }\n\n    // a context object can optionally be provided, this allows\n    // additional information to be passed to a command handler.\n    if (typeof shortCircuit === 'object') {\n      parseContext = shortCircuit\n      shortCircuit = _parseFn\n    }\n\n    // by providing a function as a second argument to\n    // parse you can capture output that would otherwise\n    // default to printing to stdout/stderr.\n    if (typeof shortCircuit === 'function') {\n      parseFn = shortCircuit\n      shortCircuit = null\n    }\n    // completion short-circuits the parsing process,\n    // skipping validation, etc.\n    if (!shortCircuit) processArgs = args\n\n    freeze()\n    if (parseFn) exitProcess = false\n\n    const parsed = self._parseArgs(args, shortCircuit)\n    if (parseFn) parseFn(exitError, parsed, output)\n    unfreeze()\n\n    return parsed\n  }\n\n  self._getParseContext = () => parseContext || {}\n\n  self._hasParseCallback = () => !!parseFn\n\n  self.option = self.options = function option (key, opt) {\n    argsert('<string|object> [object]', [key, opt], arguments.length)\n    if (typeof key === 'object') {\n      Object.keys(key).forEach((k) => {\n        self.options(k, key[k])\n      })\n    } else {\n      if (typeof opt !== 'object') {\n        opt = {}\n      }\n\n      options.key[key] = true // track manually set keys.\n\n      if (opt.alias) self.alias(key, opt.alias)\n\n      const demand = opt.demand || opt.required || opt.require\n\n      // deprecated, use 'demandOption' instead\n      if (demand) {\n        self.demand(key, demand)\n      }\n\n      if (opt.demandOption) {\n        self.demandOption(key, typeof opt.demandOption === 'string' ? opt.demandOption : undefined)\n      }\n\n      if ('conflicts' in opt) {\n        self.conflicts(key, opt.conflicts)\n      }\n\n      if ('default' in opt) {\n        self.default(key, opt.default)\n      }\n\n      if ('implies' in opt) {\n        self.implies(key, opt.implies)\n      }\n\n      if ('nargs' in opt) {\n        self.nargs(key, opt.nargs)\n      }\n\n      if (opt.config) {\n        self.config(key, opt.configParser)\n      }\n\n      if (opt.normalize) {\n        self.normalize(key)\n      }\n\n      if ('choices' in opt) {\n        self.choices(key, opt.choices)\n      }\n\n      if ('coerce' in opt) {\n        self.coerce(key, opt.coerce)\n      }\n\n      if ('group' in opt) {\n        self.group(key, opt.group)\n      }\n\n      if (opt.boolean || opt.type === 'boolean') {\n        self.boolean(key)\n        if (opt.alias) self.boolean(opt.alias)\n      }\n\n      if (opt.array || opt.type === 'array') {\n        self.array(key)\n        if (opt.alias) self.array(opt.alias)\n      }\n\n      if (opt.number || opt.type === 'number') {\n        self.number(key)\n        if (opt.alias) self.number(opt.alias)\n      }\n\n      if (opt.string || opt.type === 'string') {\n        self.string(key)\n        if (opt.alias) self.string(opt.alias)\n      }\n\n      if (opt.count || opt.type === 'count') {\n        self.count(key)\n      }\n\n      if (typeof opt.global === 'boolean') {\n        self.global(key, opt.global)\n      }\n\n      if (opt.defaultDescription) {\n        options.defaultDescription[key] = opt.defaultDescription\n      }\n\n      if (opt.skipValidation) {\n        self.skipValidation(key)\n      }\n\n      const desc = opt.describe || opt.description || opt.desc\n      self.describe(key, desc)\n      if (opt.hidden) {\n        self.hide(key)\n      }\n\n      if (opt.requiresArg) {\n        self.requiresArg(key)\n      }\n    }\n\n    return self\n  }\n  self.getOptions = () => options\n\n  self.positional = function (key, opts) {\n    argsert('<string> <object>', [key, opts], arguments.length)\n    if (context.resets === 0) {\n      throw new YError(\".positional() can only be called in a command's builder function\")\n    }\n\n    // .positional() only supports a subset of the configuration\n    // options available to .option().\n    const supportedOpts = ['default', 'defaultDescription', 'implies', 'normalize',\n      'choices', 'conflicts', 'coerce', 'type', 'describe',\n      'desc', 'description', 'alias']\n    opts = objFilter(opts, (k, v) => {\n      let accept = supportedOpts.indexOf(k) !== -1\n      // type can be one of string|number|boolean.\n      if (k === 'type' && ['string', 'number', 'boolean'].indexOf(v) === -1) accept = false\n      return accept\n    })\n\n    // copy over any settings that can be inferred from the command string.\n    const fullCommand = context.fullCommands[context.fullCommands.length - 1]\n    const parseOptions = fullCommand ? command.cmdToParseOptions(fullCommand) : {\n      array: [],\n      alias: {},\n      default: {},\n      demand: {}\n    }\n    Object.keys(parseOptions).forEach((pk) => {\n      if (Array.isArray(parseOptions[pk])) {\n        if (parseOptions[pk].indexOf(key) !== -1) opts[pk] = true\n      } else {\n        if (parseOptions[pk][key] && !(pk in opts)) opts[pk] = parseOptions[pk][key]\n      }\n    })\n    self.group(key, usage.getPositionalGroupName())\n    return self.option(key, opts)\n  }\n\n  self.group = function group (opts, groupName) {\n    argsert('<string|array> <string>', [opts, groupName], arguments.length)\n    const existing = preservedGroups[groupName] || groups[groupName]\n    if (preservedGroups[groupName]) {\n      // we now only need to track this group name in groups.\n      delete preservedGroups[groupName]\n    }\n\n    const seen = {}\n    groups[groupName] = (existing || []).concat(opts).filter((key) => {\n      if (seen[key]) return false\n      return (seen[key] = true)\n    })\n    return self\n  }\n  // combine explicit and preserved groups. explicit groups should be first\n  self.getGroups = () => Object.assign({}, groups, preservedGroups)\n\n  // as long as options.envPrefix is not undefined,\n  // parser will apply env vars matching prefix to argv\n  self.env = function (prefix) {\n    argsert('[string|boolean]', [prefix], arguments.length)\n    if (prefix === false) options.envPrefix = undefined\n    else options.envPrefix = prefix || ''\n    return self\n  }\n\n  self.wrap = function (cols) {\n    argsert('<number|null|undefined>', [cols], arguments.length)\n    usage.wrap(cols)\n    return self\n  }\n\n  let strict = false\n  self.strict = function (enabled) {\n    argsert('[boolean]', [enabled], arguments.length)\n    strict = enabled !== false\n    return self\n  }\n  self.getStrict = () => strict\n\n  let parserConfig = {}\n  self.parserConfiguration = function parserConfiguration (config) {\n    argsert('<object>', [config], arguments.length)\n    parserConfig = config\n    return self\n  }\n  self.getParserConfiguration = () => parserConfig\n\n  self.showHelp = function (level) {\n    argsert('[string|function]', [level], arguments.length)\n    if (!self.parsed) self._parseArgs(processArgs) // run parser, if it has not already been executed.\n    if (command.hasDefaultCommand()) {\n      context.resets++ // override the restriction on top-level positoinals.\n      command.runDefaultBuilderOn(self, true)\n    }\n    usage.showHelp(level)\n    return self\n  }\n\n  let versionOpt = null\n  self.version = function version (opt, msg, ver) {\n    const defaultVersionOpt = 'version'\n    argsert('[boolean|string] [string] [string]', [opt, msg, ver], arguments.length)\n\n    // nuke the key previously configured\n    // to return version #.\n    if (versionOpt) {\n      deleteFromParserHintObject(versionOpt)\n      usage.version(undefined)\n      versionOpt = null\n    }\n\n    if (arguments.length === 0) {\n      ver = guessVersion()\n      opt = defaultVersionOpt\n    } else if (arguments.length === 1) {\n      if (opt === false) { // disable default 'version' key.\n        return self\n      }\n      ver = opt\n      opt = defaultVersionOpt\n    } else if (arguments.length === 2) {\n      ver = msg\n      msg = null\n    }\n\n    versionOpt = typeof opt === 'string' ? opt : defaultVersionOpt\n    msg = msg || usage.deferY18nLookup('Show version number')\n\n    usage.version(ver || undefined)\n    self.boolean(versionOpt)\n    self.describe(versionOpt, msg)\n    return self\n  }\n\n  function guessVersion () {\n    const obj = pkgUp()\n\n    return obj.version || 'unknown'\n  }\n\n  let helpOpt = null\n  self.addHelpOpt = self.help = function addHelpOpt (opt, msg) {\n    const defaultHelpOpt = 'help'\n    argsert('[string|boolean] [string]', [opt, msg], arguments.length)\n\n    // nuke the key previously configured\n    // to return help.\n    if (helpOpt) {\n      deleteFromParserHintObject(helpOpt)\n      helpOpt = null\n    }\n\n    if (arguments.length === 1) {\n      if (opt === false) return self\n    }\n\n    // use arguments, fallback to defaults for opt and msg\n    helpOpt = typeof opt === 'string' ? opt : defaultHelpOpt\n    self.boolean(helpOpt)\n    self.describe(helpOpt, msg || usage.deferY18nLookup('Show help'))\n    return self\n  }\n\n  const defaultShowHiddenOpt = 'show-hidden'\n  options.showHiddenOpt = defaultShowHiddenOpt\n  self.addShowHiddenOpt = self.showHidden = function addShowHiddenOpt (opt, msg) {\n    argsert('[string|boolean] [string]', [opt, msg], arguments.length)\n\n    if (arguments.length === 1) {\n      if (opt === false) return self\n    }\n\n    const showHiddenOpt = typeof opt === 'string' ? opt : defaultShowHiddenOpt\n    self.boolean(showHiddenOpt)\n    self.describe(showHiddenOpt, msg || usage.deferY18nLookup('Show hidden options'))\n    options.showHiddenOpt = showHiddenOpt\n    return self\n  }\n\n  self.hide = function hide (key) {\n    argsert('<string|object>', [key], arguments.length)\n    options.hiddenOptions.push(key)\n    return self\n  }\n\n  self.showHelpOnFail = function showHelpOnFail (enabled, message) {\n    argsert('[boolean|string] [string]', [enabled, message], arguments.length)\n    usage.showHelpOnFail(enabled, message)\n    return self\n  }\n\n  var exitProcess = true\n  self.exitProcess = function (enabled) {\n    argsert('[boolean]', [enabled], arguments.length)\n    if (typeof enabled !== 'boolean') {\n      enabled = true\n    }\n    exitProcess = enabled\n    return self\n  }\n  self.getExitProcess = () => exitProcess\n\n  var completionCommand = null\n  self.completion = function (cmd, desc, fn) {\n    argsert('[string] [string|boolean|function] [function]', [cmd, desc, fn], arguments.length)\n\n    // a function to execute when generating\n    // completions can be provided as the second\n    // or third argument to completion.\n    if (typeof desc === 'function') {\n      fn = desc\n      desc = null\n    }\n\n    // register the completion command.\n    completionCommand = cmd || 'completion'\n    if (!desc && desc !== false) {\n      desc = 'generate completion script'\n    }\n    self.command(completionCommand, desc)\n\n    // a function can be provided\n    if (fn) completion.registerFunction(fn)\n\n    return self\n  }\n\n  self.showCompletionScript = function ($0) {\n    argsert('[string]', [$0], arguments.length)\n    $0 = $0 || self.$0\n    _logger.log(completion.generateCompletionScript($0, completionCommand))\n    return self\n  }\n\n  self.getCompletion = function (args, done) {\n    argsert('<array> <function>', [args, done], arguments.length)\n    completion.getCompletion(args, done)\n  }\n\n  self.locale = function (locale) {\n    argsert('[string]', [locale], arguments.length)\n    if (arguments.length === 0) {\n      guessLocale()\n      return y18n.getLocale()\n    }\n    detectLocale = false\n    y18n.setLocale(locale)\n    return self\n  }\n\n  self.updateStrings = self.updateLocale = function (obj) {\n    argsert('<object>', [obj], arguments.length)\n    detectLocale = false\n    y18n.updateLocale(obj)\n    return self\n  }\n\n  let detectLocale = true\n  self.detectLocale = function (detect) {\n    argsert('<boolean>', [detect], arguments.length)\n    detectLocale = detect\n    return self\n  }\n  self.getDetectLocale = () => detectLocale\n\n  var hasOutput = false\n  var exitError = null\n  // maybe exit, always capture\n  // context about why we wanted to exit.\n  self.exit = (code, err) => {\n    hasOutput = true\n    exitError = err\n    if (exitProcess) process.exit(code)\n  }\n\n  // we use a custom logger that buffers output,\n  // so that we can print to non-CLIs, e.g., chat-bots.\n  const _logger = {\n    log () {\n      const args = []\n      for (let i = 0; i < arguments.length; i++) args.push(arguments[i])\n      if (!self._hasParseCallback()) console.log.apply(console, args)\n      hasOutput = true\n      if (output.length) output += '\\n'\n      output += args.join(' ')\n    },\n    error () {\n      const args = []\n      for (let i = 0; i < arguments.length; i++) args.push(arguments[i])\n      if (!self._hasParseCallback()) console.error.apply(console, args)\n      hasOutput = true\n      if (output.length) output += '\\n'\n      output += args.join(' ')\n    }\n  }\n  self._getLoggerInstance = () => _logger\n  // has yargs output an error our help\n  // message in the current execution context.\n  self._hasOutput = () => hasOutput\n\n  self._setHasOutput = () => {\n    hasOutput = true\n  }\n\n  let recommendCommands\n  self.recommendCommands = function (recommend) {\n    argsert('[boolean]', [recommend], arguments.length)\n    recommendCommands = typeof recommend === 'boolean' ? recommend : true\n    return self\n  }\n\n  self.getUsageInstance = () => usage\n\n  self.getValidationInstance = () => validation\n\n  self.getCommandInstance = () => command\n\n  self.terminalWidth = () => {\n    argsert([], 0)\n    return typeof process.stdout.columns !== 'undefined' ? process.stdout.columns : null\n  }\n\n  Object.defineProperty(self, 'argv', {\n    get: () => self._parseArgs(processArgs),\n    enumerable: true\n  })\n\n  self._parseArgs = function parseArgs (args, shortCircuit, _skipValidation, commandIndex) {\n    let skipValidation = !!_skipValidation\n    args = args || processArgs\n\n    options.__ = y18n.__\n    options.configuration = self.getParserConfiguration()\n\n    // Deprecated\n    let pkgConfig = pkgUp()['yargs']\n    if (pkgConfig) {\n      console.warn('Configuring yargs through package.json is deprecated and will be removed in the next major release, please use the JS API instead.')\n      options.configuration = Object.assign({}, pkgConfig, options.configuration)\n    }\n\n    const parsed = Parser.detailed(args, options)\n    let argv = parsed.argv\n    if (parseContext) argv = Object.assign({}, argv, parseContext)\n    const aliases = parsed.aliases\n\n    argv.$0 = self.$0\n    self.parsed = parsed\n\n    try {\n      guessLocale() // guess locale lazily, so that it can be turned off in chain.\n\n      // while building up the argv object, there\n      // are two passes through the parser. If completion\n      // is being performed short-circuit on the first pass.\n      if (shortCircuit) {\n        return argv\n      }\n\n      // if there's a handler associated with a\n      // command defer processing to it.\n      if (helpOpt) {\n        // consider any multi-char helpOpt alias as a valid help command\n        // unless all helpOpt aliases are single-char\n        // note that parsed.aliases is a normalized bidirectional map :)\n        const helpCmds = [helpOpt]\n          .concat(aliases[helpOpt] || [])\n          .filter(k => k.length > 1)\n        // check if help should trigger and strip it from _.\n        if (~helpCmds.indexOf(argv._[argv._.length - 1])) {\n          argv._.pop()\n          argv[helpOpt] = true\n        }\n      }\n\n      const handlerKeys = command.getCommands()\n      const requestCompletions = completion.completionKey in argv\n      const skipRecommendation = argv[helpOpt] || requestCompletions\n      const skipDefaultCommand = skipRecommendation && (handlerKeys.length > 1 || handlerKeys[0] !== '$0')\n\n      if (argv._.length) {\n        if (handlerKeys.length) {\n          let firstUnknownCommand\n          for (let i = (commandIndex || 0), cmd; argv._[i] !== undefined; i++) {\n            cmd = String(argv._[i])\n            if (~handlerKeys.indexOf(cmd) && cmd !== completionCommand) {\n              // commands are executed using a recursive algorithm that executes\n              // the deepest command first; we keep track of the position in the\n              // argv._ array that is currently being executed.\n              return command.runCommand(cmd, self, parsed, i + 1)\n            } else if (!firstUnknownCommand && cmd !== completionCommand) {\n              firstUnknownCommand = cmd\n              break\n            }\n          }\n\n          // run the default command, if defined\n          if (command.hasDefaultCommand() && !skipDefaultCommand) {\n            return command.runCommand(null, self, parsed)\n          }\n\n          // recommend a command if recommendCommands() has\n          // been enabled, and no commands were found to execute\n          if (recommendCommands && firstUnknownCommand && !skipRecommendation) {\n            validation.recommendCommands(firstUnknownCommand, handlerKeys)\n          }\n        }\n\n        // generate a completion script for adding to ~/.bashrc.\n        if (completionCommand && ~argv._.indexOf(completionCommand) && !requestCompletions) {\n          if (exitProcess) setBlocking(true)\n          self.showCompletionScript()\n          self.exit(0)\n        }\n      } else if (command.hasDefaultCommand() && !skipDefaultCommand) {\n        return command.runCommand(null, self, parsed)\n      }\n\n      // we must run completions first, a user might\n      // want to complete the --help or --version option.\n      if (requestCompletions) {\n        if (exitProcess) setBlocking(true)\n\n        // we allow for asynchronous completions,\n        // e.g., loading in a list of commands from an API.\n        const completionArgs = args.slice(args.indexOf(`--${completion.completionKey}`) + 1)\n        completion.getCompletion(completionArgs, (completions) => {\n          ;(completions || []).forEach((completion) => {\n            _logger.log(completion)\n          })\n\n          self.exit(0)\n        })\n        return argv\n      }\n\n      // Handle 'help' and 'version' options\n      // if we haven't already output help!\n      if (!hasOutput) {\n        Object.keys(argv).forEach((key) => {\n          if (key === helpOpt && argv[key]) {\n            if (exitProcess) setBlocking(true)\n\n            skipValidation = true\n            self.showHelp('log')\n            self.exit(0)\n          } else if (key === versionOpt && argv[key]) {\n            if (exitProcess) setBlocking(true)\n\n            skipValidation = true\n            usage.showVersion()\n            self.exit(0)\n          }\n        })\n      }\n\n      // Check if any of the options to skip validation were provided\n      if (!skipValidation && options.skipValidation.length > 0) {\n        skipValidation = Object.keys(argv).some(key => options.skipValidation.indexOf(key) >= 0 && argv[key] === true)\n      }\n\n      // If the help or version options where used and exitProcess is false,\n      // or if explicitly skipped, we won't run validations.\n      if (!skipValidation) {\n        if (parsed.error) throw new YError(parsed.error.message)\n\n        // if we're executed via bash completion, don't\n        // bother with validation.\n        if (!requestCompletions) {\n          self._runValidation(argv, aliases, {}, parsed.error)\n        }\n      }\n    } catch (err) {\n      if (err instanceof YError) usage.fail(err.message, err)\n      else throw err\n    }\n\n    return argv\n  }\n\n  self._runValidation = function runValidation (argv, aliases, positionalMap, parseErrors) {\n    if (parseErrors) throw new YError(parseErrors.message || parseErrors)\n    validation.nonOptionCount(argv)\n    validation.requiredArguments(argv)\n    if (strict) validation.unknownArguments(argv, aliases, positionalMap)\n    validation.customChecks(argv, aliases)\n    validation.limitedChoices(argv)\n    validation.implications(argv)\n    validation.conflicting(argv)\n  }\n\n  function guessLocale () {\n    if (!detectLocale) return\n\n    try {\n      const { env } = process\n      const locale = env.LC_ALL || env.LC_MESSAGES || env.LANG || env.LANGUAGE || 'en_US'\n      self.locale(locale.replace(/[.:].*/, ''))\n    } catch (err) {\n      // if we explode looking up locale just noop\n      // we'll keep using the default language 'en'.\n    }\n  }\n\n  // an app should almost always have --version and --help,\n  // if you *really* want to disable this use .help(false)/.version(false).\n  self.help()\n  self.version()\n\n  return self\n}\n\n// rebase an absolute path to a relative one with respect to a base directory\n// exported for tests\nexports.rebase = rebase\nfunction rebase (base, dir) {\n  return path.relative(base, dir)\n}\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst performance_ponyfill_1 = require(\"performance-ponyfill\");\r\nconst vscode_jsonrpc_1 = require(\"vscode-jsonrpc\");\r\nconst vscs_utils_1 = require(\"@vs/vscs-utils\");\r\nconst WaterfallNode_1 = require(\"./WaterfallNode\");\r\nconst PerformanceBlocks_1 = require(\"./PerformanceBlocks\");\r\n/**\r\n * Main performance measurement class. Meant do be used recusively,\r\n * e.g. every `createGroup` mathod call will return the instance of\r\n * the same class which is linked to the parent. This allows to create\r\n * callstack-like performance trees or waterfalls.\r\n */\r\nclass Performance {\r\n    constructor(name, groupId, pathString = 'start') {\r\n        this.name = name;\r\n        this.groupId = groupId;\r\n        this.pathString = pathString;\r\n        this.groups = [];\r\n        this.onAnyEventEmitter = new vscode_jsonrpc_1.Emitter();\r\n        this.onAnyEvent = this.onAnyEventEmitter.event;\r\n        /**\r\n         * Create the child subgroup of the current group.\r\n         * All the performance groups must have the reference to the top-level performance\r\n         * class, since searching for any of the group/event ids should be possible from any\r\n         * of the performance groups.\r\n         */\r\n        this.createGroup = (groupName, groupdId = Performance.groupCount++) => {\r\n            const pathString = `${this.pathString}.${groupName}.${this.groupId}`;\r\n            const newGroup = new Performance(groupName, groupdId, pathString);\r\n            newGroup.setMainPerformance(this.main);\r\n            newGroup.onAnyEvent((e) => {\r\n                this.onAnyEventEmitter.fire(e);\r\n            });\r\n            this.groups.push(newGroup);\r\n            return newGroup;\r\n        };\r\n        /**\r\n         * Marks `start` or `end` point of a code block that need to be measured\r\n         * in between. see `blocks.markBlock` method note for man example.\r\n         */\r\n        this.markBlock = (blockOptions) => {\r\n            this.blocks.markBlock(blockOptions);\r\n            return this;\r\n        };\r\n        /**\r\n         * Marks `start` point of a code block that need to be measured\r\n         * in between. see `blocks.markBlock` method note for man example.\r\n         */\r\n        this.markBlockStart = (blockOptions, ignoreExistingBlock = false) => {\r\n            try {\r\n                this.blocks.markBlockStart(blockOptions);\r\n            }\r\n            catch (e) {\r\n                if (!ignoreExistingBlock) {\r\n                    throw e;\r\n                }\r\n            }\r\n            return this;\r\n        };\r\n        /**\r\n         * Marks `end` point of a code block that need to be measured\r\n         * in between. see `blocks.markBlock` method note for man example.\r\n         */\r\n        this.markBlockEnd = (blockOptions, ignoreExistingBlock = false) => {\r\n            try {\r\n                this.blocks.markBlockEnd(blockOptions);\r\n            }\r\n            catch (e) {\r\n                if (!ignoreExistingBlock) {\r\n                    throw e;\r\n                }\r\n            }\r\n            return this;\r\n        };\r\n        /**\r\n         * Convenience method for the `markBlock` method. Instead of calling\r\n         * the `markBlock` twice, the `measure` can wrap the code block of interest\r\n         * into an asynchronous function hence be called only once.\r\n         */\r\n        this.measure = async (options, callback) => {\r\n            return await this.blocks.measure(options, callback);\r\n        };\r\n        /**\r\n         * Sync version of the `measure`.\r\n         */\r\n        this.measureSync = (options, callback) => {\r\n            return this.blocks.measureSync(options, callback);\r\n        };\r\n        /**\r\n         * Get waterfall of all the nested performance blocks, starting from the main\r\n         * \"start\" root node that is initialized as singleton when app starts.\r\n         */\r\n        this.getWaterfall = () => {\r\n            performance_ponyfill_1.performance.measure(this.pathString, this.pathString);\r\n            const [measure] = performance_ponyfill_1.performance.getEntriesByName(this.pathString);\r\n            const node = new WaterfallNode_1.WaterfallNode(this.groupId, this.name, this.pathString, measure, this.blocks.measures(), this.groups);\r\n            return node;\r\n        };\r\n        /**\r\n         * Get a measurement of a specific block by `id`.\r\n         */\r\n        this.getBlockMeasure = (id, waterfall) => {\r\n            waterfall = waterfall !== null && waterfall !== void 0 ? waterfall : this.main.getWaterfall();\r\n            if (waterfall.id === id) {\r\n                return waterfall;\r\n            }\r\n            for (let group of waterfall.groups) {\r\n                const result = this.getBlockMeasure(id, group);\r\n                if (result) {\r\n                    return result;\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n        this.getBlock = (id) => {\r\n            return this.blocks.getBlock(id);\r\n        };\r\n        /**\r\n         * Get block `startTime` by block `id` or `null` if block is not found.\r\n         */\r\n        this.getBlockStartTime = (id) => {\r\n            const block = this.main.getBlockMeasure(id);\r\n            ;\r\n            if (!block) {\r\n                return null;\r\n            }\r\n            const { measure } = block;\r\n            return measure.startTime;\r\n        };\r\n        /**\r\n         * Get block `endTime` by block `id` or `null` if block is not found.\r\n         */\r\n        this.getBlockEndTime = (id) => {\r\n            const block = this.main.getBlockMeasure(id);\r\n            ;\r\n            if (!block) {\r\n                return null;\r\n            }\r\n            const { measure } = block;\r\n            return measure.startTime + measure.duration;\r\n        };\r\n        /**\r\n         * Get block `durationTime` by block `id` or `null` if block is not found.\r\n         */\r\n        this.getBlockDurationTime = (id) => {\r\n            const block = this.main.getBlockMeasure(id);\r\n            ;\r\n            if (!block) {\r\n                return null;\r\n            }\r\n            const { measure } = block;\r\n            return measure.duration;\r\n        };\r\n        this.blocks = new PerformanceBlocks_1.PerformanceBlocks(pathString);\r\n        performance_ponyfill_1.performance.mark(pathString);\r\n        // set self as \"main\" performance initialy\r\n        this.mainPerformanceReference = this;\r\n        this.blocks.onAnyEvent((e) => {\r\n            this.onAnyEventEmitter.fire(e);\r\n        });\r\n    }\r\n    setMainPerformance(performance) {\r\n        this.mainPerformanceReference = performance;\r\n    }\r\n    get main() {\r\n        if (!this.mainPerformanceReference) {\r\n            throw new Error('No main performance found.');\r\n        }\r\n        return this.mainPerformanceReference;\r\n    }\r\n    /**\r\n     * Subscribe to `start` or `end` events of a block by `id`.\r\n     */\r\n    onEvent(options, callback) {\r\n        this.blocks.onEvent(options, (opts) => {\r\n            const { id, type } = opts;\r\n            if (type === 'start') {\r\n                callback(opts);\r\n                return this;\r\n            }\r\n            const node = this.getBlockMeasure(id);\r\n            if (!node) {\r\n                throw new Error(`Cannot find \"${id}\" block.`);\r\n            }\r\n            callback(opts, node);\r\n        });\r\n        return this;\r\n    }\r\n    /**\r\n     * Subscribe to `start` or `end` events of a block by `id`.\r\n     */\r\n    onMeasure(options, callback) {\r\n        this.blocks.onEvent(options, (opts) => {\r\n            const { id, type } = opts;\r\n            if (type === 'start') {\r\n                callback(opts);\r\n                return this;\r\n            }\r\n            const node = this.getBlockMeasure(id);\r\n            if (!node) {\r\n                throw new Error(`Cannot find \"${id}\" block.`);\r\n            }\r\n            callback(opts, node);\r\n        });\r\n        return this;\r\n    }\r\n}\r\nexports.Performance = Performance;\r\nPerformance.groupCount = 0;\r\n/**\r\n * Function to initialize the main performance singleton class, meant to be\r\n * called on the app startup.a\r\n */\r\nexports.initializePerformanceInstance = (groupdId, PerformanceClass = Performance) => {\r\n    const codespacePerformance = new PerformanceClass('start', groupdId);\r\n    codespacePerformance.setMainPerformance(codespacePerformance);\r\n    return codespacePerformance;\r\n};\r\n/**\r\n * Get or create an instance of Performance for the group ID (default is 'extension:start').\r\n * Throws an error if group ID is empty or undefined, or performance has already been initialized with a different group ID.\r\n *\r\n * @param groupId Group id, by default it is 'extension:start'\r\n * @returns Created or existing instance of Performance with the given group ID.\r\n */\r\nexports.getOrCreatePerformance = vscs_utils_1.onlyOnce((groupId) => exports.initializePerformanceInstance(groupId), 'extension:start');\r\n//# sourceMappingURL=Performance.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode_jsonrpc_1 = require(\"vscode-jsonrpc\");\r\nconst performance_ponyfill_1 = require(\"performance-ponyfill\");\r\n/**\r\n * Utility class to abstract methods around mesuaring performance blocks.\r\n */\r\nclass PerformanceBlocks {\r\n    /**\r\n     * The `pathString` param used to define a full path of a block in\r\n     * the nested blocks tree. Hence the path includes the paths of all\r\n     * parents of the current block in the nested tree.\r\n     */\r\n    constructor(pathString) {\r\n        this.pathString = pathString;\r\n        this.blocks = {};\r\n        /**\r\n         * Events for any block `start`/`end` event.\r\n         */\r\n        this.onAnyEventEmitter = new vscode_jsonrpc_1.Emitter();\r\n        this.onAnyEvent = this.onAnyEventEmitter.event;\r\n        /**\r\n         * Mark a `start` or `end` of a code block to measure. Must include\r\n         * a name and can include `id` in case the block measurements need to\r\n         * be retrieved later.\r\n         *\r\n         * Example:\r\n         *\r\n         * ```typescript\r\n         * performanceBlocks.markBlock({ name: 'fetching info', type: 'start' });\r\n         * // .. do some work\r\n         * performanceBlocks.markBlock({ name: 'fetching info', type: 'end' });\r\n         * ```\r\n         * If id is not defined, name for the `start` and `end` should be equal.\r\n         * Each `start` or `end` block with the same `name`/`id` expected to be\r\n         * called once.\r\n         */\r\n        this.markBlock = (blockOptions) => {\r\n            const { id, name, type } = blockOptions;\r\n            // get unique block id\r\n            const blockPath = `${this.pathString}.block: ${id !== null && id !== void 0 ? id : name}`;\r\n            // get unique block id for the side (`start`/`end`) of the block\r\n            const pathStringSide = `${blockPath}-${type}`;\r\n            if (this.blocks[blockPath] && this.blocks[blockPath][type]) {\r\n                throw new Error(`The event \"${pathStringSide}\" already marked in this group.`);\r\n            }\r\n            performance_ponyfill_1.performance.mark(pathStringSide);\r\n            const [measure] = performance_ponyfill_1.performance.getEntriesByName(pathStringSide);\r\n            const currentBlock = this.blocks[blockPath] || {\r\n                path: blockPath,\r\n                id: type === 'start' ? id : undefined,\r\n                name: type === 'start' ? name : undefined,\r\n            };\r\n            currentBlock[blockOptions.type] = Object.assign(Object.assign({}, blockOptions), { path: pathStringSide });\r\n            this.blocks[blockPath] = currentBlock;\r\n            // only elements with id can have event listeners\r\n            if (id && measure !== undefined) {\r\n                const event = { id, name, type, measure };\r\n                /**\r\n                 * For the `end` event types, the measure ``\r\n                 */\r\n                if (type === 'end') {\r\n                    const [startMeasure] = performance_ponyfill_1.performance.getEntriesByName(`${blockPath}-start`);\r\n                    if (!startMeasure) {\r\n                        throw new Error(`No start block found for event ${id}`);\r\n                    }\r\n                    event.measure = Object.assign(Object.assign({}, measure), { duration: measure.startTime - startMeasure.startTime });\r\n                }\r\n                this.onAnyEventEmitter.fire(event);\r\n                this.invokeBlock(event);\r\n            }\r\n            return this;\r\n        };\r\n        /**\r\n         * Mark the beginning of the block, same as above with `type: 'start'`\r\n         */\r\n        this.markBlockStart = (blockOptions) => {\r\n            return this.markBlock(Object.assign({ type: 'start' }, blockOptions));\r\n        };\r\n        /**\r\n         * Mark the end of the block, same as above with `type: 'end'`\r\n         */\r\n        this.markBlockEnd = (blockOptions) => {\r\n            return this.markBlock(Object.assign({ type: 'end' }, blockOptions));\r\n        };\r\n        this.getBlock = (id) => {\r\n            const blockPath = `${this.pathString}.block: ${id}`;\r\n            const block = this.blocks[blockPath];\r\n            if (!block) {\r\n                return undefined;\r\n            }\r\n            return block;\r\n        };\r\n        /**\r\n         * Convenience method around the `markBlock` since that later has to be\r\n         * called twice - once for `start` and once for `end`, we created this\r\n         * wrapper method that does that for the user.\r\n         */\r\n        this.measure = async (options, callback) => {\r\n            this.markBlock(Object.assign(Object.assign({}, options), { type: 'start' }));\r\n            try {\r\n                return await callback();\r\n            }\r\n            finally {\r\n                this.markBlock(Object.assign(Object.assign({}, options), { type: 'end' }));\r\n            }\r\n        };\r\n        /**\r\n         * Sync version of the `measure`.\r\n         */\r\n        this.measureSync = (options, callback) => {\r\n            this.markBlock(Object.assign(Object.assign({}, options), { type: 'start' }));\r\n            try {\r\n                return callback();\r\n            }\r\n            finally {\r\n                this.markBlock(Object.assign(Object.assign({}, options), { type: 'end' }));\r\n            }\r\n        };\r\n        /**\r\n         * Method to calculate(measure) all the currently tracked timing blocks.\r\n         */\r\n        this.measures = () => {\r\n            const blocks = [];\r\n            for (let [id, block] of Object.entries(this.blocks)) {\r\n                const { start, end } = block;\r\n                if (!start || !end) {\r\n                    continue;\r\n                }\r\n                performance_ponyfill_1.performance.measure(block.path, `${start.path}`, `${end.path}`);\r\n                const [measure] = performance_ponyfill_1.performance.getEntriesByName(block.path);\r\n                if (!measure) {\r\n                    throw new Error(`No measure found in Performance API for \"${id}\".`);\r\n                }\r\n                blocks.push({\r\n                    id: block.id,\r\n                    name: block.name,\r\n                    measure,\r\n                });\r\n            }\r\n            return blocks;\r\n        };\r\n        this.invokeBlock = (options) => {\r\n            const blockCallbackId = this.getBlockCallbackId(options);\r\n            const emitter = PerformanceBlocks.onEventEmitters[blockCallbackId];\r\n            if (!emitter) {\r\n                return;\r\n            }\r\n            emitter.fire(options);\r\n        };\r\n        this.getBlockCallbackId = (options) => {\r\n            const { id, type } = options;\r\n            return `${id}-${type}`;\r\n        };\r\n        /**\r\n         * Method to define event listeners for the `start` or `end` block sides.\r\n         */\r\n        this.onEvent = (options, callback) => {\r\n            const blockCallbackId = this.getBlockCallbackId(options);\r\n            let emitter = PerformanceBlocks.onEventEmitters[blockCallbackId];\r\n            if (!emitter) {\r\n                emitter = new vscode_jsonrpc_1.Emitter();\r\n                PerformanceBlocks.onEventEmitters[blockCallbackId] = emitter;\r\n            }\r\n            emitter.event(callback);\r\n            return this;\r\n        };\r\n    }\r\n}\r\nexports.PerformanceBlocks = PerformanceBlocks;\r\nPerformanceBlocks.onEventEmitters = {};\r\n//# sourceMappingURL=PerformanceBlocks.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass WaterfallNode {\r\n    constructor(id, name, path, rawMeasure, blocks, perfGoups) {\r\n        this.id = id;\r\n        this.name = name;\r\n        this.path = path;\r\n        this.rawMeasure = rawMeasure;\r\n        this.perfGoups = perfGoups;\r\n        this.groups = [];\r\n        this.getTotalDuration = () => {\r\n            let maxTime = 0;\r\n            for (let group of this.groups) {\r\n                const totalTime = group.measure.startTime + group.measure.duration;\r\n                if (totalTime > maxTime) {\r\n                    maxTime = totalTime;\r\n                }\r\n            }\r\n            return maxTime;\r\n        };\r\n        // measure properties are not\r\n        // iterable, need to copy by hand\r\n        this.measure = {\r\n            name: rawMeasure.name,\r\n            duration: rawMeasure.duration,\r\n            startTime: rawMeasure.startTime,\r\n            entryType: rawMeasure.entryType,\r\n        };\r\n        for (let block of blocks) {\r\n            this.groups.push(Object.assign(Object.assign({}, block), { groups: [] }));\r\n        }\r\n        for (let group of this.perfGoups) {\r\n            this.groups.push(group.getWaterfall());\r\n        }\r\n        const duration = this.getTotalDuration() - this.measure.startTime;\r\n        this.measure = Object.assign(Object.assign({}, this.measure), { duration });\r\n    }\r\n}\r\nexports.WaterfallNode = WaterfallNode;\r\n//# sourceMappingURL=WaterfallNode.js.map","\"use strict\";\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Performance_1 = require(\"./Performance\");\r\nexports.Performance = Performance_1.Performance;\r\nexports.initializePerformanceInstance = Performance_1.initializePerformanceInstance;\r\nexports.getOrCreatePerformance = Performance_1.getOrCreatePerformance;\r\nvar logPerformanceWaterfall_1 = require(\"./logPerformanceWaterfall\");\r\nexports.logPerformanceWaterfall = logPerformanceWaterfall_1.logPerformanceWaterfall;\r\nexports.mocks = __importStar(require(\"./mocks\"));\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst ansi_colors_1 = __importDefault(require(\"ansi-colors\"));\r\nconst sortByStartTime_1 = require(\"./sortByStartTime\");\r\nconst logInternal = (type, name, startTime, duration, rootStartTime) => {\r\n    const connectionTimes = `[${startTime}ms - ${startTime + duration}ms]`;\r\n    console[type]([\r\n        `${name}:`,\r\n        ansi_colors_1.default.cyan(`${duration}ms`),\r\n        ansi_colors_1.default.magenta(`+${startTime - rootStartTime}ms`),\r\n        ansi_colors_1.default.gray(connectionTimes),\r\n    ].join(' '));\r\n};\r\nconst log = (name, startTime, duration, rootStartTime) => {\r\n    logInternal('log', name, startTime, duration, rootStartTime);\r\n};\r\nconst group = (name, startTime, duration, rootStartTime) => {\r\n    logInternal('groupCollapsed', name, startTime, duration, rootStartTime);\r\n};\r\nconst logEmptyNode = (node, rootStartTime) => {\r\n    const { name, measure } = node;\r\n    const { startTime, duration } = measure;\r\n    log(name, Math.round(startTime), Math.round(duration), rootStartTime);\r\n};\r\nexports.logPerformanceWaterfall = (root, rootStartTime) => {\r\n    const { measure, name } = root;\r\n    const { startTime, duration } = measure;\r\n    const roundStartTime = Math.round(startTime);\r\n    rootStartTime = rootStartTime !== null && rootStartTime !== void 0 ? rootStartTime : Math.round(startTime);\r\n    // log the `root` group\r\n    group(name, roundStartTime, Math.round(duration), rootStartTime);\r\n    // log either `group` or `block`\r\n    for (let item of sortByStartTime_1.sortByStartTime([...root.groups])) {\r\n        item.groups.length\r\n            ? exports.logPerformanceWaterfall(item, rootStartTime)\r\n            : logEmptyNode(item, rootStartTime);\r\n    }\r\n    // end the `root` group\r\n    console.groupEnd();\r\n};\r\n//# sourceMappingURL=logPerformanceWaterfall.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Performance_1 = require(\"../Performance\");\r\nclass PerformanceMock extends Performance_1.Performance {\r\n    /**\r\n     * Expose the `groups` for tests.\r\n     */\r\n    get groupsMock() {\r\n        return this.groups;\r\n    }\r\n}\r\nexports.PerformanceMock = PerformanceMock;\r\n;\r\n//# sourceMappingURL=PerformanceMock.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar PerformanceMock_1 = require(\"./PerformanceMock\");\r\nexports.PerformanceMock = PerformanceMock_1.PerformanceMock;\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.sortByStartTime = (items) => {\r\n    const result = [...items].sort((item1, item2) => {\r\n        return item1.measure.startTime - item2.measure.startTime;\r\n    });\r\n    return result;\r\n};\r\n//# sourceMappingURL=sortByStartTime.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/** Describes the kind of data to be formatted. */\r\nvar DataFormat;\r\n(function (DataFormat) {\r\n    DataFormat[DataFormat[\"Default\"] = 'default'] = \"Default\";\r\n    DataFormat[DataFormat[\"Email\"] = 'email'] = \"Email\";\r\n    DataFormat[DataFormat[\"Token\"] = 'token'] = \"Token\";\r\n    DataFormat[DataFormat[\"Path\"] = 'path'] = \"Path\";\r\n    DataFormat[DataFormat[\"Text\"] = 'text'] = \"Text\";\r\n    DataFormat[DataFormat[\"Uri\"] = 'uri'] = \"Uri\";\r\n    DataFormat[DataFormat[\"Omit\"] = 'omit'] = \"Omit\";\r\n    DataFormat[DataFormat[\"OmitDefault\"] = 'omitDefault'] = \"OmitDefault\";\r\n    DataFormat[DataFormat[\"Hide\"] = 'hide'] = \"Hide\";\r\n    DataFormat[DataFormat[\"SingleMember\"] = 'singleMember'] = \"SingleMember\";\r\n})(DataFormat = exports.DataFormat || (exports.DataFormat = {}));\r\n/** Creates a decorator that saves the property format in a map attached to the class constructor. */\r\nfunction dataFormat(...format) {\r\n    return (target, propertyKey) => {\r\n        if (!target.constructor.dataFormat) {\r\n            target.constructor.dataFormat = {};\r\n        }\r\n        target.constructor.dataFormat[propertyKey] = format;\r\n    };\r\n}\r\nexports.dataFormat = dataFormat;\r\n//# sourceMappingURL=DataFormat.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst RpcConnectionErrors_1 = require(\"./RpcConnectionErrors\");\r\nconst RpcClientProxy_1 = require(\"./RpcClientProxy\");\r\nconst RpcServiceHandler_1 = require(\"./RpcServiceHandler\");\r\nconst vscs_utils_1 = require(\"@vs/vscs-utils\");\r\nclass RpcClientProxy extends RpcClientProxy_1.RpcClientProxyBase {\r\n    constructor(rpcClient, logger) {\r\n        super(logger);\r\n        this.rpcClient = rpcClient;\r\n    }\r\n    ensureConnectionAsync() {\r\n        return this.rpcClient.ensureConnectionAsync();\r\n    }\r\n}\r\nclass RpcClient extends RpcServiceHandler_1.RpcServiceHandler {\r\n    constructor(connectionFactory, logger) {\r\n        super(logger);\r\n        this.connectionFactory = connectionFactory;\r\n        this.connection = null;\r\n        this.connectionFactoryMutex = new vscs_utils_1.Mutex();\r\n        this.rpcClientProxy = new RpcClientProxy(this, logger);\r\n        if (connectionFactory.dispose) {\r\n            this.addToDisposables(connectionFactory);\r\n        }\r\n    }\r\n    static fromRpcMessageStream(rpcMessageStreamCallback, logger, disposeCallback) {\r\n        return new RpcClient({\r\n            create: async (rpcClient) => {\r\n                const rpcMessageStream = await rpcMessageStreamCallback();\r\n                const rpcConnection = rpcClient.createRpcConnection(rpcMessageStream, logger);\r\n                rpcConnection.listen();\r\n                return rpcConnection;\r\n            },\r\n            dispose: () => {\r\n                if (disposeCallback) {\r\n                    disposeCallback();\r\n                }\r\n            },\r\n        }, logger);\r\n    }\r\n    sendRequest(logger, serviceAndMethodName, progress, cancellationToken, ...args) {\r\n        return this.rpcClientProxy.sendRequest(logger, serviceAndMethodName, progress, cancellationToken, ...args);\r\n    }\r\n    sendNotification(logger, serviceAndName, args) {\r\n        return this.rpcClientProxy.sendNotification(logger, serviceAndName, args);\r\n    }\r\n    async onConnect(handler) {\r\n        await this.ensureConnectionAsync();\r\n        handler();\r\n    }\r\n    async onClose(handler) {\r\n        await this.ensureConnectionAsync();\r\n        this.connection.onClose(handler);\r\n    }\r\n    async ensureConnectionInternal() {\r\n        if (!this.connection) {\r\n            await this.connectionFactoryMutex.dispatch(async () => {\r\n                if (!this.connection) {\r\n                    this.setConnection(await this.connectionFactory.create(this));\r\n                }\r\n            });\r\n        }\r\n    }\r\n    async ensureConnectionAsync() {\r\n        await this.ensureConnectionInternal();\r\n        return this.connection;\r\n    }\r\n    setConnection(conection) {\r\n        this.connection = conection;\r\n        if (conection) {\r\n            this.attachConnection(conection);\r\n            this.addToDisposables(conection);\r\n        }\r\n    }\r\n    attachConnection(connection) {\r\n        connection.onClose(() => {\r\n            this.trace.info(`RPC connection closed. disposed: \"${this.isDisposed}\"`);\r\n            if (!this.isDisposed) {\r\n                // The connection was closed unexpectedly (not due to extension deactivation).\r\n                // Dispose with an error that causes further communication attemps to be\r\n                // rejected with an appropriate exception.\r\n                this.dispose(new RpcConnectionErrors_1.RpcConnectionClosedError());\r\n            }\r\n        });\r\n        // add generic request support\r\n        connection.onRequest((method, ...params) => {\r\n            return this.onRequest(null, connection, method, ...params);\r\n        });\r\n        // Add progress and generic notification support.\r\n        connection.onNotification((method, ...params) => {\r\n            this.onNotification(connection, method, ...params);\r\n        });\r\n    }\r\n}\r\nexports.RpcClient = RpcClient;\r\n//# sourceMappingURL=RpcClient.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vso_logging_1 = require(\"@vs/vso-logging\");\r\nconst vscs_utils_1 = require(\"@vs/vscs-utils\");\r\nclass RpcClientProxyBase extends vscs_utils_1.DisposableClass {\r\n    constructor(logger) {\r\n        super(logger);\r\n    }\r\n    async sendNotification(logger, serviceAndName, args) {\r\n        const connection = await this.ensureConnectionAsync();\r\n        // Event args may contain sensitive data, so only trace when obfuscation is disabled.\r\n        const argsString = vso_logging_1.LoggerSettings.disableObfuscation ? JSON.stringify(args) : '';\r\n        logger.verbose(`sendNotification-> ${serviceAndName}: ${argsString}`);\r\n        if (Array.isArray(args)) {\r\n            // Method-style notification: 0 or more arguments.\r\n            connection.sendNotification(serviceAndName, ...args);\r\n        }\r\n        else {\r\n            // Event-style notification: a single EventArgs argument.\r\n            connection.sendNotification(serviceAndName, args);\r\n        }\r\n    }\r\n    async sendRequest(logger, serviceAndMethodName, progress, cancellationToken, ...args) {\r\n        const cancellationMessage = 'The request was cancelled.';\r\n        let connectionCompleted = false;\r\n        const connection = await Promise.race([\r\n            this.ensureConnectionAsync(),\r\n            new Promise((resolve, reject) => {\r\n                if (cancellationToken) {\r\n                    if (cancellationToken.isCancellationRequested) {\r\n                        return reject(new vscs_utils_1.CancellationError(cancellationMessage));\r\n                    }\r\n                    cancellationToken.onCancellationRequested(() => {\r\n                        if (!connectionCompleted) {\r\n                            reject(new vscs_utils_1.CancellationError(cancellationMessage));\r\n                        }\r\n                    });\r\n                }\r\n            }),\r\n        ]);\r\n        connectionCompleted = true;\r\n        let argsString = '';\r\n        if (vso_logging_1.LoggerSettings.disableObfuscation) {\r\n            // Arguments may contain sensitive data, so only trace when obfuscation is disabled.\r\n            argsString = JSON.stringify(args);\r\n            argsString = argsString.substr(1, argsString.length - 2);\r\n        }\r\n        logger.verbose(`< ${serviceAndMethodName}(${argsString})`);\r\n        const start = Date.now();\r\n        let result;\r\n        try {\r\n            if (progress) {\r\n                // Attach the progress handler to the args; the write filter will detect and register it.\r\n                // Also attach the cancellation token so progress notifications can be cancelled.\r\n                progress.cancellation = cancellationToken;\r\n                args.progress = progress;\r\n            }\r\n            // The vscode-jsonrpc sendRequest() method can only detect a cancellation token argument\r\n            // if it is not null.\r\n            let sendPromise;\r\n            if (cancellationToken) {\r\n                sendPromise = connection.sendRequest(serviceAndMethodName, args, cancellationToken);\r\n            }\r\n            else {\r\n                sendPromise = connection.sendRequest(serviceAndMethodName, args);\r\n            }\r\n            result = await sendPromise;\r\n        }\r\n        catch (err) {\r\n            if (this.isDisposed) {\r\n                // // This will either block (during deactivation) or throw a connection-closed error.\r\n                // await this.initPromise;\r\n            }\r\n            // The error 'data' property should be the remote stack trace.\r\n            logger.error(`> ${serviceAndMethodName}() error: ` + err.data);\r\n            throw err;\r\n        }\r\n        const time = (Date.now() - start).toFixed(1);\r\n        // Result may contain sensitive data, so only trace when obfuscation is disabled.\r\n        if (vso_logging_1.LoggerSettings.disableObfuscation) {\r\n            logger.verbose(`> ${serviceAndMethodName}() => ${JSON.stringify(result)} t:${time}`);\r\n        }\r\n        else {\r\n            logger.verbose(`> ${serviceAndMethodName}() succeeded t:${time}`);\r\n        }\r\n        return result;\r\n    }\r\n}\r\nexports.RpcClientProxyBase = RpcClientProxyBase;\r\nclass RpcClientProxy extends RpcClientProxyBase {\r\n    constructor(promise, logger) {\r\n        super(logger);\r\n        this.promise = promise;\r\n        this.initPromise = Promise.resolve();\r\n    }\r\n    static fromRpcConnection(connection, logger) {\r\n        return new RpcClientProxy(Promise.resolve(connection), logger);\r\n    }\r\n    static fromPromise(promise, logger) {\r\n        return new RpcClientProxy(promise, logger);\r\n    }\r\n    ensureConnectionAsync() {\r\n        return this.promise;\r\n    }\r\n}\r\nexports.RpcClientProxy = RpcClientProxy;\r\n//# sourceMappingURL=RpcClientProxy.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Error thrown from RPC requests when the connection to the agent was unexpectedly\r\n * closed before or during the request.\r\n */\r\nclass RpcConnectionClosedError extends Error {\r\n    constructor() {\r\n        super('RPC connection closed.');\r\n        this.code = RpcConnectionClosedError.code;\r\n        Object.setPrototypeOf(this, RpcConnectionClosedError.prototype);\r\n    }\r\n}\r\nexports.RpcConnectionClosedError = RpcConnectionClosedError;\r\n/** One of the well-known Node.js error code strings. */\r\nRpcConnectionClosedError.code = 'EPIPE';\r\n/**\r\n * Error thrown from RPC connection is closed due to explicit client shut down.\r\n */\r\nclass RpcConnectionShutdownError extends Error {\r\n    constructor() {\r\n        super('RPC connection closed due to client shut down.');\r\n        this.code = RpcConnectionShutdownError.code;\r\n        Object.setPrototypeOf(this, RpcConnectionShutdownError.prototype);\r\n    }\r\n}\r\nexports.RpcConnectionShutdownError = RpcConnectionShutdownError;\r\n/** One of the well-known Node.js error code strings. */\r\nRpcConnectionShutdownError.code = 'ECONNRESET';\r\n//# sourceMappingURL=RpcConnectionErrors.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass RpcLoggerAdapter {\r\n    constructor(trace) {\r\n        this.trace = trace;\r\n    }\r\n    error(message) {\r\n        this.trace.error(message);\r\n    }\r\n    warn(message) {\r\n        this.trace.warning(message);\r\n    }\r\n    info(message) {\r\n        this.trace.info(message);\r\n    }\r\n    log(message) {\r\n        this.trace.verbose(message);\r\n    }\r\n}\r\nexports.RpcLoggerAdapter = RpcLoggerAdapter;\r\n//# sourceMappingURL=RpcLoggerAdapter.js.map","\"use strict\";\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst rpc = __importStar(require(\"vscode-jsonrpc\"));\r\nconst contentLengthHeaderPrefix = 'Content-Length: ';\r\nconst headersSeparator = '\\r\\n\\r\\n';\r\nclass RpcMessageWriter {\r\n    constructor() {\r\n        this.onErrorEmitter = new rpc.Emitter();\r\n        this.onCloseEmitter = new rpc.Emitter();\r\n        this.onError = this.onErrorEmitter.event;\r\n        this.onClose = this.onCloseEmitter.event;\r\n    }\r\n    write(message) {\r\n        const messageJson = JSON.stringify(message);\r\n        const messageData = Buffer.from(messageJson);\r\n        const headerData = Buffer.from(contentLengthHeaderPrefix + messageData.length + headersSeparator);\r\n        const data = Buffer.alloc(headerData.length + messageData.length);\r\n        headerData.copy(data, 0);\r\n        messageData.copy(data, headerData.length);\r\n        if (this.onSendCallback) {\r\n            this.onSendCallback(data).catch((e) => {\r\n                this.onErrorEmitter.fire([e, undefined, undefined]);\r\n            });\r\n        }\r\n    }\r\n    dispose() { }\r\n}\r\nexports.RpcMessageWriter = RpcMessageWriter;\r\n//# sourceMappingURL=RpcMessageWriter.js.map","//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\n'use strict';\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst rpc = __importStar(require(\"vscode-jsonrpc\"));\r\nconst RpcClientProxy_1 = require(\"./RpcClientProxy\");\r\nconst vso_logging_1 = require(\"@vs/vso-logging\");\r\nconst RpcUtils_1 = require(\"./RpcUtils\");\r\n/**\r\n * Defines error codes returned by the VSLS agent implemention of JSON-RPC,\r\n * which are a super-set of standard JSON-RPC error codes.\r\n */\r\nvar RpcErrorCodes;\r\n(function (RpcErrorCodes) {\r\n    RpcErrorCodes[RpcErrorCodes[\"ParseError\"] = rpc.ErrorCodes.ParseError] = \"ParseError\";\r\n    RpcErrorCodes[RpcErrorCodes[\"InvalidRequest\"] = rpc.ErrorCodes.InvalidRequest] = \"InvalidRequest\";\r\n    RpcErrorCodes[RpcErrorCodes[\"MethodNotFound\"] = rpc.ErrorCodes.MethodNotFound] = \"MethodNotFound\";\r\n    RpcErrorCodes[RpcErrorCodes[\"InvalidParams\"] = rpc.ErrorCodes.InvalidParams] = \"InvalidParams\";\r\n    RpcErrorCodes[RpcErrorCodes[\"InternalError\"] = rpc.ErrorCodes.InternalError] = \"InternalError\";\r\n    RpcErrorCodes[RpcErrorCodes[\"ServerNotInitialized\"] = rpc.ErrorCodes.ServerNotInitialized] = \"ServerNotInitialized\";\r\n    RpcErrorCodes[RpcErrorCodes[\"UnknownErrorCode\"] = rpc.ErrorCodes.UnknownErrorCode] = \"UnknownErrorCode\";\r\n    RpcErrorCodes[RpcErrorCodes[\"RequestCancelled\"] = rpc.ErrorCodes.RequestCancelled] = \"RequestCancelled\";\r\n    RpcErrorCodes[RpcErrorCodes[\"MessageWriteError\"] = rpc.ErrorCodes.MessageWriteError] = \"MessageWriteError\";\r\n    RpcErrorCodes[RpcErrorCodes[\"MessageReadError\"] = rpc.ErrorCodes.MessageReadError] = \"MessageReadError\";\r\n    // VSLS extended RPC error codes\r\n    RpcErrorCodes[RpcErrorCodes[\"ServiceNotAvailable\"] = -32099] = \"ServiceNotAvailable\";\r\n    RpcErrorCodes[RpcErrorCodes[\"InvocationException\"] = -32098] = \"InvocationException\";\r\n    RpcErrorCodes[RpcErrorCodes[\"MessageTooLarge\"] = -32097] = \"MessageTooLarge\";\r\n})(RpcErrorCodes = exports.RpcErrorCodes || (exports.RpcErrorCodes = {}));\r\n/**\r\n * Base class for RPC service proxies. Traces all messages\r\n * and emits events for incoming notifications.\r\n */\r\nclass RpcProxy {\r\n    constructor(client, serviceName, logger) {\r\n        this.client = client;\r\n        this.serviceName = serviceName;\r\n        this.logger = logger;\r\n    }\r\n    /**\r\n     * Creates a proxy for an RPC service.\r\n     *\r\n     * @param serviceInfo Information about the service contract\r\n     * @param client RPC client\r\n     * @param logger logger to use\r\n     */\r\n    static create(serviceInfo, client, logger) {\r\n        if (!(serviceInfo && serviceInfo.name)) {\r\n            throw new Error('Missing RPC service name.');\r\n        }\r\n        const proxy = new RpcProxy(client, serviceInfo.name, logger);\r\n        // Generate async methods for requests.\r\n        for (const methodName of serviceInfo.methods) {\r\n            const methodPropertyName = `${methodName}Async`;\r\n            proxy[methodPropertyName] = function () {\r\n                // Detect whether optional cancellation token was supplied, and if so strip from args.\r\n                let args;\r\n                let cancellationToken = arguments[arguments.length - 1];\r\n                if (cancellationToken &&\r\n                    typeof cancellationToken === 'object' &&\r\n                    typeof cancellationToken.isCancellationRequested === 'boolean') {\r\n                    args = Array.prototype.slice.call(arguments, 0, arguments.length - 1);\r\n                }\r\n                else {\r\n                    args = Array.prototype.slice.call(arguments, 0, arguments.length);\r\n                    cancellationToken = null;\r\n                }\r\n                // Detect whether optional progress was supplied, and if so strip from args.\r\n                let progress = args[args.length - 1];\r\n                if (progress &&\r\n                    typeof progress === 'object' &&\r\n                    typeof progress.report === 'function') {\r\n                    args.splice(args.length - 1, 1);\r\n                }\r\n                else {\r\n                    progress = null;\r\n                }\r\n                const serviceAndMethodName = proxy.serviceName + '.' + methodName;\r\n                return proxy.client.sendRequest(this.logger, serviceAndMethodName, progress, cancellationToken, ...args);\r\n            };\r\n        }\r\n        // Generate methods for method-style notifications.\r\n        for (const methodName of serviceInfo.voidMethods || []) {\r\n            proxy[methodName] = function () {\r\n                const args = Array.prototype.slice.call(arguments, 0, arguments.length);\r\n                const serviceAndMethodName = proxy.serviceName + '.' + methodName;\r\n                proxy.client\r\n                    .sendNotification(this.logger, serviceAndMethodName, args)\r\n                    .then()\r\n                    .catch();\r\n            };\r\n        }\r\n        // Generate events for event-style notifications.\r\n        for (const eventName of serviceInfo.events) {\r\n            const emitter = new rpc.Emitter();\r\n            const eventPropertyName = RpcUtils_1.getEventPropertyName(eventName);\r\n            proxy[eventPropertyName] = emitter.event;\r\n            const serviceAndEventName = proxy.serviceName + '.' + eventName;\r\n            proxy.client\r\n                .ensureConnectionAsync()\r\n                .then((connection) => {\r\n                connection.onNotification(serviceAndEventName, (...args) => {\r\n                    const eventArgs = args[0];\r\n                    // Event args may contain sensitive data, so only trace when obfuscation is disabled.\r\n                    const argsString = vso_logging_1.LoggerSettings.disableObfuscation\r\n                        ? JSON.stringify(eventArgs)\r\n                        : '';\r\n                    proxy.logger.log(vso_logging_1.LogLevel.Debug, `> ${serviceAndEventName}: ${argsString}`);\r\n                    emitter.fire(eventArgs);\r\n                });\r\n            })\r\n                .catch((e) => {\r\n                // Failed to get the connection. There will already be errors traced elsewhere\r\n                // about the connection failure, so there's no need to trace anything more here.\r\n            });\r\n        }\r\n        return proxy;\r\n    }\r\n    static createWithConnection(serviceInfo, connection, logger) {\r\n        return RpcProxy.create(serviceInfo, RpcClientProxy_1.RpcClientProxy.fromRpcConnection(connection, logger), logger);\r\n    }\r\n    static createWithPromise(serviceInfo, promise, logger) {\r\n        return RpcProxy.create(serviceInfo, RpcClientProxy_1.RpcClientProxy.fromPromise(promise, logger), logger);\r\n    }\r\n    /**\r\n     * Sends a notification (event) from this client to the service.\r\n     *\r\n     * (This is a static method because RPC contract interfaces do not define methods\r\n     * for reverse notifications.)\r\n     */\r\n    static notifyAsync(proxy, eventName, args) {\r\n        const rpcProxy = proxy;\r\n        const serviceAndMethodName = rpcProxy.serviceName + '.' + eventName;\r\n        return rpcProxy.client.sendNotification(rpcProxy.logger, serviceAndMethodName, args);\r\n    }\r\n}\r\nexports.RpcProxy = RpcProxy;\r\n//# sourceMappingURL=RpcProxy.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst RpcProxy_1 = require(\"./RpcProxy\");\r\nclass RpcProxyCache {\r\n    constructor(clientProxy, logger) {\r\n        this.clientProxy = clientProxy;\r\n        this.logger = logger;\r\n        this.proxyMap = new Map();\r\n    }\r\n    getOrCreate(serviceInfo, traceName) {\r\n        let proxy = this.proxyMap.get(serviceInfo.name);\r\n        if (!proxy) {\r\n            this.logger.info(`Creating proxy for ${serviceInfo.name} service`);\r\n            proxy = RpcProxy_1.RpcProxy.create(serviceInfo, this.clientProxy, traceName ? this.logger.withName(traceName) : this.logger);\r\n            this.proxyMap.set(serviceInfo.name, proxy);\r\n        }\r\n        return proxy;\r\n    }\r\n}\r\nexports.RpcProxyCache = RpcProxyCache;\r\n//# sourceMappingURL=RpcProxyCache.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vso_logging_1 = require(\"@vs/vso-logging\");\r\nconst RpcServiceHandler_1 = require(\"./RpcServiceHandler\");\r\nconst sendRpcRequest_1 = require(\"./sendRpcRequest\");\r\nconst RpcUtils_1 = require(\"./RpcUtils\");\r\n/**\r\n * define a class capable to host multiple rpc services\r\n */\r\nclass RpcServer extends RpcServiceHandler_1.RpcServiceHandler {\r\n    constructor(logger, notifyEventProvider) {\r\n        super(logger);\r\n        this.rpcSessionNumber = 0;\r\n        this.rpcConnections = [];\r\n        const defaultNotifyProvider = (serviceAndMethod, e) => {\r\n            RpcUtils_1.notifyConnections(this.rpcConnections, serviceAndMethod, e, logger);\r\n        };\r\n        this.notifyEventProvider = notifyEventProvider || defaultNotifyProvider;\r\n    }\r\n    registerRemoteRpcService(serviceName, messageConnection) {\r\n        this.trace.info(`adding remote rpc service:${serviceName}`);\r\n        const serviceNamePrefix = serviceName + '.';\r\n        messageConnection.onNotification((method, ...params) => {\r\n            if (method.startsWith(serviceNamePrefix)) {\r\n                this.notifyEventProvider(method, params);\r\n            }\r\n        });\r\n        const disposable = this.onHandleNoneRequest(async (rpcConnection, method, ...params) => {\r\n            if (method.startsWith(serviceNamePrefix)) {\r\n                return await sendRpcRequest_1.sendRpcRequest(messageConnection, method, params, this.trace);\r\n            }\r\n        });\r\n        messageConnection.onClose(() => disposable.dispose());\r\n        messageConnection.onDispose(() => disposable.dispose());\r\n        return disposable;\r\n    }\r\n    sendNotification(logger, serviceAndName, args) {\r\n        this.notifyEventProvider(serviceAndName, args);\r\n        return Promise.resolve();\r\n    }\r\n    acceptRpcMessageStream(rpcMessageStream) {\r\n        const messageConnection = this.createRpcConnection(rpcMessageStream, this.trace);\r\n        const rpcSessionNumber = this.attachConnection(messageConnection);\r\n        return [messageConnection, rpcSessionNumber];\r\n    }\r\n    attachConnection(messageConnection) {\r\n        this.rpcConnections.push(messageConnection);\r\n        const rpcSessionNumber = ++this.rpcSessionNumber;\r\n        this.trace.verbose(`Rpc #${rpcSessionNumber} created`);\r\n        messageConnection.onRequest((method, ...params) => {\r\n            return this.onRequest(async (requestHandler, ...requestParams) => {\r\n                // inject rpc request context on the last argument\r\n                const rpcRequestContext = {\r\n                    connection: messageConnection,\r\n                    session: rpcSessionNumber,\r\n                };\r\n                requestParams.push(rpcRequestContext);\r\n                const result = await Promise.resolve(requestHandler(...requestParams));\r\n                const loggerResult = vso_logging_1.LoggerSettings.disableObfuscation\r\n                    ? ` => ${JSON.stringify(result)}`\r\n                    : '';\r\n                this.trace.verbose(`> #${rpcSessionNumber} ${method}()${loggerResult}`);\r\n                return result;\r\n            }, messageConnection, method, ...params);\r\n        });\r\n        // Add progress and generic notification support.\r\n        messageConnection.onNotification((method, ...params) => {\r\n            this.onNotification(messageConnection, method, ...params);\r\n        });\r\n        const removeRpc = (event) => {\r\n            const index = this.rpcConnections.indexOf(messageConnection);\r\n            if (index !== -1) {\r\n                this.trace.verbose(`Rpc #${rpcSessionNumber} removed event:${event}`);\r\n                this.rpcConnections.splice(index, 1);\r\n            }\r\n        };\r\n        messageConnection.onClose((e) => {\r\n            removeRpc('closed');\r\n        });\r\n        messageConnection.onDispose((e) => {\r\n            removeRpc('disposed');\r\n        });\r\n        return rpcSessionNumber;\r\n    }\r\n}\r\nexports.RpcServer = RpcServer;\r\n//# sourceMappingURL=RpcServer.js.map","\"use strict\";\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst rpc = __importStar(require(\"vscode-jsonrpc\"));\r\nconst vscs_utils_1 = require(\"@vs/vscs-utils\");\r\nconst RpcUtils_1 = require(\"./RpcUtils\");\r\nconst RpcLoggerAdapter_1 = require(\"./RpcLoggerAdapter\");\r\nconst RpcUtils_2 = require(\"./RpcUtils\");\r\nexports.methodProgress = '$/progress';\r\nconst RESTRICTED_HANDLERS_FIELD = '$RestrictedHandlers$';\r\n/**\r\n * Base class to handle common tasks related with handling rpc request and notifications.\r\n */\r\nclass RpcServiceHandlerBase extends vscs_utils_1.DisposableClass {\r\n    constructor(logger) {\r\n        super(logger);\r\n        this.rpcRequestsWithContext = new RpcUtils_1.RpcRequestsWithContext();\r\n        this.rpcReadFilters = [\r\n            this.rpcRequestsWithContext.readFilter,\r\n        ];\r\n        this.rpcWriteFilters = [];\r\n        this.progressHandlers = new Map();\r\n        this.requests = new Map();\r\n        this.requestsWithProgress = new Set();\r\n        this.notifications = new Map();\r\n        this.notificationsCookies = 0;\r\n        this.handleNoneRequestCallbacks = new vscs_utils_1.CallbackContainer();\r\n        this.handleNoneNotificationCallbacks = new vscs_utils_1.CallbackContainer();\r\n        this.addProgressFilters();\r\n    }\r\n    get serviceNames() {\r\n        const serviceNames = new Set();\r\n        const addServices = (keys) => {\r\n            for (const key of keys) {\r\n                serviceNames.add(key.split('.')[0]);\r\n            }\r\n        };\r\n        addServices(this.requests.keys());\r\n        addServices(this.notifications.keys());\r\n        return Array.from(serviceNames);\r\n    }\r\n    clear() {\r\n        this.requests.clear();\r\n        this.requestsWithProgress.clear();\r\n        this.notifications.clear();\r\n        this.handleNoneRequestCallbacks.clear();\r\n        this.handleNoneNotificationCallbacks.clear();\r\n    }\r\n    onHandleNoneRequest(callback) {\r\n        return this.handleNoneRequestCallbacks.add(callback);\r\n    }\r\n    onHandleNoneNotification(callback) {\r\n        return this.handleNoneNotificationCallbacks.add(callback);\r\n    }\r\n    createRpcConnection(rpcMessageStream, logger) {\r\n        const rpcConnection = rpc.createMessageConnection(this.createFilteredMessageReader(rpcMessageStream.reader), this.createFilteredMessageWriter(rpcMessageStream.writer), new RpcLoggerAdapter_1.RpcLoggerAdapter(logger));\r\n        return rpcConnection;\r\n    }\r\n    addReadFilter(filter) {\r\n        return addRpcFilter(this.rpcReadFilters, filter);\r\n    }\r\n    addWriteFilter(filter) {\r\n        return addRpcFilter(this.rpcWriteFilters, filter);\r\n    }\r\n    addRequestMethod(method, requestHandler) {\r\n        this.requests.set(method, requestHandler);\r\n    }\r\n    addRequestMethodWithContext(method, requestHandler) {\r\n        this.addRequestMethod(method, requestHandler);\r\n        this.rpcRequestsWithContext.add(method);\r\n    }\r\n    addRequestMethodWithProgress(method, requestHandler) {\r\n        this.addRequestMethod(method, requestHandler);\r\n        this.requestsWithProgress.add(method);\r\n    }\r\n    removeRequestMethod(method) {\r\n        this.requests.delete(method);\r\n        this.requestsWithProgress.delete(method);\r\n    }\r\n    addNotificationHandler(method, notificationHandler) {\r\n        let entrys = this.notifications.get(method);\r\n        if (!entrys) {\r\n            entrys = [];\r\n            this.notifications.set(method, entrys);\r\n        }\r\n        const entry = {\r\n            cookie: ++this.notificationsCookies,\r\n            notificationHandler,\r\n        };\r\n        entrys.push(entry);\r\n        return entry.cookie;\r\n    }\r\n    removeNotificationHandler(method, cookie) {\r\n        const entrys = this.notifications.get(method);\r\n        if (entrys) {\r\n            const indexEntry = entrys.findIndex((i) => i.cookie === cookie);\r\n            if (indexEntry !== -1) {\r\n                return entrys.splice(indexEntry, 1)[0].notificationHandler;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    onRequest(requestHandlerInvoke, rpcConnection, method, ...params) {\r\n        const requestHandler = this.requests.get(method);\r\n        if (!requestHandler) {\r\n            for (const callback of this.handleNoneRequestCallbacks.items) {\r\n                const result = callback(rpcConnection, method, ...params);\r\n                if (result !== undefined) {\r\n                    return result;\r\n                }\r\n            }\r\n            return Promise.resolve(RpcUtils_2.createMethodNotFoundResponse(method));\r\n        }\r\n        // The request ID was inserted into the args by the read filter. (It's not used here.)\r\n        const [requestId] = params.splice(0, 1);\r\n        if (this.requestsWithProgress.has(method)) {\r\n            const progress = {\r\n                report: (value) => {\r\n                    rpcConnection.sendNotification(exports.methodProgress, { id: requestId, value });\r\n                },\r\n            };\r\n            // Insert progress into args just before the last (cancellation) arg.\r\n            params.splice(params.length - 1, 0, progress);\r\n        }\r\n        if (requestHandlerInvoke) {\r\n            return requestHandlerInvoke(requestHandler, ...params);\r\n        }\r\n        return requestHandler(...params);\r\n    }\r\n    onNotification(rpcConnection, method, ...params) {\r\n        if (method === exports.methodProgress && typeof params[0] === 'object') {\r\n            // Note: the progress notification is being handled on the rpc read filter\r\n            // and its better to no op.\r\n            return;\r\n        }\r\n        else if (this.notifications.has(method)) {\r\n            this.notifications.get(method).forEach((item) => {\r\n                item.notificationHandler(...params);\r\n            });\r\n        }\r\n        else {\r\n            for (const callback of this.handleNoneNotificationCallbacks.items) {\r\n                callback(rpcConnection, method, ...params);\r\n            }\r\n        }\r\n    }\r\n    createFilteredMessageReader(reader) {\r\n        return new RpcUtils_1.WrappedMessageReader(reader, (msg) => RpcServiceHandlerBase.filterMessage(msg, this.rpcReadFilters));\r\n    }\r\n    createFilteredMessageWriter(writer) {\r\n        return new RpcUtils_1.WrappedMessageWriter(writer, (msg) => RpcServiceHandlerBase.filterMessage(msg, this.rpcWriteFilters));\r\n    }\r\n    static filterMessage(msg, filters) {\r\n        for (const filter of filters) {\r\n            msg = filter(msg);\r\n        }\r\n        return msg;\r\n    }\r\n    addProgressFilters() {\r\n        this.rpcReadFilters.push((msg) => {\r\n            const msgObj = msg;\r\n            const requestId = msgObj.id;\r\n            if (typeof requestId !== 'undefined') {\r\n                if (Array.isArray(msgObj.params)) {\r\n                    // This is an incoming request message.\r\n                    // Insert the request ID into the params in case it is needed for progress.\r\n                    msgObj.params.splice(0, 0, requestId);\r\n                }\r\n                else if (typeof msgObj.result !== 'undefined' ||\r\n                    typeof msgObj.error !== 'undefined') {\r\n                    // This is an incoming response message.\r\n                    // Unregister any progress handler for the response's request ID.\r\n                    this.progressHandlers.delete(requestId);\r\n                }\r\n            }\r\n            else if (msgObj.method === exports.methodProgress) {\r\n                let progressArgs = msgObj.params;\r\n                if (progressArgs.id === undefined) {\r\n                    progressArgs = msgObj.params[0];\r\n                }\r\n                const progress = this.progressHandlers.get(progressArgs.id);\r\n                if (progress) {\r\n                    progress.report(progressArgs.value, progressArgs.id);\r\n                }\r\n            }\r\n            return msg;\r\n        });\r\n        this.rpcWriteFilters.push((msg) => {\r\n            const msgObj = msg;\r\n            const requestId = msgObj.id;\r\n            const params = msgObj.params;\r\n            if (typeof requestId !== 'undefined' &&\r\n                params &&\r\n                params.progress &&\r\n                typeof params.progress.report === 'function') {\r\n                // An outgoing message has a progress handler attached to the params.\r\n                // Register the progress handler for the request ID.\r\n                this.progressHandlers.set(msgObj.id, msgObj.params.progress);\r\n                // Unregister the progress handler when the request is cancelled.\r\n                const cancellation = params.progress.cancellation;\r\n                if (cancellation) {\r\n                    cancellation.onCancellationRequested(() => {\r\n                        this.progressHandlers.delete(requestId);\r\n                    });\r\n                }\r\n                delete params.progress;\r\n            }\r\n            return msg;\r\n        });\r\n    }\r\n}\r\nexports.RpcServiceHandlerBase = RpcServiceHandlerBase;\r\nclass RpcServiceHandler extends RpcServiceHandlerBase {\r\n    /**\r\n     * Registers an RPC service and returns a disposable registration object.\r\n     * @param service Service instance. The class should implement the service interface.\r\n     * @param serviceInfo Service metadata.\r\n     * @param trace Trace source.\r\n     * @param disposables Collection of disposable objects where the registration object will be added to.\r\n     */\r\n    registerRpcService(service, serviceInfo, contextMethods, strict) {\r\n        if (!service) {\r\n            throw new Error('service argument is missing or undefined');\r\n        }\r\n        if (!serviceInfo) {\r\n            throw new Error('serviceInfo argument is missing or undefined');\r\n        }\r\n        if (contextMethods &&\r\n            contextMethods.filter((method) => serviceInfo.methods.indexOf(method) < 0).length > 0) {\r\n            throw new Error('invalid context method');\r\n        }\r\n        const serviceName = serviceInfo.name;\r\n        if (!serviceName) {\r\n            throw new Error('serviceInfo.serviceName is empty or undefined');\r\n        }\r\n        let isServiceActive = true;\r\n        const addedRequestMethods = new Set();\r\n        const addedNotificationMethods = new Map();\r\n        let eventDisposables = [];\r\n        const result = {\r\n            dispose: () => {\r\n                isServiceActive = false;\r\n                for (const d of eventDisposables) {\r\n                    d.dispose();\r\n                }\r\n                eventDisposables = [];\r\n                for (const handlerName of addedRequestMethods) {\r\n                    this.removeRequestMethod(handlerName);\r\n                }\r\n                addedRequestMethods.clear();\r\n                for (const [handlerName, cookie] of addedNotificationMethods) {\r\n                    this.removeNotificationHandler(handlerName, cookie);\r\n                }\r\n                addedNotificationMethods.clear();\r\n            },\r\n        };\r\n        const restrictedHandlers = service[RESTRICTED_HANDLERS_FIELD];\r\n        try {\r\n            for (const method of serviceInfo.methods) {\r\n                const handlerName = `${serviceName}.${method}`;\r\n                const restrictedHandler = restrictedHandlers && restrictedHandlers.get(method);\r\n                if (restrictedHandler) {\r\n                    this.addRequestMethodWithContext(handlerName, (...args) => restrictedHandler.apply(service, args));\r\n                    addedRequestMethods.add(handlerName);\r\n                    continue;\r\n                }\r\n                const impl = service[method] || service[method + 'Async'];\r\n                if (typeof impl !== 'function') {\r\n                    if (strict || strict === undefined) {\r\n                        throw new Error(`Object ${serviceInfo.name} does not implement method '${method}' of service '${serviceName}'.`);\r\n                    }\r\n                    else {\r\n                        continue;\r\n                    }\r\n                }\r\n                if (contextMethods && contextMethods.indexOf(method) >= 0) {\r\n                    this.addRequestMethodWithContext(handlerName, (...args) => impl.apply(service, args));\r\n                }\r\n                else {\r\n                    this.addRequestMethod(handlerName, (...args) => impl.apply(service, args));\r\n                }\r\n                addedRequestMethods.add(handlerName);\r\n            }\r\n            if (serviceInfo.voidMethods) {\r\n                for (const method of serviceInfo.voidMethods) {\r\n                    const handlerName = `${serviceName}.${method}`;\r\n                    if (restrictedHandlers && restrictedHandlers.get(method)) {\r\n                        throw new Error(`Restricted operation check is not supported yet for notification methods. Object ${serviceInfo.name} restricts notification '${method}' of service '${serviceName}'.`);\r\n                    }\r\n                    const impl = this[method] || service[method];\r\n                    if (typeof impl !== 'function') {\r\n                        if (strict) {\r\n                            throw new Error(`Object ${serviceInfo.name} does not implement notification '${method}' of service '${serviceName}'.`);\r\n                        }\r\n                        else {\r\n                            continue;\r\n                        }\r\n                    }\r\n                    const cookie = this.addNotificationHandler(handlerName, (...args) => impl.apply(service, args));\r\n                    addedNotificationMethods.set(handlerName, cookie);\r\n                }\r\n            }\r\n            if (serviceInfo.events) {\r\n                for (const eventName of serviceInfo.events) {\r\n                    if (!eventName) {\r\n                        continue;\r\n                    }\r\n                    const propertyName = RpcUtils_2.getEventPropertyName(eventName);\r\n                    const event = service[propertyName];\r\n                    if (typeof event === 'function') {\r\n                        event((e) => {\r\n                            if (isServiceActive) {\r\n                                this.sendNotification(this.trace, `${serviceName}.${eventName}`, e).catch((err) => this.trace.error(`Failed to send notification:${serviceName}.${eventName}`, err));\r\n                            }\r\n                        }, eventDisposables);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        catch (err) {\r\n            result.dispose();\r\n            throw err;\r\n        }\r\n        return result;\r\n    }\r\n}\r\nexports.RpcServiceHandler = RpcServiceHandler;\r\n/**\r\n * helper function to add an rpc filter and be able to remove it.\r\n */\r\nfunction addRpcFilter(filters, filter) {\r\n    filters.push(filter);\r\n    return {\r\n        dispose: () => {\r\n            const index = filters.indexOf(filter);\r\n            if (index !== -1) {\r\n                filters.splice(index, 1);\r\n            }\r\n        },\r\n    };\r\n}\r\n//# sourceMappingURL=RpcServiceHandler.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nconst vscs_utils_1 = require(\"@vs/vscs-utils\");\r\nconst vscode_jsonrpc_1 = require(\"vscode-jsonrpc\");\r\nfunction getEventPropertyName(eventName) {\r\n    return `on${eventName.substr(0, 1).toUpperCase()}${eventName.substr(1)}`;\r\n}\r\nexports.getEventPropertyName = getEventPropertyName;\r\n/**\r\n * Hookup all events from a service and invoke a generic listener\r\n * @param service The service instance\r\n * @param eventNames the name of the rpc events to hookup.\r\n * @param listener Callback to invoke when each event is fired.\r\n * @returns A disposable instance to un hookup\r\n */\r\nfunction onAllEvents(service, eventNames, listener) {\r\n    const disposables = [];\r\n    for (const eventName of eventNames) {\r\n        const eventPropertyName = getEventPropertyName(eventName);\r\n        const event = service[eventPropertyName];\r\n        disposables.push(event((e) => listener(eventName, e)));\r\n    }\r\n    return vscs_utils_1.createDisposable(() => {\r\n        disposables.forEach((d) => d.dispose());\r\n    });\r\n}\r\nexports.onAllEvents = onAllEvents;\r\n/**\r\n * notify a set of rpc connections\r\n * @param rpcConnections list of rpc connections.\r\n * @param serviceAndMethod service and method name\r\n * @param e Event argument\r\n * @param logger optional logger instance.\r\n */\r\nfunction notifyConnections(rpcConnections, serviceAndMethod, e, logger) {\r\n    rpcConnections.forEach((mc) => {\r\n        try {\r\n            mc.sendNotification(serviceAndMethod, e);\r\n        }\r\n        catch (err) {\r\n            logger === null || logger === void 0 ? void 0 : logger.error(`failed to send notification method:${serviceAndMethod} index:${rpcConnections.indexOf(mc)}`);\r\n        }\r\n    });\r\n}\r\nexports.notifyConnections = notifyConnections;\r\nclass WrappedMessageReader {\r\n    constructor(messageReader, messageTransformer) {\r\n        this.messageReader = messageReader;\r\n        this.messageTransformer = messageTransformer;\r\n        this.onError = this.messageReader.onError;\r\n        this.onClose = this.messageReader.onClose;\r\n        this.onPartialMessage = this.messageReader.onPartialMessage;\r\n    }\r\n    listen(callback) {\r\n        const wrappedCallback = (msg) => {\r\n            callback(this.messageTransformer(msg));\r\n        };\r\n        this.messageReader.listen(wrappedCallback);\r\n    }\r\n    dispose() {\r\n        this.messageReader.dispose();\r\n    }\r\n}\r\nexports.WrappedMessageReader = WrappedMessageReader;\r\nclass WrappedMessageWriter {\r\n    constructor(messageWriter, messageTransformer) {\r\n        this.messageWriter = messageWriter;\r\n        this.messageTransformer = messageTransformer;\r\n        this.onError = this.messageWriter.onError;\r\n        this.onClose = this.messageWriter.onClose;\r\n    }\r\n    write(msg) {\r\n        this.messageWriter.write(this.messageTransformer(msg));\r\n    }\r\n    dispose() {\r\n        this.messageWriter.dispose();\r\n    }\r\n}\r\nexports.WrappedMessageWriter = WrappedMessageWriter;\r\nclass TimingFilter {\r\n    constructor() {\r\n        // Map from message ids to when the message was received/sent\r\n        this.times = new Map();\r\n    }\r\n    filter(isWrite, msg) {\r\n        if (typeof msg.id !== 'number') {\r\n            return msg;\r\n        }\r\n        if (this.times.has(msg.id)) {\r\n            const duration = Date.now() - this.times.get(msg.id);\r\n            this.times.delete(msg.id);\r\n            // If one of the RPC clients doesn't include timing information (e.g. they are an older version),\r\n            // none of them should to avoid misleading data.\r\n            if (isWrite || typeof msg.times !== 'undefined') {\r\n                msg.times = TimedRpcMessageUtils.addTime(msg.times, duration);\r\n            }\r\n        }\r\n        else {\r\n            this.times.set(msg.id, Date.now());\r\n        }\r\n        return msg;\r\n    }\r\n}\r\nexports.TimingFilter = TimingFilter;\r\n/*\r\nThe \"times\" property on an RPC message is an\r\narray of times in milliseconds taken to send/receive/respond to requests\r\nIncludes times from sending requests to receiving responses and\r\ntime from receiving requests to returning responses.\r\n\r\nE.g. a simple scenario where A makes a request to B:\r\nA sends a request to B and begins timing.\r\nB receives the request and begins timing.\r\nB processes the request.\r\nB is ready to resolve the request, so stops timing, stamps\r\nthe time it took to respond on the response message, and sends the reponse.\r\nA receives the response, stops timing, subtracts off the time taken for B to respond (this time is\r\nincluded in the response message) and adds another item to the list of handling times on the response message.\r\nThe first time in the list of handling times is the amount of time it took B to process the request,\r\nand the second time in the list is the communication latency between A and B.\r\n\r\nIn more complicated scenarios where requests go through multiple clients,\r\nthe list of handling times can be used to find the communication latency between\r\neach RPC client in the chain, and how long processing took at each client.\r\n\r\nIn general, the last client in the chain will only contribute one time to the list:\r\nthe amount of time it took to respond to the request. So this is always\r\nthe first item in the list. Similarly, the first client in the chain (the one that made the initial request)\r\nonly contributes one time to the list: the communication latency between itself and the\r\nfirst client in the chain. So this is always the last item in the list. Intermediate clients contribute 2 times each:\r\nthe first is the communication latency between the client and the next in the chain. The second is the time\r\nit took the client to do any intermediate processing before forwarding the request on to the next client and\r\nreturning the response to the previous client.\r\n\r\nE.g. if times = [a, b, c, d], there were three clients involved in the request. a is the time it took\r\nthe last client to handle the request, b is the communication latency between the second and third client,\r\nc is the time it took the second client from receiving the request from the first client to forward the request\r\nto the third client plus the time from receiving the response from the third client to sending it to the first client,\r\nand d is the communication latency between the first and second client. The full time from the first client\r\nmaking the request to receiving the response is a + b + c + d. In general, the latency of the request is the sum of\r\nevery other item in the list, starting at index 1 (here b + d), and the processing time is the sum of every other item\r\nin the list, starting at index 0 (here a + c).\r\n*/\r\nclass TimedRpcMessageUtils {\r\n    static addTime(times, time) {\r\n        if (typeof times === 'undefined') {\r\n            times = [];\r\n        }\r\n        const timeToAdd = time - TimedRpcMessageUtils.getTotalTime(times);\r\n        times.push(timeToAdd > 0 ? timeToAdd : 0);\r\n        return times;\r\n    }\r\n    // The latency is the sum of every other item in the list of times, starting at index 1.\r\n    // See comment above this class for detailed explanation.\r\n    static getLatency(times) {\r\n        let latency = 0;\r\n        if (times) {\r\n            for (let i = 1; i < times.length; i += 2) {\r\n                latency += times[i];\r\n            }\r\n        }\r\n        return latency;\r\n    }\r\n    // The processing time is the sum of every other item in the list of times, starting at index 0.\r\n    // See comment above this class for detailed explanation.\r\n    static getProcessingTime(times) {\r\n        let processingTime = 0;\r\n        if (times) {\r\n            for (let i = 0; i < times.length; i += 2) {\r\n                processingTime += times[i];\r\n            }\r\n        }\r\n        return processingTime;\r\n    }\r\n    static getTotalTime(times) {\r\n        return (TimedRpcMessageUtils.getLatency(times) + TimedRpcMessageUtils.getProcessingTime(times));\r\n    }\r\n}\r\nexports.TimedRpcMessageUtils = TimedRpcMessageUtils;\r\n/*\r\n    RPC message filter that adds message context to the parameter object of RPC messages\r\n*/\r\nfunction addContextToRpcMessage(msg) {\r\n    if (!msg) {\r\n        return msg;\r\n    }\r\n    const context = msg.context;\r\n    const params = msg.params;\r\n    if (typeof context !== 'object' ||\r\n        typeof params !== 'object' ||\r\n        Array.isArray(params) ||\r\n        params.context) {\r\n        return msg;\r\n    }\r\n    return Object.assign({}, msg, { params: Object.assign({ context }, params) });\r\n}\r\nexports.addContextToRpcMessage = addContextToRpcMessage;\r\nclass RpcRequestsWithContext {\r\n    constructor() {\r\n        this.methods = new Set();\r\n        this.readFilter = this.filterMessage.bind(this);\r\n    }\r\n    add(method) {\r\n        if (method) {\r\n            this.methods.add(method);\r\n        }\r\n    }\r\n    filterMessage(msg) {\r\n        const request = msg;\r\n        if (!request.method || !this.methods.has(request.method)) {\r\n            return msg;\r\n        }\r\n        const context = msg.context || {};\r\n        if (!request.params) {\r\n            request.params = [context];\r\n        }\r\n        else if (Array.isArray(request.params)) {\r\n            request.params.push(context);\r\n        }\r\n        return request;\r\n    }\r\n}\r\nexports.RpcRequestsWithContext = RpcRequestsWithContext;\r\nfunction createMethodNotFoundResponse(method) {\r\n    return new vscode_jsonrpc_1.ResponseError(vscode_jsonrpc_1.ErrorCodes.MethodNotFound, `method:${method} not supported`);\r\n}\r\nexports.createMethodNotFoundResponse = createMethodNotFoundResponse;\r\n//# sourceMappingURL=RpcUtils.js.map","\"use strict\";\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst rpc = __importStar(require(\"vscode-jsonrpc\"));\r\nconst events_1 = require(\"events\");\r\n/**\r\n * Create a duplex rpc stream loopback to connect to rpc connections on the same process.\r\n * @returns the pair of rpc message streams.\r\n */\r\nfunction createDuplexRpcMessageStreams() {\r\n    const readableStream1 = new DuplexReadableStream();\r\n    const writableStream1 = new DuplexWritableStream(readableStream1);\r\n    const readableStream2 = new DuplexReadableStream();\r\n    const writableStream2 = new DuplexWritableStream(readableStream2);\r\n    const messageReader1 = new rpc.StreamMessageReader(readableStream1);\r\n    const messageWriter1 = new rpc.StreamMessageWriter(writableStream1);\r\n    const messageReader2 = new rpc.StreamMessageReader(readableStream2);\r\n    const messageWriter2 = new rpc.StreamMessageWriter(writableStream2);\r\n    return [\r\n        {\r\n            reader: messageReader1,\r\n            writer: messageWriter2,\r\n        },\r\n        {\r\n            reader: messageReader2,\r\n            writer: messageWriter1,\r\n        },\r\n    ];\r\n}\r\nexports.createDuplexRpcMessageStreams = createDuplexRpcMessageStreams;\r\nclass DuplexReadableStream extends events_1.EventEmitter {\r\n}\r\nclass DuplexWritableStream extends events_1.EventEmitter {\r\n    constructor(readableStream) {\r\n        super();\r\n        this.readableStream = readableStream;\r\n    }\r\n    write(str, encoding, cb) {\r\n        this.readableStream.emit('data', str);\r\n        return true;\r\n    }\r\n}\r\n//# sourceMappingURL=createDuplexRpcMessageStreams.js.map","\"use strict\";\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar RpcProxy_1 = require(\"./RpcProxy\");\r\nexports.RpcErrorCodes = RpcProxy_1.RpcErrorCodes;\r\nexports.RpcProxy = RpcProxy_1.RpcProxy;\r\nvar RpcServiceHandler_1 = require(\"./RpcServiceHandler\");\r\nexports.RpcServiceHandler = RpcServiceHandler_1.RpcServiceHandler;\r\nexports.methodProgress = RpcServiceHandler_1.methodProgress;\r\nvar RpcClient_1 = require(\"./RpcClient\");\r\nexports.RpcClient = RpcClient_1.RpcClient;\r\nvar RpcClientProxy_1 = require(\"./RpcClientProxy\");\r\nexports.RpcClientProxy = RpcClientProxy_1.RpcClientProxy;\r\nexports.RpcClientProxyBase = RpcClientProxy_1.RpcClientProxyBase;\r\nvar RpcLoggerAdapter_1 = require(\"./RpcLoggerAdapter\");\r\nexports.RpcLoggerAdapter = RpcLoggerAdapter_1.RpcLoggerAdapter;\r\nvar RpcConnectionErrors_1 = require(\"./RpcConnectionErrors\");\r\nexports.RpcConnectionClosedError = RpcConnectionErrors_1.RpcConnectionClosedError;\r\nexports.RpcConnectionShutdownError = RpcConnectionErrors_1.RpcConnectionShutdownError;\r\nvar RpcServer_1 = require(\"./RpcServer\");\r\nexports.RpcServer = RpcServer_1.RpcServer;\r\nvar RpcMessageWriter_1 = require(\"./RpcMessageWriter\");\r\nexports.RpcMessageWriter = RpcMessageWriter_1.RpcMessageWriter;\r\nvar DataFormat_1 = require(\"./DataFormat\");\r\nexports.DataFormat = DataFormat_1.DataFormat;\r\nexports.dataFormat = DataFormat_1.dataFormat;\r\nvar RpcProxyCache_1 = require(\"./RpcProxyCache\");\r\nexports.RpcProxyCache = RpcProxyCache_1.RpcProxyCache;\r\nconst rpcUtils = __importStar(require(\"./RpcUtils\"));\r\nexports.rpcUtils = rpcUtils;\r\n__export(require(\"./sendRpcRequest\"));\r\nvar createDuplexRpcMessageStreams_1 = require(\"./createDuplexRpcMessageStreams\");\r\nexports.createDuplexRpcMessageStreams = createDuplexRpcMessageStreams_1.createDuplexRpcMessageStreams;\r\nexports.rpcMaxMessageSize = 10 * 1024 * 1024; // 10 MB\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vso_logging_1 = require(\"@vs/vso-logging\");\r\n/**\r\n * Return the 'raw' message parametes array from a previously filtered array\r\n * @param filteredRcpParams The filtered rpc params\r\n * @returns raw rpc parameters without any 'injected' parameter.\r\n */\r\nfunction getRawRpcParameters(filteredRcpParams) {\r\n    const rpcParams = [...filteredRcpParams];\r\n    normalizeRpcParameters(rpcParams);\r\n    return rpcParams;\r\n}\r\nexports.getRawRpcParameters = getRawRpcParameters;\r\nfunction normalizeRpcParameters(rpcParams) {\r\n    // Note: we need to remove the injected parameter 0 that is coming from RpcServiceHandler\r\n    const requestId = rpcParams.splice(0, 1)[0];\r\n    // Note: json-rpc lib will inject a Cancellation token also at the end. Next block\r\n    // will attempt to remove it since we want a pure rpc message to flow.\r\n    if (rpcParams.length > 0) {\r\n        const cancellationTokenParam = rpcParams[rpcParams.length - 1];\r\n        if (cancellationTokenParam.constructor &&\r\n            cancellationTokenParam.constructor.name === 'MutableToken') {\r\n            const token = rpcParams.splice(rpcParams.length - 1, 1)[0];\r\n            return [requestId, token];\r\n        }\r\n    }\r\n    return [requestId, null];\r\n}\r\nexports.normalizeRpcParameters = normalizeRpcParameters;\r\n/**\r\n * send an rpc request to a message connection from an rpc service handler.\r\n */\r\nasync function sendRpcRequest(messageConnection, method, filteredRcpParams, logger) {\r\n    try {\r\n        const start = Date.now();\r\n        const result = await messageConnection.sendRequest(method, getRawRpcParameters(filteredRcpParams));\r\n        const time = (Date.now() - start).toFixed(1);\r\n        logger === null || logger === void 0 ? void 0 : logger.info(`remote rpc request method: \"${method}\" result: \"${vso_logging_1.TraceFormat.stringify(result)}\r\n            t:${time}`);\r\n        return result;\r\n    }\r\n    catch (err) {\r\n        logger === null || logger === void 0 ? void 0 : logger.error(`failed to handle request for method:${method}`, err);\r\n        throw err;\r\n    }\r\n}\r\nexports.sendRpcRequest = sendRpcRequest;\r\n//# sourceMappingURL=sendRpcRequest.js.map","\"use strict\";\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vso_rpc_1 = require(\"@vs/vso-rpc\");\r\nconst ssh = __importStar(require(\"@vs/vs-ssh\"));\r\nconst rpc = __importStar(require(\"vscode-jsonrpc\"));\r\nclass MultiChannelRpcServer extends vso_rpc_1.RpcServer {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.acceptedStreams = new Map();\r\n        this.onRpcConnectionDisposedEmitter = new rpc.Emitter();\r\n        this.onRpcConnectionDisposed = this.onRpcConnectionDisposedEmitter.event;\r\n    }\r\n    async acceptStream(transportStream) {\r\n        const multiChannelStream = new ssh.MultiChannelStream(transportStream);\r\n        const sshChannel = await multiChannelStream.acceptChannel();\r\n        const rpcMessageStream = new ssh.SshRpcMessageStream(sshChannel);\r\n        const rpcConnectionInfo = this.acceptRpcMessageStream(rpcMessageStream);\r\n        const rpcConnection = rpcConnectionInfo[0];\r\n        this.acceptedStreams.set(rpcConnection, multiChannelStream);\r\n        const disposable = transportStream.closed(() => {\r\n            // Note: on Windows we may receive the closed event twice due to an 'error' event\r\n            // or a 'closed' event.\r\n            disposable.dispose();\r\n            rpcConnection.dispose();\r\n        });\r\n        // if this rpc connection is closed we need to remove\r\n        // the joined connection if exists\r\n        rpcConnection.onDispose(async (e) => {\r\n            disposable.dispose();\r\n            this.acceptedStreams.delete(rpcConnection);\r\n            this.onRpcConnectionDisposedEmitter.fire(rpcConnection);\r\n            // if we have the stream wasn't closed we should\r\n            if (!transportStream.isDisposed) {\r\n                await transportStream.close();\r\n            }\r\n        });\r\n        return rpcConnectionInfo;\r\n    }\r\n    /**\r\n     * Return the current multi channel stream request\r\n     */\r\n    getMultiChannelStream(rpcConnection) {\r\n        return this.acceptedStreams.get(rpcConnection);\r\n    }\r\n}\r\nexports.MultiChannelRpcServer = MultiChannelRpcServer;\r\n//# sourceMappingURL=MultiChannelRpcServer.js.map","\"use strict\";\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vso_rpc_1 = require(\"@vs/vso-rpc\");\r\nconst vscs_utils_1 = require(\"@vs/vscs-utils\");\r\nconst ssh = __importStar(require(\"@vs/vs-ssh\"));\r\nconst vscs_utils_2 = require(\"@vs/vscs-utils\");\r\nconst rpc = __importStar(require(\"vscode-jsonrpc\"));\r\nconst reconnectTimeout = 1000 * 60;\r\n/**\r\n * Ssh rpc server class.\r\n */\r\nclass SshRpcServer extends vso_rpc_1.RpcServer {\r\n    constructor(sshPrivateKeys, logger) {\r\n        super(logger);\r\n        this.sshPrivateKeys = sshPrivateKeys;\r\n        this.rpcServerProviders = [];\r\n        this.reconnectableSessions = [];\r\n        this.rpcSessions = new Map();\r\n        this.onSessionClosedEmitter = new rpc.Emitter();\r\n        this.onUserAuthenticateCallbacks = new vscs_utils_2.CallbackContainer();\r\n        this.sshServerSessionNumber = 0;\r\n        this.onSessionClosed = this.onSessionClosedEmitter.event;\r\n    }\r\n    dispose(reason) {\r\n        this.reconnectableSessions.forEach((item) => item.dispose());\r\n        return super.dispose(reason);\r\n    }\r\n    async acceptConnections(cancellationToken) {\r\n        await Promise.all(this.rpcServerProviders.map((p) => p.acceptConnections(cancellationToken)));\r\n    }\r\n    registerRpcServerProvider(rpcServerProvider) {\r\n        this.rpcServerProviders.push(rpcServerProvider);\r\n        const onRpcStreamJoinedDisposable = rpcServerProvider.onRpcStreamJoined((e) => {\r\n            this.acceptRpcStream(rpcServerProvider.name, e).catch((err) => {\r\n                this.trace.error('Failed to accept rpc stream', err);\r\n            });\r\n        });\r\n        return {\r\n            dispose: async () => {\r\n                this.trace.info(`unregister rpc server provider:${rpcServerProvider.name}`);\r\n                onRpcStreamJoinedDisposable.dispose();\r\n                const index = this.rpcServerProviders.indexOf(rpcServerProvider);\r\n                if (index !== -1) {\r\n                    this.rpcServerProviders.splice(index, 1);\r\n                }\r\n                if (typeof rpcServerProvider.dispose === 'function') {\r\n                    this.trace.verbose(`dispose rpc server provider:${rpcServerProvider.name}`);\r\n                    await rpcServerProvider.dispose();\r\n                }\r\n            },\r\n        };\r\n    }\r\n    onUserAuthenticate(callback) {\r\n        return this.onUserAuthenticateCallbacks.add(callback);\r\n    }\r\n    /**\r\n     * Close the ssh server session associated with an rpc connection.\r\n     * @param rpcMessageConnection the rpc message connection using the ssh session channel\r\n     */\r\n    async closeSshSession(rpcMessageConnection) {\r\n        const sshServerSession = this.rpcSessions.get(rpcMessageConnection);\r\n        if (sshServerSession) {\r\n            await sshServerSession.close(ssh.SshDisconnectReason.byApplication);\r\n        }\r\n    }\r\n    async acceptRpcStream(providerName, stream) {\r\n        const sshChannel = await createServerSession(stream, this.sshPrivateKeys, this.trace, async (userToken) => {\r\n            for (const callback of this.onUserAuthenticateCallbacks.items) {\r\n                const result = await callback(userToken);\r\n                if (result !== undefined) {\r\n                    return result;\r\n                }\r\n            }\r\n        }, this.reconnectableSessions);\r\n        const sshServerSessionNumber = ++this.sshServerSessionNumber;\r\n        this.trace.verbose(`Created ssh server session:${sshServerSessionNumber} for provider:${providerName}`);\r\n        const sshServerSession = sshChannel.session;\r\n        let rpcMessageConnection;\r\n        const onRpcSessionClosed = (reason) => {\r\n            this.trace.verbose(`ssh server session:${sshServerSessionNumber} closed reason:${reason}`);\r\n            this.onSessionClosedEmitter.fire(rpcMessageConnection);\r\n            this.rpcSessions.delete(rpcMessageConnection);\r\n        };\r\n        sshServerSession.onDisconnected(async (e) => {\r\n            this.trace.info(`Disconnected server session:${sshServerSessionNumber} waiting to reconnect.`);\r\n            let reconnected = false;\r\n            sshServerSession.onReconnected((reconnectedEvent) => {\r\n                this.trace.info(`Reconnected server session:${sshServerSessionNumber}`);\r\n                reconnected = true;\r\n            });\r\n            await vscs_utils_1.wait(reconnectTimeout);\r\n            if (!reconnected) {\r\n                this.trace.info(`Closing disconnected server session:${sshServerSessionNumber} because the client ` +\r\n                    'has not reconnected within the timeout.');\r\n                await sshServerSession.close(ssh.SshDisconnectReason.connectionLost);\r\n                onRpcSessionClosed(ssh.SshDisconnectReason.connectionLost);\r\n            }\r\n        });\r\n        const rpcMessageStream = new ssh.SshRpcMessageStream(sshChannel);\r\n        rpcMessageConnection = this.acceptRpcMessageStream(rpcMessageStream)[0];\r\n        rpcMessageConnection.listen();\r\n        this.rpcSessions.set(rpcMessageConnection, sshServerSession);\r\n        sshServerSession.onClosed((e) => onRpcSessionClosed(e.reason));\r\n    }\r\n}\r\nexports.SshRpcServer = SshRpcServer;\r\nfunction createSshServerSession(reconnectableSessions) {\r\n    const config = new ssh.SshSessionConfiguration();\r\n    config.keyExchangeAlgorithms.splice(0);\r\n    config.keyExchangeAlgorithms.push(ssh.SshAlgorithms.keyExchange.ecdhNistp384Sha384);\r\n    config.keyExchangeAlgorithms.push(ssh.SshAlgorithms.keyExchange.ecdhNistp256Sha256);\r\n    config.keyExchangeAlgorithms.push(ssh.SshAlgorithms.keyExchange.dhGroup14Sha256);\r\n    config.protocolExtensions.push(ssh.SshProtocolExtensionNames.sessionReconnect);\r\n    config.protocolExtensions.push(ssh.SshProtocolExtensionNames.sessionLatency);\r\n    return new ssh.SshServerSession(config, reconnectableSessions);\r\n}\r\n/**\r\n * Create a server ssh channel\r\n */\r\nasync function createServerSession(socketStream, privateKeys, logger, authenticationCallback, reconnectableSessions) {\r\n    logger.verbose('Created socket stream');\r\n    const sshServerSession = await createSshServerSession(reconnectableSessions);\r\n    logger.verbose('created SSH server session');\r\n    sshServerSession.credentials = { publicKeys: privateKeys };\r\n    sshServerSession.onAuthenticating((e) => {\r\n        // Password should be a Cascade token.\r\n        const userToken = e.password;\r\n        logger.verbose('authenticating request');\r\n        if (userToken !== null) {\r\n            e.authenticationPromise = authenticationCallback(userToken);\r\n        }\r\n    });\r\n    sshServerSession.onChannelOpening((e) => {\r\n        if (sshServerSession.principal === undefined) {\r\n            logger.error('unauthenticated request');\r\n            e.failureReason = ssh.SshChannelOpenFailureReason.administrativelyProhibited;\r\n            e.failureDescription = 'Not authenticated';\r\n        }\r\n    });\r\n    const disposable = sshServerSession.onChannelOpening((e) => {\r\n        e.channel.onRequest((requestEvent) => {\r\n            requestEvent.isAuthorized = requestEvent.requestType === 'json-rpc';\r\n            logger.info('rpc channel opening request ' + requestEvent.requestType);\r\n            disposable.dispose();\r\n        });\r\n    });\r\n    await sshServerSession.connect(socketStream);\r\n    logger.verbose('connected to server session');\r\n    const sshChannel = await sshServerSession.acceptChannel();\r\n    logger.verbose(`opened channel ${sshChannel.channelId}`);\r\n    return sshChannel;\r\n}\r\n//# sourceMappingURL=SshRpcServer.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst createDuplexStreams_1 = require(\"./createDuplexStreams\");\r\nconst createMultiChannelRpcClient_1 = require(\"./createMultiChannelRpcClient\");\r\nasync function createDuplexMultiChannelRpcClient(rcpServer, logger) {\r\n    const [stream1, stream2] = createDuplexStreams_1.createDuplexStreams();\r\n    const serverPromise = rcpServer.acceptStream(stream1);\r\n    const multiChannelRpcClientPromise = createMultiChannelRpcClient_1.createMultiChannelRpcClient(stream2, logger);\r\n    const [messageConnectionInfo, rpcClient] = await Promise.all([\r\n        serverPromise,\r\n        multiChannelRpcClientPromise,\r\n    ]);\r\n    messageConnectionInfo[0].listen();\r\n    return rpcClient;\r\n}\r\nexports.createDuplexMultiChannelRpcClient = createDuplexMultiChannelRpcClient;\r\n//# sourceMappingURL=createDuplexMultiChannelRpcClient.js.map","\"use strict\";\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst ssh = __importStar(require(\"@vs/vs-ssh\"));\r\nfunction createDuplexStreams() {\r\n    return DuplexStream.createStreams();\r\n}\r\nexports.createDuplexStreams = createDuplexStreams;\r\nclass DuplexStream extends ssh.BaseStream {\r\n    constructor() {\r\n        super();\r\n    }\r\n    static createStreams() {\r\n        const stream1 = new DuplexStream();\r\n        const stream2 = new DuplexStream();\r\n        stream1.other = stream2;\r\n        stream2.other = stream1;\r\n        return [stream1, stream2];\r\n    }\r\n    async write(data, cancellation) {\r\n        if (!data)\r\n            throw new TypeError('Data is required.');\r\n        this.other.onData(Buffer.from(data));\r\n        return;\r\n    }\r\n    async close(error, cancellation) {\r\n        if (!error) {\r\n            this.dispose();\r\n            this.other.onEnd();\r\n            this.other.dispose();\r\n        }\r\n        else {\r\n            this.onError(error);\r\n            this.dispose();\r\n            this.other.onError(error);\r\n            this.other.dispose();\r\n        }\r\n        return;\r\n    }\r\n    dispose() {\r\n        super.dispose();\r\n        if (!this.other.isDisposed) {\r\n            this.other.onError(new Error('Stream disposed.'));\r\n            this.other.dispose();\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=createDuplexStreams.js.map","\"use strict\";\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst ssh = __importStar(require(\"@vs/vs-ssh\"));\r\nconst vso_rpc_1 = require(\"@vs/vso-rpc\");\r\nasync function createMultiChannelRpcClient(transportStream, logger, listen = true) {\r\n    const multiChannelStream = new ssh.MultiChannelStream(transportStream);\r\n    const sshChannel = await multiChannelStream.openChannel();\r\n    const rcpClient = new MultiChannelRpcClient(multiChannelStream, sshChannel, logger);\r\n    rcpClient.addToDisposables(multiChannelStream, {\r\n        dispose: () => transportStream.close(),\r\n    });\r\n    if (listen) {\r\n        rcpClient.rpcConnection.listen();\r\n    }\r\n    return rcpClient;\r\n}\r\nexports.createMultiChannelRpcClient = createMultiChannelRpcClient;\r\nclass MultiChannelRpcClient extends vso_rpc_1.RpcClient {\r\n    constructor(multiChannelStream, sshChannel, logger) {\r\n        super({}, logger);\r\n        this.multiChannelStream = multiChannelStream;\r\n        const rpcStream = new ssh.SshRpcMessageStream(sshChannel);\r\n        this.setConnection(this.createRpcConnection(rpcStream, logger));\r\n    }\r\n    get rpcConnection() {\r\n        return this.connection;\r\n    }\r\n}\r\n//# sourceMappingURL=createMultiChannelRpcClient.js.map","\"use strict\";\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar SshRpcServer_1 = require(\"./SshRpcServer\");\r\nexports.SshRpcServer = SshRpcServer_1.SshRpcServer;\r\nvar MultiChannelRpcServer_1 = require(\"./MultiChannelRpcServer\");\r\nexports.MultiChannelRpcServer = MultiChannelRpcServer_1.MultiChannelRpcServer;\r\nvar createDuplexStreams_1 = require(\"./createDuplexStreams\");\r\nexports.createDuplexStreams = createDuplexStreams_1.createDuplexStreams;\r\nvar createDuplexMultiChannelRpcClient_1 = require(\"./createDuplexMultiChannelRpcClient\");\r\nexports.createDuplexMultiChannelRpcClient = createDuplexMultiChannelRpcClient_1.createDuplexMultiChannelRpcClient;\r\n__export(require(\"./createMultiChannelRpcClient\"));\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar FaultType;\r\n(function (FaultType) {\r\n    FaultType[FaultType[\"Error\"] = 0] = \"Error\";\r\n    FaultType[FaultType[\"User\"] = 1] = \"User\";\r\n    FaultType[FaultType[\"Unknown\"] = 2] = \"Unknown\";\r\n    FaultType[FaultType[\"NonBlockingFault\"] = 3] = \"NonBlockingFault\";\r\n    FaultType[FaultType[\"UserCancelled\"] = 4] = \"UserCancelled\";\r\n    FaultType[FaultType[\"ByDesign\"] = 5] = \"ByDesign\";\r\n})(FaultType = exports.FaultType || (exports.FaultType = {}));\r\n//# sourceMappingURL=FaultType.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Result;\r\n(function (Result) {\r\n    Result[Result[\"Cancel\"] = 0] = \"Cancel\";\r\n    Result[Result[\"Success\"] = 1] = \"Success\";\r\n    Result[Result[\"Failure\"] = 2] = \"Failure\";\r\n    Result[Result[\"UserFailure\"] = 3] = \"UserFailure\";\r\n    Result[Result[\"IndeterminateFailure\"] = 4] = \"IndeterminateFailure\";\r\n    Result[Result[\"NonBlockingFailure\"] = 5] = \"NonBlockingFailure\";\r\n    Result[Result[\"ByDesignFailure\"] = 6] = \"ByDesignFailure\";\r\n})(Result = exports.Result || (exports.Result = {}));\r\n//# sourceMappingURL=Result.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst uuid = require(\"uuid\");\r\nconst vso_logging_1 = require(\"@vs/vso-logging\");\r\nconst FaultType_1 = require(\"./FaultType\");\r\nconst TelemetryStrings_1 = require(\"./TelemetryStrings\");\r\nconst vscode_jsonrpc_1 = require(\"vscode-jsonrpc\");\r\nconst Result_1 = require(\"./Result\");\r\nlet sequence = 0;\r\nfunction setSequence() {\r\n    sequence += 1;\r\n    return sequence;\r\n}\r\nclass TelemetryClass {\r\n    constructor() {\r\n        this.telemetryEvents = {};\r\n        this.filters = [];\r\n        this.canSendSensitiveFlag = false;\r\n    }\r\n    get reporter() {\r\n        return this.telemetryReporter;\r\n    }\r\n    get canSendSensitiveInformation() {\r\n        return this.canSendSensitiveFlag;\r\n    }\r\n    init(reporter, featureName, canSendSensitiveInformation, faultSendCallbackParam) {\r\n        this.telemetryReporter = reporter;\r\n        this.canSendSensitiveFlag = canSendSensitiveInformation;\r\n        TelemetryStrings_1.TelemetryPropertyNames.FEATURE_NAME = featureName || '';\r\n        if (faultSendCallbackParam) {\r\n            faultSendCallback = faultSendCallbackParam;\r\n        }\r\n        this.contextProperties = {};\r\n        this.addContextProperty(TelemetryStrings_1.TelemetryPropertyNames.SESSION_ID, uuid());\r\n    }\r\n    addFilter(filter) {\r\n        this.filters.push(filter);\r\n    }\r\n    removeFilter(filter) {\r\n        const idx = this.filters.indexOf(filter);\r\n        if (idx >= 0) {\r\n            this.filters.splice(idx, 1);\r\n        }\r\n    }\r\n    addContextProperties(props, isPII = false) {\r\n        for (const [key, value] of Object.entries(props)) {\r\n            this.addContextProperty(key, value, isPII);\r\n        }\r\n        return this;\r\n    }\r\n    addContextProperty(property, value, isPII = false) {\r\n        // no need to set `undefined` values\r\n        if (value === undefined) {\r\n            return this;\r\n        }\r\n        const valueString = String(value);\r\n        if (isPII && !this.canSendSensitiveInformation) {\r\n            this.contextProperties[property] = vso_logging_1.Privacy.getShortHash(valueString);\r\n        }\r\n        else {\r\n            this.contextProperties[property] = valueString;\r\n        }\r\n        return this;\r\n    }\r\n    removeContextProperty(property) {\r\n        delete this.contextProperties[property];\r\n    }\r\n    getContextProperty(property) {\r\n        return this.contextProperties[property];\r\n    }\r\n    addContextPropertiesToObject(properties) {\r\n        return Object.assign({}, this.contextProperties, properties);\r\n    }\r\n    filterAndSendTelemetryEvent(eventName, callback, properties, measures) {\r\n        if (!this.reporter) {\r\n            // init not called\r\n            return;\r\n        }\r\n        const augmentedMeasures = Object.assign({}, measures);\r\n        const augmentedProperties = this.addContextPropertiesToObject(properties);\r\n        for (const filter of this.filters) {\r\n            if (!filter.shouldSend(eventName, augmentedProperties, augmentedMeasures)) {\r\n                return;\r\n            }\r\n        }\r\n        augmentedMeasures[TelemetryStrings_1.TelemetryPropertyNames.SEQUENCE_NUMBER] = setSequence();\r\n        callback(augmentedProperties, augmentedMeasures);\r\n    }\r\n    sendTelemetryEvent(eventName, properties, measures) {\r\n        const cb = (augmentedProperties, augmentedMeasures) => this.reporter.sendTelemetryEvent(eventName, augmentedProperties, augmentedMeasures);\r\n        this.filterAndSendTelemetryEvent(eventName, cb, properties, measures);\r\n    }\r\n    sendTelemetryErrorEvent(eventName, properties, measures, errorProps) {\r\n        const cb = (augmentedProperties, augmentedMeasures) => this.reporter.sendTelemetryErrorEvent(eventName, augmentedProperties, augmentedMeasures, errorProps);\r\n        this.filterAndSendTelemetryEvent(eventName, cb, properties, measures);\r\n    }\r\n    sendFault(eventName, type, details, exception, correlatedEvent) {\r\n        (new Fault(eventName, type, details, exception, correlatedEvent)).send();\r\n    }\r\n    startTimedEvent(eventName, correlate = false) {\r\n        const timedEvent = new TimedEvent(eventName, correlate);\r\n        // save the event to telemetry events queue\r\n        this.telemetryEvents[timedEvent.id] = timedEvent;\r\n        return timedEvent;\r\n    }\r\n    setCorrelationEvent(correlationEvent) {\r\n        this.correlationEvent = correlationEvent;\r\n    }\r\n    removeCorrelationEvent(correlationEvent) {\r\n        if (this.correlationEvent === correlationEvent) {\r\n            this.correlationEvent = undefined;\r\n        }\r\n    }\r\n    correlate(telemetryEvent) {\r\n        if (this.correlationEvent) {\r\n            telemetryEvent.correlateWith(this.correlationEvent);\r\n        }\r\n    }\r\n    async endAllPendingEvents() {\r\n        for (let eventId of Object.keys(this.telemetryEvents)) {\r\n            const event = this.telemetryEvents[eventId];\r\n            await event.endIfNotSent();\r\n            delete this.telemetryEvents[eventId];\r\n        }\r\n    }\r\n    async dispose() {\r\n        await this.reporter.dispose();\r\n    }\r\n}\r\nexports.TelemetryClass = TelemetryClass;\r\n// tslint:disable-next-line: variable-name\r\nconst Telemetry = new TelemetryClass();\r\nexports.Telemetry = Telemetry;\r\nlet faultSendCallback;\r\nclass TelemetryEvent {\r\n    constructor(eventName, correlate = false) {\r\n        this.isSent = false;\r\n        this.id = uuid();\r\n        this.eventName = eventName;\r\n        this.properties = {};\r\n        this.measures = {};\r\n        this.correlationId = uuid();\r\n        if (correlate) {\r\n            Telemetry.correlate(this);\r\n        }\r\n    }\r\n    static create(property, data) {\r\n        const correlate = data ? !!data.correlate : false;\r\n        const telemetryEvent = new TelemetryEvent(property, correlate);\r\n        if (data.properties) {\r\n            Object.keys(data.properties)\r\n                .forEach(key => telemetryEvent.addProperty(TelemetryStrings_1.TelemetryPropertyNames.FEATURE_NAME + key, data.properties[key]));\r\n        }\r\n        if (data.measures) {\r\n            Object.keys(data.measures)\r\n                .forEach(key => telemetryEvent.addMeasure(TelemetryStrings_1.TelemetryPropertyNames.FEATURE_NAME + key, data.measures[key]));\r\n        }\r\n        return telemetryEvent;\r\n    }\r\n    addProperty(property, value, isPII = false, unkeyed = false) {\r\n        // no need to set `undefined` values\r\n        if (value === undefined) {\r\n            return this;\r\n        }\r\n        const valueString = String(value);\r\n        if (isPII && !Telemetry.canSendSensitiveInformation) {\r\n            this.properties[property] = vso_logging_1.Privacy.getHash(valueString, unkeyed);\r\n        }\r\n        else {\r\n            this.properties[property] = valueString;\r\n        }\r\n        return this;\r\n    }\r\n    addProperties(props, isPII = true) {\r\n        for (let [key, value] of Object.entries(props)) {\r\n            this.addProperty(key, value, isPII);\r\n        }\r\n        return this;\r\n    }\r\n    addPropertyIfNotExists(property, value, isPII = false, unkeyed = false) {\r\n        if (!this.propertyExists(property)) {\r\n            this.addProperty(property, value, isPII, unkeyed);\r\n        }\r\n        return this;\r\n    }\r\n    propertyExists(property) {\r\n        return property in this.properties;\r\n    }\r\n    addMeasure(measure, value) {\r\n        this.measures[measure] = value;\r\n    }\r\n    addMeasureIfNotExists(measure, value) {\r\n        if (this.measures[measure] === undefined) {\r\n            this.addMeasure(measure, value);\r\n        }\r\n    }\r\n    getCorrelationId() {\r\n        return this.correlationId;\r\n    }\r\n    correlateWith(otherEvent) {\r\n        this.correlationId = otherEvent.getCorrelationId();\r\n        return this;\r\n    }\r\n    correlateWithId(correlationId) {\r\n        this.correlationId = correlationId;\r\n        return this;\r\n    }\r\n    addCommonProperties() {\r\n        this.addProperty(TelemetryStrings_1.TelemetryPropertyNames.EVENT_ID, this.id);\r\n        this.addProperty(TelemetryStrings_1.TelemetryPropertyNames.CORRELATION_ID, this.correlationId);\r\n    }\r\n    send() {\r\n        this.addCommonProperties();\r\n        Telemetry.sendTelemetryEvent(this.eventName, this.properties, this.measures);\r\n        this.isSent = true;\r\n    }\r\n    sendAsError(errorProps) {\r\n        this.addCommonProperties();\r\n        Telemetry.sendTelemetryErrorEvent(this.eventName, this.properties, this.measures, errorProps);\r\n        this.isSent = true;\r\n    }\r\n}\r\nexports.TelemetryEvent = TelemetryEvent;\r\nclass Fault extends TelemetryEvent {\r\n    constructor(eventName, type, details, exception, correlatedEvent) {\r\n        super(eventName);\r\n        this.exception = exception;\r\n        this.addProperty(TelemetryStrings_1.TelemetryPropertyNames.FAULT_TYPE, FaultType_1.FaultType[type]);\r\n        if (details) {\r\n            this.addProperty(TelemetryStrings_1.TelemetryPropertyNames.EVENT_MESSAGE, cleanSensitiveInformation(details));\r\n        }\r\n        let exceptionStack = '';\r\n        if (exception && exception instanceof vscode_jsonrpc_1.ResponseError) {\r\n            if (exception.code && typeof exception.code === 'number') {\r\n                this.addMeasure(TelemetryStrings_1.TelemetryPropertyNames.EVENT_EXCEPTION_CODE, exception.code);\r\n            }\r\n            if (exception.data && typeof exception.data === 'string') {\r\n                // RPC response errors have the remote stack trace in the data property.\r\n                exceptionStack += cleanSensitiveInformation(exception.data) +\r\n                    '\\n   --- End of remote exception stack trace ---\\n';\r\n            }\r\n        }\r\n        if (exception && exception.stack && typeof exception.stack === 'string') {\r\n            exceptionStack += cleanSensitiveInformation(vso_logging_1.errorToString(exception));\r\n        }\r\n        if (!exceptionStack) {\r\n            exceptionStack = 'No Stack';\r\n        }\r\n        this.addProperty(TelemetryStrings_1.TelemetryPropertyNames.EVENT_EXCEPTION_STACK, exceptionStack);\r\n        if (correlatedEvent) {\r\n            this.correlateWith(correlatedEvent);\r\n        }\r\n    }\r\n    async send() {\r\n        let errorProps = [];\r\n        if (faultSendCallback) {\r\n            errorProps = await faultSendCallback(this);\r\n        }\r\n        return super.sendAsError([...errorProps, TelemetryStrings_1.TelemetryPropertyNames.EVENT_MESSAGE, TelemetryStrings_1.TelemetryPropertyNames.EVENT_EXCEPTION_STACK]);\r\n    }\r\n}\r\nexports.Fault = Fault;\r\nclass TimedEvent extends TelemetryEvent {\r\n    constructor(eventName, correlate = false, sendStartEvent = false) {\r\n        super(eventName, correlate);\r\n        this.startTime = (new Date()).getTime();\r\n        this.lastMarkTime = this.startTime;\r\n        TimedEvent.scopeStack.push(this);\r\n        this.addProperty(TelemetryStrings_1.TelemetryPropertyNames.EVENT_CREATION_TIME, new Date().toISOString());\r\n        this.addProperty(TelemetryStrings_1.TelemetryPropertyNames.EVENT_TYPE, TelemetryStrings_1.TelemetryPropertyValues.END);\r\n        if (sendStartEvent) {\r\n            const startEvent = new TelemetryEvent(eventName);\r\n            startEvent.correlateWith(this);\r\n            startEvent.addProperty(TelemetryStrings_1.TelemetryPropertyNames.EVENT_TYPE, TelemetryStrings_1.TelemetryPropertyValues.START);\r\n            startEvent.send();\r\n        }\r\n    }\r\n    markTime(markName, fromStart = false) {\r\n        let currentTime = (new Date()).getTime();\r\n        let duration = fromStart ? (currentTime - this.startTime) : (currentTime - this.lastMarkTime);\r\n        this.lastMarkTime = currentTime;\r\n        this.addMeasure(markName, duration);\r\n        return duration;\r\n    }\r\n    end(result, message, sendNow = true) {\r\n        this.addProperty(TelemetryStrings_1.TelemetryPropertyNames.EVENT_RESULT, Result_1.Result[result]);\r\n        if (message) {\r\n            this.addProperty(TelemetryStrings_1.TelemetryPropertyNames.EVENT_MESSAGE, cleanSensitiveInformation(message));\r\n        }\r\n        const duration = this.markTime(TelemetryStrings_1.TelemetryPropertyNames.EVENT_DURATION, true);\r\n        Telemetry.removeCorrelationEvent(this);\r\n        if (sendNow) {\r\n            this.send();\r\n        }\r\n        for (let i = TimedEvent.scopeStack.length - 1; i >= 0; i--) {\r\n            if (TimedEvent.scopeStack[i] === this) {\r\n                TimedEvent.scopeStack.splice(i, 1);\r\n            }\r\n        }\r\n        return duration;\r\n    }\r\n    async endIfNotSent() {\r\n        if (this.isSent) {\r\n            return;\r\n        }\r\n        await this.end(Result_1.Result.Cancel, 'Completing pending telemetry events.');\r\n    }\r\n}\r\nexports.TimedEvent = TimedEvent;\r\nTimedEvent.scopeStack = [];\r\nfunction removeEmailAddresses(str) {\r\n    return str.replace(/[\\S]+@[\\S]+/gi, '[EMAIL]');\r\n}\r\nfunction cleanSensitiveInformation(str) {\r\n    return str ? removeEmailAddresses(removePath(str, '[PATH]/')) : str;\r\n}\r\nexports.cleanSensitiveInformation = cleanSensitiveInformation;\r\nfunction removePath(filePath, replacementString = '') {\r\n    return filePath.replace(/([A-Za-z]:)?(\\S*[\\\\\\/])+\\S*/gi, (match, drive, directory, offset, whole) => {\r\n        if (/^\\d{1,4}\\/\\d{1,2}\\/\\d{1,4}$/.test(match)) { // This is a date. No need to scrub.\r\n            return match;\r\n        }\r\n        else {\r\n            const driveAndDirectoryLength = (drive ? drive.length : 0) + directory.length;\r\n            const fileName = match.substr(driveAndDirectoryLength);\r\n            return replacementString + fileName;\r\n        }\r\n    });\r\n}\r\nexports.propagateOffsetMarkTime = (markName, markEvent) => {\r\n    for (let i = 0; i < TimedEvent.scopeStack.length; i++) {\r\n        const targetEvent = TimedEvent.scopeStack[i];\r\n        if (targetEvent !== markEvent) {\r\n            targetEvent.markTime(markName);\r\n        }\r\n    }\r\n};\r\n//# sourceMappingURL=Telemetry.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst TelemetryStrings_1 = require(\"./TelemetryStrings\");\r\n// This filter ensures that only one telemetry event with the given\r\n// event name and set of properties is ever sent. This is useful in\r\n// situations where the same event can be sent many times; e.g. exceptions.\r\nclass SendOnceFilter {\r\n    constructor(eventName, distinctProperties = []) {\r\n        this.eventName = eventName;\r\n        this.distinctProperties = distinctProperties;\r\n        this.sentEventsProperties = [];\r\n    }\r\n    shouldSend(eventName, properties, measures) {\r\n        if (eventName === this.eventName) {\r\n            for (const sentProperties of this.sentEventsProperties) {\r\n                if (this.propertySubsetsEqual(properties, sentProperties)) {\r\n                    return false;\r\n                }\r\n            }\r\n            this.sentEventsProperties.push(this.createPropertySubset(properties));\r\n        }\r\n        return true;\r\n    }\r\n    reset() {\r\n        this.sentEventsProperties = [];\r\n    }\r\n    createPropertySubset(properties) {\r\n        const propertySubset = {};\r\n        for (const p of this.distinctProperties) {\r\n            propertySubset[p] = properties[p];\r\n        }\r\n        return propertySubset;\r\n    }\r\n    propertySubsetsEqual(properties1, properties2) {\r\n        for (const p of this.distinctProperties) {\r\n            if (properties1[p] !== properties2[p]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\nexports.SendOnceFilter = SendOnceFilter;\r\nclass SamplingFilter {\r\n    constructor(samplingConfig) {\r\n        this.samplingConfig = samplingConfig;\r\n    }\r\n    shouldSend(eventName, properties, measures) {\r\n        if (!eventName) {\r\n            return true;\r\n        }\r\n        // Check if sampling is enabled for this event\r\n        const sampleRate = this.samplingConfig[eventName];\r\n        if (typeof sampleRate === 'number' && !isNaN(sampleRate)) {\r\n            if (sampleRate === 0 || Math.random() * sampleRate > 1) {\r\n                // The event is disabled (sampleRate is 0) or sampled out\r\n                return false;\r\n            }\r\n            // Include into the sample - add sample rate measure\r\n            measures[TelemetryStrings_1.TelemetryPropertyNames.SAMPLE_RATE] = sampleRate;\r\n        }\r\n        return true;\r\n    }\r\n}\r\nexports.SamplingFilter = SamplingFilter;\r\n//# sourceMappingURL=TelemetryFilters.js.map","\"use strict\";\r\n//\r\n//  Copyright (c) Microsoft Corporation. All rights reserved.\r\n//\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass TelemetryPropertyNames {\r\n    static get FAULT_TYPE() {\r\n        return TelemetryPropertyNames.FEATURE_NAME + 'FaultType';\r\n    }\r\n    static get EVENT_ID() {\r\n        return TelemetryPropertyNames.FEATURE_NAME + 'EventId';\r\n    }\r\n    static get CORRELATION_ID() {\r\n        return TelemetryPropertyNames.FEATURE_NAME + 'CorrelationId';\r\n    }\r\n    static get LOG_LINES() {\r\n        return TelemetryPropertyNames.FEATURE_NAME + 'LogLines';\r\n    }\r\n    static get EVENT_MESSAGE() {\r\n        return TelemetryPropertyNames.FEATURE_NAME + 'Message';\r\n    }\r\n    static get EVENT_EXCEPTION_STACK() {\r\n        return TelemetryPropertyNames.FEATURE_NAME + 'ExceptionStack';\r\n    }\r\n    static get EVENT_RESULT() {\r\n        return TelemetryPropertyNames.FEATURE_NAME + 'Result';\r\n    }\r\n    static get EVENT_TYPE() {\r\n        return TelemetryPropertyNames.FEATURE_NAME + 'Type';\r\n    }\r\n    static get EVENT_DURATION() {\r\n        return TelemetryPropertyNames.FEATURE_NAME + 'Duration';\r\n    }\r\n    static get EVENT_CREATION_TIME() {\r\n        return TelemetryPropertyNames.FEATURE_NAME + 'CreationTime';\r\n    }\r\n    static get SESSION_ID() {\r\n        return TelemetryPropertyNames.FEATURE_NAME + 'SessionId';\r\n    }\r\n    static get EVENT_EXCEPTION_CODE() {\r\n        return TelemetryPropertyNames.FEATURE_NAME + 'ExceptionCode';\r\n    }\r\n    static get SAMPLE_RATE() {\r\n        return TelemetryPropertyNames.FEATURE_NAME + 'SampleRate';\r\n    }\r\n    static get SEQUENCE_NUMBER() {\r\n        return TelemetryPropertyNames.FEATURE_NAME + 'SequenceNumber';\r\n    }\r\n}\r\nexports.TelemetryPropertyNames = TelemetryPropertyNames;\r\nTelemetryPropertyNames.FEATURE_NAME = 'liveshare.';\r\nclass TelemetryPropertyValues {\r\n}\r\nexports.TelemetryPropertyValues = TelemetryPropertyValues;\r\nTelemetryPropertyValues.START = 'start';\r\nTelemetryPropertyValues.END = 'end';\r\n//# sourceMappingURL=TelemetryStrings.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Telemetry_1 = require(\"./Telemetry\");\r\nexports.Telemetry = Telemetry_1.Telemetry;\r\nexports.TelemetryClass = Telemetry_1.TelemetryClass;\r\nexports.TelemetryEvent = Telemetry_1.TelemetryEvent;\r\nexports.Fault = Telemetry_1.Fault;\r\nexports.TimedEvent = Telemetry_1.TimedEvent;\r\nexports.cleanSensitiveInformation = Telemetry_1.cleanSensitiveInformation;\r\nexports.propagateOffsetMarkTime = Telemetry_1.propagateOffsetMarkTime;\r\nvar TelemetryStrings_1 = require(\"./TelemetryStrings\");\r\nexports.TelemetryPropertyNames = TelemetryStrings_1.TelemetryPropertyNames;\r\nvar FaultType_1 = require(\"./FaultType\");\r\nexports.FaultType = FaultType_1.FaultType;\r\nvar Result_1 = require(\"./Result\");\r\nexports.TelemetryResult = Result_1.Result;\r\nvar TelemetryFilters_1 = require(\"./TelemetryFilters\");\r\nexports.SendOnceFilter = TelemetryFilters_1.SendOnceFilter;\r\nexports.SamplingFilter = TelemetryFilters_1.SamplingFilter;\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst os = require(\"os\");\r\nconst appInsights = require(\"applicationinsights\");\r\nclass TelemetryReporter {\r\n    // tslint:disable-next-line\r\n    constructor(key, params, firstParty, logger) {\r\n        this.key = key;\r\n        this.params = params;\r\n        this.logger = logger;\r\n        this.firstParty = false;\r\n        this.firstParty = !!firstParty;\r\n        this.createAppInsightsClient(key);\r\n    }\r\n    createAppInsightsClient(key) {\r\n        //check if another instance is already initialized\r\n        if (appInsights.defaultClient) {\r\n            this.appInsightsClient = new appInsights.TelemetryClient(key);\r\n            // no other way to enable offline mode\r\n            this.appInsightsClient.channel.setUseDiskRetryCaching(true);\r\n        }\r\n        else {\r\n            appInsights.setup(key)\r\n                .setAutoCollectRequests(false)\r\n                .setAutoCollectPerformance(false)\r\n                .setAutoCollectExceptions(false)\r\n                .setAutoCollectDependencies(false)\r\n                .setAutoDependencyCorrelation(false)\r\n                .setAutoCollectConsole(false)\r\n                .setUseDiskRetryCaching(true)\r\n                .start();\r\n            this.appInsightsClient = appInsights.defaultClient;\r\n        }\r\n        this.appInsightsClient.commonProperties = this.getCommonProperties();\r\n        if (this.params.env) {\r\n            this.appInsightsClient.context.tags[this.appInsightsClient.context.keys.userId] = this.params.env.machineId;\r\n            this.appInsightsClient.context.tags[this.appInsightsClient.context.keys.sessionId] = this.params.env.sessionId;\r\n        }\r\n        //check if it's an Asimov key to change the endpoint\r\n        if (key && key.indexOf('AIF-') === 0) {\r\n            this.appInsightsClient.config.endpointUrl = \"https://vortex.data.microsoft.com/collect/v1\";\r\n            this.firstParty = true;\r\n        }\r\n    }\r\n    getCommonProperties() {\r\n        const commonProperties = Object.create(null);\r\n        commonProperties['common.os'] = os.platform();\r\n        commonProperties['common.platformversion'] = (os.release() || '').replace(/^(\\d+)(\\.\\d+)?(\\.\\d+)?(.*)/, '$1$2$3');\r\n        commonProperties['common.extname'] = this.params.name;\r\n        commonProperties['common.extversion'] = this.params.version;\r\n        if (this.params.env) {\r\n            commonProperties['common.vscodemachineid'] = this.params.env.machineId;\r\n            commonProperties['common.vscodesessionid'] = this.params.env.sessionId;\r\n            commonProperties['common.vscodeversion'] = this.params.version;\r\n            commonProperties['common.uikind'] = 'desktop';\r\n            commonProperties['common.remotename'] = this.cleanRemoteName(this.params.env.remoteName);\r\n        }\r\n        return commonProperties;\r\n    }\r\n    cleanRemoteName(remoteName) {\r\n        if (!remoteName) {\r\n            return 'none';\r\n        }\r\n        let ret = 'other';\r\n        // Allowed remote authorities\r\n        ['ssh-remote', 'dev-container', 'attached-container', 'wsl'].forEach((res) => {\r\n            if (remoteName.indexOf(`${res}+`) === 0) {\r\n                ret = res;\r\n            }\r\n        });\r\n        return ret;\r\n    }\r\n    cloneAndChange(obj, change) {\r\n        if (obj === null || typeof obj !== 'object')\r\n            return obj;\r\n        if (typeof change !== 'function')\r\n            return obj;\r\n        const ret = {};\r\n        for (const key in obj) {\r\n            ret[key] = change(key, obj[key]);\r\n        }\r\n        return ret;\r\n    }\r\n    anonymizeFilePaths(stack, anonymizeFilePaths) {\r\n        if (stack === undefined || stack === null) {\r\n            return '';\r\n        }\r\n        const cleanupPatterns = [];\r\n        if (this.params.env) {\r\n            cleanupPatterns.push(new RegExp(this.params.env.appRoot.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), 'gi'));\r\n        }\r\n        if (this.params.extensionPath) {\r\n            cleanupPatterns.push(new RegExp(this.params.extensionPath.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), 'gi'));\r\n        }\r\n        let updatedStack = stack;\r\n        if (anonymizeFilePaths) {\r\n            const cleanUpIndexes = [];\r\n            for (let regexp of cleanupPatterns) {\r\n                while (true) {\r\n                    const result = regexp.exec(stack);\r\n                    if (!result) {\r\n                        break;\r\n                    }\r\n                    cleanUpIndexes.push([result.index, regexp.lastIndex]);\r\n                }\r\n            }\r\n            const nodeModulesRegex = /^[\\\\\\/]?(node_modules|node_modules\\.asar)[\\\\\\/]/;\r\n            const fileRegex = /(file:\\/\\/)?([a-zA-Z]:(\\\\\\\\|\\\\|\\/)|(\\\\\\\\|\\\\|\\/))?([\\w-\\._]+(\\\\\\\\|\\\\|\\/))+[\\w-\\._]*/g;\r\n            let lastIndex = 0;\r\n            updatedStack = '';\r\n            while (true) {\r\n                const result = fileRegex.exec(stack);\r\n                if (!result) {\r\n                    break;\r\n                }\r\n                // Anoynimize user file paths that do not need to be retained or cleaned up.\r\n                if (!nodeModulesRegex.test(result[0]) && cleanUpIndexes.every(([x, y]) => result.index < x || result.index >= y)) {\r\n                    updatedStack += stack.substring(lastIndex, result.index) + '<REDACTED: user-file-path>';\r\n                    lastIndex = fileRegex.lastIndex;\r\n                }\r\n            }\r\n            if (lastIndex < stack.length) {\r\n                updatedStack += stack.substr(lastIndex);\r\n            }\r\n        }\r\n        // sanitize with configured cleanup patterns\r\n        for (let regexp of cleanupPatterns) {\r\n            updatedStack = updatedStack.replace(regexp, '');\r\n        }\r\n        return updatedStack;\r\n    }\r\n    shouldSendErrorTelemetry() {\r\n        return true;\r\n    }\r\n    sendTelemetryEvent(eventName, properties, measurements) {\r\n        if (eventName && this.appInsightsClient) {\r\n            const cleanProperties = this.cloneAndChange(properties, (_key, prop) => this.anonymizeFilePaths(prop, this.firstParty));\r\n            this.appInsightsClient.trackEvent({\r\n                name: `${this.params.name}/${eventName}`,\r\n                properties: cleanProperties,\r\n                measurements: measurements\r\n            });\r\n            if (this.logger) {\r\n                this.logger.info(`telemetry/${eventName} ${JSON.stringify({ properties, measurements })}`);\r\n            }\r\n        }\r\n    }\r\n    sendTelemetryErrorEvent(eventName, properties, measurements, errorProps) {\r\n        if (eventName && this.appInsightsClient) {\r\n            // always clean the properties if first party\r\n            // do not send any error properties if we shouldn't send error telemetry\r\n            // if we have no errorProps, assume all are error props\r\n            const cleanProperties = this.cloneAndChange(properties, (key, prop) => {\r\n                if (this.shouldSendErrorTelemetry()) {\r\n                    return this.anonymizeFilePaths(prop, this.firstParty);\r\n                }\r\n                if (errorProps === undefined || errorProps.indexOf(key) !== -1) {\r\n                    return 'REDACTED';\r\n                }\r\n                return this.anonymizeFilePaths(prop, this.firstParty);\r\n            });\r\n            this.appInsightsClient.trackEvent({\r\n                name: `${this.params.name}/${eventName}`,\r\n                properties: cleanProperties,\r\n                measurements: measurements\r\n            });\r\n            if (this.logger) {\r\n                this.logger.info(`telemetry/${eventName} ${JSON.stringify({ properties, measurements })}`);\r\n            }\r\n        }\r\n    }\r\n    dispose() {\r\n        const flushEventsToAI = new Promise(resolve => {\r\n            if (this.appInsightsClient) {\r\n                this.appInsightsClient.flush({\r\n                    callback: () => {\r\n                        // all data flushed\r\n                        this.appInsightsClient = undefined;\r\n                        resolve(void 0);\r\n                    }\r\n                });\r\n            }\r\n            else {\r\n                resolve(void 0);\r\n            }\r\n        });\r\n        return Promise.all([flushEventsToAI]);\r\n    }\r\n}\r\nexports.TelemetryReporter = TelemetryReporter;\r\n//# sourceMappingURL=TelemetryReporter.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar TelemetryReporter_1 = require(\"./TelemetryReporter\");\r\nexports.TelemetryReporter = TelemetryReporter_1.TelemetryReporter;\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass CallbackContainer {\r\n    constructor() {\r\n        this.callbacks = [];\r\n    }\r\n    clear() {\r\n        this.callbacks.length = 0;\r\n    }\r\n    get items() {\r\n        return this.callbacks;\r\n    }\r\n    add(callback) {\r\n        if (callback) {\r\n            this.callbacks.push(callback);\r\n        }\r\n        return {\r\n            dispose: () => {\r\n                if (!callback) {\r\n                    return;\r\n                }\r\n                const index = this.callbacks.indexOf(callback);\r\n                if (index !== -1) {\r\n                    this.callbacks.splice(index, 1);\r\n                }\r\n            }\r\n        };\r\n    }\r\n}\r\nexports.CallbackContainer = CallbackContainer;\r\n//# sourceMappingURL=CallbackContainer.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode_jsonrpc_1 = require(\"vscode-jsonrpc\");\r\nconst utils_1 = require(\"../utils\");\r\n/**\r\n * Disposable class can handle multiple child disposable that will\r\n * be disposed when the disposable class isntance is disposed itself.\r\n * It provides the `onDispose` event for your convenience and will\r\n * handle the disposables lifecycle, including removing the child\r\n * disposable object reference from the disposables list when the\r\n * child gets disposed, hence enable the garbage collection of the\r\n * object.\r\n * Also holds the `trace` instance so all classes that inherit from\r\n * this one will have the tracing available by default.\r\n */\r\nclass DisposableClass {\r\n    constructor(traceReference) {\r\n        this.traceReference = traceReference;\r\n        this.disposablesReference = [];\r\n        this.isDisposedReference = false;\r\n        this.onDisposeEmitter = new vscode_jsonrpc_1.Emitter();\r\n        this.onDisposeEvent = this.onDisposeEmitter.event;\r\n        /**\r\n         * Dispose a particular single disposable object.\r\n         */\r\n        this.disposeObject = (disposable, reason) => {\r\n            this.trace.verbose('disposing the object', reason, disposable);\r\n            try {\r\n                disposable.dispose(reason);\r\n            }\r\n            catch (e) {\r\n                this.trace.warning('Error from disposable', disposable, reason, e);\r\n            }\r\n            finally {\r\n                this.removeFromDisposables(disposable);\r\n            }\r\n        };\r\n        /**\r\n         * Remove a particular disposable from the child disposables list.\r\n         */\r\n        this.removeFromDisposables = (disposable) => {\r\n            const index = this.disposablesReference.indexOf(disposable);\r\n            if (index < 0) {\r\n                return this;\r\n            }\r\n            this.disposablesReference.splice(index, 1);\r\n            return this;\r\n        };\r\n        this.dispose = this.dispose.bind(this);\r\n        this.onDispose = this.onDispose.bind(this);\r\n    }\r\n    /**\r\n     * Trace instance used by the disposable class instance.\r\n     */\r\n    get disposables() {\r\n        return [...this.disposablesReference];\r\n    }\r\n    /**\r\n     * Trace instance used by the disposable class instance.\r\n     */\r\n    get trace() {\r\n        return this.traceReference;\r\n    }\r\n    /**\r\n     * Whether the disposable class is already disposed.\r\n     */\r\n    get isDisposed() {\r\n        return this.isDisposedReference;\r\n    }\r\n    /**\r\n     * Dispose all child disposables.\r\n     */\r\n    dispose(reason) {\r\n        this.trace.verbose('disposing self');\r\n        if (this.isDisposed) {\r\n            this.trace.verbose('already disposed');\r\n            return this;\r\n        }\r\n        this.isDisposedReference = true;\r\n        const reasonToLog = () => {\r\n            var _a;\r\n            if (reason) {\r\n                if (typeof reason === 'function') {\r\n                    return `${(_a = reason.constructor) === null || _a === void 0 ? void 0 : _a.name}-${JSON.stringify(reason)}`;\r\n                }\r\n                return String(reason);\r\n            }\r\n            return 'n/a';\r\n        };\r\n        try {\r\n            const reason = reasonToLog();\r\n            this.trace.verbose(`disposing reason: '${reason}', disposing ${this.disposables.length} objects`);\r\n            /**\r\n             * We use the public property here since it will make the disposables array clone,\r\n             * otherwise it might be a problem since the the `disposeObject` (or rather the\r\n             * `removeFromDisposables`) will modify the `disposablesReference` array in-place\r\n             * which will mess up the `forEach` loop.\r\n             */\r\n            this.disposables.forEach((disposable, i) => {\r\n                if (!disposable) {\r\n                    this.trace.warning('disposable is not set in the disposables object');\r\n                    return;\r\n                }\r\n                if (disposable.isDisposed) {\r\n                    return;\r\n                }\r\n                return this.disposeObject(disposable, `${reason} $${i}`);\r\n            });\r\n            this.disposablesReference.length = 0;\r\n        }\r\n        catch (e) {\r\n            this.trace.warning('error while disposing an object', e);\r\n        }\r\n        this.onDisposeEmitter.fire(this);\r\n        this.onDisposeEmitter.dispose();\r\n        return this;\r\n    }\r\n    /**\r\n     * Adds an `IDisposable` to the list of the child disposables, each of which will be\r\n     * disposed when the disposable class is disposed.\r\n     */\r\n    addToDisposables(...disposables) {\r\n        for (const disposable of disposables) {\r\n            utils_1.assertDefined(disposable, 'Disposable must be defined.');\r\n            /**\r\n             * Subscribe to `onDispose` from child disposables and remove the disposable\r\n             * from the `disposables` array so we don't hold the reference to the object.\r\n             */\r\n            if ('onDispose' in disposable) {\r\n                const eventListener = disposable.onDispose(() => {\r\n                    this.disposeObject(eventListener);\r\n                    this.removeFromDisposables(disposable);\r\n                });\r\n            }\r\n            if ('dispose' in disposable) {\r\n                this.disposablesReference.push(disposable);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Event fired only once, when the disposable class is disposed.\r\n     * If the disposable class already disposed the callback called immediatelly.\r\n     */\r\n    onDispose(callback, thisArgs) {\r\n        if (this.isDisposed) {\r\n            this.trace.verbose('already disposed, calling callback immediately');\r\n            callback.call(thisArgs, this);\r\n            return {\r\n                dispose: () => { },\r\n            };\r\n        }\r\n        this.trace.verbose('subscribing to onDispose event');\r\n        return this.onDisposeEvent(callback.bind(thisArgs, this));\r\n    }\r\n}\r\nexports.DisposableClass = DisposableClass;\r\n//# sourceMappingURL=DisposableClass.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass Mutex {\r\n    constructor() {\r\n        this.mutex = Promise.resolve();\r\n    }\r\n    async dispatch(fn) {\r\n        const unlock = await this.lock();\r\n        try {\r\n            return await Promise.resolve(fn());\r\n        }\r\n        finally {\r\n            unlock();\r\n        }\r\n    }\r\n    lock() {\r\n        let begin = (unlock) => { };\r\n        this.mutex = this.mutex.then(() => {\r\n            return new Promise(begin);\r\n        });\r\n        return new Promise((resolve) => {\r\n            begin = resolve;\r\n        });\r\n    }\r\n}\r\nexports.Mutex = Mutex;\r\n//# sourceMappingURL=Mutex.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst utils_1 = require(\"../utils\");\r\nconst errors_1 = require(\"../errors\");\r\n/**\r\n * An abstraction above a promise, makes it easy to `resolve`/`reject`\r\n * promise afterward and keeps the promise state attributes.\r\n */\r\nclass Signal {\r\n    constructor(cancellationToken) {\r\n        this.stateReference = 'pending';\r\n        // tslint:disable-next-line: promise-must-complete\r\n        this.promiseReference = new Promise((resolve, reject) => {\r\n            this.promiseResolve = resolve;\r\n            this.promiseReject = reject;\r\n        });\r\n        this.resolve = this.resolve.bind(this);\r\n        this.reject = this.reject.bind(this);\r\n        this.cancel = this.cancel.bind(this);\r\n        if (!cancellationToken) {\r\n            return;\r\n        }\r\n        if (cancellationToken.isCancellationRequested) {\r\n            this.cancel();\r\n        }\r\n        else if (cancellationToken.onCancellationRequested) {\r\n            cancellationToken.onCancellationRequested(() => {\r\n                if (this.isFulfilled) {\r\n                    return;\r\n                }\r\n                this.cancel();\r\n            });\r\n        }\r\n    }\r\n    get isFulfilled() {\r\n        return this.state !== 'pending';\r\n    }\r\n    get state() {\r\n        return this.stateReference;\r\n    }\r\n    get isResolved() {\r\n        return this.state === 'resolved';\r\n    }\r\n    get isRejected() {\r\n        return this.state === 'rejected';\r\n    }\r\n    get isCancelled() {\r\n        return this.state === 'cancelled';\r\n    }\r\n    resolve(result) {\r\n        if (this.isFulfilled) {\r\n            return;\r\n        }\r\n        this.stateReference = 'resolved';\r\n        utils_1.assertDefined(this.promiseResolve, 'No `promiseResolve` function found.');\r\n        this.promiseResolve(result);\r\n    }\r\n    reject(error) {\r\n        if (this.isFulfilled) {\r\n            return;\r\n        }\r\n        this.stateReference = 'rejected';\r\n        utils_1.assertDefined(this.promiseReject, 'No `promiseReject` function found.');\r\n        this.promiseReject(error);\r\n    }\r\n    cancel() {\r\n        if (this.isFulfilled) {\r\n            return;\r\n        }\r\n        this.stateReference = 'cancelled';\r\n        utils_1.assertDefined(this.promiseReject, 'No `promiseReject` function found.');\r\n        this.promiseReject(new errors_1.CancellationError());\r\n    }\r\n    get promise() {\r\n        return this.promiseReference;\r\n    }\r\n    static from(value) {\r\n        const signal = new Signal();\r\n        if (utils_1.isThenable(value)) {\r\n            value.then(signal.resolve, signal.reject);\r\n        }\r\n        else {\r\n            signal.resolve(value);\r\n        }\r\n        return signal;\r\n    }\r\n    dispose() {\r\n        if (this.isFulfilled) {\r\n            return;\r\n        }\r\n        this.cancel();\r\n    }\r\n}\r\nexports.Signal = Signal;\r\n//# sourceMappingURL=Signal.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar DisposableClass_1 = require(\"./DisposableClass\");\r\nexports.DisposableClass = DisposableClass_1.DisposableClass;\r\nvar Signal_1 = require(\"./Signal\");\r\nexports.Signal = Signal_1.Signal;\r\nvar Mutex_1 = require(\"./Mutex\");\r\nexports.Mutex = Mutex_1.Mutex;\r\nvar CallbackContainer_1 = require(\"./CallbackContainer\");\r\nexports.CallbackContainer = CallbackContainer_1.CallbackContainer;\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vso_logging_1 = require(\"@vs/vso-logging\");\r\n__export(require(\"./time\"));\r\nexports.globalTrace = new vso_logging_1.TraceSource('vscs');\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.TIME_SECOND_MS = 1000;\r\nexports.TIME_MINUTE_MS = 60 * exports.TIME_SECOND_MS;\r\nexports.TIME_HOUR_MS = 60 * exports.TIME_MINUTE_MS;\r\nexports.TIME_DAY_MS = 24 * exports.TIME_HOUR_MS;\r\n//# sourceMappingURL=time.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst _1 = require(\".\");\r\n/**\r\n * Aggregate error holds a list of errors.\r\n */\r\nclass AggregateError extends _1.BaseError {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.errorType = 'AggregateError';\r\n        /**\r\n         * The errors list as a private reference.\r\n         */\r\n        this.errorsReference = [];\r\n    }\r\n    /**\r\n     * Get a copy aggregate error list.\r\n     */\r\n    get errors() {\r\n        return [...this.errorsReference];\r\n    }\r\n    /**\r\n     * Add errors to the aggregate error list.\r\n     */\r\n    addErrors(...errors) {\r\n        this.errorsReference.push(...errors);\r\n        return this;\r\n    }\r\n    /**\r\n     * Creates new `AggregateError` copy from the current one and adds the errors.\r\n     */\r\n    cloneWithErrors(...errors) {\r\n        const newError = new AggregateError();\r\n        newError.addErrors(...this.errors, ...errors);\r\n        return newError;\r\n    }\r\n    /**\r\n     * Return the last error in the error sequence.s\r\n     */\r\n    get lastError() {\r\n        const lastErrorIndex = this.errorsReference.length - 1;\r\n        return this.errorsReference[lastErrorIndex];\r\n    }\r\n}\r\nexports.AggregateError = AggregateError;\r\n;\r\n//# sourceMappingURL=AggregateError.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst BaseError_1 = require(\"./BaseError\");\r\n/**\r\n * Error thrown when an assertion fails.\r\n */\r\nclass AssertionError extends BaseError_1.BaseError {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.errorType = 'AssertionError';\r\n    }\r\n}\r\nexports.AssertionError = AssertionError;\r\n;\r\n//# sourceMappingURL=AssertionError.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst BaseError_1 = require(\"./BaseError\");\r\n/**\r\n * Error inticates authentication failure.\r\n */\r\nclass AuthenticationError extends BaseError_1.BaseError {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.errorType = 'AuthenticationError';\r\n    }\r\n}\r\nexports.AuthenticationError = AuthenticationError;\r\n;\r\n//# sourceMappingURL=AuthenticationError.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Base error, all errors should extened it and specify new `errorType`.\r\n *\r\n * The error has:\r\n\r\n *  - `errorType` - idetifies the eror type, every eror that inherits from\r\n *      this one, override the `errorType` with its own value.\r\n * - `errorCode` - error code (number) for the specific error case.\r\n * - `originalErrorType` - if an error with an `errorType`/`errorCode` is\r\n *     \"wrapped\" with this error, the data is reserved in the `originalErrorType`\r\n *     so we don't loose the original context.\r\n * - `stack`[optional] - error stack trace. If an error is wrapped with this\r\n *     error, the stack is copied over.\r\n */\r\nclass BaseError extends Error {\r\n    constructor(error, errorCode) {\r\n        super((typeof error === 'string')\r\n            ? error\r\n            : error === null || error === void 0 ? void 0 : error.message);\r\n        this.errorCode = errorCode;\r\n        this.errorType = 'BaseError';\r\n        if (error instanceof Error) {\r\n            this.originalError = error;\r\n            this.stack = error.stack;\r\n            this.originalErrorType = this.getOriginalErrorCode(error);\r\n            this.errorCode = errorCode !== null && errorCode !== void 0 ? errorCode : error.errorCode;\r\n        }\r\n    }\r\n    getOriginalErrorCode(error) {\r\n        const { errorType = '<no-type>', errorCode = '<no-code>', } = error;\r\n        return `[${errorType}:${errorCode}]`;\r\n    }\r\n}\r\nexports.BaseError = BaseError;\r\n;\r\n//# sourceMappingURL=BaseError.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst BaseError_1 = require(\"./BaseError\");\r\n/**\r\n * Error thrown when something is cancelled. Used by `Signal`.\r\n */\r\nclass CancellationError extends BaseError_1.BaseError {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.errorType = 'CancellationError';\r\n    }\r\n}\r\nexports.CancellationError = CancellationError;\r\n//# sourceMappingURL=CancellationError.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst BaseError_1 = require(\"./BaseError\");\r\n/**\r\n * Error thrown when an some function or method is not implemented.\r\n */\r\nclass NotImplementedError extends BaseError_1.BaseError {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.errorType = 'NotImplementedError';\r\n    }\r\n}\r\nexports.NotImplementedError = NotImplementedError;\r\n;\r\n//# sourceMappingURL=NotImplementedError.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst BaseError_1 = require(\"./BaseError\");\r\n/**\r\n * The promise race error is thrown when all promises have thrown.\r\n * In this case the error will be derrived from the last thrown\r\n * error and `errorList` will contain entire error list.\r\n */\r\nclass PromiseRaceError extends BaseError_1.BaseError {\r\n    constructor(errorList, error, errorCode) {\r\n        super(error, errorCode);\r\n        this.errorList = errorList;\r\n        this.errorType = 'PromiseRaceError';\r\n    }\r\n}\r\nexports.PromiseRaceError = PromiseRaceError;\r\n;\r\n//# sourceMappingURL=PromiseRaceError.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar BaseError_1 = require(\"./BaseError\");\r\nexports.BaseError = BaseError_1.BaseError;\r\nvar AggregateError_1 = require(\"./AggregateError\");\r\nexports.AggregateError = AggregateError_1.AggregateError;\r\nvar AssertionError_1 = require(\"./AssertionError\");\r\nexports.AssertionError = AssertionError_1.AssertionError;\r\nvar PromiseRaceError_1 = require(\"./PromiseRaceError\");\r\nexports.PromiseRaceError = PromiseRaceError_1.PromiseRaceError;\r\nvar CancellationError_1 = require(\"./CancellationError\");\r\nexports.CancellationError = CancellationError_1.CancellationError;\r\nvar NotImplementedError_1 = require(\"./NotImplementedError\");\r\nexports.NotImplementedError = NotImplementedError_1.NotImplementedError;\r\nvar AuthenticationError_1 = require(\"./AuthenticationError\");\r\nexports.AuthenticationError = AuthenticationError_1.AuthenticationError;\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Utilities\r\n */\r\n__export(require(\"./utils\"));\r\n/**\r\n * Components\r\n */\r\n__export(require(\"./components\"));\r\n/**\r\n * Errors\r\n */\r\n__export(require(\"./errors\"));\r\n/**\r\n * Constants\r\n */\r\n__export(require(\"./constants\"));\r\n/**\r\n * Mocks\r\n */\r\n__export(require(\"./mocks\"));\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vso_logging_1 = require(\"@vs/vso-logging\");\r\nclass DisposableClassMock {\r\n    constructor() {\r\n        this.trace = new vso_logging_1.TraceSource('test-logger');\r\n        this.addToDisposables = (disposable) => {\r\n            return this;\r\n        };\r\n        this.isDisposed = false;\r\n        this.onDispose = (callback, thisArgs) => {\r\n            return {\r\n                dispose: () => { },\r\n            };\r\n        };\r\n        this.dispose = () => {\r\n            return this;\r\n        };\r\n    }\r\n}\r\nexports.DisposableClassMock = DisposableClassMock;\r\n//# sourceMappingURL=DisposableClassMock.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar DisposableClassMock_1 = require(\"./DisposableClassMock\");\r\nexports.DisposableClassMock = DisposableClassMock_1.DisposableClassMock;\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Reduce an array to one that has unique items only.\r\n */\r\nexports.arrayUnique = (arr) => {\r\n    const set = new Set(arr);\r\n    return [...set];\r\n};\r\n//# sourceMappingURL=arrayUnique.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst AssertionError_1 = require(\"../../errors/AssertionError\");\r\n/**\r\n * Assert that the expression that results in `val` holds, otherwise throw\r\n * an `AssertionError` with the `errorMessage`. Alternatively, if an error\r\n * instance is passed as the `errorMessage`, throw that instead.\r\n */\r\nexports.assert = (val, errorMessage) => {\r\n    if (val !== true) {\r\n        const error = (typeof errorMessage === 'string')\r\n            ? new AssertionError_1.AssertionError(errorMessage)\r\n            : errorMessage;\r\n        throw error;\r\n    }\r\n};\r\n//# sourceMappingURL=assert.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst assert_1 = require(\"./assert\");\r\n/**\r\n * Assert the `val` object is not `null` nor `undefined`, if it is\r\n * throw an `AssertionError` with the `errorMessage`. Alternatively,\r\n * if an error instance is passed as the `errorMessage`, throw that instead.\r\n */\r\nexports.assertDefined = (val, errorMessage) => {\r\n    return assert_1.assert(val != null, errorMessage);\r\n};\r\n//# sourceMappingURL=assertDefined.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst assert_1 = require(\"./assert\");\r\n/**\r\n * Assert the `val` is instance of `classObject`.\r\n */\r\nexports.assertInstance = (val, classObject, errorMessage) => {\r\n    return assert_1.assert(val instanceof classObject, errorMessage);\r\n};\r\n//# sourceMappingURL=assertInstance.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst errors_1 = require(\"../../errors\");\r\n/**\r\n * Assert to cover the cases that should never happen.\r\n */\r\n// TODO legomushroom - test this\r\nexports.assertNever = (value, errorMessage) => {\r\n    const error = (typeof errorMessage === 'string')\r\n        ? new errors_1.AssertionError(errorMessage)\r\n        : errorMessage;\r\n    throw error;\r\n};\r\n//# sourceMappingURL=assertNever.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar assertInstance_1 = require(\"./assertInstance\");\r\nexports.assertInstance = assertInstance_1.assertInstance;\r\nvar assertDefined_1 = require(\"./assertDefined\");\r\nexports.assertDefined = assertDefined_1.assertDefined;\r\nvar assertNever_1 = require(\"./assertNever\");\r\nexports.assertNever = assertNever_1.assertNever;\r\nvar assert_1 = require(\"./assert\");\r\nexports.assert = assert_1.assert;\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Function to replace all paths with [PATH] label.\r\n */\r\nexports.obfusticatePaths = (filePath, replacementString = '') => {\r\n    return filePath.replace(/([A-Za-z]:)?(\\S*[\\\\\\/])+\\S*/gi, (match, drive, directory, offset, whole) => {\r\n        if (/^\\d{1,4}\\/\\d{1,2}\\/\\d{1,4}$/.test(match)) { // This is a date. No need to scrub.\r\n            return match;\r\n        }\r\n        else {\r\n            const driveAndDirectoryLength = (drive ? drive.length : 0) + directory.length;\r\n            const fileName = match.substr(driveAndDirectoryLength);\r\n            return replacementString + fileName;\r\n        }\r\n    });\r\n};\r\n/**\r\n *  Function to replace all emails with `[EMAIL]` label.\r\n */\r\nexports.obfusticateEmailAddresses = (str) => {\r\n    return str.replace(/[\\S]+@[\\S]+/gi, '[EMAIL]');\r\n};\r\n/**\r\n *  Function to remove PII from a string.\r\n */\r\nexports.cleanupPII = (str) => {\r\n    if (!str) {\r\n        return str;\r\n    }\r\n    return exports.obfusticateEmailAddresses(exports.obfusticatePaths(str, '[PATH]/'));\r\n};\r\n//# sourceMappingURL=cleanupPII.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst createDisposable_1 = require(\"./createDisposable\");\r\n/**\r\n * Function to connect 2 events, then the `event` fired,\r\n * fire the `event` also.\r\n */\r\nexports.connectEvents = (notify, ...events) => {\r\n    const disposables = events.map((event) => {\r\n        return event(notify.fire.bind(notify));\r\n    });\r\n    return createDisposable_1.createDisposable(() => {\r\n        for (const disposable of disposables) {\r\n            disposable === null || disposable === void 0 ? void 0 : disposable.dispose();\r\n        }\r\n    });\r\n};\r\n//# sourceMappingURL=connectEvents.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Wrap some code to create a disposable.\r\n */\r\nexports.createDisposable = (dispose) => {\r\n    return {\r\n        dispose,\r\n    };\r\n};\r\n//# sourceMappingURL=createDisposable.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Interval version of a debounce util.\r\n */\r\nexports.debounce = (fn, timeout) => {\r\n    let interval;\r\n    const debounced = (...args) => {\r\n        clearInterval(interval);\r\n        interval = setInterval(() => {\r\n            fn(...args);\r\n        }, timeout);\r\n    };\r\n    debounced.stop = () => {\r\n        clearInterval(interval);\r\n    };\r\n    return debounced;\r\n};\r\n//# sourceMappingURL=debounce.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar withRetriesDecorator_1 = require(\"./withRetriesDecorator\");\r\nexports.withRetriesDecorator = withRetriesDecorator_1.withRetriesDecorator;\r\nvar withHelperDecorator_1 = require(\"./withHelperDecorator\");\r\nexports.withHelperDecorator = withHelperDecorator_1.withHelperDecorator;\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst assertDefined_1 = require(\"../asserts/assertDefined\");\r\nconst assert_1 = require(\"../asserts/assert\");\r\n/**\r\n * Factory function to construct a helper with\r\n * specific execution context.\r\n */\r\nconst contextMap = new Map();\r\nconst getHelper = (method, helper, options, context) => {\r\n    /**\r\n     * The overriden method should be associated with both\r\n     * class instance and the class method, hence we are\r\n     * using 2 maps here.\r\n     */\r\n    const existingHelpers = contextMap.get(context);\r\n    if (existingHelpers) {\r\n        const existingHelper = existingHelpers.get(method);\r\n        if (existingHelper) {\r\n            return existingHelper;\r\n        }\r\n    }\r\n    else {\r\n        contextMap.set(context, new Map());\r\n    }\r\n    const newHelper = helper(method.bind(context), options);\r\n    const helpers = contextMap.get(context);\r\n    assertDefined_1.assertDefined(helpers, 'No helpers found.');\r\n    helpers.set(method, newHelper);\r\n    return newHelper;\r\n};\r\n/**\r\n * Generic decorator to wrap a method with a helper.\r\n */\r\nfunction withHelperDecorator(helper, options) {\r\n    return function (target, propertyName, propertyDesciptor) {\r\n        const { value: method } = propertyDesciptor;\r\n        assert_1.assert(method instanceof Function, 'This decorator works only on methods');\r\n        assertDefined_1.assertDefined(method, `The method \"${propertyName}\" is not defined.`);\r\n        // must be `function` to not loose `this` context\r\n        propertyDesciptor.value = async function (...args) {\r\n            const wrappedMethod = getHelper(method, helper, options, this);\r\n            return await wrappedMethod.call(this, ...args);\r\n        };\r\n        return propertyDesciptor;\r\n    };\r\n}\r\nexports.withHelperDecorator = withHelperDecorator;\r\n;\r\n//# sourceMappingURL=withHelperDecorator.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst assertDefined_1 = require(\"../asserts/assertDefined\");\r\nconst withRetries_1 = require(\"../withRetries\");\r\nconst assert_1 = require(\"../asserts/assert\");\r\n/**\r\n * Method decorator, analog of the `withRetries` util.\r\n */\r\n// TODO legomushroom - test this\r\nexports.withRetriesDecorator = (options = {}) => {\r\n    return (target, propertyName, propertyDesciptor) => {\r\n        const { value: method } = propertyDesciptor;\r\n        assert_1.assert(method instanceof Function, 'This decorator works only on methods');\r\n        assertDefined_1.assertDefined(method, `The method \"${propertyName}\" is not defined.`);\r\n        // must be `function` to not loose `this` context\r\n        const result = async function (...args) {\r\n            return await withRetries_1.withRetries(async (retry) => {\r\n                return await method.call(this, ...args, retry);\r\n            }, options);\r\n        };\r\n        propertyDesciptor.value = result;\r\n        return propertyDesciptor;\r\n    };\r\n};\r\n//# sourceMappingURL=withRetriesDecorator.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Defer execution by `timout` milliseconds.\r\n */\r\nexports.defer = (fn, timeout = 1) => {\r\n    const timer = setTimeout(fn, timeout);\r\n    return timer;\r\n};\r\n//# sourceMappingURL=defer.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction createDisposable(callback, logger) {\r\n    return {\r\n        dispose: (reason) => {\r\n            logger === null || logger === void 0 ? void 0 : logger.verbose(`Disposing reason:${reason}`);\r\n            return callback(reason);\r\n        }\r\n    };\r\n}\r\nexports.createDisposable = createDisposable;\r\nfunction createDisposablesAll(logger, ...disposables) {\r\n    return {\r\n        dispose: (reason) => {\r\n            logger === null || logger === void 0 ? void 0 : logger.verbose(`createDisposablesAll->dispose reason:${reason}`);\r\n            return Promise.all(disposables.map(d => d.dispose(reason)));\r\n        }\r\n    };\r\n}\r\nexports.createDisposablesAll = createDisposablesAll;\r\nfunction createDisposablesSeries(logger, ...disposables) {\r\n    return {\r\n        dispose: async (reason) => {\r\n            logger === null || logger === void 0 ? void 0 : logger.verbose(`createDisposablesSeries->dispose reason:${reason}`);\r\n            for (let d of disposables) {\r\n                try {\r\n                    await d.dispose(reason);\r\n                }\r\n                catch (err) {\r\n                    logger === null || logger === void 0 ? void 0 : logger.error(`Failed to dispose`, err);\r\n                }\r\n            }\r\n        }\r\n    };\r\n}\r\nexports.createDisposablesSeries = createDisposablesSeries;\r\n//# sourceMappingURL=dispose.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst cleanupPII_1 = require(\"./cleanupPII\");\r\n/**\r\n * Create a plain object that represents an error.\r\n * Can be used to send the error to telemetry or\r\n * log it to the console.\r\n */\r\n// TODO legomushroom - test this\r\nexports.errorToObject = (error, isInternal = true) => {\r\n    const vscsError = error;\r\n    const { errorCode = -1, errorType = 'GenericError', message = '<no message>', originalErrorType = '<no original type>', } = vscsError;\r\n    const stack = (isInternal)\r\n        ? vscsError.stack\r\n        : cleanupPII_1.cleanupPII(vscsError.stack);\r\n    return {\r\n        errorMessage: message,\r\n        originalErrorType,\r\n        errorCode,\r\n        errorType,\r\n        stack,\r\n    };\r\n};\r\n//# sourceMappingURL=errorToObject.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst errorToObject_1 = require(\"./errorToObject\");\r\n/**\r\n * Create a stringified object that represents an error.\r\n */\r\n// TODO legomushroom - test this\r\nexports.errorToString = (error, isInternal = false) => {\r\n    return JSON.stringify(errorToObject_1.errorToObject(error, isInternal), null, 2);\r\n};\r\n//# sourceMappingURL=errorToString.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Generate a hash from a string.\r\n */\r\nexports.hashString = (str) => {\r\n    return str\r\n        .split('')\r\n        .reduce((a, b) => {\r\n        a = (((a << 5) - a) + b).charCodeAt(0);\r\n        return a & a;\r\n    }, 0)\r\n        .toString();\r\n};\r\n//# sourceMappingURL=hashString.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Identity function.\r\n */\r\n// TODO legomushroom - test this\r\nexports.idFunction = (...args) => {\r\n    return args;\r\n};\r\n//# sourceMappingURL=idFunction.js.map","\"use strict\";\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// decorators\r\n__export(require(\"./decorators\"));\r\n// assertion utils\r\n__export(require(\"./asserts\"));\r\n// misc utils\r\nvar once_1 = require(\"./once\");\r\nexports.once = once_1.once;\r\nvar onlyOnce_1 = require(\"./onlyOnce\");\r\nexports.onlyOnce = onlyOnce_1.onlyOnce;\r\nvar wait_1 = require(\"./wait\");\r\nexports.wait = wait_1.wait;\r\nvar raceAsync_1 = require(\"./raceAsync\");\r\nexports.raceAsync = raceAsync_1.raceAsync;\r\nvar withCache_1 = require(\"./withCache\");\r\nexports.withCache = withCache_1.withCache;\r\nvar withMutexByArguments_1 = require(\"./withMutexByArguments\");\r\nexports.withMutexByArguments = withMutexByArguments_1.withMutexByArguments;\r\nvar idFunction_1 = require(\"./idFunction\");\r\nexports.idFunction = idFunction_1.idFunction;\r\nvar withRetries_1 = require(\"./withRetries\");\r\nexports.withRetries = withRetries_1.withRetries;\r\nvar connectEvents_1 = require(\"./connectEvents\");\r\nexports.connectEvents = connectEvents_1.connectEvents;\r\nvar cleanupPII_1 = require(\"./cleanupPII\");\r\nexports.cleanupPII = cleanupPII_1.cleanupPII;\r\nexports.obfusticatePaths = cleanupPII_1.obfusticatePaths;\r\nexports.obfusticateEmailAddresses = cleanupPII_1.obfusticateEmailAddresses;\r\nvar randomInt_1 = require(\"./randomInt\");\r\nexports.randomInt = randomInt_1.randomInt;\r\nvar randomBytes_1 = require(\"./randomBytes\");\r\nexports.randomBytes = randomBytes_1.randomBytes;\r\nvar randomString_1 = require(\"./randomString\");\r\nexports.randomString = randomString_1.randomString;\r\nvar hashString_1 = require(\"./hashString\");\r\nexports.hashString = hashString_1.hashString;\r\nvar debounce_1 = require(\"./debounce\");\r\nexports.debounce = debounce_1.debounce;\r\nvar throttle_1 = require(\"./throttle\");\r\nexports.throttle = throttle_1.throttle;\r\nvar defer_1 = require(\"./defer\");\r\nexports.defer = defer_1.defer;\r\nvar arrayUnique_1 = require(\"./arrayUnique\");\r\nexports.arrayUnique = arrayUnique_1.arrayUnique;\r\nvar isThenable_1 = require(\"./isThenable\");\r\nexports.isThenable = isThenable_1.isThenable;\r\nvar createDisposable_1 = require(\"./createDisposable\");\r\nexports.createDisposable = createDisposable_1.createDisposable;\r\nvar timeoutPromise_1 = require(\"./timeoutPromise\");\r\nexports.timeoutPromise = timeoutPromise_1.timeoutPromise;\r\nvar errorToObject_1 = require(\"./errorToObject\");\r\nexports.errorToObject = errorToObject_1.errorToObject;\r\nvar errorToString_1 = require(\"./errorToString\");\r\nexports.errorToString = errorToString_1.errorToString;\r\nvar notImplemented_1 = require(\"./notImplemented\");\r\nexports.notImplemented = notImplemented_1.notImplemented;\r\n__export(require(\"./dispose\"));\r\nvar promiseAny_1 = require(\"./promiseAny\");\r\nexports.promiseAny = promiseAny_1.promiseAny;\r\nvar toCamelCase_1 = require(\"./toCamelCase\");\r\nexports.toCamelCase = toCamelCase_1.toCamelCase;\r\n// TODO legomushroom - cleanup?\r\nfunction propertiesToJSON(o) {\r\n    if (o) {\r\n        return JSON.stringify(o, Object.getOwnPropertyNames(o));\r\n    }\r\n}\r\nexports.propertiesToJSON = propertiesToJSON;\r\nfunction propertiesToString(o) {\r\n    var _a;\r\n    return `type:${(_a = o === null || o === void 0 ? void 0 : o.constructor) === null || _a === void 0 ? void 0 : _a.name} props:${propertiesToJSON(o)}`;\r\n}\r\nexports.propertiesToString = propertiesToString;\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Check if `val` is thenable or promiseLike.\r\n */\r\nexports.isThenable = (val) => {\r\n    if (val == null) {\r\n        return false;\r\n    }\r\n    if (typeof val.then !== 'function') {\r\n        return false;\r\n    }\r\n    return true;\r\n};\r\n//# sourceMappingURL=isThenable.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction notImplemented() {\r\n    throw new Error('Method not implemented.');\r\n}\r\nexports.notImplemented = notImplemented;\r\n;\r\n//# sourceMappingURL=notImplemented.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Function to wrap any function (let say `fun`) with the wrapper that will\r\n * ensure that the `fun` will be called only once. The wrapper will cache\r\n * the first return value of the `fun` and return it immediately on any\r\n * subsequent calls.\r\n */\r\nexports.once = (fun) => {\r\n    const invocationSymbol = Symbol();\r\n    let result;\r\n    const onceFunction = (...args) => {\r\n        if (fun[invocationSymbol]) {\r\n            return result;\r\n        }\r\n        fun[invocationSymbol] = true;\r\n        result = fun(...args);\r\n        return result;\r\n    };\r\n    return onceFunction;\r\n};\r\n//# sourceMappingURL=once.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction onlyOnce(fun, ...defaultParams) {\r\n    const invocationSymbol = Symbol();\r\n    let recursionCount = 0;\r\n    let firstParams;\r\n    let firstResult;\r\n    return function (...params) {\r\n        if (params.length === 0) {\r\n            params = defaultParams;\r\n        }\r\n        if (!fun[invocationSymbol]) {\r\n            recursionCount++;\r\n            let result;\r\n            try {\r\n                result = fun(...params);\r\n                if (recursionCount > 1) {\r\n                    return result;\r\n                }\r\n            }\r\n            finally {\r\n                recursionCount--;\r\n            }\r\n            // Set the flag after we have called the function and got the result to allow recursion for the first invocation\r\n            fun[invocationSymbol] = true;\r\n            firstParams = params;\r\n            firstResult = result;\r\n        }\r\n        else if (!parametersEqual(firstParams, params)) {\r\n            throw new Error(`Parameters must be the same as in the first call of ${onlyOnce.name}(${fun.name}).`);\r\n        }\r\n        return firstResult;\r\n    };\r\n}\r\nexports.onlyOnce = onlyOnce;\r\n;\r\n/** Check if two parameter arrays match.\r\n *\r\n * This check only uses === to compare the elements, so they must be of primitive type only.\r\n * If one array is larger than the other, the extra elements must be all undefined.\r\n */\r\nfunction parametersEqual(a1, a2) {\r\n    if (!Array.isArray(a1) || !Array.isArray(a2)) {\r\n        return false;\r\n    }\r\n    if (a1 === a2) {\r\n        return true;\r\n    }\r\n    const l = Math.min(a1.length, a2.length);\r\n    for (var i = 0; i < l; i++) {\r\n        if (a1[i] !== a2[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    const a = a1.length > l ? a1 : a2;\r\n    for (var i = l; i < a.length; i++) {\r\n        if (a[i] !== undefined) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n//# sourceMappingURL=onlyOnce.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.promiseAny = async (iterable) => {\r\n    return Promise.all([...iterable].map(promise => {\r\n        return new Promise((resolve, reject) => Promise.resolve(promise).then(reject, resolve));\r\n    })).then(errors => Promise.reject(errors), value => Promise.resolve(value));\r\n};\r\n//# sourceMappingURL=promiseAny.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst components_1 = require(\"../components\");\r\nconst PromiseRaceError_1 = require(\"../errors/PromiseRaceError\");\r\n/**\r\n * Method to wait on first promise resolve or all promises rejected.\r\n * If a single promise resolves, the function with resolve with its result.\r\n * If all promises have rejected, then the function rejects with the last\r\n * rejection error and the `PromiseRaceError` will have all the rejected\r\n * errors in the order of rejection.\r\n */\r\nexports.raceAsync = (promises) => {\r\n    const signal = new components_1.Signal();\r\n    const errors = [];\r\n    let cnt = promises.length;\r\n    promises.forEach((promise) => {\r\n        promise\r\n            .then((value) => {\r\n            signal.resolve(value);\r\n        })\r\n            .catch((error) => {\r\n            cnt--;\r\n            errors.push(error);\r\n            if (cnt === 0) {\r\n                signal.reject(new PromiseRaceError_1.PromiseRaceError(errors, error));\r\n            }\r\n        });\r\n    });\r\n    return signal.promise;\r\n};\r\n//# sourceMappingURL=raceAsync.js.map","\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst randombytes_1 = __importDefault(require(\"randombytes\"));\r\n/**\r\n * Safe random bytes utility, depends on crypto API which\r\n * should be polyfilled for NodeJS.\r\n */\r\nexports.randomBytes = (length) => {\r\n    return randombytes_1.default(length);\r\n};\r\n//# sourceMappingURL=randomBytes.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst assert_1 = require(\"./asserts/assert\");\r\n/**\r\n * Function to get a random integer from a defined range.\r\n */\r\nexports.randomInt = (max, min = 0) => {\r\n    assert_1.assert(max > min, 'the `max` param should be greater than the `min`');\r\n    assert_1.assert(!isNaN(min), 'the `min` is not a number');\r\n    assert_1.assert(!isNaN(max), 'the `max` is not a number');\r\n    const delta = max - min;\r\n    const randomFloat = delta * Math.random();\r\n    return Math.round(min + randomFloat);\r\n};\r\n//# sourceMappingURL=randomInt.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst randomBytes_1 = require(\"./randomBytes\");\r\n/**\r\n * Generate random string (`hex` by default) using `length` bytes.\r\n */\r\nexports.randomString = (length = 16, encoding = 'hex') => {\r\n    const randomBuffer = randomBytes_1.randomBytes(length);\r\n    return randomBuffer.toString(encoding);\r\n};\r\n//# sourceMappingURL=randomString.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n;\r\n/**\r\n * Function that throttles a function invocation to\r\n * at most one per every `interval` milliseconds.\r\n */\r\nfunction throttle(fn, options) {\r\n    let lockInterval;\r\n    // wrap the original function\r\n    return function throttledFunction(...args) {\r\n        /**\r\n         * If still locked, return immediatelly.\r\n         */\r\n        if (lockInterval) {\r\n            return;\r\n        }\r\n        /**\r\n         * If not locked, invoke the original function and\r\n         * lock so no invocation\r\n         */\r\n        const { interval } = options;\r\n        lockInterval = setTimeout(() => {\r\n            if (lockInterval) {\r\n                clearInterval(lockInterval);\r\n                lockInterval = undefined;\r\n            }\r\n        }, interval);\r\n        /**\r\n         * Run the original function and return the result.\r\n         */\r\n        return fn.call(this, ...args);\r\n    };\r\n}\r\nexports.throttle = throttle;\r\n;\r\n//# sourceMappingURL=throttle.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst CancellationError_1 = require(\"../errors/CancellationError\");\r\nexports.timeoutPromise = async (promise, timeout, error, promiseCancellationSource) => {\r\n    let timeoutReference;\r\n    let ctsDisposable;\r\n    const dispose = () => {\r\n        ctsDisposable === null || ctsDisposable === void 0 ? void 0 : ctsDisposable.dispose();\r\n        clearTimeout(timeoutReference);\r\n    };\r\n    const result = await Promise.race([\r\n        /**\r\n         * Original promise.\r\n         */\r\n        promise.finally(() => {\r\n            dispose();\r\n        }),\r\n        /**\r\n         * Timeout promise.\r\n         */\r\n        new Promise((_, reject) => {\r\n            ctsDisposable = promiseCancellationSource === null || promiseCancellationSource === void 0 ? void 0 : promiseCancellationSource.token.onCancellationRequested(() => {\r\n                dispose();\r\n                reject(new CancellationError_1.CancellationError());\r\n            });\r\n            timeoutReference = setTimeout(() => {\r\n                dispose();\r\n                const rejectionError = error !== null && error !== void 0 ? error : new Error(`Promise rejected after ${timeout}ms.`);\r\n                reject(rejectionError);\r\n            }, timeout);\r\n        }),\r\n    ]);\r\n    return result;\r\n};\r\n//# sourceMappingURL=timeoutPromise.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction toCamelCase(str) {\r\n    if (str && str.length > 0) {\r\n        return str.substring(0, 1).toLowerCase() + str.substring(1);\r\n    }\r\n    return str;\r\n}\r\nexports.toCamelCase = toCamelCase;\r\n//# sourceMappingURL=toCamelCase.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Wait on `delay` milliseconds asynronously before proceeding.\r\n */\r\nexports.wait = (delay) => {\r\n    return new Promise((resolve) => {\r\n        setTimeout(resolve, delay);\r\n    });\r\n};\r\n//# sourceMappingURL=wait.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst assertDefined_1 = require(\"./asserts/assertDefined\");\r\nconst Signal_1 = require(\"../components/Signal\");\r\nconst defer_1 = require(\"./defer\");\r\n/**\r\n * Utility to run an asynchronous function and reuse\r\n * the currently running version of it, if present.\r\n */\r\nexports.withCache = (fn) => {\r\n    let runningSignal;\r\n    const res = async (...args) => {\r\n        if (runningSignal && !runningSignal.isFulfilled) {\r\n            return await runningSignal.promise;\r\n        }\r\n        runningSignal = new Signal_1.Signal();\r\n        /**\r\n         * Defer function execution so we can return the signal promise\r\n         * that will resolve to the result of the original function.\r\n         */\r\n        defer_1.defer(async () => {\r\n            assertDefined_1.assertDefined(runningSignal, 'No running signal is defined.');\r\n            try {\r\n                const result = await fn(...args);\r\n                runningSignal.resolve(result);\r\n            }\r\n            catch (e) {\r\n                runningSignal.reject(e);\r\n            }\r\n        }, 1);\r\n        return await runningSignal.promise;\r\n    };\r\n    return res;\r\n};\r\n//# sourceMappingURL=withCache.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Signal_1 = require(\"../components/Signal\");\r\nconst hashString_1 = require(\"./hashString\");\r\nconst defer_1 = require(\"./defer\");\r\n/**\r\n * Given a list of arguments, return a serialized\r\n * string (id) for the arguments list.\r\n */\r\nconst serializeArgs = (...args) => {\r\n    const hashedArgs = args.map((str) => {\r\n        return hashString_1.hashString(`${str}`);\r\n    });\r\n    return hashedArgs.join('::');\r\n};\r\n;\r\n/**\r\n * Default arguments for the `withMutexByArguments` helper.\r\n */\r\nconst DEFAULT_OPTIONS = {\r\n    serializeArguments: serializeArgs,\r\n};\r\n/**\r\n * Utility to run an asynchronous function and reuse the currently\r\n * running instance of it, based on the arguments list. To work\r\n * correctly all the arguments should be serializable to string,\r\n * as they will be used as an `id` for each invocation instance.\r\n *\r\n * Any prior invocation result is ignored, e.g. we reuse only currently\r\n * running function instances, ignoring any previously finished ones.\r\n */\r\nexports.withMutexByArguments = (fn, options = DEFAULT_OPTIONS) => {\r\n    // the map that holds current running signals for the function invocations.\r\n    const mutextMap = new Map();\r\n    // result function\r\n    const result = async (...args) => {\r\n        const { serializeArguments = serializeArgs } = options;\r\n        const id = serializeArguments(...args);\r\n        const runningSignal = mutextMap.get(id);\r\n        if (runningSignal && !runningSignal.isFulfilled) {\r\n            return await runningSignal.promise;\r\n        }\r\n        const newRunningSignal = new Signal_1.Signal();\r\n        mutextMap.set(id, newRunningSignal);\r\n        /**\r\n         * Defer function execution so we can return the signal promise\r\n         * that will resolve to the result of the original function.\r\n         */\r\n        defer_1.defer(async () => {\r\n            try {\r\n                const result = await fn(...args);\r\n                newRunningSignal.resolve(result);\r\n            }\r\n            catch (e) {\r\n                newRunningSignal.reject(e);\r\n            }\r\n            finally {\r\n                mutextMap.delete(id);\r\n            }\r\n        }, 1);\r\n        return await newRunningSignal.promise;\r\n    };\r\n    return result;\r\n};\r\n//# sourceMappingURL=withMutexByArguments.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst errors_1 = require(\"../errors\");\r\nconst assert_1 = require(\"./asserts/assert\");\r\nconst wait_1 = require(\"./wait\");\r\n/**\r\n * Function to throw either the `AggregateError`, or,\r\n * if the `isThrowLastError` is `true`, the last error\r\n * in the aggregate error list.\r\n */\r\nconst throwAggregateError = (error, isThrowLastError) => {\r\n    if (isThrowLastError) {\r\n        throw error.lastError;\r\n    }\r\n    throw error;\r\n};\r\n/**\r\n * Defaults.\r\n */\r\nconst WITH_RETRIES_DEFAULTS = {\r\n    // 1 call + 2 retries = 3 calls total\r\n    retries: 2,\r\n    // no delay by default\r\n    retryDelay: 0,\r\n    // no-op `shouldStopRetries` callback\r\n    shouldStopRetries: () => { return false; },\r\n    // should throw the last error instead of `AggregateError`\r\n    isAggregateError: true,\r\n};\r\n/**\r\n * Utility to run an asynchronous function with a number of retries.\r\n * Can be used as a polling helper if the `retryDelay` is specified.\r\n *\r\n * Throws `AggregateError` with all the thrown `errors` that we risen\r\n * during the retry attempts. The `last` property of the `AggregateError`\r\n * is the last throw error in the sequence.\r\n *\r\n * - Returns the return value of the last `fn` call. If the last `fn` call\r\n *   throws, the `AggregateError` is thrown.\r\n *\r\n * - Throw `CancellationError` inside the `fn` callback to cancel the retries.\r\n *\r\n * - If the `CancellationToken` is passed and cancellation is requested,\r\n *   the `AggregateError` is thrown, with the `CancellationError` error\r\n *   as the last in the list.\r\n *\r\n * - `shouldStopRetries`, optional callback meant for implementing an early bail-out\r\n *   from the retry loop. It receives an `error` from the last failed retry attempt\r\n *   and should return a `boolean` indicating if we should stop the retry loop.\r\n *   Helpful for the cases when the error thrown is known to be fatal, so doesn't\r\n *   make sense to continue the remaining retries.\r\n */\r\nexports.withRetries = async (fn, opts = {}, aggregateError = new errors_1.AggregateError()) => {\r\n    /**\r\n     * Extend the options with defaults.\r\n     */\r\n    const options = Object.assign(Object.assign({}, WITH_RETRIES_DEFAULTS), opts);\r\n    const { retries, retryDelay, shouldStopRetries, cancellationToken, isAggregateError, } = options;\r\n    /**\r\n     * Make sure a number of retries left. In theory should never\r\n     * go in this case, unless wrong `retries` option was passed.\r\n     *\r\n     * Throwing the `AggregateError` with a single `AssertionError`\r\n     * for consistency.\r\n     */\r\n    const assertionError = new errors_1.AssertionError('Retries should have at least zero retries.');\r\n    /**\r\n     * If `isAggregateError` option set, throw the error itself,\r\n     * to be consistent with the logic inside the catch block.\r\n     */\r\n    assert_1.assert(retries > -1, (!isAggregateError)\r\n        ? assertionError\r\n        : aggregateError.cloneWithErrors(assertionError));\r\n    try {\r\n        /**\r\n         * Check that the cancellation is not requested yet on the `CancellationToken`.\r\n         */\r\n        assert_1.assert(!(cancellationToken === null || cancellationToken === void 0 ? void 0 : cancellationToken.isCancellationRequested), new errors_1.CancellationError('CancellationToken is cancelled.'));\r\n        /**\r\n         * Invoke the main procedure callback.\r\n         */\r\n        return await fn(retries);\r\n    }\r\n    catch (e) {\r\n        /**\r\n         * If the invocation fails, add the error to the aggregate\r\n         * error list.\r\n         */\r\n        aggregateError.addErrors(e);\r\n        /**\r\n         * Check if we should stop retrying premarturely.\r\n         * Helpful in the cases hwen the error throw is indicative of a\r\n         * fatal failure, hence does not make sence to retry anymore.\r\n         *\r\n         * The `shouldStopRetries` is awaited, to enable optional delays\r\n         * in the callback, e.g. if the error is of known type, a delay\r\n         * can be applied for that specific error kind.\r\n         */\r\n        const isStop = await shouldStopRetries(e);\r\n        if (isStop) {\r\n            return throwAggregateError(aggregateError, !isAggregateError);\r\n        }\r\n        /**\r\n         * If cancelled inside the callback, stop retrying.\r\n         */\r\n        if (e instanceof errors_1.CancellationError) {\r\n            return throwAggregateError(aggregateError, !isAggregateError);\r\n        }\r\n        /**\r\n         * Check that the cancellation is not requested yet on the `CancellationToken`.\r\n         */\r\n        const cancellationError = new errors_1.CancellationError('CancellationToken is cancelled after retry.');\r\n        assert_1.assert(!(cancellationToken === null || cancellationToken === void 0 ? void 0 : cancellationToken.isCancellationRequested), \r\n        /**\r\n         * Throw either `AggregateError` with the `CancellationError` at the end,\r\n         * or the `CancellationError` itself (if the `isAggregateError` is set).\r\n         */\r\n        (!isAggregateError)\r\n            ? cancellationError\r\n            : aggregateError.cloneWithErrors(cancellationError));\r\n        /**\r\n         * If retries left, call the same function recursively.\r\n         */\r\n        if (retries > 0) {\r\n            /**\r\n             * Wait for `retryDelay`ms before making another retry.\r\n             */\r\n            await wait_1.wait(retryDelay);\r\n            /**\r\n             * Retry, decrementing the retries count.\r\n             */\r\n            return await exports.withRetries(fn, Object.assign(Object.assign({}, options), { retries: retries - 1 }), aggregateError);\r\n        }\r\n        /**\r\n         * No retries, throw the result error.\r\n         * - by default, throw the  aggregate error that contains\r\n         *   the list of all errors thrown during the retries.\r\n         * - if `isAggregateError` set to `false`, throw the last\r\n         *  error in the list.\r\n         */\r\n        return throwAggregateError(aggregateError, !isAggregateError);\r\n    }\r\n};\r\n//# sourceMappingURL=withRetries.js.map","\"use strict\";\r\n//----------------------\r\n// <auto-generated>\r\n//     Generated using the NSwag toolchain v9.10.19.0 (Newtonsoft.Json v9.0.0.0) (http://NJsonSchema.org)\r\n// </auto-generated>\r\n//----------------------\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/** Describes the kind of data to be formatted. */\r\nconst vso_rpc_1 = require(\"@vs/vso-rpc\");\r\nclass EventArgs {\r\n}\r\nexports.EventArgs = EventArgs;\r\n/** Notification class for contact service */\r\nclass NotifyContactServiceEventArgs extends EventArgs {\r\n}\r\nexports.NotifyContactServiceEventArgs = NotifyContactServiceEventArgs;\r\n/** The presence status default options */\r\nvar PresenceStatus;\r\n(function (PresenceStatus) {\r\n    PresenceStatus[PresenceStatus[\"Unknown\"] = 'unknown'] = \"Unknown\";\r\n    PresenceStatus[PresenceStatus[\"Available\"] = 'available'] = \"Available\";\r\n    PresenceStatus[PresenceStatus[\"Busy\"] = 'busy'] = \"Busy\";\r\n    PresenceStatus[PresenceStatus[\"DoNotDisturb\"] = 'doNotDisturb'] = \"DoNotDisturb\";\r\n    PresenceStatus[PresenceStatus[\"Away\"] = 'away'] = \"Away\";\r\n    PresenceStatus[PresenceStatus[\"Invisible\"] = 'invisible'] = \"Invisible\";\r\n    PresenceStatus[PresenceStatus[\"Offline\"] = 'offline'] = \"Offline\";\r\n})(PresenceStatus = exports.PresenceStatus || (exports.PresenceStatus = {}));\r\n/** Contact property types */\r\nvar ContactProperty;\r\n(function (ContactProperty) {\r\n    ContactProperty[ContactProperty[\"DisplayName\"] = 'displayName'] = \"DisplayName\";\r\n    ContactProperty[ContactProperty[\"Email\"] = 'email'] = \"Email\";\r\n    ContactProperty[ContactProperty[\"AvatarUri\"] = 'avatarUri'] = \"AvatarUri\";\r\n    ContactProperty[ContactProperty[\"Status\"] = 'status'] = \"Status\";\r\n})(ContactProperty = exports.ContactProperty || (exports.ContactProperty = {}));\r\n/** Contact entity */\r\nclass Contact {\r\n}\r\nexports.Contact = Contact;\r\n/** Empty parameters */\r\nclass EmptyRequest {\r\n}\r\nexports.EmptyRequest = EmptyRequest;\r\n/** Empty result */\r\nclass EmptyResponse {\r\n}\r\nexports.EmptyResponse = EmptyResponse;\r\nclass PublishPresenceRequest {\r\n}\r\nexports.PublishPresenceRequest = PublishPresenceRequest;\r\n/** Parameters passed during Initialize method */\r\nclass InitializeRequest {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(PublishPresenceRequest),\r\n    __metadata(\"design:type\", PublishPresenceRequest)\r\n], InitializeRequest.prototype, \"publishPresence\", void 0);\r\nexports.InitializeRequest = InitializeRequest;\r\n/** Definition of a workspace folder */\r\nclass WorkspaceFolder {\r\n}\r\nexports.WorkspaceFolder = WorkspaceFolder;\r\n/** A workspace Uri from vscode */\r\nclass WorkspaceUri {\r\n}\r\nexports.WorkspaceUri = WorkspaceUri;\r\n/** Capabilities that a service would offer */\r\nclass Capabilities {\r\n}\r\nexports.Capabilities = Capabilities;\r\n/** Returned on the Initialized method */\r\nclass InitializeResponse {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(Capabilities),\r\n    __metadata(\"design:type\", Capabilities)\r\n], InitializeResponse.prototype, \"capabilities\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(Contact),\r\n    __metadata(\"design:type\", Contact)\r\n], InitializeResponse.prototype, \"selfContact\", void 0);\r\nexports.InitializeResponse = InitializeResponse;\r\n/** The signed state option */\r\nvar SignedStatus;\r\n(function (SignedStatus) {\r\n    SignedStatus[SignedStatus[\"None\"] = 'none'] = \"None\";\r\n    SignedStatus[SignedStatus[\"SignedOut\"] = 'signedOut'] = \"SignedOut\";\r\n    SignedStatus[SignedStatus[\"SigningIn\"] = 'signingIn'] = \"SigningIn\";\r\n    SignedStatus[SignedStatus[\"SignedIn\"] = 'signedIn'] = \"SignedIn\";\r\n})(SignedStatus = exports.SignedStatus || (exports.SignedStatus = {}));\r\n/** A presence status changed for a contact entity */\r\nclass ContactPresenceUpdate {\r\n}\r\nexports.ContactPresenceUpdate = ContactPresenceUpdate;\r\n/** Batch of presence changed for multiple contacts */\r\nclass PresenceChangedNotification {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(ContactPresenceUpdate),\r\n    __metadata(\"design:type\", Array)\r\n], PresenceChangedNotification.prototype, \"changes\", void 0);\r\nexports.PresenceChangedNotification = PresenceChangedNotification;\r\nclass ContactPropertyValueChanged {\r\n}\r\nexports.ContactPropertyValueChanged = ContactPropertyValueChanged;\r\nclass ContactChangedNotification {\r\n}\r\nexports.ContactChangedNotification = ContactChangedNotification;\r\nclass ContactPropertiesChangedNotification {\r\n}\r\nexports.ContactPropertiesChangedNotification = ContactPropertiesChangedNotification;\r\nclass InviteRequest {\r\n}\r\nexports.InviteRequest = InviteRequest;\r\nclass InviteReceivedNotification {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(Contact),\r\n    __metadata(\"design:type\", Contact)\r\n], InviteReceivedNotification.prototype, \"fromContact\", void 0);\r\nexports.InviteReceivedNotification = InviteReceivedNotification;\r\nclass SelfContactNotification {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(Contact),\r\n    __metadata(\"design:type\", Contact)\r\n], SelfContactNotification.prototype, \"contact\", void 0);\r\nexports.SelfContactNotification = SelfContactNotification;\r\nclass ContactsNotification {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(Contact),\r\n    __metadata(\"design:type\", Array)\r\n], ContactsNotification.prototype, \"contacts\", void 0);\r\nexports.ContactsNotification = ContactsNotification;\r\nclass SuggestedContactsNotification extends ContactsNotification {\r\n}\r\nexports.SuggestedContactsNotification = SuggestedContactsNotification;\r\nclass ContactPresenceRequest {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(Contact),\r\n    __metadata(\"design:type\", Array)\r\n], ContactPresenceRequest.prototype, \"contacts\", void 0);\r\nexports.ContactPresenceRequest = ContactPresenceRequest;\r\nclass ContactResponse {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(Contact),\r\n    __metadata(\"design:type\", Contact)\r\n], ContactResponse.prototype, \"contact\", void 0);\r\nexports.ContactResponse = ContactResponse;\r\nclass ContactPresenceResponse {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(ContactResponse),\r\n    __metadata(\"design:type\", Array)\r\n], ContactPresenceResponse.prototype, \"contacts\", void 0);\r\nexports.ContactPresenceResponse = ContactPresenceResponse;\r\nclass ContactPresenceDisposeRequest {\r\n}\r\nexports.ContactPresenceDisposeRequest = ContactPresenceDisposeRequest;\r\nclass SearchContactProperty {\r\n}\r\nexports.SearchContactProperty = SearchContactProperty;\r\nclass SearchContactsRequest {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(SearchContactProperty),\r\n    __metadata(\"design:type\", Array)\r\n], SearchContactsRequest.prototype, \"queryOptions\", void 0);\r\nexports.SearchContactsRequest = SearchContactsRequest;\r\nclass SearchContactsResponse {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(Contact),\r\n    __metadata(\"design:type\", Array)\r\n], SearchContactsResponse.prototype, \"results\", void 0);\r\nexports.SearchContactsResponse = SearchContactsResponse;\r\nclass MessagePayload {\r\n}\r\nexports.MessagePayload = MessagePayload;\r\nclass SendMessageRequest extends MessagePayload {\r\n}\r\nexports.SendMessageRequest = SendMessageRequest;\r\nclass MessageReceivedNotification extends MessagePayload {\r\n}\r\nexports.MessageReceivedNotification = MessageReceivedNotification;\r\nclass SignInRequest {\r\n}\r\nexports.SignInRequest = SignInRequest;\r\nclass SignedStateChangedNotification {\r\n}\r\nexports.SignedStateChangedNotification = SignedStateChangedNotification;\r\nclass AuthenticationRequiredNotification {\r\n}\r\nexports.AuthenticationRequiredNotification = AuthenticationRequiredNotification;\r\nvar Methods;\r\n(function (Methods) {\r\n    Methods[\"RequestInitializeName\"] = \"initialize\";\r\n    Methods[\"RequestDisposeName\"] = \"dispose\";\r\n    Methods[\"RequestInviteName\"] = \"inviteLink\";\r\n    Methods[\"RequestPublishPresenceName\"] = \"publishPresence\";\r\n    Methods[\"RequestContactPresenceName\"] = \"contactPresenceRequest\";\r\n    Methods[\"RequestContactPresenceDisposeName\"] = \"contactPresenceDispose\";\r\n    Methods[\"RequestSearchContactsName\"] = \"searchContacts\";\r\n    Methods[\"RequestSendMessageName\"] = \"sendMessageRequest\";\r\n    Methods[\"RequestSignInName\"] = \"signIn\";\r\n    Methods[\"RequestSignOutName\"] = \"signOut\";\r\n    Methods[\"NotifyPresenceChangedName\"] = \"presenceChanged\";\r\n    Methods[\"NotifySelfContactName\"] = \"selfContact\";\r\n    Methods[\"NotifyAvailableUsersName\"] = \"availableUsers\";\r\n    Methods[\"NotifyAvailableUsersAddedName\"] = \"availableUsersAdded\";\r\n    Methods[\"NotifyAvailableUsersRemovedName\"] = \"availableUsersRemoved\";\r\n    Methods[\"NotifyInviteReceivedName\"] = \"inviteLinkReceived\";\r\n    Methods[\"NotifyContactChangedName\"] = \"contactChanged\";\r\n    Methods[\"NotifyContactPropertiesChangedName\"] = \"contactPropertiesChanged\";\r\n    Methods[\"NotifySuggestedUsersName\"] = \"suggestedUsers\";\r\n    Methods[\"NotifyCapabilitiesUpdateName\"] = \"capabilitiesUpdate\";\r\n    Methods[\"NotifyMessageReceivedName\"] = \"messageReceived\";\r\n    Methods[\"NotifySignedStateChangedName\"] = \"signedStateChanged\";\r\n    Methods[\"NotifyAuthenticationRequiredName\"] = \"authenticationRequired\";\r\n})(Methods = exports.Methods || (exports.Methods = {}));\r\nexports.ContactServiceProvider = {\r\n    methods: ['request'],\r\n    events: ['notified'],\r\n};\r\n//# sourceMappingURL=ContactProtocol.js.map","\"use strict\";\r\n//----------------------\r\n// <auto-generated>\r\n//     Generated using the NSwag toolchain v9.10.19.0 (Newtonsoft.Json v9.0.0.0) (http://NJsonSchema.org)\r\n// </auto-generated>\r\n//----------------------\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/** Describes the kind of data to be formatted. */\r\nconst vso_rpc_1 = require(\"@vs/vso-rpc\");\r\n/** Represents a data object containing attributes needed to access a remote stream. */\r\nclass RemoteStreamMoniker {\r\n}\r\nexports.RemoteStreamMoniker = RemoteStreamMoniker;\r\n/** File service root directory configuration. */\r\nclass FileServiceRootDirectoryConfiguration {\r\n}\r\nexports.FileServiceRootDirectoryConfiguration = FileServiceRootDirectoryConfiguration;\r\n/** File service root configuration. */\r\nclass FileServiceRootConfiguration {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(FileServiceRootDirectoryConfiguration),\r\n    __metadata(\"design:type\", Array)\r\n], FileServiceRootConfiguration.prototype, \"directories\", void 0);\r\nexports.FileServiceRootConfiguration = FileServiceRootConfiguration;\r\nclass MaybeImmutableOfAccessControl {\r\n}\r\nexports.MaybeImmutableOfAccessControl = MaybeImmutableOfAccessControl;\r\n/** Access control */\r\nclass AccessControl extends MaybeImmutableOfAccessControl {\r\n}\r\nexports.AccessControl = AccessControl;\r\nvar SeekOrigin;\r\n(function (SeekOrigin) {\r\n    SeekOrigin[SeekOrigin[\"Begin\"] = 'begin'] = \"Begin\";\r\n    SeekOrigin[SeekOrigin[\"Current\"] = 'current'] = \"Current\";\r\n    SeekOrigin[SeekOrigin[\"End\"] = 'end'] = \"End\";\r\n})(SeekOrigin = exports.SeekOrigin || (exports.SeekOrigin = {}));\r\nclass FeatureFlagStore {\r\n}\r\nexports.FeatureFlagStore = FeatureFlagStore;\r\nclass EventArgs {\r\n}\r\nexports.EventArgs = EventArgs;\r\nclass AttemptHubConnectionEventArgs extends EventArgs {\r\n}\r\nexports.AttemptHubConnectionEventArgs = AttemptHubConnectionEventArgs;\r\nvar HubConnectionError;\r\n(function (HubConnectionError) {\r\n    HubConnectionError[HubConnectionError[\"None\"] = 'none'] = \"None\";\r\n    HubConnectionError[HubConnectionError[\"TokenExpired\"] = 'tokenExpired'] = \"TokenExpired\";\r\n    HubConnectionError[HubConnectionError[\"ServiceUnavailable\"] = 'serviceUnavailable'] = \"ServiceUnavailable\";\r\n})(HubConnectionError = exports.HubConnectionError || (exports.HubConnectionError = {}));\r\nclass AgentTraceEventArgs extends EventArgs {\r\n}\r\nexports.AgentTraceEventArgs = AgentTraceEventArgs;\r\nclass AgentSessionRequest {\r\n}\r\nexports.AgentSessionRequest = AgentSessionRequest;\r\nclass AgentSessionResponse {\r\n}\r\nexports.AgentSessionResponse = AgentSessionResponse;\r\nclass AuthenticationToken {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Omit),\r\n    __metadata(\"design:type\", String)\r\n], AuthenticationToken.prototype, \"token\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Omit),\r\n    __metadata(\"design:type\", String)\r\n], AuthenticationToken.prototype, \"code\", void 0);\r\nexports.AuthenticationToken = AuthenticationToken;\r\n/** UserAccountInfo represents the minimum information we require in order to retrieve cached credentials in a machine. It purposefully doesn't include the User's Id, as that is unknown at the time of retrieval. */\r\nclass UserAccountInfo {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Hide),\r\n    __metadata(\"design:type\", String)\r\n], UserAccountInfo.prototype, \"accountId\", void 0);\r\nexports.UserAccountInfo = UserAccountInfo;\r\nclass UserInfo extends UserAccountInfo {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Hide),\r\n    __metadata(\"design:type\", String)\r\n], UserInfo.prototype, \"id\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Hide),\r\n    __metadata(\"design:type\", String)\r\n], UserInfo.prototype, \"displayName\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Email),\r\n    __metadata(\"design:type\", String)\r\n], UserInfo.prototype, \"emailAddress\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Hide),\r\n    __metadata(\"design:type\", String)\r\n], UserInfo.prototype, \"userName\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Uri),\r\n    __metadata(\"design:type\", String)\r\n], UserInfo.prototype, \"avatarUri\", void 0);\r\nexports.UserInfo = UserInfo;\r\nvar UserAccountStatus;\r\n(function (UserAccountStatus) {\r\n    UserAccountStatus[UserAccountStatus[\"Unknown\"] = 'unknown'] = \"Unknown\";\r\n    UserAccountStatus[UserAccountStatus[\"Transient\"] = 'transient'] = \"Transient\";\r\n    UserAccountStatus[UserAccountStatus[\"Pending\"] = 'pending'] = \"Pending\";\r\n    UserAccountStatus[UserAccountStatus[\"Accepted\"] = 'accepted'] = \"Accepted\";\r\n    UserAccountStatus[UserAccountStatus[\"Deleted\"] = 'deleted'] = \"Deleted\";\r\n})(UserAccountStatus = exports.UserAccountStatus || (exports.UserAccountStatus = {}));\r\nclass RecentCollaborator {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Email),\r\n    __metadata(\"design:type\", String)\r\n], RecentCollaborator.prototype, \"email\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Hide),\r\n    __metadata(\"design:type\", String)\r\n], RecentCollaborator.prototype, \"name\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Uri),\r\n    __metadata(\"design:type\", String)\r\n], RecentCollaborator.prototype, \"avatarUri\", void 0);\r\nexports.RecentCollaborator = RecentCollaborator;\r\nclass AuthenticationOptions {\r\n}\r\nexports.AuthenticationOptions = AuthenticationOptions;\r\nclass AuthenticationChangedEventArgs extends EventArgs {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(UserInfo),\r\n    __metadata(\"design:type\", UserInfo)\r\n], AuthenticationChangedEventArgs.prototype, \"account\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Omit),\r\n    __metadata(\"design:type\", String)\r\n], AuthenticationChangedEventArgs.prototype, \"accessToken\", void 0);\r\nexports.AuthenticationChangedEventArgs = AuthenticationChangedEventArgs;\r\nclass AuthenticatedUserInfo {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(UserInfo),\r\n    __metadata(\"design:type\", UserInfo)\r\n], AuthenticatedUserInfo.prototype, \"userInfo\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Omit),\r\n    __metadata(\"design:type\", String)\r\n], AuthenticatedUserInfo.prototype, \"accessToken\", void 0);\r\nexports.AuthenticatedUserInfo = AuthenticatedUserInfo;\r\n/** A data object containing charasteristics necessary to establish and configure a broker RPC session. */\r\nclass BrokerManifest {\r\n}\r\nexports.BrokerManifest = BrokerManifest;\r\n/** Represents event data associated with certain broker events. */\r\nclass BrokerEventArgs extends EventArgs {\r\n}\r\nexports.BrokerEventArgs = BrokerEventArgs;\r\nvar ChatMessageType;\r\n(function (ChatMessageType) {\r\n    ChatMessageType[ChatMessageType[\"Text\"] = 'text'] = \"Text\";\r\n    ChatMessageType[ChatMessageType[\"Typing\"] = 'typing'] = \"Typing\";\r\n})(ChatMessageType = exports.ChatMessageType || (exports.ChatMessageType = {}));\r\nclass ChatParticipant {\r\n}\r\nexports.ChatParticipant = ChatParticipant;\r\nclass ChatMessageBody {\r\n}\r\nexports.ChatMessageBody = ChatMessageBody;\r\nclass ChatMessage {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(ChatMessageBody),\r\n    __metadata(\"design:type\", ChatMessageBody)\r\n], ChatMessage.prototype, \"body\", void 0);\r\nexports.ChatMessage = ChatMessage;\r\nclass MessageReceivedEventArgs extends EventArgs {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(ChatMessage),\r\n    __metadata(\"design:type\", ChatMessage)\r\n], MessageReceivedEventArgs.prototype, \"message\", void 0);\r\nexports.MessageReceivedEventArgs = MessageReceivedEventArgs;\r\nclass Position {\r\n    constructor() {\r\n        /** The zero-based index of the character in the buffer. */\r\n        this.startOffset = -1;\r\n    }\r\n}\r\nexports.Position = Position;\r\nvar CommentThreadStatus;\r\n(function (CommentThreadStatus) {\r\n    CommentThreadStatus[CommentThreadStatus[\"Active\"] = 'active'] = \"Active\";\r\n    CommentThreadStatus[CommentThreadStatus[\"Closed\"] = 'closed'] = \"Closed\";\r\n})(CommentThreadStatus = exports.CommentThreadStatus || (exports.CommentThreadStatus = {}));\r\nclass CommentThreadContext {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Path),\r\n    __metadata(\"design:type\", String)\r\n], CommentThreadContext.prototype, \"filePath\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(Position),\r\n    __metadata(\"design:type\", Position)\r\n], CommentThreadContext.prototype, \"leftFileStart\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(Position),\r\n    __metadata(\"design:type\", Position)\r\n], CommentThreadContext.prototype, \"leftFileEnd\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(Position),\r\n    __metadata(\"design:type\", Position)\r\n], CommentThreadContext.prototype, \"rightFileStart\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(Position),\r\n    __metadata(\"design:type\", Position)\r\n], CommentThreadContext.prototype, \"rightFileEnd\", void 0);\r\nexports.CommentThreadContext = CommentThreadContext;\r\nclass Comment {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Text),\r\n    __metadata(\"design:type\", String)\r\n], Comment.prototype, \"participantId\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Text),\r\n    __metadata(\"design:type\", String)\r\n], Comment.prototype, \"participantLabel\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Text),\r\n    __metadata(\"design:type\", String)\r\n], Comment.prototype, \"text\", void 0);\r\nexports.Comment = Comment;\r\nclass CommentThread {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(Comment),\r\n    __metadata(\"design:type\", Array)\r\n], CommentThread.prototype, \"comments\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(CommentThreadContext),\r\n    __metadata(\"design:type\", CommentThreadContext)\r\n], CommentThread.prototype, \"threadContext\", void 0);\r\nexports.CommentThread = CommentThread;\r\nclass CommentThreadChangedEventArgs extends EventArgs {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(CommentThread),\r\n    __metadata(\"design:type\", CommentThread)\r\n], CommentThreadChangedEventArgs.prototype, \"newThread\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(Comment),\r\n    __metadata(\"design:type\", Comment)\r\n], CommentThreadChangedEventArgs.prototype, \"changedComment\", void 0);\r\nexports.CommentThreadChangedEventArgs = CommentThreadChangedEventArgs;\r\nclass CommentThreadLocation {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(CommentThreadContext),\r\n    vso_rpc_1.dataFormat(CommentThreadContext),\r\n    __metadata(\"design:type\", CommentThreadContext)\r\n], CommentThreadLocation.prototype, \"threadContext\", void 0);\r\nexports.CommentThreadLocation = CommentThreadLocation;\r\nclass AddressAndMask {\r\n}\r\nexports.AddressAndMask = AddressAndMask;\r\nclass AgentVersionInfo {\r\n}\r\nexports.AgentVersionInfo = AgentVersionInfo;\r\nclass ClientVersionInfo {\r\n}\r\nexports.ClientVersionInfo = ClientVersionInfo;\r\nvar FirewallStatus;\r\n(function (FirewallStatus) {\r\n    FirewallStatus[FirewallStatus[\"None\"] = 'none'] = \"None\";\r\n    FirewallStatus[FirewallStatus[\"Allow\"] = 'allow'] = \"Allow\";\r\n    FirewallStatus[FirewallStatus[\"Block\"] = 'block'] = \"Block\";\r\n})(FirewallStatus = exports.FirewallStatus || (exports.FirewallStatus = {}));\r\nclass HubMethodNotifyEventArgs extends EventArgs {\r\n}\r\nexports.HubMethodNotifyEventArgs = HubMethodNotifyEventArgs;\r\nclass HubConnectionStateEventArgs extends EventArgs {\r\n}\r\nexports.HubConnectionStateEventArgs = HubConnectionStateEventArgs;\r\n/** Possible states on an Invited Contact status */\r\nvar InviteContactStatus;\r\n(function (InviteContactStatus) {\r\n    InviteContactStatus[InviteContactStatus[\"None\"] = 'none'] = \"None\";\r\n    InviteContactStatus[InviteContactStatus[\"Invited\"] = 'invited'] = \"Invited\";\r\n    InviteContactStatus[InviteContactStatus[\"Dismissed\"] = 'dismissed'] = \"Dismissed\";\r\n    InviteContactStatus[InviteContactStatus[\"Joining\"] = 'joining'] = \"Joining\";\r\n    InviteContactStatus[InviteContactStatus[\"Joined\"] = 'joined'] = \"Joined\";\r\n})(InviteContactStatus = exports.InviteContactStatus || (exports.InviteContactStatus = {}));\r\n/** Define a notification entity when an invite status changed for an Invite contact */\r\nclass InviteStatusNotify {\r\n}\r\nexports.InviteStatusNotify = InviteStatusNotify;\r\n/** Represents state of Live Share session at online environment client. */\r\nvar LiveShareSessionState;\r\n(function (LiveShareSessionState) {\r\n    LiveShareSessionState[LiveShareSessionState[\"Idle\"] = 'idle'] = \"Idle\";\r\n    LiveShareSessionState[LiveShareSessionState[\"Shared\"] = 'shared'] = \"Shared\";\r\n})(LiveShareSessionState = exports.LiveShareSessionState || (exports.LiveShareSessionState = {}));\r\n/** Shared server info. StreamName and Condition can be used to get the streams from CancellationToken). */\r\nclass SharedServer {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Uri),\r\n    __metadata(\"design:type\", String)\r\n], SharedServer.prototype, \"browseUrl\", void 0);\r\nexports.SharedServer = SharedServer;\r\nvar PrivacyEnum;\r\n(function (PrivacyEnum) {\r\n    PrivacyEnum[PrivacyEnum[\"Private\"] = 'private'] = \"Private\";\r\n    PrivacyEnum[PrivacyEnum[\"Public\"] = 'public'] = \"Public\";\r\n    PrivacyEnum[PrivacyEnum[\"Org\"] = 'org'] = \"Org\";\r\n})(PrivacyEnum = exports.PrivacyEnum || (exports.PrivacyEnum = {}));\r\n/** Shared pipe info. StreamName and Condition can be used to get the streams from CancellationToken). */\r\nclass SharedPipe {\r\n}\r\nexports.SharedPipe = SharedPipe;\r\n/** Event args for an event when a new server is shared. */\r\nclass ServerSharingStartedEventArgs extends EventArgs {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(SharedServer),\r\n    __metadata(\"design:type\", SharedServer)\r\n], ServerSharingStartedEventArgs.prototype, \"server\", void 0);\r\nexports.ServerSharingStartedEventArgs = ServerSharingStartedEventArgs;\r\n/** Event args for an event when a new pipe is shared. */\r\nclass PipeSharingStartedEventArgs extends EventArgs {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(SharedPipe),\r\n    __metadata(\"design:type\", SharedPipe)\r\n], PipeSharingStartedEventArgs.prototype, \"pipe\", void 0);\r\nexports.PipeSharingStartedEventArgs = PipeSharingStartedEventArgs;\r\n/** Event args for an event when a server is no longer shared. */\r\nclass ServerSharingStoppedEventArgs extends EventArgs {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(SharedServer),\r\n    __metadata(\"design:type\", SharedServer)\r\n], ServerSharingStoppedEventArgs.prototype, \"server\", void 0);\r\nexports.ServerSharingStoppedEventArgs = ServerSharingStoppedEventArgs;\r\n/** Event args for an event when a pipe is no longer shared. */\r\nclass PipeSharingStoppedEventArgs extends EventArgs {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(SharedPipe),\r\n    __metadata(\"design:type\", SharedPipe)\r\n], PipeSharingStoppedEventArgs.prototype, \"pipe\", void 0);\r\nexports.PipeSharingStoppedEventArgs = PipeSharingStoppedEventArgs;\r\n/** Event args for an event when a server is updated. */\r\nclass ServerSharingChangedEventArgs extends EventArgs {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(SharedServer),\r\n    __metadata(\"design:type\", SharedServer)\r\n], ServerSharingChangedEventArgs.prototype, \"server\", void 0);\r\nexports.ServerSharingChangedEventArgs = ServerSharingChangedEventArgs;\r\nclass SessionUpdateEventArgs extends EventArgs {\r\n}\r\nexports.SessionUpdateEventArgs = SessionUpdateEventArgs;\r\n/** Source control identity. */\r\nclass SourceControlIdentifier {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Path),\r\n    __metadata(\"design:type\", String)\r\n], SourceControlIdentifier.prototype, \"instanceId\", void 0);\r\nexports.SourceControlIdentifier = SourceControlIdentifier;\r\n/** Version within source control. */\r\nclass SourceControlVersion {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Path),\r\n    __metadata(\"design:type\", String)\r\n], SourceControlVersion.prototype, \"version\", void 0);\r\nexports.SourceControlVersion = SourceControlVersion;\r\n/** Type of source control resource. */\r\nvar SourceControlResourceType;\r\n(function (SourceControlResourceType) {\r\n    SourceControlResourceType[SourceControlResourceType[\"Workspace\"] = 'workspace'] = \"Workspace\";\r\n    SourceControlResourceType[SourceControlResourceType[\"External\"] = 'external'] = \"External\";\r\n    SourceControlResourceType[SourceControlResourceType[\"SpecificVerision\"] = 'specificVerision'] = \"SpecificVerision\";\r\n    SourceControlResourceType[SourceControlResourceType[\"WorkspaceWithSpecificVersion\"] = 'workspaceWithSpecificVersion'] = \"WorkspaceWithSpecificVersion\";\r\n})(SourceControlResourceType = exports.SourceControlResourceType || (exports.SourceControlResourceType = {}));\r\n/** Type of source control resource change or diff. */\r\nvar SourceControlChangeType;\r\n(function (SourceControlChangeType) {\r\n    SourceControlChangeType[SourceControlChangeType[\"None\"] = 'none'] = \"None\";\r\n    SourceControlChangeType[SourceControlChangeType[\"Add\"] = 'add'] = \"Add\";\r\n    SourceControlChangeType[SourceControlChangeType[\"Edit\"] = 'edit'] = \"Edit\";\r\n    SourceControlChangeType[SourceControlChangeType[\"Delete\"] = 'delete'] = \"Delete\";\r\n    SourceControlChangeType[SourceControlChangeType[\"Rename\"] = 'rename'] = \"Rename\";\r\n    SourceControlChangeType[SourceControlChangeType[\"Conflict\"] = 'conflict'] = \"Conflict\";\r\n    SourceControlChangeType[SourceControlChangeType[\"IndexEdit\"] = 'indexEdit'] = \"IndexEdit\";\r\n    SourceControlChangeType[SourceControlChangeType[\"IndexDelete\"] = 'indexDelete'] = \"IndexDelete\";\r\n    SourceControlChangeType[SourceControlChangeType[\"IndexCopy\"] = 'indexCopy'] = \"IndexCopy\";\r\n    SourceControlChangeType[SourceControlChangeType[\"Untracked\"] = 'untracked'] = \"Untracked\";\r\n    SourceControlChangeType[SourceControlChangeType[\"Ignored\"] = 'ignored'] = \"Ignored\";\r\n    SourceControlChangeType[SourceControlChangeType[\"AddByUs\"] = 'addByUs'] = \"AddByUs\";\r\n    SourceControlChangeType[SourceControlChangeType[\"AddByThem\"] = 'addByThem'] = \"AddByThem\";\r\n    SourceControlChangeType[SourceControlChangeType[\"DeleteByUs\"] = 'deleteByUs'] = \"DeleteByUs\";\r\n    SourceControlChangeType[SourceControlChangeType[\"DeleteByThem\"] = 'deleteByThem'] = \"DeleteByThem\";\r\n    SourceControlChangeType[SourceControlChangeType[\"AddBoth\"] = 'addBoth'] = \"AddBoth\";\r\n    SourceControlChangeType[SourceControlChangeType[\"DeleteBoth\"] = 'deleteBoth'] = \"DeleteBoth\";\r\n})(SourceControlChangeType = exports.SourceControlChangeType || (exports.SourceControlChangeType = {}));\r\n/** Resource under source control. */\r\nclass SourceControlResource {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Path),\r\n    __metadata(\"design:type\", String)\r\n], SourceControlResource.prototype, \"path\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Path),\r\n    __metadata(\"design:type\", String)\r\n], SourceControlResource.prototype, \"version\", void 0);\r\nexports.SourceControlResource = SourceControlResource;\r\n/** Individual file state under source control. */\r\nclass SourceControlResourceState {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(SourceControlResource),\r\n    __metadata(\"design:type\", SourceControlResource)\r\n], SourceControlResourceState.prototype, \"current\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(SourceControlResource),\r\n    __metadata(\"design:type\", SourceControlResource)\r\n], SourceControlResourceState.prototype, \"original\", void 0);\r\nexports.SourceControlResourceState = SourceControlResourceState;\r\n/** Identifier of the source control resource. */\r\nclass SourceControlResourceIdentifier extends SourceControlResource {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Uri),\r\n    __metadata(\"design:type\", String)\r\n], SourceControlResourceIdentifier.prototype, \"instanceId\", void 0);\r\nexports.SourceControlResourceIdentifier = SourceControlResourceIdentifier;\r\n/** Group of source-controlled states, e.g. 'Changes', 'Index', or 'Merge' in git. */\r\nclass SourceControlResourceGroup {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(SourceControlResourceState),\r\n    __metadata(\"design:type\", Array)\r\n], SourceControlResourceGroup.prototype, \"resourceStates\", void 0);\r\nexports.SourceControlResourceGroup = SourceControlResourceGroup;\r\n/** Source control data. */\r\nclass SourceControlInstance extends SourceControlIdentifier {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Path),\r\n    __metadata(\"design:type\", String)\r\n], SourceControlInstance.prototype, \"name\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(SourceControlResourceGroup),\r\n    __metadata(\"design:type\", Array)\r\n], SourceControlInstance.prototype, \"resourceGroups\", void 0);\r\nexports.SourceControlInstance = SourceControlInstance;\r\n/** Source control resource diff info. */\r\nclass SourceControlResourceDiff {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(SourceControlResource),\r\n    __metadata(\"design:type\", SourceControlResource)\r\n], SourceControlResourceDiff.prototype, \"right\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(SourceControlResource),\r\n    __metadata(\"design:type\", SourceControlResource)\r\n], SourceControlResourceDiff.prototype, \"left\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Path),\r\n    __metadata(\"design:type\", String)\r\n], SourceControlResourceDiff.prototype, \"title\", void 0);\r\nexports.SourceControlResourceDiff = SourceControlResourceDiff;\r\n/** Source control change type. */\r\nvar SourceControlChange;\r\n(function (SourceControlChange) {\r\n    SourceControlChange[SourceControlChange[\"Updated\"] = 'updated'] = \"Updated\";\r\n    SourceControlChange[SourceControlChange[\"Added\"] = 'added'] = \"Added\";\r\n    SourceControlChange[SourceControlChange[\"Removed\"] = 'removed'] = \"Removed\";\r\n})(SourceControlChange = exports.SourceControlChange || (exports.SourceControlChange = {}));\r\n/** Event args for event when source control changed on the host. */\r\nclass SourceControlChangedEventArgs extends EventArgs {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(SourceControlIdentifier),\r\n    __metadata(\"design:type\", SourceControlIdentifier)\r\n], SourceControlChangedEventArgs.prototype, \"sourceControl\", void 0);\r\nexports.SourceControlChangedEventArgs = SourceControlChangedEventArgs;\r\n/** Event args for event when source control resources changed on the host. */\r\nclass SourceControlResourceChangedEventArgs extends EventArgs {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(SourceControlIdentifier),\r\n    __metadata(\"design:type\", SourceControlIdentifier)\r\n], SourceControlResourceChangedEventArgs.prototype, \"sourceControl\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(SourceControlResource),\r\n    __metadata(\"design:type\", Array)\r\n], SourceControlResourceChangedEventArgs.prototype, \"resources\", void 0);\r\nexports.SourceControlResourceChangedEventArgs = SourceControlResourceChangedEventArgs;\r\nclass SyncStatus {\r\n}\r\nexports.SyncStatus = SyncStatus;\r\n/** A content type of a task output or feed. */\r\nvar TaskOutputContentType;\r\n(function (TaskOutputContentType) {\r\n    TaskOutputContentType[TaskOutputContentType[\"PlainText\"] = 'plainText'] = \"PlainText\";\r\n    TaskOutputContentType[TaskOutputContentType[\"TextWithAnsiEscapeCodes\"] = 'textWithAnsiEscapeCodes'] = \"TextWithAnsiEscapeCodes\";\r\n})(TaskOutputContentType = exports.TaskOutputContentType || (exports.TaskOutputContentType = {}));\r\n/** Single task execution feed */\r\nclass TaskOutputFeedInfo {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(RemoteStreamMoniker),\r\n    __metadata(\"design:type\", RemoteStreamMoniker)\r\n], TaskOutputFeedInfo.prototype, \"streamMoniker\", void 0);\r\nexports.TaskOutputFeedInfo = TaskOutputFeedInfo;\r\n/** Options pertaining to a task output */\r\nclass TaskOutputOptions {\r\n}\r\nexports.TaskOutputOptions = TaskOutputOptions;\r\n/** Represents a task output, typically associated with a output or terminal window in IDE. It can be used to send ouput from task execution feeds. Only one feed can be active. */\r\nclass TaskOutputInfo {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(TaskOutputFeedInfo),\r\n    __metadata(\"design:type\", TaskOutputFeedInfo)\r\n], TaskOutputInfo.prototype, \"feed\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(TaskOutputOptions),\r\n    __metadata(\"design:type\", TaskOutputOptions)\r\n], TaskOutputInfo.prototype, \"options\", void 0);\r\nexports.TaskOutputInfo = TaskOutputInfo;\r\n/** Represents an event data sent with a task output event. */\r\nclass TaskOutputEventArgs extends EventArgs {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(TaskOutputInfo),\r\n    __metadata(\"design:type\", TaskOutputInfo)\r\n], TaskOutputEventArgs.prototype, \"taskOutput\", void 0);\r\nexports.TaskOutputEventArgs = TaskOutputEventArgs;\r\nclass TelemetrySettings {\r\n}\r\nexports.TelemetrySettings = TelemetrySettings;\r\nclass GenericOperationEventArgs extends EventArgs {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Omit),\r\n    __metadata(\"design:type\", Object)\r\n], GenericOperationEventArgs.prototype, \"payload\", void 0);\r\nexports.GenericOperationEventArgs = GenericOperationEventArgs;\r\nvar TelemetryResult;\r\n(function (TelemetryResult) {\r\n    TelemetryResult[TelemetryResult[\"None\"] = 'none'] = \"None\";\r\n    TelemetryResult[TelemetryResult[\"Success\"] = 'success'] = \"Success\";\r\n    TelemetryResult[TelemetryResult[\"Failure\"] = 'failure'] = \"Failure\";\r\n    TelemetryResult[TelemetryResult[\"UserFault\"] = 'userFault'] = \"UserFault\";\r\n    TelemetryResult[TelemetryResult[\"UserCancel\"] = 'userCancel'] = \"UserCancel\";\r\n})(TelemetryResult = exports.TelemetryResult || (exports.TelemetryResult = {}));\r\nclass FaultTelemetryEventArgs extends EventArgs {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Omit),\r\n    __metadata(\"design:type\", Object)\r\n], FaultTelemetryEventArgs.prototype, \"payload\", void 0);\r\nexports.FaultTelemetryEventArgs = FaultTelemetryEventArgs;\r\n/** Options that control how terminal is started */\r\nclass TerminalOptions {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Path),\r\n    __metadata(\"design:type\", String)\r\n], TerminalOptions.prototype, \"cwd\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Path),\r\n    __metadata(\"design:type\", String)\r\n], TerminalOptions.prototype, \"app\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Hide),\r\n    __metadata(\"design:type\", Array)\r\n], TerminalOptions.prototype, \"commandLine\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Omit),\r\n    __metadata(\"design:type\", Boolean)\r\n], TerminalOptions.prototype, \"verbatimCommandLine\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Omit),\r\n    __metadata(\"design:type\", Object)\r\n], TerminalOptions.prototype, \"environment\", void 0);\r\nexports.TerminalOptions = TerminalOptions;\r\n/** Info on running terminal */\r\nclass TerminalInfo {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(TerminalOptions),\r\n    __metadata(\"design:type\", TerminalOptions)\r\n], TerminalInfo.prototype, \"options\", void 0);\r\nexports.TerminalInfo = TerminalInfo;\r\n/** Event args for notification for a terminal */\r\nclass TerminalEventArgs extends EventArgs {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(TerminalInfo),\r\n    __metadata(\"design:type\", TerminalInfo)\r\n], TerminalEventArgs.prototype, \"terminal\", void 0);\r\nexports.TerminalEventArgs = TerminalEventArgs;\r\n/** A class that describes a restricted operation which is controlled by access control. By default, the operation is disabled in read-only session. */\r\nclass RestrictedOperation {\r\n}\r\nexports.RestrictedOperation = RestrictedOperation;\r\n/** Restricted operation for a specific terminal */\r\nclass SharedTerminalRestrictedOperation extends RestrictedOperation {\r\n}\r\nexports.SharedTerminalRestrictedOperation = SharedTerminalRestrictedOperation;\r\nclass VSServerWorkspaceInfo {\r\n}\r\nexports.VSServerWorkspaceInfo = VSServerWorkspaceInfo;\r\nclass VSServerCreateSessionInfo {\r\n}\r\nexports.VSServerCreateSessionInfo = VSServerCreateSessionInfo;\r\nclass MaybeImmutableOfWorkspaceAccessControl {\r\n}\r\nexports.MaybeImmutableOfWorkspaceAccessControl = MaybeImmutableOfWorkspaceAccessControl;\r\n/** Event args for an event when user access control changes. */\r\nclass WorkspaceAccessControl extends MaybeImmutableOfWorkspaceAccessControl {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(AccessControl),\r\n    __metadata(\"design:type\", AccessControl)\r\n], WorkspaceAccessControl.prototype, \"defaultAccessControl\", void 0);\r\nexports.WorkspaceAccessControl = WorkspaceAccessControl;\r\n/** Event args for an event when user access control changes. */\r\nclass WorkspaceAccessControlEventArgs extends EventArgs {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(WorkspaceAccessControl),\r\n    __metadata(\"design:type\", WorkspaceAccessControl)\r\n], WorkspaceAccessControlEventArgs.prototype, \"accessControl\", void 0);\r\nexports.WorkspaceAccessControlEventArgs = WorkspaceAccessControlEventArgs;\r\n/** Event args for an event when a guest requests access to a restricted operation. */\r\nclass RestrictedOperationAccessRequestedEventArgs extends EventArgs {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(RestrictedOperation),\r\n    __metadata(\"design:type\", RestrictedOperation)\r\n], RestrictedOperationAccessRequestedEventArgs.prototype, \"operation\", void 0);\r\nexports.RestrictedOperationAccessRequestedEventArgs = RestrictedOperationAccessRequestedEventArgs;\r\n/** Represents severity of an error reported by a workspace task. */\r\nvar ErrorSeverity;\r\n(function (ErrorSeverity) {\r\n    ErrorSeverity[ErrorSeverity[\"Error\"] = 'error'] = \"Error\";\r\n    ErrorSeverity[ErrorSeverity[\"Warning\"] = 'warning'] = \"Warning\";\r\n    ErrorSeverity[ErrorSeverity[\"Message\"] = 'message'] = \"Message\";\r\n})(ErrorSeverity = exports.ErrorSeverity || (exports.ErrorSeverity = {}));\r\n/** An entry representing error, warning or message generated by a workspace task */\r\nclass DiagnosticEntry {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Path),\r\n    __metadata(\"design:type\", String)\r\n], DiagnosticEntry.prototype, \"fileId\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Hide),\r\n    __metadata(\"design:type\", String)\r\n], DiagnosticEntry.prototype, \"message\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Omit),\r\n    __metadata(\"design:type\", Object)\r\n], DiagnosticEntry.prototype, \"properties\", void 0);\r\nexports.DiagnosticEntry = DiagnosticEntry;\r\n/** Describes a diagnostic data event containing a collection of diagnostic entries emitted by a workspace task. */\r\nclass DiagnosticDataChangedEventArgs extends EventArgs {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(DiagnosticEntry),\r\n    __metadata(\"design:type\", Array)\r\n], DiagnosticDataChangedEventArgs.prototype, \"entries\", void 0);\r\nexports.DiagnosticDataChangedEventArgs = DiagnosticDataChangedEventArgs;\r\n/** Invitation link info provided to the agent to create an access control link */\r\nclass InvitationLinkInfo {\r\n}\r\nexports.InvitationLinkInfo = InvitationLinkInfo;\r\nclass WorkspaceInfo {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Text),\r\n    __metadata(\"design:type\", String)\r\n], WorkspaceInfo.prototype, \"name\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Omit),\r\n    __metadata(\"design:type\", String)\r\n], WorkspaceInfo.prototype, \"joinUri\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Omit),\r\n    __metadata(\"design:type\", String)\r\n], WorkspaceInfo.prototype, \"ownerId\", void 0);\r\nexports.WorkspaceInfo = WorkspaceInfo;\r\nvar WorkspaceConnectionStatus;\r\n(function (WorkspaceConnectionStatus) {\r\n    WorkspaceConnectionStatus[WorkspaceConnectionStatus[\"Unknown\"] = 'unknown'] = \"Unknown\";\r\n    WorkspaceConnectionStatus[WorkspaceConnectionStatus[\"Available\"] = 'available'] = \"Available\";\r\n    WorkspaceConnectionStatus[WorkspaceConnectionStatus[\"Unavailable\"] = 'unavailable'] = \"Unavailable\";\r\n    WorkspaceConnectionStatus[WorkspaceConnectionStatus[\"Connected\"] = 'connected'] = \"Connected\";\r\n    WorkspaceConnectionStatus[WorkspaceConnectionStatus[\"Disconnected\"] = 'disconnected'] = \"Disconnected\";\r\n})(WorkspaceConnectionStatus = exports.WorkspaceConnectionStatus || (exports.WorkspaceConnectionStatus = {}));\r\nvar WorkspaceDisconnectedReason;\r\n(function (WorkspaceDisconnectedReason) {\r\n    WorkspaceDisconnectedReason[WorkspaceDisconnectedReason[\"None\"] = 'none'] = \"None\";\r\n    WorkspaceDisconnectedReason[WorkspaceDisconnectedReason[\"Requested\"] = 'requested'] = \"Requested\";\r\n    WorkspaceDisconnectedReason[WorkspaceDisconnectedReason[\"UserRemoved\"] = 'userRemoved'] = \"UserRemoved\";\r\n    WorkspaceDisconnectedReason[WorkspaceDisconnectedReason[\"UserBlocked\"] = 'userBlocked'] = \"UserBlocked\";\r\n    WorkspaceDisconnectedReason[WorkspaceDisconnectedReason[\"SessionEnded\"] = 'sessionEnded'] = \"SessionEnded\";\r\n    WorkspaceDisconnectedReason[WorkspaceDisconnectedReason[\"ConnectionLost\"] = 'connectionLost'] = \"ConnectionLost\";\r\n    WorkspaceDisconnectedReason[WorkspaceDisconnectedReason[\"InternalError\"] = 'internalError'] = \"InternalError\";\r\n    WorkspaceDisconnectedReason[WorkspaceDisconnectedReason[\"SessionExpired\"] = 'sessionExpired'] = \"SessionExpired\";\r\n    WorkspaceDisconnectedReason[WorkspaceDisconnectedReason[\"NetworkDisconnected\"] = 'networkDisconnected'] = \"NetworkDisconnected\";\r\n    WorkspaceDisconnectedReason[WorkspaceDisconnectedReason[\"ListenerWentOffline\"] = 'listenerWentOffline'] = \"ListenerWentOffline\";\r\n    WorkspaceDisconnectedReason[WorkspaceDisconnectedReason[\"CollaborationServiceFactoryCriticalFailure\"] = 'collaborationServiceFactoryCriticalFailure'] = \"CollaborationServiceFactoryCriticalFailure\";\r\n})(WorkspaceDisconnectedReason = exports.WorkspaceDisconnectedReason || (exports.WorkspaceDisconnectedReason = {}));\r\nclass WorkspaceConnectionStatusChangedEventArgs extends EventArgs {\r\n}\r\nexports.WorkspaceConnectionStatusChangedEventArgs = WorkspaceConnectionStatusChangedEventArgs;\r\n/** Event that is fired by IWorkspaceService when shared workspace become ready for connections */\r\nclass WorkspaceReadyForConnectionEventArgs extends EventArgs {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(WorkspaceInfo),\r\n    __metadata(\"design:type\", WorkspaceInfo)\r\n], WorkspaceReadyForConnectionEventArgs.prototype, \"workspace\", void 0);\r\nexports.WorkspaceReadyForConnectionEventArgs = WorkspaceReadyForConnectionEventArgs;\r\nvar WorkspaceProgress;\r\n(function (WorkspaceProgress) {\r\n    WorkspaceProgress[WorkspaceProgress[\"None\"] = 'none'] = \"None\";\r\n    WorkspaceProgress[WorkspaceProgress[\"CreatedWorkspace\"] = 'createdWorkspace'] = \"CreatedWorkspace\";\r\n    WorkspaceProgress[WorkspaceProgress[\"InitializedAgentServices\"] = 'initializedAgentServices'] = \"InitializedAgentServices\";\r\n    WorkspaceProgress[WorkspaceProgress[\"InitializedRelayAndTCP\"] = 'initializedRelayAndTCP'] = \"InitializedRelayAndTCP\";\r\n    WorkspaceProgress[WorkspaceProgress[\"AddedUserToWorkspace\"] = 'addedUserToWorkspace'] = \"AddedUserToWorkspace\";\r\n    WorkspaceProgress[WorkspaceProgress[\"JoinedLocalWorkspace\"] = 'joinedLocalWorkspace'] = \"JoinedLocalWorkspace\";\r\n    WorkspaceProgress[WorkspaceProgress[\"ReadWorkspaceInfo\"] = 'readWorkspaceInfo'] = \"ReadWorkspaceInfo\";\r\n    WorkspaceProgress[WorkspaceProgress[\"OpeningRemoteSession\"] = 'openingRemoteSession'] = \"OpeningRemoteSession\";\r\n    WorkspaceProgress[WorkspaceProgress[\"OpenedRemoteSession\"] = 'openedRemoteSession'] = \"OpenedRemoteSession\";\r\n    WorkspaceProgress[WorkspaceProgress[\"JoiningRemoteSession\"] = 'joiningRemoteSession'] = \"JoiningRemoteSession\";\r\n    WorkspaceProgress[WorkspaceProgress[\"JoinedRemoteSession\"] = 'joinedRemoteSession'] = \"JoinedRemoteSession\";\r\n    WorkspaceProgress[WorkspaceProgress[\"WaitingForHost\"] = 'waitingForHost'] = \"WaitingForHost\";\r\n    WorkspaceProgress[WorkspaceProgress[\"DoneWaitingForHost\"] = 'doneWaitingForHost'] = \"DoneWaitingForHost\";\r\n    WorkspaceProgress[WorkspaceProgress[\"ReconnectingToHost\"] = 'reconnectingToHost'] = \"ReconnectingToHost\";\r\n    WorkspaceProgress[WorkspaceProgress[\"ReconnectedToHost\"] = 'reconnectedToHost'] = \"ReconnectedToHost\";\r\n    WorkspaceProgress[WorkspaceProgress[\"ReconnectionFailed\"] = 'reconnectionFailed'] = \"ReconnectionFailed\";\r\n    WorkspaceProgress[WorkspaceProgress[\"UpdatedWorkspace\"] = 'updatedWorkspace'] = \"UpdatedWorkspace\";\r\n})(WorkspaceProgress = exports.WorkspaceProgress || (exports.WorkspaceProgress = {}));\r\nclass WorkspaceProgressEventArgs extends EventArgs {\r\n}\r\nexports.WorkspaceProgressEventArgs = WorkspaceProgressEventArgs;\r\nclass WorkspaceShareInfo extends WorkspaceInfo {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Path),\r\n    __metadata(\"design:type\", Array)\r\n], WorkspaceShareInfo.prototype, \"rootDirectories\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(FileServiceRootConfiguration),\r\n    __metadata(\"design:type\", FileServiceRootConfiguration)\r\n], WorkspaceShareInfo.prototype, \"persistentRootConfiguration\", void 0);\r\nexports.WorkspaceShareInfo = WorkspaceShareInfo;\r\n/** Defines the ways that an RPC caller can connect to a workspace when joining. */\r\nvar ConnectionMode;\r\n(function (ConnectionMode) {\r\n    ConnectionMode[ConnectionMode[\"Auto\"] = 'auto'] = \"Auto\";\r\n    ConnectionMode[ConnectionMode[\"Direct\"] = 'direct'] = \"Direct\";\r\n    ConnectionMode[ConnectionMode[\"Relay\"] = 'relay'] = \"Relay\";\r\n    ConnectionMode[ConnectionMode[\"Local\"] = 'local'] = \"Local\";\r\n    ConnectionMode[ConnectionMode[\"SignalR\"] = 'signalR'] = \"SignalR\";\r\n})(ConnectionMode = exports.ConnectionMode || (exports.ConnectionMode = {}));\r\nclass ClientCapabilities {\r\n}\r\nexports.ClientCapabilities = ClientCapabilities;\r\nclass WorkspaceJoinInfo {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Text),\r\n    __metadata(\"design:type\", String)\r\n], WorkspaceJoinInfo.prototype, \"directAddress\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Text),\r\n    __metadata(\"design:type\", String)\r\n], WorkspaceJoinInfo.prototype, \"relayAddress\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Token),\r\n    __metadata(\"design:type\", String)\r\n], WorkspaceJoinInfo.prototype, \"relaySharedAccessSignature\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Token),\r\n    __metadata(\"design:type\", String)\r\n], WorkspaceJoinInfo.prototype, \"joiningUserSessionToken\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(ClientCapabilities),\r\n    __metadata(\"design:type\", ClientCapabilities)\r\n], WorkspaceJoinInfo.prototype, \"clientCapabilities\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Token),\r\n    __metadata(\"design:type\", String)\r\n], WorkspaceJoinInfo.prototype, \"userIdentity\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Token),\r\n    __metadata(\"design:type\", String)\r\n], WorkspaceJoinInfo.prototype, \"initialViewName\", void 0);\r\nexports.WorkspaceJoinInfo = WorkspaceJoinInfo;\r\nclass WorkspaceListOptions {\r\n    constructor() {\r\n        /** Optionally include remote workspaces. */\r\n        this.includeRemoteWorkspaces = true;\r\n        /** Get only the managed workspaces. */\r\n        this.onlyManagedWorkspaces = false;\r\n    }\r\n}\r\nexports.WorkspaceListOptions = WorkspaceListOptions;\r\nclass WorkspaceSessionInfo extends WorkspaceInfo {\r\n}\r\nexports.WorkspaceSessionInfo = WorkspaceSessionInfo;\r\nclass WorkspaceUserProfile {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Text),\r\n    __metadata(\"design:type\", String)\r\n], WorkspaceUserProfile.prototype, \"name\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Email),\r\n    __metadata(\"design:type\", String)\r\n], WorkspaceUserProfile.prototype, \"email\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Text),\r\n    __metadata(\"design:type\", String)\r\n], WorkspaceUserProfile.prototype, \"userName\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Text),\r\n    __metadata(\"design:type\", String)\r\n], WorkspaceUserProfile.prototype, \"provider\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Uri),\r\n    __metadata(\"design:type\", String)\r\n], WorkspaceUserProfile.prototype, \"avatarUri\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(ClientCapabilities),\r\n    __metadata(\"design:type\", ClientCapabilities)\r\n], WorkspaceUserProfile.prototype, \"clientCapabilities\", void 0);\r\nexports.WorkspaceUserProfile = WorkspaceUserProfile;\r\nclass WorkspaceServicesChangedEventArgs extends EventArgs {\r\n}\r\nexports.WorkspaceServicesChangedEventArgs = WorkspaceServicesChangedEventArgs;\r\nvar CollectionChangeType;\r\n(function (CollectionChangeType) {\r\n    CollectionChangeType[CollectionChangeType[\"None\"] = 'none'] = \"None\";\r\n    CollectionChangeType[CollectionChangeType[\"Add\"] = 'add'] = \"Add\";\r\n    CollectionChangeType[CollectionChangeType[\"Remove\"] = 'remove'] = \"Remove\";\r\n    CollectionChangeType[CollectionChangeType[\"Replace\"] = 'replace'] = \"Replace\";\r\n})(CollectionChangeType = exports.CollectionChangeType || (exports.CollectionChangeType = {}));\r\nclass GuestAcceptance {\r\n}\r\nexports.GuestAcceptance = GuestAcceptance;\r\nvar WorkspaceSessionChangeType;\r\n(function (WorkspaceSessionChangeType) {\r\n    WorkspaceSessionChangeType[WorkspaceSessionChangeType[\"None\"] = 'none'] = \"None\";\r\n    WorkspaceSessionChangeType[WorkspaceSessionChangeType[\"Joined\"] = 'joined'] = \"Joined\";\r\n    WorkspaceSessionChangeType[WorkspaceSessionChangeType[\"Unjoined\"] = 'unjoined'] = \"Unjoined\";\r\n    WorkspaceSessionChangeType[WorkspaceSessionChangeType[\"Canceled\"] = 'canceled'] = \"Canceled\";\r\n    WorkspaceSessionChangeType[WorkspaceSessionChangeType[\"Requested\"] = 'requested'] = \"Requested\";\r\n})(WorkspaceSessionChangeType = exports.WorkspaceSessionChangeType || (exports.WorkspaceSessionChangeType = {}));\r\nclass WorkspaceSessionChangedEventArgs extends EventArgs {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(WorkspaceUserProfile),\r\n    __metadata(\"design:type\", WorkspaceUserProfile)\r\n], WorkspaceSessionChangedEventArgs.prototype, \"userProfile\", void 0);\r\nexports.WorkspaceSessionChangedEventArgs = WorkspaceSessionChangedEventArgs;\r\nclass UserSettings {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(FeatureFlagStore),\r\n    __metadata(\"design:type\", FeatureFlagStore)\r\n], UserSettings.prototype, \"experimentalFeatures\", void 0);\r\nexports.UserSettings = UserSettings;\r\nclass VSOnlineSettings {\r\n}\r\nexports.VSOnlineSettings = VSOnlineSettings;\r\nclass TextChange {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Text),\r\n    __metadata(\"design:type\", String)\r\n], TextChange.prototype, \"newText\", void 0);\r\nexports.TextChange = TextChange;\r\nclass MessageBase {\r\n    constructor() {\r\n        this.messageType = MessageType.Unknown;\r\n    }\r\n}\r\nexports.MessageBase = MessageBase;\r\nvar MessageType;\r\n(function (MessageType) {\r\n    MessageType[MessageType[\"SelectionChange\"] = 'selectionChange'] = \"SelectionChange\";\r\n    MessageType[MessageType[\"NotebookSelectionChange\"] = 'notebookSelectionChange'] = \"NotebookSelectionChange\";\r\n    MessageType[MessageType[\"VisibleRangesChange\"] = 'visibleRangesChange'] = \"VisibleRangesChange\";\r\n    MessageType[MessageType[\"TextChange\"] = 'textChange'] = \"TextChange\";\r\n    MessageType[MessageType[\"FileOpenRequest\"] = 'fileOpenRequest'] = \"FileOpenRequest\";\r\n    MessageType[MessageType[\"ResetFileClient\"] = 'resetFileClient'] = \"ResetFileClient\";\r\n    MessageType[MessageType[\"UntitledFileSaved\"] = 'untitledFileSaved'] = \"UntitledFileSaved\";\r\n    MessageType[MessageType[\"UntitledFileOpened\"] = 'untitledFileOpened'] = \"UntitledFileOpened\";\r\n    MessageType[MessageType[\"UntitledFileClosed\"] = 'untitledFileClosed'] = \"UntitledFileClosed\";\r\n    MessageType[MessageType[\"DiffViewOpen\"] = 'diffViewOpen'] = \"DiffViewOpen\";\r\n    MessageType[MessageType[\"DiffViewClosed\"] = 'diffViewClosed'] = \"DiffViewClosed\";\r\n    MessageType[MessageType[\"FileOpenAcknowledge\"] = 'fileOpenAcknowledge'] = \"FileOpenAcknowledge\";\r\n    MessageType[MessageType[\"FileRelease\"] = 'fileRelease'] = \"FileRelease\";\r\n    MessageType[MessageType[\"SaveFile\"] = 'saveFile'] = \"SaveFile\";\r\n    MessageType[MessageType[\"SaveNotebook\"] = 'saveNotebook'] = \"SaveNotebook\";\r\n    MessageType[MessageType[\"JoinRequest\"] = 'joinRequest'] = \"JoinRequest\";\r\n    MessageType[MessageType[\"JoinAcknowledge\"] = 'joinAcknowledge'] = \"JoinAcknowledge\";\r\n    MessageType[MessageType[\"ReadOnlyChange\"] = 'readOnlyChange'] = \"ReadOnlyChange\";\r\n    MessageType[MessageType[\"Handshake\"] = 'handshake'] = \"Handshake\";\r\n    MessageType[MessageType[\"Summon\"] = 'summon'] = \"Summon\";\r\n    MessageType[MessageType[\"LayoutScroll\"] = 'layoutScroll'] = \"LayoutScroll\";\r\n    MessageType[MessageType[\"NotebookScroll\"] = 'notebookScroll'] = \"NotebookScroll\";\r\n    MessageType[MessageType[\"ProjectFileOpened\"] = 'projectFileOpened'] = \"ProjectFileOpened\";\r\n    MessageType[MessageType[\"ProjectFileClosed\"] = 'projectFileClosed'] = \"ProjectFileClosed\";\r\n    MessageType[MessageType[\"PresenterUpdate\"] = 'presenterUpdate'] = \"PresenterUpdate\";\r\n    MessageType[MessageType[\"FollowChange\"] = 'followChange'] = \"FollowChange\";\r\n    MessageType[MessageType[\"AnonymousAccessLevelChange\"] = 'anonymousAccessLevelChange'] = \"AnonymousAccessLevelChange\";\r\n    MessageType[MessageType[\"Ping\"] = 'ping'] = \"Ping\";\r\n    MessageType[MessageType[\"Unknown\"] = 'unknown'] = \"Unknown\";\r\n})(MessageType = exports.MessageType || (exports.MessageType = {}));\r\nclass FileMessageBase extends MessageBase {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Path),\r\n    __metadata(\"design:type\", String)\r\n], FileMessageBase.prototype, \"fileName\", void 0);\r\nexports.FileMessageBase = FileMessageBase;\r\nclass JoinRequestMessage extends MessageBase {\r\n}\r\nexports.JoinRequestMessage = JoinRequestMessage;\r\nclass JoinAcknowledgeMessage extends MessageBase {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Path),\r\n    __metadata(\"design:type\", Array)\r\n], JoinAcknowledgeMessage.prototype, \"files\", void 0);\r\nexports.JoinAcknowledgeMessage = JoinAcknowledgeMessage;\r\nclass PresenterUpdateMessage extends MessageBase {\r\n}\r\nexports.PresenterUpdateMessage = PresenterUpdateMessage;\r\nclass FollowChangeMessage extends MessageBase {\r\n}\r\nexports.FollowChangeMessage = FollowChangeMessage;\r\nclass SelectionChangeMessage extends FileMessageBase {\r\n}\r\nexports.SelectionChangeMessage = SelectionChangeMessage;\r\nclass NotebookSelectionChangeMessage extends FileMessageBase {\r\n}\r\nexports.NotebookSelectionChangeMessage = NotebookSelectionChangeMessage;\r\nclass Range {\r\n}\r\nexports.Range = Range;\r\nclass LayoutScrollMessage extends FileMessageBase {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(Range),\r\n    __metadata(\"design:type\", Array)\r\n], LayoutScrollMessage.prototype, \"visibleRanges\", void 0);\r\nexports.LayoutScrollMessage = LayoutScrollMessage;\r\nclass NotebookScrollMessage extends FileMessageBase {\r\n}\r\nexports.NotebookScrollMessage = NotebookScrollMessage;\r\nclass EditorVisibleRanges {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Path),\r\n    __metadata(\"design:type\", String)\r\n], EditorVisibleRanges.prototype, \"fileName\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(Range),\r\n    __metadata(\"design:type\", Array)\r\n], EditorVisibleRanges.prototype, \"visibleRanges\", void 0);\r\nexports.EditorVisibleRanges = EditorVisibleRanges;\r\nclass VisibleRangesChangeMessage extends MessageBase {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(EditorVisibleRanges),\r\n    __metadata(\"design:type\", Array)\r\n], VisibleRangesChangeMessage.prototype, \"clientVisibleRanges\", void 0);\r\nexports.VisibleRangesChangeMessage = VisibleRangesChangeMessage;\r\nclass FileOpenRequestMessage extends FileMessageBase {\r\n}\r\nexports.FileOpenRequestMessage = FileOpenRequestMessage;\r\nclass ResetFileClientMessage extends FileMessageBase {\r\n}\r\nexports.ResetFileClientMessage = ResetFileClientMessage;\r\nclass UntitledFileSavedMessage extends FileMessageBase {\r\n}\r\nexports.UntitledFileSavedMessage = UntitledFileSavedMessage;\r\nclass UntitledFileOpenedMessage extends FileMessageBase {\r\n}\r\nexports.UntitledFileOpenedMessage = UntitledFileOpenedMessage;\r\nclass UntitledFileClosedMessage extends FileMessageBase {\r\n}\r\nexports.UntitledFileClosedMessage = UntitledFileClosedMessage;\r\nclass DiffViewMessage extends MessageBase {\r\n}\r\nexports.DiffViewMessage = DiffViewMessage;\r\nclass DiffViewOpenMessage extends DiffViewMessage {\r\n}\r\nexports.DiffViewOpenMessage = DiffViewOpenMessage;\r\nclass DiffViewClosedMessage extends DiffViewMessage {\r\n}\r\nexports.DiffViewClosedMessage = DiffViewClosedMessage;\r\nclass HandshakeMessage extends FileMessageBase {\r\n}\r\nexports.HandshakeMessage = HandshakeMessage;\r\nclass SaveFileMessage extends FileMessageBase {\r\n}\r\nexports.SaveFileMessage = SaveFileMessage;\r\nclass SaveNotebookMessage extends FileMessageBase {\r\n}\r\nexports.SaveNotebookMessage = SaveNotebookMessage;\r\nclass FileReleaseMessage extends FileMessageBase {\r\n}\r\nexports.FileReleaseMessage = FileReleaseMessage;\r\nclass AnonymousAcccessLevelChangedMessage extends FileMessageBase {\r\n}\r\nexports.AnonymousAcccessLevelChangedMessage = AnonymousAcccessLevelChangedMessage;\r\nclass TextChangeMessage extends FileMessageBase {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(TextChange),\r\n    __metadata(\"design:type\", Array)\r\n], TextChangeMessage.prototype, \"changes\", void 0);\r\nexports.TextChangeMessage = TextChangeMessage;\r\nclass ReadOnlyChangeMessage extends FileMessageBase {\r\n}\r\nexports.ReadOnlyChangeMessage = ReadOnlyChangeMessage;\r\n/** Message sent by a guest or Nexus client when he or she opens the first editor window for a project file. */\r\nclass ProjectFileOpenedMessage extends FileMessageBase {\r\n}\r\nexports.ProjectFileOpenedMessage = ProjectFileOpenedMessage;\r\n/** Message sent by a guest or Nexus client when he or she closes the last editor window for a project file. */\r\nclass ProjectFileClosedMessage extends FileMessageBase {\r\n}\r\nexports.ProjectFileClosedMessage = ProjectFileClosedMessage;\r\nclass ServerVersionSnapshot {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(TextChangeMessage),\r\n    __metadata(\"design:type\", TextChangeMessage)\r\n], ServerVersionSnapshot.prototype, \"message\", void 0);\r\nexports.ServerVersionSnapshot = ServerVersionSnapshot;\r\nclass FileOpenAcknowledgeMessage extends FileMessageBase {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(ServerVersionSnapshot),\r\n    __metadata(\"design:type\", Array)\r\n], FileOpenAcknowledgeMessage.prototype, \"history\", void 0);\r\nexports.FileOpenAcknowledgeMessage = FileOpenAcknowledgeMessage;\r\nclass SummonMessage extends MessageBase {\r\n}\r\nexports.SummonMessage = SummonMessage;\r\nclass PingMessage extends MessageBase {\r\n}\r\nexports.PingMessage = PingMessage;\r\nvar DocumentChangesNotificationFlags;\r\n(function (DocumentChangesNotificationFlags) {\r\n    DocumentChangesNotificationFlags[DocumentChangesNotificationFlags[\"NotifyDidOpenClose\"] = 'notifyDidOpenClose'] = \"NotifyDidOpenClose\";\r\n    DocumentChangesNotificationFlags[DocumentChangesNotificationFlags[\"NotifyDidChange\"] = 'notifyDidChange'] = \"NotifyDidChange\";\r\n    DocumentChangesNotificationFlags[DocumentChangesNotificationFlags[\"NotifyDidSave\"] = 'notifyDidSave'] = \"NotifyDidSave\";\r\n    DocumentChangesNotificationFlags[DocumentChangesNotificationFlags[\"NotifyAll\"] = 'notifyAll'] = \"NotifyAll\";\r\n})(DocumentChangesNotificationFlags = exports.DocumentChangesNotificationFlags || (exports.DocumentChangesNotificationFlags = {}));\r\nclass CoeditingInformation {\r\n}\r\nexports.CoeditingInformation = CoeditingInformation;\r\nclass DocumentFilter {\r\n}\r\nexports.DocumentFilter = DocumentFilter;\r\nclass LanguageServerProviderMetadata {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(DocumentFilter),\r\n    __metadata(\"design:type\", Array)\r\n], LanguageServerProviderMetadata.prototype, \"documentFilters\", void 0);\r\nexports.LanguageServerProviderMetadata = LanguageServerProviderMetadata;\r\nclass NotificationEventArgs extends EventArgs {\r\n}\r\nexports.NotificationEventArgs = NotificationEventArgs;\r\nclass LspMessage {\r\n}\r\nexports.LspMessage = LspMessage;\r\nclass DebugSession {\r\n}\r\nexports.DebugSession = DebugSession;\r\nvar DebugSessionChangeType;\r\n(function (DebugSessionChangeType) {\r\n    DebugSessionChangeType[DebugSessionChangeType[\"None\"] = 'none'] = \"None\";\r\n    DebugSessionChangeType[DebugSessionChangeType[\"Add\"] = 'add'] = \"Add\";\r\n    DebugSessionChangeType[DebugSessionChangeType[\"Remove\"] = 'remove'] = \"Remove\";\r\n})(DebugSessionChangeType = exports.DebugSessionChangeType || (exports.DebugSessionChangeType = {}));\r\nclass DebugSessionChangedEventArgs extends EventArgs {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(DebugSession),\r\n    __metadata(\"design:type\", DebugSession)\r\n], DebugSessionChangedEventArgs.prototype, \"debugSession\", void 0);\r\nexports.DebugSessionChangedEventArgs = DebugSessionChangedEventArgs;\r\nclass LaunchConfigurationChangedEventArgs extends EventArgs {\r\n}\r\nexports.LaunchConfigurationChangedEventArgs = LaunchConfigurationChangedEventArgs;\r\nvar ContinueReason;\r\n(function (ContinueReason) {\r\n    ContinueReason[ContinueReason[\"Go\"] = 'go'] = \"Go\";\r\n    ContinueReason[ContinueReason[\"StepIn\"] = 'stepIn'] = \"StepIn\";\r\n    ContinueReason[ContinueReason[\"StepOut\"] = 'stepOut'] = \"StepOut\";\r\n    ContinueReason[ContinueReason[\"StepOver\"] = 'stepOver'] = \"StepOver\";\r\n})(ContinueReason = exports.ContinueReason || (exports.ContinueReason = {}));\r\n/** Event args for an event when access control changes. */\r\nclass AccessControlEventArgs extends EventArgs {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(AccessControl),\r\n    __metadata(\"design:type\", AccessControl)\r\n], AccessControlEventArgs.prototype, \"accessControl\", void 0);\r\nexports.AccessControlEventArgs = AccessControlEventArgs;\r\n/** Access for a restricted operation. */\r\nvar RestrictedOperationAccess;\r\n(function (RestrictedOperationAccess) {\r\n    RestrictedOperationAccess[RestrictedOperationAccess[\"Allowed\"] = 'allowed'] = \"Allowed\";\r\n    RestrictedOperationAccess[RestrictedOperationAccess[\"RejectedInReadOnlySession\"] = 'rejectedInReadOnlySession'] = \"RejectedInReadOnlySession\";\r\n    RestrictedOperationAccess[RestrictedOperationAccess[\"RejectedForNotOwner\"] = 'rejectedForNotOwner'] = \"RejectedForNotOwner\";\r\n    RestrictedOperationAccess[RestrictedOperationAccess[\"DisabledByHostConfiguration\"] = 'disabledByHostConfiguration'] = \"DisabledByHostConfiguration\";\r\n    RestrictedOperationAccess[RestrictedOperationAccess[\"ExplicitlyRejectedByHost\"] = 'explicitlyRejectedByHost'] = \"ExplicitlyRejectedByHost\";\r\n    RestrictedOperationAccess[RestrictedOperationAccess[\"RejectedPersistentRootNotSupported\"] = 'rejectedPersistentRootNotSupported'] = \"RejectedPersistentRootNotSupported\";\r\n})(RestrictedOperationAccess = exports.RestrictedOperationAccess || (exports.RestrictedOperationAccess = {}));\r\n/** Event args for an event when a restricted operation has failed. */\r\nclass RestrictedOperationAccessEventArgs extends EventArgs {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(RestrictedOperation),\r\n    __metadata(\"design:type\", RestrictedOperation)\r\n], RestrictedOperationAccessEventArgs.prototype, \"operation\", void 0);\r\nexports.RestrictedOperationAccessEventArgs = RestrictedOperationAccessEventArgs;\r\nclass FileListOptions {\r\n}\r\nexports.FileListOptions = FileListOptions;\r\n/** Specifies what descendents should be included when listing or watching a path. */\r\nvar FileRecurseMode;\r\n(function (FileRecurseMode) {\r\n    FileRecurseMode[FileRecurseMode[\"None\"] = 'none'] = \"None\";\r\n    FileRecurseMode[FileRecurseMode[\"Children\"] = 'children'] = \"Children\";\r\n    FileRecurseMode[FileRecurseMode[\"SingleChildDescendants\"] = 'singleChildDescendants'] = \"SingleChildDescendants\";\r\n    FileRecurseMode[FileRecurseMode[\"AllDescendants\"] = 'allDescendants'] = \"AllDescendants\";\r\n})(FileRecurseMode = exports.FileRecurseMode || (exports.FileRecurseMode = {}));\r\nvar FileAttributes;\r\n(function (FileAttributes) {\r\n    FileAttributes[FileAttributes[\"None\"] = 'none'] = \"None\";\r\n    FileAttributes[FileAttributes[\"Hidden\"] = 'hidden'] = \"Hidden\";\r\n    FileAttributes[FileAttributes[\"ReadOnly\"] = 'readOnly'] = \"ReadOnly\";\r\n    FileAttributes[FileAttributes[\"Excluded\"] = 'excluded'] = \"Excluded\";\r\n    FileAttributes[FileAttributes[\"External\"] = 'external'] = \"External\";\r\n})(FileAttributes = exports.FileAttributes || (exports.FileAttributes = {}));\r\nclass FileInfo {\r\n    constructor() {\r\n        this.exists = true;\r\n    }\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Path),\r\n    __metadata(\"design:type\", String)\r\n], FileInfo.prototype, \"path\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(FileInfo),\r\n    __metadata(\"design:type\", Array)\r\n], FileInfo.prototype, \"children\", void 0);\r\nexports.FileInfo = FileInfo;\r\nclass FileRootInfo extends FileInfo {\r\n}\r\nexports.FileRootInfo = FileRootInfo;\r\nclass FileTextInfo extends FileInfo {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Text),\r\n    __metadata(\"design:type\", String)\r\n], FileTextInfo.prototype, \"text\", void 0);\r\nexports.FileTextInfo = FileTextInfo;\r\nclass FileReadOptions {\r\n}\r\nexports.FileReadOptions = FileReadOptions;\r\nclass FileWriteOptions {\r\n}\r\nexports.FileWriteOptions = FileWriteOptions;\r\nclass FileMoveOptions {\r\n}\r\nexports.FileMoveOptions = FileMoveOptions;\r\nclass FileDeleteOptions {\r\n}\r\nexports.FileDeleteOptions = FileDeleteOptions;\r\nclass FileWatchOptions {\r\n}\r\nexports.FileWatchOptions = FileWatchOptions;\r\nclass FileChange {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Path),\r\n    __metadata(\"design:type\", String)\r\n], FileChange.prototype, \"path\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Path),\r\n    __metadata(\"design:type\", String)\r\n], FileChange.prototype, \"fullPath\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Path),\r\n    __metadata(\"design:type\", String)\r\n], FileChange.prototype, \"localFullPath\", void 0);\r\nexports.FileChange = FileChange;\r\nvar FileChangeType;\r\n(function (FileChangeType) {\r\n    FileChangeType[FileChangeType[\"None\"] = 'none'] = \"None\";\r\n    FileChangeType[FileChangeType[\"Updated\"] = 'updated'] = \"Updated\";\r\n    FileChangeType[FileChangeType[\"Added\"] = 'added'] = \"Added\";\r\n    FileChangeType[FileChangeType[\"Deleted\"] = 'deleted'] = \"Deleted\";\r\n})(FileChangeType = exports.FileChangeType || (exports.FileChangeType = {}));\r\nclass FilesChangedEventArgs extends EventArgs {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(FileChange),\r\n    __metadata(\"design:type\", Array)\r\n], FilesChangedEventArgs.prototype, \"changes\", void 0);\r\nexports.FilesChangedEventArgs = FilesChangedEventArgs;\r\nclass ExternalFilesChangedEventArgs extends EventArgs {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Path),\r\n    __metadata(\"design:type\", Array)\r\n], ExternalFilesChangedEventArgs.prototype, \"localPaths\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Path),\r\n    __metadata(\"design:type\", Array)\r\n], ExternalFilesChangedEventArgs.prototype, \"vslsPaths\", void 0);\r\nexports.ExternalFilesChangedEventArgs = ExternalFilesChangedEventArgs;\r\n/** File service root changed event args. */\r\nclass RootsChangedEventArgs extends EventArgs {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Path),\r\n    __metadata(\"design:type\", String)\r\n], RootsChangedEventArgs.prototype, \"root\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Path),\r\n    __metadata(\"design:type\", String)\r\n], RootsChangedEventArgs.prototype, \"fullPath\", void 0);\r\nexports.RootsChangedEventArgs = RootsChangedEventArgs;\r\nclass DiffBaseInfo {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Text),\r\n    __metadata(\"design:type\", String)\r\n], DiffBaseInfo.prototype, \"description\", void 0);\r\nexports.DiffBaseInfo = DiffBaseInfo;\r\nclass ExternalFileMapResult {\r\n}\r\nexports.ExternalFileMapResult = ExternalFileMapResult;\r\nclass TextSearchResultRange {\r\n}\r\nexports.TextSearchResultRange = TextSearchResultRange;\r\nclass TextSearchResult {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Path),\r\n    __metadata(\"design:type\", String)\r\n], TextSearchResult.prototype, \"path\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Text),\r\n    __metadata(\"design:type\", String)\r\n], TextSearchResult.prototype, \"text\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(TextSearchResultRange),\r\n    __metadata(\"design:type\", Array)\r\n], TextSearchResult.prototype, \"ranges\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(TextSearchResultRange),\r\n    __metadata(\"design:type\", Array)\r\n], TextSearchResult.prototype, \"previewRanges\", void 0);\r\nexports.TextSearchResult = TextSearchResult;\r\nclass ReadTextResult {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(FileTextInfo),\r\n    __metadata(\"design:type\", Array)\r\n], ReadTextResult.prototype, \"results\", void 0);\r\nexports.ReadTextResult = ReadTextResult;\r\nclass TextSearchOptions {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Text),\r\n    __metadata(\"design:type\", Array)\r\n], TextSearchOptions.prototype, \"fileIncludes\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Text),\r\n    __metadata(\"design:type\", Array)\r\n], TextSearchOptions.prototype, \"fileExcludes\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Text),\r\n    __metadata(\"design:type\", String)\r\n], TextSearchOptions.prototype, \"pattern\", void 0);\r\nexports.TextSearchOptions = TextSearchOptions;\r\n/** Types of nodes present in a solution view */\r\nclass NodeType {\r\n}\r\nexports.NodeType = NodeType;\r\n/** Represents a node in solution view */\r\nclass SolutionWorkspaceNode {\r\n}\r\nexports.SolutionWorkspaceNode = SolutionWorkspaceNode;\r\n/** Hierarchy change event data */\r\nclass SolutionChangedEventArgs extends EventArgs {\r\n}\r\nexports.SolutionChangedEventArgs = SolutionChangedEventArgs;\r\n/** Workspace root changed!: solution || folder opened || closed */\r\nclass WorkspaceRootChangedEventArgs extends EventArgs {\r\n}\r\nexports.WorkspaceRootChangedEventArgs = WorkspaceRootChangedEventArgs;\r\n/** The type of workspace being shared */\r\nvar WorkspaceMode;\r\n(function (WorkspaceMode) {\r\n    WorkspaceMode[WorkspaceMode[\"Empty\"] = 'empty'] = \"Empty\";\r\n    WorkspaceMode[WorkspaceMode[\"Folder\"] = 'folder'] = \"Folder\";\r\n    WorkspaceMode[WorkspaceMode[\"Solution\"] = 'solution'] = \"Solution\";\r\n})(WorkspaceMode = exports.WorkspaceMode || (exports.WorkspaceMode = {}));\r\n/** Types of hierarchy node operations */\r\nclass SolutionChangeType {\r\n}\r\nexports.SolutionChangeType = SolutionChangeType;\r\nclass SourceEventArgs extends EventArgs {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(vso_rpc_1.DataFormat.Hide),\r\n    __metadata(\"design:type\", String)\r\n], SourceEventArgs.prototype, \"jsonContent\", void 0);\r\nexports.SourceEventArgs = SourceEventArgs;\r\nvar StreamTraits;\r\n(function (StreamTraits) {\r\n    StreamTraits[StreamTraits[\"None\"] = 'none'] = \"None\";\r\n    StreamTraits[StreamTraits[\"CanRead\"] = 'canRead'] = \"CanRead\";\r\n    StreamTraits[StreamTraits[\"CanWrite\"] = 'canWrite'] = \"CanWrite\";\r\n    StreamTraits[StreamTraits[\"CanSeek\"] = 'canSeek'] = \"CanSeek\";\r\n})(StreamTraits = exports.StreamTraits || (exports.StreamTraits = {}));\r\n/** The scope a task is associated with */\r\nvar TaskScope;\r\n(function (TaskScope) {\r\n    TaskScope[TaskScope[\"Global\"] = 'global'] = \"Global\";\r\n    TaskScope[TaskScope[\"Workspace\"] = 'workspace'] = \"Workspace\";\r\n    TaskScope[TaskScope[\"WorkspaceFolder\"] = 'workspaceFolder'] = \"WorkspaceFolder\";\r\n})(TaskScope = exports.TaskScope || (exports.TaskScope = {}));\r\n/** Represents a task declared in a collaboration workspace. Examples!: build, publish, pack, lint, etc. */\r\nclass WorkspaceTask {\r\n}\r\nexports.WorkspaceTask = WorkspaceTask;\r\n/** Represents a task execution. Any single task may be executed multiple times. Each execution will receive a new moniker with unique ID. */\r\nclass TaskExecutionMoniker {\r\n}\r\nexports.TaskExecutionMoniker = TaskExecutionMoniker;\r\n/** Event occured to a task that may lead to a task state change. */\r\nvar TaskExecutionStatusChange;\r\n(function (TaskExecutionStatusChange) {\r\n    TaskExecutionStatusChange[TaskExecutionStatusChange[\"Started\"] = 'started'] = \"Started\";\r\n    TaskExecutionStatusChange[TaskExecutionStatusChange[\"Terminated\"] = 'terminated'] = \"Terminated\";\r\n})(TaskExecutionStatusChange = exports.TaskExecutionStatusChange || (exports.TaskExecutionStatusChange = {}));\r\n/** Message sent by a remote task to signal change in the status. */\r\nclass TaskExecutionStatusEventArgs extends EventArgs {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(TaskExecutionMoniker),\r\n    __metadata(\"design:type\", TaskExecutionMoniker)\r\n], TaskExecutionStatusEventArgs.prototype, \"taskExecution\", void 0);\r\n__decorate([\r\n    vso_rpc_1.dataFormat(WorkspaceTask),\r\n    __metadata(\"design:type\", WorkspaceTask)\r\n], TaskExecutionStatusEventArgs.prototype, \"task\", void 0);\r\nexports.TaskExecutionStatusEventArgs = TaskExecutionStatusEventArgs;\r\n/** List of statuses produced by IWorkspaceTaskService in response to start a task execution. */\r\nvar RunTaskStatus;\r\n(function (RunTaskStatus) {\r\n    RunTaskStatus[RunTaskStatus[\"Started\"] = 'started'] = \"Started\";\r\n    RunTaskStatus[RunTaskStatus[\"AlreadyRunning\"] = 'alreadyRunning'] = \"AlreadyRunning\";\r\n    RunTaskStatus[RunTaskStatus[\"RetryLater\"] = 'retryLater'] = \"RetryLater\";\r\n    RunTaskStatus[RunTaskStatus[\"TaskNotFound\"] = 'taskNotFound'] = \"TaskNotFound\";\r\n    RunTaskStatus[RunTaskStatus[\"RejectedByHost\"] = 'rejectedByHost'] = \"RejectedByHost\";\r\n})(RunTaskStatus = exports.RunTaskStatus || (exports.RunTaskStatus = {}));\r\n/** Represents a result of a run task operation. */\r\nclass RunTaskResult {\r\n}\r\n__decorate([\r\n    vso_rpc_1.dataFormat(TaskExecutionMoniker),\r\n    __metadata(\"design:type\", TaskExecutionMoniker)\r\n], RunTaskResult.prototype, \"taskExecution\", void 0);\r\nexports.RunTaskResult = RunTaskResult;\r\n/** Restricted operation for a control action performed for a specific task, including run and terminate actions. */\r\nclass WorkspaceTaskRestrictedOperation extends RestrictedOperation {\r\n}\r\nexports.WorkspaceTaskRestrictedOperation = WorkspaceTaskRestrictedOperation;\r\nvar ErrorCodes;\r\n(function (ErrorCodes) {\r\n    ErrorCodes[ErrorCodes[\"CouldNotConnectToServer\"] = -32000] = \"CouldNotConnectToServer\";\r\n    ErrorCodes[ErrorCodes[\"OlderThanServer\"] = -32001] = \"OlderThanServer\";\r\n    ErrorCodes[ErrorCodes[\"NewerThanServer\"] = -32002] = \"NewerThanServer\";\r\n    ErrorCodes[ErrorCodes[\"OlderThanPeer\"] = -32003] = \"OlderThanPeer\";\r\n    ErrorCodes[ErrorCodes[\"NewerThanPeer\"] = -32004] = \"NewerThanPeer\";\r\n    ErrorCodes[ErrorCodes[\"OlderThanAgent\"] = -32005] = \"OlderThanAgent\";\r\n    ErrorCodes[ErrorCodes[\"NewerThanAgent\"] = -32006] = \"NewerThanAgent\";\r\n    ErrorCodes[ErrorCodes[\"NoIPAddressesDetected\"] = -32010] = \"NoIPAddressesDetected\";\r\n    ErrorCodes[ErrorCodes[\"NoConnectionAddresses\"] = -32011] = \"NoConnectionAddresses\";\r\n    ErrorCodes[ErrorCodes[\"AutoConnectionFailed\"] = -32012] = \"AutoConnectionFailed\";\r\n    ErrorCodes[ErrorCodes[\"RelayConnectionFailed\"] = -32013] = \"RelayConnectionFailed\";\r\n    ErrorCodes[ErrorCodes[\"DirectConnectionFailed\"] = -32014] = \"DirectConnectionFailed\";\r\n    ErrorCodes[ErrorCodes[\"SessionProtocolError\"] = -32015] = \"SessionProtocolError\";\r\n    ErrorCodes[ErrorCodes[\"SessionAuthenticationFailed\"] = -32016] = \"SessionAuthenticationFailed\";\r\n    ErrorCodes[ErrorCodes[\"ReconnectFailed\"] = -32017] = \"ReconnectFailed\";\r\n    ErrorCodes[ErrorCodes[\"DirectConnectionNotEnabled\"] = -32020] = \"DirectConnectionNotEnabled\";\r\n    ErrorCodes[ErrorCodes[\"RelayConnectionNotEnabled\"] = -32021] = \"RelayConnectionNotEnabled\";\r\n    ErrorCodes[ErrorCodes[\"CollaborationSessionUsersLimitReached\"] = -32022] = \"CollaborationSessionUsersLimitReached\";\r\n    ErrorCodes[ErrorCodes[\"CollaborationSessionGuestRejected\"] = -32023] = \"CollaborationSessionGuestRejected\";\r\n    ErrorCodes[ErrorCodes[\"CollaborationSessionRequestTimedOut\"] = -32024] = \"CollaborationSessionRequestTimedOut\";\r\n    ErrorCodes[ErrorCodes[\"CollaborationSessionGuestCanceled\"] = -32025] = \"CollaborationSessionGuestCanceled\";\r\n    ErrorCodes[ErrorCodes[\"CollaborationSessionNotFound\"] = -32026] = \"CollaborationSessionNotFound\";\r\n    ErrorCodes[ErrorCodes[\"CollaborationSessionEnded\"] = -32027] = \"CollaborationSessionEnded\";\r\n    ErrorCodes[ErrorCodes[\"CollaborationSessionGuestBlocked\"] = -32028] = \"CollaborationSessionGuestBlocked\";\r\n    ErrorCodes[ErrorCodes[\"NonSuccessHttpStatusCodeReceived\"] = -32030] = \"NonSuccessHttpStatusCodeReceived\";\r\n    ErrorCodes[ErrorCodes[\"KeychainAccessFailed\"] = -32031] = \"KeychainAccessFailed\";\r\n    ErrorCodes[ErrorCodes[\"UnauthorizedHttpStatusCode\"] = -32032] = \"UnauthorizedHttpStatusCode\";\r\n    ErrorCodes[ErrorCodes[\"ForbiddenHttpStatusCode\"] = -32033] = \"ForbiddenHttpStatusCode\";\r\n    ErrorCodes[ErrorCodes[\"RelayConnectionHostFailure\"] = -32040] = \"RelayConnectionHostFailure\";\r\n    ErrorCodes[ErrorCodes[\"RelayConnectionGuestFailure\"] = -32041] = \"RelayConnectionGuestFailure\";\r\n    ErrorCodes[ErrorCodes[\"RelayHubNotFoundFailure\"] = -32045] = \"RelayHubNotFoundFailure\";\r\n    ErrorCodes[ErrorCodes[\"RelayHubNoHostFailure\"] = -32046] = \"RelayHubNoHostFailure\";\r\n    ErrorCodes[ErrorCodes[\"RelayHubNotConnectedFailure\"] = -32047] = \"RelayHubNotConnectedFailure\";\r\n    ErrorCodes[ErrorCodes[\"BrokerNotAuthorized\"] = -32050] = \"BrokerNotAuthorized\";\r\n    ErrorCodes[ErrorCodes[\"CouldNotConnectToServerAuthFailed\"] = -32060] = \"CouldNotConnectToServerAuthFailed\";\r\n    ErrorCodes[ErrorCodes[\"RemoteLaunchNotEnabled\"] = -32200] = \"RemoteLaunchNotEnabled\";\r\n    ErrorCodes[ErrorCodes[\"CollaborationSessionGuestRejectedWithSpecificReason\"] = -32300] = \"CollaborationSessionGuestRejectedWithSpecificReason\";\r\n    ErrorCodes[ErrorCodes[\"OperationRejected\"] = -32400] = \"OperationRejected\";\r\n    ErrorCodes[ErrorCodes[\"OperationRejectedInReadOnlySession\"] = -32401] = \"OperationRejectedInReadOnlySession\";\r\n    ErrorCodes[ErrorCodes[\"OperationRejectedForNotOwner\"] = -32402] = \"OperationRejectedForNotOwner\";\r\n    ErrorCodes[ErrorCodes[\"OperationRejectedAsPersistentRootNotSupported\"] = -32403] = \"OperationRejectedAsPersistentRootNotSupported\";\r\n    ErrorCodes[ErrorCodes[\"FileOperationNotSupported\"] = -32500] = \"FileOperationNotSupported\";\r\n    ErrorCodes[ErrorCodes[\"ErrorFileAdditionFailed\"] = -32501] = \"ErrorFileAdditionFailed\";\r\n    ErrorCodes[ErrorCodes[\"ErrorFileDeleteFailed\"] = -32502] = \"ErrorFileDeleteFailed\";\r\n    ErrorCodes[ErrorCodes[\"ErrorFileRenameFailed\"] = -32503] = \"ErrorFileRenameFailed\";\r\n    ErrorCodes[ErrorCodes[\"FileAlreadyExists\"] = -32504] = \"FileAlreadyExists\";\r\n    ErrorCodes[ErrorCodes[\"ErrorFolderAdditionFailed\"] = -32505] = \"ErrorFolderAdditionFailed\";\r\n    ErrorCodes[ErrorCodes[\"ErrorFolderRenameFailed\"] = -32506] = \"ErrorFolderRenameFailed\";\r\n})(ErrorCodes = exports.ErrorCodes || (exports.ErrorCodes = {}));\r\nvar TraceEventIds;\r\n(function (TraceEventIds) {\r\n    TraceEventIds[TraceEventIds[\"None\"] = 0] = \"None\";\r\n    TraceEventIds[TraceEventIds[\"AgentLogCreated\"] = 1002] = \"AgentLogCreated\";\r\n    TraceEventIds[TraceEventIds[\"AgentOutput\"] = 2001] = \"AgentOutput\";\r\n    TraceEventIds[TraceEventIds[\"CallingOutput\"] = 10001] = \"CallingOutput\";\r\n    TraceEventIds[TraceEventIds[\"RpcListeningOnPipe\"] = 1001] = \"RpcListeningOnPipe\";\r\n})(TraceEventIds = exports.TraceEventIds || (exports.TraceEventIds = {}));\r\nvar TraceSources;\r\n(function (TraceSources) {\r\n    TraceSources[\"Agent\"] = \"Agent\";\r\n    TraceSources[\"AgentAuth\"] = \"Agent.Auth\";\r\n    TraceSources[\"AgentCSharpLS\"] = \"Agent.CSharpLS\";\r\n    TraceSources[\"AgentFile\"] = \"Agent.File\";\r\n    TraceSources[\"AgentFirewall\"] = \"Agent.Firewall\";\r\n    TraceSources[\"AgentHttp\"] = \"Agent.Http\";\r\n    TraceSources[\"AgentProxy\"] = \"Agent.Proxy\";\r\n    TraceSources[\"AgentPortForwarding\"] = \"Agent.PortFowrading\";\r\n    TraceSources[\"AgentTcpListenersObserver\"] = \"Agent.TcpListeners\";\r\n    TraceSources[\"AgentRpc\"] = \"Agent.Rpc\";\r\n    TraceSources[\"AgentRpcAuth\"] = \"Agent.Rpc.Auth\";\r\n    TraceSources[\"AgentRpcChat\"] = \"Agent.Rpc.Chat\";\r\n    TraceSources[\"AgentRpcFile\"] = \"Agent.Rpc.File\";\r\n    TraceSources[\"AgentRpcFirewall\"] = \"Agent.Rpc.Firewall\";\r\n    TraceSources[\"AgentRpcServerSharing\"] = \"Agent.Rpc.ServerSharing\";\r\n    TraceSources[\"AgentRpcSourceEvent\"] = \"Agent.Rpc.SourceEvent\";\r\n    TraceSources[\"AgentRpcStream\"] = \"Agent.Rpc.Stream\";\r\n    TraceSources[\"AgentRpcStreamManager\"] = \"Agent.Rpc.StreamManager\";\r\n    TraceSources[\"AgentRpcStreamTransport\"] = \"Agent.Rpc.StreamTransport\";\r\n    TraceSources[\"AgentRpcTerminal\"] = \"Agent.Rpc.Terminal\";\r\n    TraceSources[\"AgentTerminalConnection\"] = \"Agent.Terminal.Connection\";\r\n    TraceSources[\"AgentRpcWorkspace\"] = \"Agent.Rpc.Workspace\";\r\n    TraceSources[\"AgentRpcWorkspaceUser\"] = \"Agent.Rpc.WorkspaceUser\";\r\n    TraceSources[\"AgentRpcTaskOutput\"] = \"Agent.Rpc.TaskOutput\";\r\n    TraceSources[\"AgentSsh\"] = \"Agent.Ssh\";\r\n    TraceSources[\"AgentTSLS\"] = \"Agent.TSLS\";\r\n    TraceSources[\"AgentWorkspace\"] = \"Agent.Workspace\";\r\n    TraceSources[\"AgentWorkspaceSessionAccessControl\"] = \"Agent.WorkspaceSession.AccessControl\";\r\n    TraceSources[\"ClientAgent\"] = \"Client.Agent\";\r\n    TraceSources[\"ClientCoEditing\"] = \"Client.CoEditing\";\r\n    TraceSources[\"ClientCoEditingBufferManager\"] = \"Client.CoEditing.BufferManager\";\r\n    TraceSources[\"ClientCoEditingVSCodeEvent\"] = \"Client.CoEditing.VSCodeEvent\";\r\n    TraceSources[\"ClientFileProvider\"] = \"Client.FileProvider\";\r\n    TraceSources[\"ClientLauncher\"] = \"Client.Launcher\";\r\n    TraceSources[\"ClientRpc\"] = \"Client.Rpc\";\r\n    TraceSources[\"ClientRpcAgentSession\"] = \"Client.Rpc.AgentSession\";\r\n    TraceSources[\"ClientRpcAuth\"] = \"Client.Rpc.Auth\";\r\n    TraceSources[\"ClientRpcFile\"] = \"Client.Rpc.File\";\r\n    TraceSources[\"ClientRpcPortForwarding\"] = \"Client.Rpc.PortForwarding\";\r\n    TraceSources[\"ClientRpcServerSharing\"] = \"Client.Rpc.ServerSharing\";\r\n    TraceSources[\"ClientRpcSourceEvent\"] = \"Client.Rpc.SourceEvent\";\r\n    TraceSources[\"ClientRpcStream\"] = \"Client.Rpc.Stream\";\r\n    TraceSources[\"ClientRpcStreamManager\"] = \"Client.Rpc.StreamManager\";\r\n    TraceSources[\"ClientRpcTerminal\"] = \"Client.Rpc.Terminal\";\r\n    TraceSources[\"ClientRpcChat\"] = \"Client.Rpc.Chat\";\r\n    TraceSources[\"ClientRpcTerminalEndpoint\"] = \"Client.Rpc.TerminalEndpoint\";\r\n    TraceSources[\"ClientRpcWorkspace\"] = \"Client.Rpc.Workspace\";\r\n    TraceSources[\"ClientRpcWorkspaceUser\"] = \"Client.Rpc.WorkspaceUser\";\r\n    TraceSources[\"ClientRpcSessionContext\"] = \"Client.Rpc.SessionContext\";\r\n    TraceSources[\"ClientRpcContact\"] = \"Client.Rpc.Contact\";\r\n    TraceSources[\"ClientWorkspace\"] = \"Client.Workspace\";\r\n    TraceSources[\"ClientRemoteBuild\"] = \"Client.RemoteBuild\";\r\n    TraceSources[\"ClientCSharpLS\"] = \"Client.CSharpLS\";\r\n    TraceSources[\"ClientSharedTerminal\"] = \"Client.SharedTerminal\";\r\n    TraceSources[\"ClientWorkspaceAccessControl\"] = \"Client.Workspace.AccessControl\";\r\n    TraceSources[\"ClientAccessControl\"] = \"Client.AccessControl\";\r\n    TraceSources[\"ClientSearch\"] = \"Client.Search\";\r\n    TraceSources[\"ClientSourceControl\"] = \"Client.SourceControl\";\r\n    TraceSources[\"ClientSyncService\"] = \"Client.SyncService\";\r\n    TraceSources[\"ClientCommentService\"] = \"Client.CommentService\";\r\n    TraceSources[\"ClientGettingStartedPageContentProvider\"] = \"Client.GettingStartedPageContentProvider\";\r\n    TraceSources[\"ClientPortForwardingBrowser\"] = \"Client.PortForwardingBrowser\";\r\n    TraceSources[\"ClientOnlineEnvironmentSessionService\"] = \"Client.OnlineEnvironmentSessionService\";\r\n    TraceSources[\"Calling\"] = \"Calling\";\r\n    TraceSources[\"DebugHostAdapter\"] = \"Debug.HostAdapter\";\r\n    TraceSources[\"DebugRpcHostAdapter\"] = \"Debug.Rpc.HostAdapter\";\r\n    TraceSources[\"DebugAdapterHost\"] = \"Debug.AdapterHost\";\r\n    TraceSources[\"ForwardingTcpServer\"] = \"ForwardingTcpServer\";\r\n    TraceSources[\"ForwardingPipeServer\"] = \"ForwardingPipeServer\";\r\n    TraceSources[\"Telemetry\"] = \"Telemetry\";\r\n    TraceSources[\"ClientAccessCheck\"] = \"ClientAccessCheck\";\r\n    TraceSources[\"LSPCoauthoringManager\"] = \"LSP.CoauthoringManager\";\r\n    TraceSources[\"RemoteServiceBroker\"] = \"RemoteServiceBroker\";\r\n    TraceSources[\"ReviewsDiffs\"] = \"Reviews.Diffs\";\r\n    TraceSources[\"Cli\"] = \"CLI\";\r\n    TraceSources[\"CliRestore\"] = \"CLI.restore\";\r\n    TraceSources[\"CliStart\"] = \"CLI.start\";\r\n    TraceSources[\"CliStop\"] = \"CLI.stop\";\r\n    TraceSources[\"TTY\"] = \"TTY\";\r\n    TraceSources[\"Settings\"] = \"Settings\";\r\n    TraceSources[\"API\"] = \"API\";\r\n    TraceSources[\"VmAgent\"] = \"VmAgent\";\r\n    TraceSources[\"SelfHostedAgent\"] = \"SelfHostedAgent\";\r\n    TraceSources[\"EnvironmentConfig\"] = \"EnvConfig\";\r\n    TraceSources[\"VMConfig\"] = \"VMCFG\";\r\n    TraceSources[\"LinuxContainerUpdate\"] = \"LinuxContainerUpdate\";\r\n    TraceSources[\"ShutDownEnvironmentHandler\"] = \"ShutdownEnvironment\";\r\n    TraceSources[\"StartEnvironmentHandler\"] = \"StartEnvironment\";\r\n    TraceSources[\"VmAgentRpcService\"] = \"VmAgentRpcService\";\r\n    TraceSources[\"RebuildEnvironmentHandler\"] = \"RebuildEnvironment\";\r\n    TraceSources[\"WarmupEnvironmentHandler\"] = \"WarmupEnvironment\";\r\n    TraceSources[\"StartLiveShareHandler\"] = \"StartLiveShare\";\r\n    TraceSources[\"StartPortForwardingHandler\"] = \"StartPortForwardingHandler\";\r\n    TraceSources[\"ContainerEnvironmentMonitor\"] = \"ContainerMonitor\";\r\n    TraceSources[\"SSHServerMonitor\"] = \"SSHServerMonitor\";\r\n    TraceSources[\"ContainerTunnel\"] = \"ContainerTunnel\";\r\n    TraceSources[\"RunningContainerInfoProvider\"] = \"RunningContainerInfo\";\r\n    TraceSources[\"DevContainerChangesWatcher\"] = \"DevContainerChangesWatcher\";\r\n    TraceSources[\"VSCodeServerHostService\"] = \"VSCodeServerHostService\";\r\n    TraceSources[\"SshServerHostService\"] = \"SSHServerHostService\";\r\n    TraceSources[\"CodespaceHostService\"] = \"CodespaceHostService\";\r\n    TraceSources[\"ClientAutoSuspendMonitor\"] = \"ClientAutoSuspendMonitor\";\r\n    TraceSources[\"DockerImagePrune\"] = \"DockerImagePrune\";\r\n    TraceSources[\"PrebuildPoolUpdateHandler\"] = \"PrebuildPoolUpdate\";\r\n    TraceSources[\"StandAloneAgent\"] = \"StandAloneAgent\";\r\n    TraceSources[\"Viewlet\"] = \"Viewlet\";\r\n    TraceSources[\"VSIX\"] = \"VSIX\";\r\n    TraceSources[\"ClientPrefix\"] = \"Client.\";\r\n    TraceSources[\"ClientLSP\"] = \"Client.LSP\";\r\n    TraceSources[\"LSPHost\"] = \"LSP.Host\";\r\n    TraceSources[\"BreakpointManager\"] = \"BreakpointManager\";\r\n    TraceSources[\"DebugAdapter\"] = \"Debug.Adapter\";\r\n    TraceSources[\"DebugRemote\"] = \"Debug.Remote\";\r\n    TraceSources[\"DebugSessionHost\"] = \"Debug.SessionHost\";\r\n    TraceSources[\"DebugHost\"] = \"Debug.Host\";\r\n    TraceSources[\"DebugRpcHost\"] = \"Debug.Rpc.Host\";\r\n    TraceSources[\"DebugTargetHostProcess\"] = \"Debug.TargetHostProcess\";\r\n    TraceSources[\"DebugRpcSessionHost\"] = \"Debug.Rpc.SessionHost\";\r\n})(TraceSources = exports.TraceSources || (exports.TraceSources = {}));\r\nexports.AgentSessionService = {\r\n    name: 'agentSessionService',\r\n    methods: ['initializeSession', 'enableReconnect', 'keepAlive', 'forceKill'],\r\n    events: [],\r\n};\r\nexports.AuthenticationCoreService = {\r\n    methods: ['getCurrentAuthenticatedUser', 'getCurrentUser', 'removeRecentCollaborator', 'removeAllRecentCollaborators'],\r\n    events: ['authenticationChanged'],\r\n};\r\nexports.AuthenticationService = {\r\n    name: 'auth',\r\n    methods: ['getLoginUri', 'findLoginCode', 'login', 'loginAsAnonymous', 'loginWithCachedToken', 'loginWithExternalToken', 'logout', 'getCachedToken', 'getCurrentAuthenticatedUser', 'getCurrentUser', 'removeRecentCollaborator', 'removeAllRecentCollaborators'],\r\n    events: ['authenticationChanged'],\r\n};\r\nexports.BrokerAuthorizationService = {\r\n    name: 'brokerAuthorization',\r\n    methods: ['authorize'],\r\n    events: [],\r\n};\r\nexports.BrokerManagerService = {\r\n    name: 'brokerManager',\r\n    methods: ['register', 'tryRevoke'],\r\n    events: [],\r\n};\r\nexports.ChatService = {\r\n    name: 'chat',\r\n    methods: ['getMessageHistory', 'getParticipants', 'sendMessage', 'dispose'],\r\n    events: ['messageReceived'],\r\n};\r\nexports.CommentService = {\r\n    name: 'commentService',\r\n    methods: ['createCommentThread', 'createComment', 'updateComment', 'deleteComment', 'getAllCommentThreads', 'getCommentThreadPositions', 'updateLike'],\r\n    events: ['commentThreadChanged'],\r\n};\r\nexports.ConfigurationService = {\r\n    name: 'version',\r\n    methods: ['exchangeVersions', 'exchangeSettings', 'getSubnetMasks'],\r\n    events: [],\r\n};\r\nexports.FirewallService = {\r\n    name: 'firewall',\r\n    methods: ['getFirewallStatus'],\r\n    events: [],\r\n};\r\nexports.HubConnectionService = {\r\n    name: 'hubConnection',\r\n    methods: ['getIsConnected', 'getIsAttempting', 'getEnabled', 'setEnabled', 'registerHubMethodNotify', 'unregisterHubMethodNotify', 'invokeHubMethod', 'sendHubMethod'],\r\n    events: ['hubConnectionStateChanged', 'hubConnectionAttempted', 'hubMethodNotified'],\r\n};\r\nexports.OnlineEnvironmentSessionService = {\r\n    name: 'onlineEnvironmentLiveShareSessionService',\r\n    methods: ['getSessionState', 'updateSessionState'],\r\n    events: [],\r\n};\r\nexports.PortForwardingService = {\r\n    name: 'portForwarding',\r\n    methods: ['getSharedServers', 'getSharedPipes', 'getLastAccessTime', 'setDestinationPort'],\r\n    events: ['sharingStarted', 'pipeSharingStarted', 'browseSharingStarted', 'sharingStopped', 'pipeSharingStopped', 'sharingChanged'],\r\n};\r\nexports.ServerSharingService = {\r\n    name: 'serverSharing',\r\n    methods: ['startSharing', 'startSharingPipe', 'stopSharing', 'stopSharingPipe', 'stopSharingBrowseSessions', 'getSharedServers', 'getSharedPipes', 'updateSessionName', 'updateSharedServerVisibility', 'updateSharedServerProtocol', 'updateSharedServerPrivacy'],\r\n    events: ['sharingStarted', 'pipeSharingStarted', 'browseSharingStarted', 'sharingStopped', 'pipeSharingStopped', 'sharingChanged'],\r\n};\r\nexports.SessionContextService = {\r\n    name: 'sessionContext',\r\n    methods: ['getServiceNames'],\r\n    voidMethods: ['sendSessionStateUpdateToClient', 'sendSessionStatusUpdateToClient'],\r\n    events: ['sessionStateUpdate', 'sessionStatusUpdate'],\r\n};\r\nexports.SourceControlService = {\r\n    name: 'sourceControl',\r\n    methods: ['getAllSourceControls', 'getSourceControls', 'getSourceControl', 'getRecentVersions', 'getRecentVersionsTillMergeVersion', 'getDiffsForVersion', 'getDiffForResource', 'getResource', 'cleanResources', 'getMergeVersion', 'getRemoteVersionsNames', 'getCurrentVersionName'],\r\n    events: ['sourceControlChanged', 'resourceChanged'],\r\n};\r\nexports.SyncService = {\r\n    name: 'syncService',\r\n    methods: ['checkSync', 'checkSyncForVersion', 'checkSyncForVersion2'],\r\n    events: [],\r\n};\r\nexports.TaskOutputService = {\r\n    name: 'taskOutput',\r\n    methods: ['getTaskOutputs', 'shareTaskOutput', 'updateTaskOutputFeed', 'closeTaskOutput'],\r\n    events: ['taskOutputShared', 'taskOutputFeedUpdated', 'taskOutputClosed'],\r\n};\r\nexports.TelemetryService = {\r\n    name: 'telemetry',\r\n    methods: ['initialize', 'getServiceUri'],\r\n    events: ['genericOperation', 'fault'],\r\n};\r\nexports.TerminalEndpoint = {\r\n    name: 'terminalEndpoint',\r\n    methods: ['readBytes', 'writeBytes', 'readString', 'writeString'],\r\n    events: [],\r\n};\r\nexports.TerminalService = {\r\n    name: 'terminal',\r\n    methods: ['startTerminal', 'getRunningTerminals', 'resizeTerminal', 'stopTerminal', 'clearTerminalBuffer', 'setTerminalReadOnlyForGuests'],\r\n    events: ['terminalStarted', 'terminalResized', 'terminalStopped', 'terminalReadOnlyChanged'],\r\n};\r\nexports.TextSearchService = {\r\n    name: 'textSearch',\r\n    methods: ['getTextSearchResults', 'getTextSearchResultsWithProgress'],\r\n    events: [],\r\n};\r\nexports.VSServerHostService = {\r\n    name: 'vsServerHostService',\r\n    methods: ['createSession'],\r\n    events: [],\r\n};\r\nexports.WorkspaceAccessControlService = {\r\n    name: 'workspaceAccessControl',\r\n    methods: ['getAccessControl', 'setAccessControl', 'requestOperationAccess', 'setOperationAccess', 'rejectOperation'],\r\n    events: ['accessControlChanged', 'operationRejected', 'operationAccessChanged', 'opeationAccessRequested'],\r\n};\r\nexports.WorkspaceDiagnosticsService = {\r\n    name: 'workspaceDiagnostics',\r\n    methods: ['getDiagnostics'],\r\n    events: ['diagnosticDataChanged'],\r\n};\r\nexports.WorkspaceService = {\r\n    name: 'workspace',\r\n    methods: ['getWorkspace', 'listWorkspaces', 'createPersistentWorkspace', 'deleteWorkspace', 'renameWorkspace', 'shareWorkspace', 'createInvitationLink', 'getInvitationLinks', 'unshareWorkspace', 'beginJoinWorkspace', 'joinWorkspace', 'unjoinWorkspace', 'registerServices', 'canUserShareWorkspace', 'canUserHostWorkspace', 'createPublicInviteLink', 'disconnectGuest', 'unjoinOnlineEnvironmentsGuests', 'setWorkspaceReadyForConnection', 'updateWorkspaceOwner'],\r\n    events: ['servicesChanged', 'connectionStatusChanged', 'progressUpdated', 'userRemoved', 'userBlocked', 'workspaceReadyForConnection'],\r\n};\r\nexports.WorkspaceUserService = {\r\n    name: 'workspaceuser',\r\n    methods: ['acceptOrRejectGuest', 'autoAcceptGuests', 'removeUser', 'removeAllInteractiveUsers', 'fireProgressUpdatedToGuest', 'getCountOfGuestsWithSameAccount', 'createGuestDisplayName', 'getCachedGuestDisplayName', 'getGuestUserProfile', 'getCountOfInteractiveGuests'],\r\n    events: ['workspaceSessionChanged'],\r\n};\r\nexports.LanguageServerProvider = {\r\n    methods: ['getMetadata', 'request'],\r\n    voidMethods: ['notify'],\r\n    events: ['notified'],\r\n};\r\nexports.DebuggerHostService = {\r\n    name: 'DebuggerHostService',\r\n    methods: ['getCurrentDebugSessions', 'launchDebugSession', 'getLaunchConfigurations'],\r\n    events: ['debugSessionChanged', 'launchConfigurationsChanged'],\r\n};\r\nexports.AccessControlService = {\r\n    name: 'accessControl',\r\n    methods: ['getAccessControl'],\r\n    events: ['accessControlChanged'],\r\n};\r\nexports.FileService = {\r\n    name: 'file',\r\n    methods: ['registerExternalFiles', 'listRoots', 'list', 'readText', 'readTextWithProgress', 'writeText', 'createDirectory', 'delete', 'copy', 'move', 'getFiles', 'isExcluded', 'findFiles', 'getTextSearchResults', 'getTextSearchResultsWithProgress', 'clearRoots', 'addRoot', 'removeRoot', 'replaceRoot'],\r\n    events: ['filesChanged', 'rootsChanged', 'externalFilesChanged'],\r\n};\r\nexports.SolutionViewService = {\r\n    name: 'solutionView',\r\n    methods: ['getSolutionMode', 'getSolutionCaption', 'getChildrenNodes', 'getRootNodes', 'addNewItem', 'renameItem', 'deleteItem'],\r\n    events: ['solutionChanged', 'workspaceRootChanged'],\r\n};\r\nexports.SourceEventService = {\r\n    name: 'sourceEvent',\r\n    methods: ['fireEvent', 'setSourceData', 'getSourceData'],\r\n    events: ['event'],\r\n};\r\nexports.StreamManagerService = {\r\n    name: 'streamManager',\r\n    methods: ['getStream'],\r\n    events: [],\r\n};\r\nexports.StreamService = {\r\n    name: 'stream',\r\n    methods: ['getStreamTraits', 'getLength', 'setLength', 'seek', 'readBytes', 'writeBytes', 'disposeStream'],\r\n    events: [],\r\n};\r\nexports.WorkspaceTaskService = {\r\n    name: 'workspaceTask',\r\n    methods: ['getSupportedTasks', 'getTaskExecutions', 'runTask', 'runProjectTask', 'runDefaultBuildTask', 'terminateTask'],\r\n    events: ['taskStarted', 'taskTerminated'],\r\n};\r\n//# sourceMappingURL=VSLS.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// export auto generated VSLS\r\nexports.vsls = require(\"./contracts/VSLS\");\r\n// export auto generated ContactProtocol\r\nexports.contactProtocol = require(\"./contracts/ContactProtocol\");\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst rpc = __importStar(require(\"vscode-jsonrpc\"));\r\nconst vso_logging_1 = require(\"@vs/vso-logging\");\r\nconst vso_workspace_core_1 = require(\"@vs/vso-workspace-core\");\r\nconst vso_rpc_1 = require(\"@vs/vso-rpc\");\r\nconst vso_rpc_ssh_1 = require(\"@vs/vso-rpc-ssh\");\r\nconst vscs_utils_1 = require(\"@vs/vscs-utils\");\r\nconst workspaceNotJoined = 'workspace not joined';\r\nclass WorkspaceHubClient extends vscs_utils_1.DisposableClass {\r\n    constructor(multiChannelRpcClient, logger) {\r\n        super(logger);\r\n        this.multiChannelRpcClient = multiChannelRpcClient;\r\n        this.onHostConnectionChangedEmitter = new rpc.Emitter();\r\n        this.onWorkspaceMetricsUpdatedEmitter = new rpc.Emitter();\r\n        this.onHostConnectionChanged = this.onHostConnectionChangedEmitter.event;\r\n        this.onWorkspaceMetricsUpdated = this.onWorkspaceMetricsUpdatedEmitter.event;\r\n        const fireHostConnectionChanged = (e) => {\r\n            this.onHostConnectionChangedEmitter.fire(e);\r\n        };\r\n        let fireHostClosed = false;\r\n        const fireHostConnectionClosed = (reason, e) => {\r\n            if (!fireHostClosed) {\r\n                logger.info(`firing host connection closed -> reason:${reason}`);\r\n                fireHostClosed = true;\r\n                fireHostConnectionChanged(e !== null && e !== void 0 ? e : {\r\n                    state: vso_workspace_core_1.ConnectedState.Closed,\r\n                    duration: 0,\r\n                });\r\n                this.disconnect().catch((error) => {\r\n                    logger.info(`error while disconnecting workspace hub client`, vscs_utils_1.errorToObject(error));\r\n                });\r\n                this.dispose('host connection closed');\r\n            }\r\n        };\r\n        multiChannelRpcClient.rpcConnection.onDispose(() => {\r\n            // fire host closed if needed.\r\n            fireHostConnectionClosed('onDisposed');\r\n            // Note: if the rpc is being closed it is for 2 reasons, one of them is that we dispose this\r\n            // instance or we are being closed because of the remote connection is dropped.\r\n            if (!this.isDisposed) {\r\n                logger.warning('Rpc connection was disposed from our hub service');\r\n            }\r\n        });\r\n        const proxyLogger = logger.createChild('rpc');\r\n        this.workspaceServiceClient = vso_rpc_1.RpcProxy.create(vso_workspace_core_1.workspaceServiceClient, this.rpcClient, new vso_logging_1.Logger(logger.name, (logLevel, message, ...args) => {\r\n            // remove rpc verbose messages we know about\r\n            if (message.startsWith('> workspaceServiceClient.workspaceMetricsUpdated') ||\r\n                message.includes('workspaceServiceClient.checkConnection()')) {\r\n                return;\r\n            }\r\n            proxyLogger.log(logLevel, message, ...args);\r\n        }));\r\n        // Route event from the hub\r\n        this.workspaceServiceClient.onHostConnectionChanged((e) => {\r\n            if (e.workspaceId === this.joinedWorkspaceId) {\r\n                if (e.state === vso_workspace_core_1.ConnectedState.Closed) {\r\n                    fireHostConnectionClosed('onHostConnectionChanged', e);\r\n                }\r\n                else {\r\n                    fireHostConnectionChanged(e);\r\n                }\r\n            }\r\n        });\r\n        this.workspaceServiceClient.onWorkspaceMetricsUpdated((e) => {\r\n            if (e.workspaceId === this.joinedWorkspaceId) {\r\n                this.onWorkspaceMetricsUpdatedEmitter.fire(e);\r\n            }\r\n        });\r\n        this.addToDisposables({\r\n            dispose: () => fireHostConnectionClosed('disposed'),\r\n        }, multiChannelRpcClient);\r\n        this.rpcProxyCache = new vso_rpc_1.RpcProxyCache(this.multiChannelRpcClient, logger);\r\n    }\r\n    static async create(transportStream, logger) {\r\n        const multiChannelRpcClient = await vso_rpc_ssh_1.createMultiChannelRpcClient(transportStream, logger);\r\n        return new WorkspaceHubClient(multiChannelRpcClient, logger);\r\n    }\r\n    get rpcClient() {\r\n        return this.multiChannelRpcClient;\r\n    }\r\n    getServiceProxy(serviceInfo) {\r\n        return this.rpcProxyCache.getOrCreate(serviceInfo);\r\n    }\r\n    async join(joinConnectOptions) {\r\n        const start = Date.now();\r\n        const workspaceId = joinConnectOptions.workspaceId;\r\n        let workspaceSessionInfo;\r\n        // if seesion factory defined it may be worth to retrieve the session info on the hub service.\r\n        if (joinConnectOptions.sessionInfoFactory) {\r\n            workspaceSessionInfo = await this.workspaceServiceClient.getSessionInfoAsync(workspaceId);\r\n        }\r\n        if (!workspaceSessionInfo) {\r\n            try {\r\n                const liveshareConnectOptions = Object.assign({}, joinConnectOptions);\r\n                // Note: remove any properties that should not be serialize trough JSON\r\n                ['performance', 'sessionInfoFactory'].forEach(\r\n                // @ts-ignore\r\n                (key) => delete liveshareConnectOptions[key]);\r\n                // delete any mock keys\r\n                Object.keys(liveshareConnectOptions)\r\n                    .filter((k) => k.startsWith('mock'))\r\n                    // @ts-ignore\r\n                    .forEach((k) => delete liveshareConnectOptions[k]);\r\n                if (joinConnectOptions.sessionInfoFactory) {\r\n                    liveshareConnectOptions.connectionInfo = await joinConnectOptions.sessionInfoFactory(workspaceId);\r\n                }\r\n                workspaceSessionInfo = await this.workspaceServiceClient.joinAsync(liveshareConnectOptions);\r\n            }\r\n            catch (err) {\r\n                if (err instanceof rpc.ResponseError) {\r\n                    if (err.code === vso_workspace_core_1.RPC_ERR_NO_HOST_NOT_CONNECTED) {\r\n                        throw new vso_workspace_core_1.NoHostConnectedError(err.data);\r\n                    }\r\n                    else if (err.code === vso_workspace_core_1.RPC_ERR_RELAY_CONNECTIONY_SSH) {\r\n                        throw new vso_workspace_core_1.RelayConnectionError(err.message, err.data);\r\n                    }\r\n                }\r\n                throw err;\r\n            }\r\n        }\r\n        this.joinedWorkspaceId = workspaceId;\r\n        const time = (Date.now() - start).toFixed(1);\r\n        this.trace.info(`join completed -> time:${time} session:${workspaceSessionInfo.sessionNumber} conversation:${workspaceSessionInfo.conversationId}`);\r\n        return workspaceSessionInfo;\r\n    }\r\n    async openStreamingChannel(streamId, cancellationToken) {\r\n        vscs_utils_1.assertDefined(this.joinedWorkspaceId, 'Workspace not joined.');\r\n        // open the channel and then open a remote stream channel on the hub and wait\r\n        const [sshChannel] = await Promise.all([\r\n            this.multiChannelRpcClient.multiChannelStream.openChannel(),\r\n            this.workspaceServiceClient.openStreamingChannelAsync(this.joinedWorkspaceId, streamId, cancellationToken !== null && cancellationToken !== void 0 ? cancellationToken : rpc.CancellationToken.None),\r\n        ]);\r\n        return sshChannel;\r\n    }\r\n    async disconnect() {\r\n        vscs_utils_1.assertDefined(this.joinedWorkspaceId, workspaceNotJoined);\r\n        await this.workspaceServiceClient.disconnectAsync(this.joinedWorkspaceId);\r\n        this.dispose();\r\n    }\r\n    keepAlive(time) {\r\n        return this.workspaceServiceClient.keepAliveAsync(time);\r\n    }\r\n    async checkConnection(cancellationToken) {\r\n        vscs_utils_1.assertDefined(this.joinedWorkspaceId, workspaceNotJoined);\r\n        await this.workspaceServiceClient.checkConnectionAsync(this.joinedWorkspaceId, cancellationToken);\r\n    }\r\n    async setCheckConnectionOptions(options) {\r\n        vscs_utils_1.assertDefined(this.joinedWorkspaceId, workspaceNotJoined);\r\n        await this.workspaceServiceClient.setCheckConnectionOptionsAsync(this.joinedWorkspaceId, options);\r\n    }\r\n}\r\nexports.WorkspaceHubClient = WorkspaceHubClient;\r\n//# sourceMappingURL=WorkspaceHubClient.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar WorkspaceHubClient_1 = require(\"./WorkspaceHubClient\");\r\nexports.WorkspaceHubClient = WorkspaceHubClient_1.WorkspaceHubClient;\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst ssh = __importStar(require(\"@vs/vs-ssh\"));\r\nconst websocket_1 = require(\"websocket\");\r\nconst vso_logging_1 = require(\"@vs/vso-logging\");\r\nconst vso_workspace_core_1 = require(\"@vs/vso-workspace-core\");\r\nconst strings_nls_json_1 = __importDefault(require(\"./strings.nls.json\"));\r\nclass SshHelpers {\r\n    static getRelayUri(workspace, action) {\r\n        if (!workspace.relayLink) {\r\n            throw new Error('Workspace does not have a relay endpoint.');\r\n        }\r\n        // Reference:\r\n        // https://github.com/Azure/azure-relay-node/blob/7b57225365df3010163bf4b9e640868a02737eb6/hyco-ws/index.js#L107-L137\r\n        const relayUri = workspace.relayLink.replace('sb:', 'wss:').replace('.net/', '.net:443/$hc/') +\r\n            `?sb-hc-action=${action}&sb-hc-token=` +\r\n            encodeURIComponent(workspace.relaySas || '');\r\n        return relayUri;\r\n    }\r\n    static openConnection(workspaceConnectionInfo, logger) {\r\n        const relayUri = SshHelpers.getRelayUri(workspaceConnectionInfo, 'connect');\r\n        logger.log(vso_logging_1.LogLevel.Debug, `connecting to relay link:${workspaceConnectionInfo.relayLink}`);\r\n        if (exports.isNode()) {\r\n            logger.log(vso_logging_1.LogLevel.Debug, `creating node SSH...`);\r\n            return SshHelpers.nodeSshStreamFactory(relayUri, workspaceConnectionInfo);\r\n        }\r\n        logger.log(vso_logging_1.LogLevel.Debug, `creating web SSH...`);\r\n        return SshHelpers.webSshStreamFactory(new WebSocket(relayUri));\r\n    }\r\n    static createSshClientSession() {\r\n        return SshHelpers.createSshSession((config) => new ssh.SshClientSession(config));\r\n    }\r\n    static createSshServerSession(reconnectableSessions) {\r\n        return SshHelpers.createSshSession((config) => new ssh.SshServerSession(config, reconnectableSessions));\r\n    }\r\n    static async authenticate(sshSession, workspaceInfo, workspaceAccess, socketStream, clientAuthenticatedCompletion) {\r\n        // The client authenticates over SSH using the workspace session token.\r\n        const clientCredentials = {\r\n            username: '',\r\n            password: workspaceAccess.sessionToken,\r\n        };\r\n        // The server authenticates over SSH via a public key.\r\n        sshSession.onAuthenticating((e) => {\r\n            // At this point the SSH protocol has already validated that the server holds\r\n            // the private key that corresponds to the public key in e.key. So we just need\r\n            // to check if the public key matches one of the host keys published for the workspace.\r\n            e.authenticationPromise = SshHelpers.authenticateServer(workspaceInfo, e.publicKey);\r\n        });\r\n        await sshSession.connect(socketStream);\r\n        if (!(await sshSession.authenticateServer())) {\r\n            throw new Error('Live Share server authentication failed.');\r\n        }\r\n        if (clientAuthenticatedCompletion) {\r\n            // A completion was supplied. Send the client authentication request but don't\r\n            // directly wait for the response. Route the response to the completion instead.\r\n            await sshSession.authenticateClient(clientCredentials, (err, result) => {\r\n                if (!err && !result) {\r\n                    // Convert from a false result to an Error.\r\n                    err = new Error('Live Share client authentication failed.');\r\n                }\r\n                if (err) {\r\n                    clientAuthenticatedCompletion.reject(err);\r\n                }\r\n                else {\r\n                    clientAuthenticatedCompletion.resolve(err);\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            // No completion was supplied, so just wait for full client authentication now.\r\n            if (!(await sshSession.authenticateClient(clientCredentials))) {\r\n                throw new Error('Live Share client authentication failed.');\r\n            }\r\n        }\r\n        return sshSession;\r\n    }\r\n    static createWebSocketStreamAdapter(connection) {\r\n        return new ssh.WebSocketStream(new WebsocketStreamAdapter(connection));\r\n    }\r\n    static webSshStreamFactory(socket) {\r\n        socket.binaryType = 'arraybuffer';\r\n        return new Promise((resolve, reject) => {\r\n            socket.onopen = () => {\r\n                resolve(new ssh.WebSocketStream(socket));\r\n            };\r\n            socket.onerror = (e) => {\r\n                reject(new Error(`Failed to connect to relay url`));\r\n            };\r\n        });\r\n    }\r\n    static createSshSession(factoryCallback) {\r\n        const config = new ssh.SshSessionConfiguration();\r\n        config.keyExchangeAlgorithms.splice(0);\r\n        config.keyExchangeAlgorithms.push(ssh.SshAlgorithms.keyExchange.ecdhNistp384Sha384);\r\n        config.keyExchangeAlgorithms.push(ssh.SshAlgorithms.keyExchange.ecdhNistp256Sha256);\r\n        config.keyExchangeAlgorithms.push(ssh.SshAlgorithms.keyExchange.dhGroup14Sha256);\r\n        config.protocolExtensions.push(ssh.SshProtocolExtensionNames.sessionReconnect);\r\n        config.protocolExtensions.push(ssh.SshProtocolExtensionNames.sessionLatency);\r\n        return factoryCallback(config);\r\n    }\r\n    static nodeSshStreamFactory(relayUri, workspaceConnectionInfo) {\r\n        const client = new websocket_1.client();\r\n        return new Promise((resolve, reject) => {\r\n            client.on('connect', (connection) => {\r\n                resolve(new ssh.WebSocketStream(new WebsocketStreamAdapter(connection)));\r\n            });\r\n            client.on('connectFailed', (e) => {\r\n                if (e.message && e.message.startsWith('Error: ')) {\r\n                    e.message = e.message.substr(7);\r\n                }\r\n                let errorType = vso_workspace_core_1.RelayErrorType.ServerError;\r\n                // Unfortunately the status code can only be obtained from the error message.\r\n                // Also status 404 may be used for at least two distinct error conditions.\r\n                // So we have to match on the error message text. This could break when\r\n                // the relay server behavior changes or when updating the client websocket library.\r\n                // But then in the worst case the original error message will be reported.\r\n                if (/status: 401/.test(e.message)) {\r\n                    e.message = strings_nls_json_1.default['error.relaySasInvalid'];\r\n                    errorType = vso_workspace_core_1.RelayErrorType.SasInvalid;\r\n                }\r\n                else if (/status: 404 Endpoint does not exist/.test(e.message)) {\r\n                    e.message = strings_nls_json_1.default['error.relayEndpointNotFound'];\r\n                    errorType = vso_workspace_core_1.RelayErrorType.EndpointNotFound;\r\n                }\r\n                else if (/status: 404 There are no listeners connected/.test(e.message)) {\r\n                    e.message = strings_nls_json_1.default['error.relayListenerOffline'];\r\n                    errorType = vso_workspace_core_1.RelayErrorType.ListenerOffline;\r\n                }\r\n                else if (/status: 500/.test(e.message)) {\r\n                    e.message = strings_nls_json_1.default['error.relayServerError'];\r\n                    errorType = vso_workspace_core_1.RelayErrorType.ServerError;\r\n                }\r\n                else {\r\n                    // Other errors are most likely connectivity issues.\r\n                    // The original error message may have additional helpful details.\r\n                    e.message = strings_nls_json_1.default['error.relayConnectionError'] + ' ' + e.message;\r\n                }\r\n                reject(new vso_workspace_core_1.RelayConnectionError(e.message, {\r\n                    errorType,\r\n                    workspaceConnectionInfo,\r\n                }));\r\n            });\r\n            client.connect(relayUri);\r\n        });\r\n    }\r\n    static async authenticateServer(workspaceInfo, serverKey) {\r\n        const rsa = ssh.SshAlgorithms.publicKey.rsaWithSha512;\r\n        const serverKeyBytes = (await serverKey.getPublicKeyBytes());\r\n        for (const knownHostKey of (workspaceInfo && workspaceInfo.hostPublicKeys) || []) {\r\n            // Get the public key bytes using the matching algorithm name to ensure a valid comparison.\r\n            const hostKey = rsa.createKeyPair();\r\n            await hostKey.setPublicKeyBytes(Buffer.from(knownHostKey, 'base64'));\r\n            const hostKeyBytes = (await hostKey.getPublicKeyBytes());\r\n            if (serverKeyBytes.equals(hostKeyBytes)) {\r\n                // Returning a non-null object indicates successful authentication.\r\n                // (We're not using the principal here.)\r\n                const serverPrincipal = {};\r\n                return serverPrincipal;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\nexports.SshHelpers = SshHelpers;\r\n/**\r\n * Partially adapts a Node websocket connection object to the browser websocket API,\r\n * enough so that it can be used as an SSH stream.\r\n */\r\nclass WebsocketStreamAdapter {\r\n    constructor(connection) {\r\n        this.connection = connection;\r\n    }\r\n    set onmessage(messageHandler) {\r\n        if (messageHandler) {\r\n            this.connection.on('message', (message) => {\r\n                // This assumes all messages are binary.\r\n                messageHandler({ data: message.binaryData });\r\n            });\r\n        }\r\n        else {\r\n            // Removing event handlers is not implemented.\r\n        }\r\n    }\r\n    set onclose(closeHandler) {\r\n        if (closeHandler) {\r\n            this.connection.on('close', (code, reason) => {\r\n                closeHandler({ code, reason, wasClean: !(code || reason) });\r\n            });\r\n        }\r\n        else {\r\n            // Removing event handlers is not implemented.\r\n        }\r\n    }\r\n    send(data) {\r\n        if (Buffer.isBuffer(data)) {\r\n            this.connection.sendBytes(data);\r\n        }\r\n        else {\r\n            this.connection.sendBytes(Buffer.from(data));\r\n        }\r\n    }\r\n    close(code, reason) {\r\n        if (code || reason) {\r\n            this.connection.drop(code, reason);\r\n        }\r\n        else {\r\n            this.connection.close();\r\n        }\r\n    }\r\n}\r\nexports.isNode = () => typeof process !== 'undefined' &&\r\n    typeof process.release !== 'undefined' &&\r\n    process.release.name === 'node';\r\n//# sourceMappingURL=SshHelpers.js.map","\"use strict\";\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode_jsonrpc_1 = require(\"vscode-jsonrpc\");\r\nconst ssh = __importStar(require(\"@vs/vs-ssh\"));\r\nconst vso_workspace_core_1 = require(\"@vs/vso-workspace-core\");\r\nconst vscs_utils_1 = require(\"@vs/vscs-utils\");\r\nclass SshWorkspaceSession extends vscs_utils_1.DisposableClass {\r\n    constructor(sshSession, authCompletion, logger, reconnectCallback) {\r\n        super(logger);\r\n        this.sshSession = sshSession;\r\n        this.authCompletion = authCompletion;\r\n        this.onConnectedStateChangedEmitter = new vscode_jsonrpc_1.Emitter();\r\n        this.isReconnectingFlag = false;\r\n        this.onConnectedStateChanged = this.onConnectedStateChangedEmitter.event;\r\n        this.addToDisposables(sshSession, sshSession.onDisconnected((e) => {\r\n            if (reconnectCallback) {\r\n                this.isReconnectingFlag = true;\r\n                this.onConnectedStateChangedEmitter.fire({\r\n                    state: vso_workspace_core_1.ConnectedState.Reconnecting,\r\n                    retryCount: 0,\r\n                });\r\n                reconnectCallback()\r\n                    .then((result) => {\r\n                    this.isReconnectingFlag = false;\r\n                    this.onConnectedStateChangedEmitter.fire({\r\n                        state: result.error === undefined\r\n                            ? vso_workspace_core_1.ConnectedState.Reconnected\r\n                            : vso_workspace_core_1.ConnectedState.Closed,\r\n                        retryCount: result.retryCount,\r\n                        error: result.error,\r\n                    });\r\n                })\r\n                    .catch((err) => {\r\n                    this.isReconnectingFlag = false;\r\n                    // ignore err\r\n                });\r\n            }\r\n            else {\r\n                this.isReconnectingFlag = false;\r\n                this.onConnectedStateChangedEmitter.fire({\r\n                    state: vso_workspace_core_1.ConnectedState.Closed,\r\n                    retryCount: 0,\r\n                });\r\n                this.dispose('auto reconnect disabled');\r\n            }\r\n        }));\r\n    }\r\n    get isReconnecting() {\r\n        return this.isReconnectingFlag;\r\n    }\r\n    async createRpcMessageStream() {\r\n        const channelRequest = new ssh.ChannelRequestMessage();\r\n        channelRequest.requestType = 'json-rpc';\r\n        channelRequest.wantReply = true;\r\n        const channel = await this.sshSession.openChannel(null, channelRequest);\r\n        return new ssh.SshRpcMessageStream(channel);\r\n    }\r\n    async openStreamingChannel(streamId, cancellationToken) {\r\n        if (!this.sshSession) {\r\n            throw new Error('Ssh session not initiated yet');\r\n        }\r\n        const channel = await this.sshSession.openChannel();\r\n        const channelRequestType = `stream-transport-${streamId}`;\r\n        const result = await channel.request(new ssh.ChannelRequestMessage(channelRequestType), cancellationToken);\r\n        if (!result) {\r\n            throw new Error(`Failed to create stream transport channel with streamId - ${streamId}`);\r\n        }\r\n        return channel;\r\n    }\r\n}\r\nexports.SshWorkspaceSession = SshWorkspaceSession;\r\n//# sourceMappingURL=SshWorkspaceSession.js.map","\"use strict\";\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst ssh = __importStar(require(\"@vs/vs-ssh\"));\r\nconst vscs_utils_1 = require(\"@vs/vscs-utils\");\r\nconst SshHelpers_1 = require(\"./SshHelpers\");\r\nconst SshWorkspaceSession_1 = require(\"./SshWorkspaceSession\");\r\nconst debug_1 = __importDefault(require(\"debug\"));\r\nconst defaultMaxTimeReconnect = 60 * vscs_utils_1.TIME_SECOND_MS; // around 1 min\r\nconst defaultRetryTimeout = 5 * vscs_utils_1.TIME_SECOND_MS; // 5 secs\r\nconst maxReconnectTimeout = 5 * vscs_utils_1.TIME_SECOND_MS; // 5 secs\r\nclass SshWorkspaceSessionFactory {\r\n    static async createSshWorkspaceSession(sessionInfo, logger, socketStreamFactory, sshReconnectOptions) {\r\n        const streamFactory = socketStreamFactory || SshHelpers_1.SshHelpers.openConnection;\r\n        // Enable SSH protocol tracing and route it to the current logger. For now this\r\n        // uses static properties on the `debug` package; currently that package is\r\n        // instanced because this package references a different version than others.\r\n        // If package versions are consolidated, the settings here could have broader impact.\r\n        // TODO: Consider supporting a more flexible logging interface in the SSH lib.\r\n        const sshTrace = logger.createChild('ssh');\r\n        debug_1.default.enable(debug_1.default.disable() + ',vs-ssh');\r\n        if (typeof debug_1.default.inspectOpts === 'object') {\r\n            debug_1.default.inspectOpts.hideDate = true;\r\n        }\r\n        const defaultLog = debug_1.default.log;\r\n        debug_1.default.log = function (...args) {\r\n            if (this.namespace === 'vs-ssh') {\r\n                sshTrace.info(args[0], ...args.slice(1));\r\n            }\r\n            else {\r\n                defaultLog();\r\n            }\r\n        };\r\n        const reconnectOptions = sshReconnectOptions || { enabled: true };\r\n        let socketStream = await streamFactory(sessionInfo, logger);\r\n        const sshSession = await SshHelpers_1.SshHelpers.createSshClientSession();\r\n        const reconnect = async () => {\r\n            const maxTimeReconnect = reconnectOptions.maxTimeReconnect || defaultMaxTimeReconnect;\r\n            const retryTimeout = reconnectOptions.retryTimeout || defaultRetryTimeout;\r\n            logger.info(`reconnect started maxTimeReconnect:${maxTimeReconnect} retryTimeout:${retryTimeout}`);\r\n            const start = Date.now();\r\n            let retryCount = 1;\r\n            let error;\r\n            while (Date.now() - start <= maxTimeReconnect && !sshSession.isClosed) {\r\n                try {\r\n                    socketStream = await streamFactory(sessionInfo, logger);\r\n                    logger.info(`reconnecting ssh session retryCount:${retryCount}`);\r\n                    await vscs_utils_1.timeoutPromise(sshSession.reconnect(socketStream), maxReconnectTimeout, new Error('timeout on ssh reconnection'));\r\n                    logger.info(`ssh session successfully reconnected on retryCount:${retryCount} time:${(Date.now() - start).toFixed(1)}`);\r\n                    error = undefined;\r\n                    break;\r\n                }\r\n                catch (e) {\r\n                    error = e;\r\n                    if (e instanceof ssh.SshReconnectError) {\r\n                        // Retry is not likely to succeed after an SshReconnectError\r\n                        logger.error(`failed to reconnect ssh session: ${e.message}`);\r\n                        break;\r\n                    }\r\n                    logger.verbose(`failed to reconnect ssh session retryCount:${retryCount} error:${e}`);\r\n                    // wait for 5 secs to retry.\r\n                    await vscs_utils_1.wait(retryTimeout);\r\n                }\r\n                ++retryCount;\r\n            }\r\n            // if error log & dispose the ssh session.\r\n            if (error) {\r\n                logger.error(`unable to reconnect ssh session -> retryCount:${retryCount}`);\r\n                sshSession.dispose();\r\n            }\r\n            return {\r\n                retryCount,\r\n                error,\r\n            };\r\n        };\r\n        const clientAuthCompletion = new ssh.PromiseCompletionSource();\r\n        logger.verbose(`authenticating...`);\r\n        await SshHelpers_1.SshHelpers.authenticate(sshSession, sessionInfo, sessionInfo, socketStream, clientAuthCompletion);\r\n        return new SshWorkspaceSession_1.SshWorkspaceSession(sshSession, clientAuthCompletion.promise, logger.createChild('SshWorkspaceSession'), reconnectOptions.enabled ? reconnect : undefined);\r\n    }\r\n}\r\nexports.SshWorkspaceSessionFactory = SshWorkspaceSessionFactory;\r\n//# sourceMappingURL=SshWorkspaceSessionFactory.js.map","\"use strict\";\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst ssh = __importStar(require(\"@vs/vs-ssh\"));\r\nconst vscs_utils_1 = require(\"@vs/vscs-utils\");\r\nconst vso_rpc_1 = require(\"@vs/vso-rpc\");\r\nconst vso_workspace_core_1 = require(\"@vs/vso-workspace-core\");\r\nconst vsls_contracts_1 = require(\"@vs/vsls-contracts\");\r\nconst SshWorkspaceSessionFactory_1 = require(\"./SshWorkspaceSessionFactory\");\r\nconst vso_telemetry_1 = require(\"@vs/vso-telemetry\");\r\nclass WorkspaceClient extends vso_workspace_core_1.WorkspaceClientBase {\r\n    constructor(logger, socketStreamFactory, sshReconnectOptions) {\r\n        super(new vso_rpc_1.RpcClient({\r\n            create: (rpcClient) => this.rpcConnected.promise,\r\n        }, logger), logger);\r\n        this.socketStreamFactory = socketStreamFactory;\r\n        this.sshReconnectOptions = sshReconnectOptions;\r\n        this.checkConnectionMutex = new vscs_utils_1.Mutex();\r\n        this.rpcConnected = new vscs_utils_1.Signal();\r\n    }\r\n    async join(joinConnectOptions) {\r\n        var _a;\r\n        const performance = (_a = joinConnectOptions.performance) !== null && _a !== void 0 ? _a : {\r\n            measure: (options, callback) => {\r\n                return callback();\r\n            },\r\n        };\r\n        vscs_utils_1.assertDefined(joinConnectOptions.connectionInfo ||\r\n            joinConnectOptions.sessionInfoFactory ||\r\n            joinConnectOptions.liveShareEndpoint.length !== 0, 'join connect options expected');\r\n        const sessionInfo = await this.getSessionInfo(joinConnectOptions, performance);\r\n        // throw if host not connected\r\n        if (sessionInfo.isHostConnected === false) {\r\n            throw new vso_workspace_core_1.NoHostConnectedError(joinConnectOptions.workspaceId);\r\n        }\r\n        // create the workspace session\r\n        this.sshWorkspaceSession = await this.createWorkspaceSession(performance, sessionInfo);\r\n        performance\r\n            .measure({\r\n            id: 'ssh-auth-completion',\r\n            name: 'Ssh auth completion',\r\n        }, () => this.sshWorkspaceSession.authCompletion)\r\n            .catch((err) => {\r\n            this.trace.error('auth failed');\r\n        });\r\n        this.addToDisposables(this.sshWorkspaceSession);\r\n        const sshSession = this.sshWorkspaceSession.sshSession;\r\n        // hookup metrics events\r\n        const fireMetricsUpdated = (bytesIn, bytesOut, latency) => {\r\n            this.onWorkspaceMetricsUpdatedEmitter.fire({\r\n                bytesIn,\r\n                bytesOut,\r\n                latency,\r\n            });\r\n        };\r\n        sshSession === null || sshSession === void 0 ? void 0 : sshSession.metrics.onMessageReceived(() => {\r\n            fireMetricsUpdated(sshSession.metrics.bytesReceived, undefined, undefined);\r\n        });\r\n        sshSession === null || sshSession === void 0 ? void 0 : sshSession.metrics.onMessageSent(() => {\r\n            fireMetricsUpdated(undefined, sshSession.metrics.bytesSent, undefined);\r\n        });\r\n        sshSession === null || sshSession === void 0 ? void 0 : sshSession.metrics.onLatencyUpdated(() => {\r\n            const latency = new vso_workspace_core_1.LatencyMetrics(sshSession.metrics.latencyCurrentMs, sshSession.metrics.latencyAverageMs, sshSession.metrics.latencyMinMs, sshSession.metrics.latencyMaxMs);\r\n            fireMetricsUpdated(undefined, undefined, latency);\r\n        });\r\n        this.trace.info(`join started`);\r\n        const { clientVersionInfo, workspaceJoinInfo, clientCapabilities } = joinConnectOptions;\r\n        const joinPromise = performance.measure({\r\n            id: 'join-internal',\r\n            name: 'Joining the workspace',\r\n        }, () => this.joinInternal(sessionInfo, clientVersionInfo !== null && clientVersionInfo !== void 0 ? clientVersionInfo : {}, workspaceJoinInfo, clientCapabilities));\r\n        await Promise.all([this.sshWorkspaceSession.authCompletion, joinPromise]);\r\n        this.onWorkspaceSessionConnectionChange(joinConnectOptions);\r\n        // if check connection options is enabled.\r\n        if (joinConnectOptions.checkConnectionOptions) {\r\n            await this.setCheckConnectionOptions(joinConnectOptions.checkConnectionOptions);\r\n        }\r\n        return this.workspaceSessionInfo;\r\n    }\r\n    ensureIsJoined() {\r\n        vscs_utils_1.assertDefined(this.sshWorkspaceSession, 'Ssh session not initiated yet');\r\n    }\r\n    canCheckConnection() {\r\n        var _a;\r\n        return ((_a = this.sshWorkspaceSession) === null || _a === void 0 ? void 0 : _a.isReconnecting) === false;\r\n    }\r\n    async createWorkspaceSession(performance, sessionInfo) {\r\n        return await performance.measure({\r\n            id: 'createSshWorkspaceSession',\r\n            name: 'Creating the ssh workspace session',\r\n        }, () => SshWorkspaceSessionFactory_1.SshWorkspaceSessionFactory.createSshWorkspaceSession(sessionInfo, this.trace, this.socketStreamFactory, this.sshReconnectOptions));\r\n    }\r\n    onWorkspaceSessionConnectionChange(joinConnectOptions) {\r\n        var _a;\r\n        // wire up reconnection\r\n        const sendReconnectEvent = (elapsed, result) => {\r\n            var _a;\r\n            const reconnectEvent = new vso_telemetry_1.TelemetryEvent(vso_workspace_core_1.TelemetryEventNames.WORKSPACE_RECONNECT);\r\n            const telemetryProperties = joinConnectOptions.telemetryProperties;\r\n            if (telemetryProperties) {\r\n                Object.keys(telemetryProperties).forEach((key) => reconnectEvent.addProperty(key, telemetryProperties[key]));\r\n            }\r\n            reconnectEvent.addProperty(vso_telemetry_1.TelemetryPropertyNames.FEATURE_NAME +\r\n                vso_workspace_core_1.TelemetryPropertyNames.RECONNECT_SUCCEEDED, result.error === undefined ? true : false);\r\n            reconnectEvent.addProperty(vso_telemetry_1.TelemetryPropertyNames.FEATURE_NAME + vso_workspace_core_1.TelemetryPropertyNames.RECONNECT_ELAPSED, elapsed);\r\n            reconnectEvent.addProperty(vso_telemetry_1.TelemetryPropertyNames.FEATURE_NAME +\r\n                vso_workspace_core_1.TelemetryPropertyNames.RECONNECT_RETRY_COUNT, result.retryCount);\r\n            if (result.error !== undefined) {\r\n                if (result.error instanceof ssh.SshReconnectError) {\r\n                    const reason = (_a = result.error.reason) !== null && _a !== void 0 ? _a : ssh.SshReconnectFailureReason.unknownClientFailure;\r\n                    reconnectEvent.addProperty(vso_telemetry_1.TelemetryPropertyNames.FEATURE_NAME +\r\n                        vso_workspace_core_1.TelemetryPropertyNames.RECONNECT_ERROR_REASON, reason);\r\n                }\r\n                reconnectEvent.addProperty(vso_telemetry_1.TelemetryPropertyNames.FEATURE_NAME +\r\n                    vso_workspace_core_1.TelemetryPropertyNames.RECONNECT_ERROR_MESSAGE, result.error.message);\r\n            }\r\n            reconnectEvent.send();\r\n        };\r\n        let start;\r\n        (_a = this.sshWorkspaceSession) === null || _a === void 0 ? void 0 : _a.onConnectedStateChanged((e) => {\r\n            const elapsed = start ? Date.now() - start : 0;\r\n            if (e.state === vso_workspace_core_1.ConnectedState.Reconnecting) {\r\n                start = Date.now();\r\n            }\r\n            else if (e.state === vso_workspace_core_1.ConnectedState.Reconnected) {\r\n                if (start) {\r\n                    sendReconnectEvent(elapsed, e);\r\n                }\r\n                start = undefined;\r\n            }\r\n            else if (e.state === vso_workspace_core_1.ConnectedState.Closed) {\r\n                if (start) {\r\n                    sendReconnectEvent(elapsed, e);\r\n                }\r\n                start = undefined;\r\n            }\r\n            this.onHostConnectionChangedEmitter.fire({\r\n                state: e.state,\r\n                duration: elapsed,\r\n            });\r\n        });\r\n        this.trace.info(`join completed`);\r\n    }\r\n    async disconnect() {\r\n        if (this.workspaceSessionInfo) {\r\n            const sessionInfo = this.workspaceSessionInfo;\r\n            this.workspaceSessionInfo = undefined;\r\n            this.trace.info(`unjoing`);\r\n            await this.getServiceProxy(vsls_contracts_1.vsls.WorkspaceService).unjoinWorkspaceAsync(sessionInfo.id);\r\n            this.dispose('disconnect');\r\n        }\r\n    }\r\n    async getSessionInfo(joinConnectOptions, performance) {\r\n        if (joinConnectOptions.connectionInfo) {\r\n            return joinConnectOptions.connectionInfo;\r\n        }\r\n        else if (joinConnectOptions.sessionInfoFactory) {\r\n            return await joinConnectOptions.sessionInfoFactory(joinConnectOptions.workspaceId);\r\n        }\r\n        else {\r\n            return await performance.measure({\r\n                id: 'workspaceApi-getWorkspaceSessionInfo',\r\n                name: 'get workspace session info from liveshare',\r\n            }, () => vso_workspace_core_1.WorkspaceApi.getWorkspaceSessionInfo(joinConnectOptions.workspaceId, joinConnectOptions, this.trace.createChild('WorkspaceApi')));\r\n        }\r\n    }\r\n    async joinInternal(sessionInfo, clientVersionInfo, workspaceJoinInfo, clientCapabilities) {\r\n        const rpcStream = await this.sshWorkspaceSession.createRpcMessageStream();\r\n        // Note: we want to wrap the 'raw' ssh rpc reader stream\r\n        const joinMessages = [];\r\n        const listen = rpcStream.reader.listen.bind(rpcStream.reader);\r\n        let dataCallback;\r\n        const listenWrapper = (callback) => {\r\n            dataCallback = callback;\r\n            listen((data) => {\r\n                if (!this.rpcConnected.isFulfilled && data.hasOwnProperty('method')) {\r\n                    joinMessages.push(data);\r\n                }\r\n                callback(data);\r\n            });\r\n        };\r\n        // inject the listen wrapper\r\n        rpcStream.reader.listen = listenWrapper;\r\n        const rpcConnection = this.rcpClientInstance.createRpcConnection(rpcStream, this.trace);\r\n        rpcConnection.listen();\r\n        const configClient = this.getServiceProxyWithConnection(rpcConnection, vsls_contracts_1.vsls.ConfigurationService);\r\n        const hostVersionInfo = await configClient.exchangeVersionsAsync({}, clientVersionInfo);\r\n        this.trace.info('Host version: ' + JSON.stringify(hostVersionInfo));\r\n        if (!clientCapabilities) {\r\n            clientCapabilities = new vsls_contracts_1.vsls.ClientCapabilities();\r\n            clientCapabilities.isNonInteractive = false;\r\n        }\r\n        // default workspace join info\r\n        let joinInfo = {\r\n            id: sessionInfo.id,\r\n            connectionMode: vsls_contracts_1.vsls.ConnectionMode.Local,\r\n            joiningUserSessionToken: sessionInfo.sessionToken,\r\n            clientCapabilities,\r\n        };\r\n        if (workspaceJoinInfo) {\r\n            joinInfo = Object.assign(Object.assign({}, joinInfo), workspaceJoinInfo);\r\n        }\r\n        const workspaceService = this.getServiceProxyWithConnection(rpcConnection, {\r\n            name: vsls_contracts_1.vsls.WorkspaceService.name,\r\n            methods: vsls_contracts_1.vsls.WorkspaceService.methods,\r\n            voidMethods: vsls_contracts_1.vsls.WorkspaceService.voidMethods,\r\n            events: [],\r\n        });\r\n        this.workspaceSessionInfo = await workspaceService.joinWorkspaceAsync(joinInfo);\r\n        // complete rpc connections\r\n        this.rpcConnected.resolve(rpcConnection);\r\n        // flush rpc messages that would happen during the join\r\n        joinMessages.forEach((m) => {\r\n            dataCallback(m);\r\n        });\r\n        this.trace.info(`joinWorkspace -> session:${this.workspaceSessionInfo.sessionNumber} conversation:${this.workspaceSessionInfo.conversationId} join messages count:${joinMessages.length}`);\r\n    }\r\n    getServiceProxyWithConnection(rpcConnection, serviceInfo) {\r\n        return vso_rpc_1.RpcProxy.createWithConnection(serviceInfo, rpcConnection, this.trace);\r\n    }\r\n    async openStreamingChannel(streamId, cancellationToken) {\r\n        vscs_utils_1.assertDefined(this.sshWorkspaceSession, 'Ssh session not initiated yet');\r\n        this.trace.info(`openStreamingChannel -> streamId:${streamId}`);\r\n        const sshChannel = await this.sshWorkspaceSession.openStreamingChannel(streamId, cancellationToken);\r\n        return sshChannel;\r\n    }\r\n    async checkConnection(cancellationToken) {\r\n        vscs_utils_1.assertDefined(this.sshWorkspaceSession, 'Ssh session not initiated yet');\r\n        this.trace.verbose('checking ssh connection');\r\n        const sshSession = this.sshWorkspaceSession.sshSession;\r\n        vscs_utils_1.assert(!sshSession.isClosed, 'ssh session is closed');\r\n        // Note: by sending a simple request to the ssh server session we want to guarantee a packet\r\n        // was properly send and received no matter we know it won't be handled by the server logic.\r\n        const request = new ssh.SessionRequestMessage('ping-check-connection', true);\r\n        await this.checkConnectionMutex.dispatch(() => sshSession.request(request, cancellationToken));\r\n    }\r\n}\r\nexports.WorkspaceClient = WorkspaceClient;\r\n//# sourceMappingURL=WorkspaceClient.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar WorkspaceClient_1 = require(\"./WorkspaceClient\");\r\nexports.WorkspaceClient = WorkspaceClient_1.WorkspaceClient;\r\nvar SshHelpers_1 = require(\"./SshHelpers\");\r\nexports.SshHelpers = SshHelpers_1.SshHelpers;\r\nexports.isNode = SshHelpers_1.isNode;\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscs_utils_1 = require(\"@vs/vscs-utils\");\r\nconst LiveShareConnection_1 = require(\"./LiveShareConnection\");\r\nclass CodespaceConnection extends LiveShareConnection_1.LiveShareConnection {\r\n    setWorkspaceSessionInfo(workspaceSessionInfo) {\r\n        this.trace.verbose(`setWorkspaceSessionInfo`, workspaceSessionInfo);\r\n        const { ownerId, sessionNumber, sessions } = workspaceSessionInfo;\r\n        vscs_utils_1.assertDefined(ownerId, 'No owner id defined.');\r\n        this.trace.info(`ownerId: \"${ownerId}\"`);\r\n        vscs_utils_1.assert(!ownerId.startsWith('vm_'), 'Session host is not updated to the user, retrying...');\r\n        vscs_utils_1.assertDefined(sessions, 'Workspace sessions not defined.');\r\n        const session = sessions[sessionNumber];\r\n        vscs_utils_1.assertDefined(session, `Session #${sessionNumber} not defined.`);\r\n        vscs_utils_1.assert(session.isOwner, 'Session does not have owner permissions');\r\n        super.setWorkspaceSessionInfo(workspaceSessionInfo);\r\n    }\r\n}\r\nexports.CodespaceConnection = CodespaceConnection;\r\n//# sourceMappingURL=CodespaceConnection.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscs_utils_1 = require(\"@vs/vscs-utils\");\r\nconst vscode_jsonrpc_1 = require(\"vscode-jsonrpc\");\r\nconst ConnectionCancellationError_1 = require(\"../errors/ConnectionCancellationError\");\r\nconst errorToConnectionError_1 = require(\"../utils/errorToConnectionError\");\r\nconst ConnectionStateError_1 = require(\"../errors/ConnectionStateError\");\r\nconst ConnectionError_1 = require(\"../errors/ConnectionError\");\r\nconst ConnectionTimeoutError_1 = require(\"../errors/ConnectionTimeoutError\");\r\nclass Connection extends vscs_utils_1.DisposableClass {\r\n    constructor(traceName, performance, options = {}) {\r\n        super(traceName);\r\n        this.traceName = traceName;\r\n        this.performance = performance;\r\n        this.options = options;\r\n        this.isDisconnectedFlag = false;\r\n        this.isDisposingRef = false;\r\n        /**\r\n         * The `onConnectionChanged` callback is called every time the connection status changes.\r\n         */\r\n        this.onConnectionChangedEventEmitter = new vscode_jsonrpc_1.Emitter();\r\n        this.connectionStatus = 'none';\r\n        this.previousConnectionStatus = 'none';\r\n        this.addToDisposables(this.onConnectionChangedEventEmitter);\r\n    }\r\n    /**\r\n     * If the connection was explicitly disconnected (vs disposed).\r\n     */\r\n    get isDisconnected() {\r\n        return this.isDisconnectedFlag;\r\n    }\r\n    /**\r\n     * Get connection `id` from the connection `options`.\r\n     */\r\n    getId(options) {\r\n        throw new ConnectionError_1.ConnectionError('Not implemented.');\r\n    }\r\n    get onConnectionChanged() {\r\n        if (this.isDisposed) {\r\n            throw new ConnectionStateError_1.ConnectionStateError('Cannot listen to `onConnectionChanged`, connection already disposed.');\r\n        }\r\n        return this.onConnectionChangedEventEmitter.event;\r\n    }\r\n    /**\r\n     * If the connection is being disposed\r\n     */\r\n    get isDisposing() {\r\n        return this.isDisposingRef;\r\n    }\r\n    /**\r\n     * Connection status.\r\n     */\r\n    get status() {\r\n        return this.connectionStatus;\r\n    }\r\n    /**\r\n     * Previous connection status.\r\n     */\r\n    get previousStatus() {\r\n        return this.previousConnectionStatus;\r\n    }\r\n    /**\r\n     * Method to connect to LiveShare Session and create basic RPC services.\r\n     * Will reuse connection currently in progress if one already exists.\r\n     */\r\n    async connect() {\r\n        var _a, _b;\r\n        try {\r\n            this.trace.info('asked to connect');\r\n            /**\r\n             * This will make sure we preserve the original rejection error versus\r\n             * always returning the ConnectionStateError.\r\n             */\r\n            if (((_a = this.connectionSignal) === null || _a === void 0 ? void 0 : _a.isCancelled) || ((_b = this.connectionSignal) === null || _b === void 0 ? void 0 : _b.isRejected)) {\r\n                return await this.connectionSignal.promise;\r\n            }\r\n            vscs_utils_1.assert(this.status !== 'disconnected', new ConnectionStateError_1.ConnectionStateError('Connection already disconnected, please create a new one.'));\r\n            vscs_utils_1.assert(!this.isDisposed, new ConnectionStateError_1.ConnectionStateError('Connection is already disposed, please create a new one.'));\r\n            if (this.connectionSignal) {\r\n                this.trace.info(`return promise, resolved: ${this.connectionSignal.isResolved}`);\r\n                return await this.connectionSignal.promise;\r\n            }\r\n            this.trace.info('creating new connection');\r\n            return await this.createConnection();\r\n        }\r\n        catch (e) {\r\n            this.handleConnectionError(e);\r\n            throw errorToConnectionError_1.errorToConnectionError(e);\r\n        }\r\n    }\r\n    /**\r\n     * Disconnect method is disposing the connection. Will cause the\r\n     * `onConnectionChanged` and `onDispose` events to be fired.\r\n     */\r\n    disconnect(reason) {\r\n        this.isDisconnectedFlag = true;\r\n        return Promise.resolve(this.dispose(reason));\r\n    }\r\n    /**\r\n     * Dispose the connection, same as `disconnect`. Will cause the\r\n     * `onConnectionChanged` and `onDispose` events to be fired.\r\n     */\r\n    dispose(reason) {\r\n        this.isDisposingRef = true;\r\n        if (this.isDisposed) {\r\n            return this;\r\n        }\r\n        this.onConnectionChangedHandler('disconnected', new ConnectionCancellationError_1.ConnectionCancellationError('Disposing the connection.'));\r\n        super.dispose(reason);\r\n        return this;\r\n    }\r\n    /**\r\n     * Same as connect but with timeout.\r\n     */\r\n    async connectWithTimeout(timeout) {\r\n        try {\r\n            this.trace.info(`asked to connect with timeout of ${timeout} ms`);\r\n            if (!isFinite(timeout)) {\r\n                return await this.connect();\r\n            }\r\n            return await vscs_utils_1.timeoutPromise(this.connect(), timeout, new ConnectionTimeoutError_1.ConnectionTimeoutError(`Could not establish connection in ${timeout}ms.`));\r\n        }\r\n        catch (e) {\r\n            this.handleConnectionError(e);\r\n            throw errorToConnectionError_1.errorToConnectionError(e);\r\n        }\r\n    }\r\n    onConnectionChangedHandler(connectionStatus, error) {\r\n        if (connectionStatus === this.connectionStatus) {\r\n            return;\r\n        }\r\n        this.trace.info(`connection status changed: ${this.connectionStatus} -> ${connectionStatus}, error:`, error);\r\n        this.previousConnectionStatus = this.connectionStatus;\r\n        this.connectionStatus = connectionStatus;\r\n        const event = {\r\n            status: connectionStatus,\r\n            previousStatus: this.previousConnectionStatus,\r\n        };\r\n        this.trace.info('firing change event: ', event);\r\n        this.onConnectionChangedEventEmitter.fire(event);\r\n        vscs_utils_1.assertDefined(this.connectionSignal, 'No `connectionSignal` found.');\r\n        if (this.connectionSignal.isFulfilled) {\r\n            return;\r\n        }\r\n        if (connectionStatus === 'connected') {\r\n            this.trace.info(' connected');\r\n            this.connectionSignal.resolve(this);\r\n        }\r\n        if (connectionStatus === 'disconnected') {\r\n            this.trace.info('disconnected');\r\n            this.connectionSignal.reject(errorToConnectionError_1.errorToConnectionError(error !== null && error !== void 0 ? error : new ConnectionError_1.ConnectionError('Connection failed.')));\r\n        }\r\n    }\r\n    initializeConnection() {\r\n        this.trace.info('creating connection');\r\n        this.connectionSignal = new vscs_utils_1.Signal();\r\n        this.connectionSignal.promise.catch((reason) => {\r\n            this.trace.verbose(`signal rejected reason -> ${vscs_utils_1.propertiesToString(reason)}`);\r\n        });\r\n        this.addToDisposables(this.connectionSignal);\r\n        this.onConnectionChangedHandler('connecting');\r\n        return this;\r\n    }\r\n    async createConnection() {\r\n        this.initializeConnection();\r\n        vscs_utils_1.assertDefined(this.connectionSignal, new ConnectionError_1.ConnectionError('No `connectionSignal` found.'));\r\n        await this.connectionSignal.promise;\r\n        throw new ConnectionError_1.ConnectionError('Not implemented.');\r\n    }\r\n    handleConnectionError(e) {\r\n        var _a;\r\n        this.trace.error('connection failed: ', e);\r\n        this.onConnectionChangedHandler('disconnected', e);\r\n        (_a = this.connectionSignal) === null || _a === void 0 ? void 0 : _a.reject(errorToConnectionError_1.errorToConnectionError(e));\r\n        this.dispose();\r\n    }\r\n}\r\nexports.Connection = Connection;\r\n//# sourceMappingURL=Connection.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscs_utils_1 = require(\"@vs/vscs-utils\");\r\nconst vsls_contracts_1 = require(\"@vs/vsls-contracts\");\r\nconst vso_workspace_core_1 = require(\"@vs/vso-workspace-core\");\r\nconst vso_workspace_client_1 = require(\"@vs/vso-workspace-client\");\r\nconst TConnectionTypes_1 = require(\"../interfaces/TConnectionTypes\");\r\nconst ConnectionError_1 = require(\"../errors/ConnectionError\");\r\nconst Connection_1 = require(\"./Connection\");\r\nconst PerformanceEventIds_1 = require(\"../performance/PerformanceEventIds\");\r\nconst errorToConnectionError_1 = require(\"../utils/errorToConnectionError\");\r\n/**\r\n * Class to connect to LiveShare Session and create basic RPC services.\r\n */\r\nclass LiveShareConnection extends Connection_1.Connection {\r\n    constructor(trace, performance, options) {\r\n        super(trace.createChild('liveshare'), performance);\r\n        this.performance = performance;\r\n        this.options = options;\r\n    }\r\n    /**\r\n     * Get connection `id` from the connection `options`.\r\n     */\r\n    getId(options) {\r\n        const { workspaceId } = options;\r\n        return workspaceId;\r\n    }\r\n    get type() {\r\n        return TConnectionTypes_1.TConnectionTypes.MainThread;\r\n    }\r\n    /**\r\n     * LiveShare WorkspaceClient.\r\n     */\r\n    get workspaceClient() {\r\n        vscs_utils_1.assertDefined(this.workspaceClientReference, 'No `WorkspaceClient` found.');\r\n        return this.workspaceClientReference;\r\n    }\r\n    /**\r\n     * Method to get RPC service proxy client.\r\n     */\r\n    getRpcService(rpcServiceContract) {\r\n        return this.workspaceClient.getServiceProxy(rpcServiceContract);\r\n    }\r\n    dispose(reason) {\r\n        super.dispose(reason);\r\n        this.workspaceClientReference = undefined;\r\n        this.workspaceSessionInfoReference = undefined;\r\n        return this;\r\n    }\r\n    get workspaceSessionInfo() {\r\n        return this.workspaceSessionInfoReference;\r\n    }\r\n    async createWorkspaceClient() {\r\n        const workspaceClient = new vso_workspace_client_1.WorkspaceClient(this.trace.createChild('WorkspaceClient'), undefined, {\r\n            enabled: true,\r\n            retryTimeout: 0.25 * vscs_utils_1.TIME_SECOND_MS,\r\n            maxTimeReconnect: 10 * vscs_utils_1.TIME_SECOND_MS,\r\n        });\r\n        return workspaceClient;\r\n    }\r\n    setWorkspaceSessionInfo(workspaceSessionInfo) {\r\n        this.workspaceSessionInfoReference = workspaceSessionInfo;\r\n    }\r\n    async createConnection() {\r\n        try {\r\n            this.initializeConnection();\r\n            this.trace.info('creating workspace client', this.options);\r\n            const workspaceClient = await this.createWorkspaceClient();\r\n            this.addToDisposables({\r\n                dispose: () => {\r\n                    workspaceClient.dispose('Disposed from LiveShareConnection');\r\n                },\r\n            });\r\n            const workspaceSessionInfo = await this.performance.measure({\r\n                id: PerformanceEventIds_1.PerformanceEventIds.LiveshareJoinWorkspace,\r\n                name: 'join LiveShare session',\r\n            }, async () => {\r\n                return await workspaceClient.join(Object.assign(Object.assign({}, this.options), { performance: this.performance.createGroup(`${this.trace.name}:${this.options.workspaceId}`), checkConnectionOptions: {\r\n                        enabled: true,\r\n                    } }));\r\n            });\r\n            this.workspaceClientReference = workspaceClient;\r\n            this.setWorkspaceSessionInfo(workspaceSessionInfo);\r\n            this.trace.info(`LS session joined and authenticated`);\r\n            await this.performance.measure({\r\n                name: 'create workspace service',\r\n            }, async () => {\r\n                const workspaceService = workspaceClient.getServiceProxy(vsls_contracts_1.vsls.WorkspaceService);\r\n                vscs_utils_1.assertDefined(workspaceService, 'WorkspaceService not set.');\r\n                await workspaceClient.rpcClient.onClose(() => {\r\n                    this.onConnectionChangedHandler('disconnected', new ConnectionError_1.ConnectionError('RPC client closed.'));\r\n                });\r\n                this.addToDisposables(workspaceService.onConnectionStatusChanged((event) => {\r\n                    if (event.connectionStatus ===\r\n                        vsls_contracts_1.vsls.WorkspaceConnectionStatus.Disconnected) {\r\n                        this.onConnectionChangedHandler('disconnected', new ConnectionError_1.ConnectionError(`Workspace service disconnected with status: \"${event.disconnectedReason}\".`));\r\n                    }\r\n                }));\r\n            });\r\n            this.onConnectionChangedHandler('connected');\r\n            // hookup host connection events\r\n            workspaceClient.onHostConnectionChanged((e) => {\r\n                this.trace.info(`host connection changed to \"${vso_workspace_core_1.ConnectedState[e.state]}\"`);\r\n                if (e.state === vso_workspace_core_1.ConnectedState.Reconnecting) {\r\n                    this.initializeConnection();\r\n                }\r\n                else if (e.state === vso_workspace_core_1.ConnectedState.Reconnected) {\r\n                    this.onConnectionChangedHandler('connected');\r\n                }\r\n                else if (e.state === vso_workspace_core_1.ConnectedState.Closed) {\r\n                    this.onConnectionChangedHandler('disconnected');\r\n                }\r\n            });\r\n            return this;\r\n        }\r\n        catch (e) {\r\n            this.handleConnectionError(e);\r\n            throw errorToConnectionError_1.errorToConnectionError(e);\r\n        }\r\n    }\r\n}\r\nexports.LiveShareConnection = LiveShareConnection;\r\n//# sourceMappingURL=LiveShareConnection.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscs_utils_1 = require(\"@vs/vscs-utils\");\r\nconst LiveShareConnection_1 = require(\"./LiveShareConnection\");\r\n/**\r\n * Class to connect to LiveShare Session through a main thread or service worker.\r\n */\r\nclass LiveShareJointConnection extends LiveShareConnection_1.LiveShareConnection {\r\n    constructor(trace, performance, options, connectionHubs) {\r\n        super(trace.createChild('liveshare-joint'), performance, options);\r\n        this.performance = performance;\r\n        this.options = options;\r\n        this.connectionHubs = connectionHubs;\r\n        /******************************************************\r\n         * Implementation details.\r\n         ******************************************************/\r\n        this.connectionReference = null;\r\n    }\r\n    get type() {\r\n        vscs_utils_1.assertDefined(this.connectionReference, '');\r\n        return this.connectionReference.type;\r\n    }\r\n    get workspaceSessionInfo() {\r\n        if (!this.connectionReference) {\r\n            return;\r\n        }\r\n        return this.connectionReference.workspaceSessionInfo;\r\n    }\r\n    get connection() {\r\n        return this.connectionReference;\r\n    }\r\n    async createConnection() {\r\n        try {\r\n            this.trace.info('creating connection');\r\n            this.connectionSignal = new vscs_utils_1.Signal();\r\n            this.addToDisposables(this.connectionSignal);\r\n            this.onConnectionChangedHandler('connecting');\r\n            const connectionPromises = this.connectionHubs.map((hub, i) => {\r\n                return hub.connectOnce(this.options, {\r\n                    performance: this.performance.createGroup(`connection #${i}`),\r\n                });\r\n            });\r\n            const connection = await vscs_utils_1.raceAsync(connectionPromises);\r\n            connection.addToDisposables(this);\r\n            vscs_utils_1.assertDefined(this.connectionSignal, 'No connection signal found.');\r\n            this.connectionReference = connection;\r\n            this.workspaceClientReference = connection.workspaceClient;\r\n            this.addToDisposables(connection);\r\n            this.addToDisposables(connection.onConnectionChanged(this.onConnectionChangedEventEmitter.fire.bind(connection)));\r\n            this.onConnectionChangedHandler('connected');\r\n            return this;\r\n        }\r\n        catch (e) {\r\n            this.handleConnectionError(e);\r\n            throw e;\r\n        }\r\n    }\r\n}\r\nexports.LiveShareJointConnection = LiveShareJointConnection;\r\n//# sourceMappingURL=LiveShareJointConnection.js.map","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscs_utils_1 = require(\"@vs/vscs-utils\");\r\nconst vscode_jsonrpc_1 = require(\"vscode-jsonrpc\");\r\nconst vsls_contracts_1 = require(\"@vs/vsls-contracts\");\r\nconst PerformanceEventIds_1 = require(\"../performance/PerformanceEventIds\");\r\nconst PerformanceGroupIds_1 = require(\"../performance/PerformanceGroupIds\");\r\nconst errorToConnectionError_1 = require(\"../utils/errorToConnectionError\");\r\nconst ConnectionError_1 = require(\"../errors/ConnectionError\");\r\nconst findSourcePort_1 = require(\"../utils/findSourcePort\");\r\nconst Connection_1 = require(\"./Connection\");\r\nconst VSCodeServerHostRPCService_1 = require(\"../interfaces/VSCodeServerHostRPCService\");\r\nconst vscs_utils_2 = require(\"@vs/vscs-utils\");\r\nconst getVSCodeServerSessionName_1 = require(\"../utils/getVSCodeServerSessionName\");\r\nexports.DEFAULT_FORWARDING_HOST = '127.0.0.1';\r\n/**\r\n * Class responsible for `vscode` connection - e.g. starting VSCode server and forwarding server\r\n * port. It consume the `LiveShareConnectionHub` that orchestrates the LiveShare connections.\r\n */\r\nclass VSCodeConnection extends Connection_1.Connection {\r\n    constructor(trace, performance, options, connectionHubs) {\r\n        super(trace.createChild('vscode'), performance);\r\n        this.performance = performance;\r\n        this.options = options;\r\n        this.connectionHubs = connectionHubs;\r\n        this.onVSCodeServerStartedEmitter = new vscode_jsonrpc_1.Emitter();\r\n        this.onVSCodeServerStarted = this\r\n            .onVSCodeServerStartedEmitter.event;\r\n        this.forecastChannels = [];\r\n        this.vscodeServerHostClientReference = null;\r\n        /******************************************************\r\n         * Implementation details.\r\n         ******************************************************/\r\n        this.sharedServerReference = null;\r\n        this.liveshareConnectionReference = null;\r\n        this.serverSharingServiceReference = null;\r\n        this.remotePortReference = null;\r\n    }\r\n    /**\r\n     * Get connection `id` from the connection `options`.\r\n     */\r\n    getId(options) {\r\n        const { workspaceId, environmentId, vsCodeQuality, vsCodeCommit } = options;\r\n        return `${workspaceId}_${environmentId}_${vsCodeQuality}_${vsCodeCommit}`;\r\n    }\r\n    /**\r\n     * Method to get LiveShare RPC service client proxy.\r\n     */\r\n    getRpcService(rpcServiceContract) {\r\n        return this.workspaceClient.getServiceProxy(rpcServiceContract);\r\n    }\r\n    /**\r\n     * WorkspaceClient reference.\r\n     */\r\n    get workspaceClient() {\r\n        vscs_utils_1.assertDefined(this.liveshareConnection, 'No LiveShare connection found.');\r\n        const { workspaceClient } = this.liveshareConnection;\r\n        vscs_utils_1.assertDefined(workspaceClient, 'No WorkspaceClient found.');\r\n        return workspaceClient;\r\n    }\r\n    /**\r\n     * VSCodeServerHostService reference.\r\n     */\r\n    get vscodeServerHostClient() {\r\n        vscs_utils_1.assertDefined(this.vscodeServerHostClientReference, 'No VSCodeServerHostClient defined.');\r\n        return this.vscodeServerHostClientReference;\r\n    }\r\n    /**\r\n     * ServerSharing service reference.\r\n     */\r\n    get serverSharingService() {\r\n        vscs_utils_1.assertDefined(this.serverSharingServiceReference, 'No ServerSharing service found.');\r\n        return this.serverSharingServiceReference;\r\n    }\r\n    /**\r\n     * LiveShareConnection reference.\r\n     */\r\n    get liveshareConnection() {\r\n        vscs_utils_1.assertDefined(this.liveshareConnectionReference, 'No LiveShare connection found.');\r\n        return this.liveshareConnectionReference;\r\n    }\r\n    async createConnection() {\r\n        const [liveshareConnectionHub] = this.connectionHubs;\r\n        vscs_utils_1.assertDefined(liveshareConnectionHub, 'LiveShareConnectionHub not found.');\r\n        try {\r\n            this.initializeConnection();\r\n            this.trace.info('get LS connection');\r\n            this.liveshareConnectionReference = await this.performance.measure({\r\n                name: 'liveshare connection',\r\n            }, async () => {\r\n                return await liveshareConnectionHub.connectOnce(this.options, {\r\n                    performance: this.performance.createGroup('liveshare connection'),\r\n                });\r\n            });\r\n            this.liveshareConnectionReference.addToDisposables(this);\r\n            this.addToDisposables(this.liveshareConnectionReference.onConnectionChanged((e) => {\r\n                const { previousStatus, status } = e;\r\n                this.trace.info(`LiveShareConnection status changed: \"${previousStatus}\" -> \"${status}\"`);\r\n                this.dispose('LiveShareConnection disconnected');\r\n            }), this.liveshareConnectionReference.onDispose((e) => {\r\n                this.trace.info(`LiveShareConnection disposed`);\r\n                this.dispose('LiveShareConnection disposed');\r\n            }));\r\n            const { workspaceClient } = this.liveshareConnectionReference;\r\n            // TODO legomushroom - this is redundant in the \"web\" connction case?\r\n            await this.getVSCodeSharedServer(workspaceClient);\r\n            // Start opening forecasted channels now, so they will be (almost) ready\r\n            // by the time they are requested.\r\n            for (let i = 0; i < VSCodeConnection.channelForecast; i++) {\r\n                this.forecastChannels.push(this.openChannel(this.performance, false));\r\n            }\r\n            this.onConnectionChangedHandler('connected');\r\n            return this;\r\n        }\r\n        catch (e) {\r\n            this.handleConnectionError(e);\r\n            throw errorToConnectionError_1.errorToConnectionError(e);\r\n        }\r\n    }\r\n    get sharedServer() {\r\n        vscs_utils_1.assertDefined(this.sharedServerReference, 'No SharedServer found.');\r\n        return this.sharedServerReference;\r\n    }\r\n    async getVSCodeSharedServer(workspaceClient) {\r\n        const sharePerformance = this.performance.createGroup('share vscode server', PerformanceGroupIds_1.PerformanceGroupIds.VSCodeServerStartup);\r\n        this.serverSharingServiceReference = workspaceClient.getServiceProxy(vsls_contracts_1.vsls.ServerSharingService);\r\n        const port = await sharePerformance.measure({\r\n            name: 'start vscode server',\r\n            id: PerformanceEventIds_1.PerformanceEventIds.VSCodeServerStartupServerStart,\r\n        }, async () => {\r\n            return await this.startVSCodeServer(workspaceClient);\r\n        });\r\n        vscs_utils_1.assertDefined(port, new ConnectionError_1.ConnectionError(`VSCode Server port is \"${port}\"`));\r\n        this.trace.info(`forwarding the VSCode Server port \"${port}\".`);\r\n        /**\r\n         * If the sharing of the vscode server port have stopped,\r\n         * dispose the current connection.\r\n         */\r\n        this.addToDisposables(this.serverSharingService.onSharingStopped((e) => {\r\n            const { server } = e;\r\n            this.trace.verbose('serverSharingService onSharingStopped:', server);\r\n            if (server.sourcePort !== port) {\r\n                return;\r\n            }\r\n            this.trace.info('serverSharingService closed.', server);\r\n            this.onConnectionChangedHandler('disconnected', new ConnectionError_1.ConnectionError('Port closed.'));\r\n        }));\r\n        // TODO legomushroom - not needed?\r\n        // /**\r\n        //  * If the sharing of the vscode server port have changed,\r\n        //  * dispose the current connection.\r\n        //  */\r\n        // this.addToDisposables(\r\n        //     this.serverSharingService.onSharingChanged((e: vsls.ServerSharingChangedEventArgs) => {\r\n        //         const { server } = e;\r\n        //         const { isTCPServerConnectionEstablished } = server;\r\n        //         this.trace.verbose('serverSharingService onSharingChanged:', server);\r\n        //         if (server.sourcePort !== port) {\r\n        //             return;\r\n        //         }\r\n        //         if (isTCPServerConnectionEstablished === false) {\r\n        //             this.onConnectionChangedHandler(\r\n        //                 'disconnected',\r\n        //                 new ConnectionError('Port closed.')\r\n        //             );\r\n        //         }\r\n        //     })\r\n        // );\r\n        this.sharedServerReference = await sharePerformance.measure({\r\n            name: 'share vscode server TCP port',\r\n            id: PerformanceEventIds_1.PerformanceEventIds.VSCodeServerStartupServerTcpPortForwarding,\r\n        }, async () => {\r\n            const { clientId } = this.options;\r\n            return await this.serverSharingService.startSharingAsync(port, getVSCodeServerSessionName_1.getVSCodeServerSessionName(clientId), '');\r\n        });\r\n        this.trace.info(`VSCode Server port \"${port}\" forwarded.`);\r\n        return this.sharedServerReference;\r\n    }\r\n    async getSharedServers() {\r\n        try {\r\n            /**\r\n             * There is the current bug that makes RPC calls hang\r\n             * after connection lost/reconnection. Timeout the RPC\r\n             * call and dispose the LiveShare connection if that happens.\r\n             */\r\n            const sharedServers = await vscs_utils_1.timeoutPromise(this.serverSharingService.getSharedServersAsync(), 2 * vscs_utils_1.TIME_SECOND_MS, new ConnectionError_1.ConnectionError('Getting shared servers timed out.'));\r\n            this.trace.verbose('got shared servers list', sharedServers);\r\n            return sharedServers;\r\n        }\r\n        catch (e) {\r\n            this.trace.error('getting shared servers failed: ', e);\r\n            this.liveshareConnection.dispose(`disposed by vscode connection: \"${e.message}\"`);\r\n            throw e;\r\n        }\r\n    }\r\n    async startVSCodeServer(workspaceClient) {\r\n        const { shouldReuseExistingServers = false, clientId } = this.options;\r\n        this.trace.info('starting vscode server..', this.options);\r\n        this.vscodeServerHostClientReference = workspaceClient.getServiceProxy(VSCodeServerHostRPCService_1.vscodeServerHostRPCService);\r\n        /**\r\n         * If the `shouldReuseExistingServers` flag is set,\r\n         * get the existing vscode server.\r\n         */\r\n        if (shouldReuseExistingServers) {\r\n            this.trace.info('checking if existing vscode server can be reused');\r\n            const sharedPorts = await this.getSharedServers();\r\n            this.trace.info('checking already running ports', sharedPorts);\r\n            // take the last shared port\r\n            const vscodeServerPort = sharedPorts.reverse().find((port) => {\r\n                return port.sessionName === getVSCodeServerSessionName_1.getVSCodeServerSessionName(clientId);\r\n            });\r\n            if (vscodeServerPort) {\r\n                this.remotePortReference = vscodeServerPort.sourcePort;\r\n                this.trace.info(`reusing already shared port ${this.remotePortReference}`);\r\n                this.onVSCodeServerStartedEmitter.fire({\r\n                    port: this.remotePort,\r\n                    connectionToken: this.options.vsCodeCommit,\r\n                });\r\n                return this.remotePortReference;\r\n            }\r\n        }\r\n        this.trace.info('vscode started, forwarding the server port');\r\n        this.remotePortReference = await this.vscodeServerHostClient.startRemoteServerAsync(Object.assign(Object.assign({}, this.options), { quality: this.options.vsCodeQuality }));\r\n        this.trace.info(`the server port forwarded, port number is ${this.remotePortReference}`);\r\n        this.trace.info('vscode server startup complete');\r\n        this.onVSCodeServerStartedEmitter.fire({\r\n            port: this.remotePort,\r\n            connectionToken: this.options.vsCodeCommit,\r\n        });\r\n        return this.remotePort;\r\n    }\r\n    /**\r\n     * The remote port that vscode server is running on.\r\n     */\r\n    get remotePort() {\r\n        vscs_utils_1.assertDefined(this.remotePortReference, 'No remote port found.');\r\n        return this.remotePortReference;\r\n    }\r\n    async startForwardingPort(port, host = exports.DEFAULT_FORWARDING_HOST) {\r\n        this.trace.info(`start sharing the port \"${port}\"`);\r\n        const servers = await this.getSharedServers();\r\n        return await this.startForwardingPortCore(servers, port, host);\r\n    }\r\n    async startForwardingPortWithVisibility(port, isPublic, host = exports.DEFAULT_FORWARDING_HOST) {\r\n        const servers = await this.getSharedServers();\r\n        const server = await this.startForwardingPortCore(servers, port, host);\r\n        await this.updateForwardedPortCore(server, port, isPublic);\r\n        return server;\r\n    }\r\n    async updateForwardedPortVisibility(port, isPublic) {\r\n        this.trace.info(`updating visibility of \"${port}\" to \"${isPublic}\"`);\r\n        const servers = await this.getSharedServers();\r\n        const currentPort = findSourcePort_1.findSourcePort(servers, port);\r\n        vscs_utils_1.assertDefined(currentPort, `No port \"${port}\" found.`);\r\n        return await this.updateForwardedPortCore(currentPort, port, isPublic);\r\n    }\r\n    async updateForwardedPortProtocol(port, isHttps) {\r\n        this.trace.info(`updating protocol of \"${port}\" to \"${isHttps}\"`);\r\n        const servers = await this.getSharedServers();\r\n        const currentPort = findSourcePort_1.findSourcePort(servers, port);\r\n        vscs_utils_1.assertDefined(currentPort, `No port \"${port}\" found.`);\r\n        return await this.updateForwardedPortProtocolCore(currentPort, port, isHttps);\r\n    }\r\n    async updateForwardedPortPrivacy(port, privacy) {\r\n        this.trace.info(`updating privacy of \"${port}\" to \"${privacy}\"`);\r\n        const servers = await this.getSharedServers();\r\n        const currentPort = findSourcePort_1.findSourcePort(servers, port);\r\n        vscs_utils_1.assertDefined(currentPort, `No port \"${port}\" found.`);\r\n        return await this.updateForwardedPortPrivacyCore(currentPort, port, privacy);\r\n    }\r\n    async stopForwardingPort(port) {\r\n        const serverSharingClient = this.workspaceClient.getServiceProxy(vsls_contracts_1.vsls.ServerSharingService);\r\n        await serverSharingClient.stopSharingAsync(port);\r\n        return this;\r\n    }\r\n    async openChannel(performance = this.performance, useForecast = true) {\r\n        if (useForecast) {\r\n            const channelPromise = this.forecastChannels.shift();\r\n            if (channelPromise) {\r\n                return await channelPromise;\r\n            }\r\n        }\r\n        const streamManager = this.getRpcService(vsls_contracts_1.vsls.StreamManagerService);\r\n        const streamId = await performance.measure({\r\n            name: 'get stream Id',\r\n            id: vscs_utils_1.randomString(),\r\n        }, async () => {\r\n            vscs_utils_1.assertDefined(this.sharedServer, 'No SharedServer found.');\r\n            return await streamManager.getStreamAsync(this.sharedServer.streamName, this.sharedServer.streamCondition);\r\n        });\r\n        const channel = await performance.measure({\r\n            name: `open streaming channel \"${streamId}\"`,\r\n        }, async () => {\r\n            return await this.workspaceClient.openStreamingChannel(streamId);\r\n        });\r\n        return channel || null;\r\n    }\r\n    // TODO legomushroom - move out of the common connection class\r\n    // [ref:0fd69cbff577529b853378fd51839fb7]\r\n    async sendHandshakeRequest(requestStr) {\r\n        const openedChannel = new vscs_utils_1.Signal();\r\n        try {\r\n            this.trace.info('opening ssh channel');\r\n            const channel = await this.openChannel();\r\n            vscs_utils_1.assertDefined(channel, 'Cannot open a channel.');\r\n            const dataReceivedHandler = channel.onDataReceived((e) => {\r\n                // the first request on this channel is for the handshake,\r\n                // ignore all other data messages as the consumer will set up its own listeners.\r\n                dataReceivedHandler.dispose();\r\n                this.trace.info(`response: \\n${e.toString()}\\n`);\r\n                channel.adjustWindow(e.length);\r\n                openedChannel.resolve(channel);\r\n            });\r\n            this.addToDisposables(dataReceivedHandler);\r\n            this.trace.info(`sending the request: \\n${requestStr}\\n`);\r\n            await channel.send(Buffer.from(requestStr));\r\n            this.trace.info(' connected');\r\n        }\r\n        catch (err) {\r\n            this.trace.info('failed to send request');\r\n            openedChannel.reject(err);\r\n        }\r\n        return await openedChannel.promise;\r\n    }\r\n    /**\r\n     * Disconnect method is disposing the connection. Will cause the\r\n     * `onConnectionChanged` and `onDispose` events to be fired.\r\n     */\r\n    async disconnect(reason) {\r\n        this.trace.info(`disconnecting with reason: \"${reason}\"`);\r\n        if (this.isDisconnected) {\r\n            this.trace.info('already disconnected');\r\n            return this;\r\n        }\r\n        try {\r\n            // stop sharing the vscode server port\r\n            if (this.remotePortReference && this.serverSharingServiceReference) {\r\n                this.trace.info(`stop sharing vscode server port \"${this.remotePortReference}\"`);\r\n                await this.serverSharingService.stopSharingAsync(this.remotePortReference);\r\n            }\r\n            // shut down the vscode server\r\n            await this.vscodeServerHostClient.shutDownRemoteServerAsync();\r\n        }\r\n        catch (e) {\r\n            this.trace.warning('error while disconnecting', e);\r\n        }\r\n        finally {\r\n            this.remotePortReference = null;\r\n            this.vscodeServerHostClientReference = null;\r\n        }\r\n        return super.disconnect(reason);\r\n    }\r\n    async startForwardingPortCore(servers, port, host = exports.DEFAULT_FORWARDING_HOST) {\r\n        const server = findSourcePort_1.findSourcePort(servers, port);\r\n        if (server) {\r\n            this.trace.info(`port ${port} is already forwarded.`);\r\n            return server;\r\n        }\r\n        return await this.serverSharingService.startSharingAsync(port, host, '');\r\n    }\r\n    async updateForwardedPortCore(server, port, isPublic) {\r\n        if (server.isPublic === isPublic) {\r\n            this.trace.info(`port ${port} visibility is already ${isPublic ? 'public' : 'private'}.`);\r\n            return this;\r\n        }\r\n        await this.serverSharingService.updateSharedServerVisibilityAsync(port, isPublic);\r\n        this.trace.info(`port ${port} visibility updated to ${isPublic ? 'public' : 'private'}.`);\r\n        return this;\r\n    }\r\n    async updateForwardedPortProtocolCore(server, port, isHttps) {\r\n        if (server.hasTLSHandshakePassed === isHttps) {\r\n            this.trace.info(`port ${port} protocol is already ${isHttps ? 'https' : 'http'}.`);\r\n            return this;\r\n        }\r\n        await this.serverSharingService.updateSharedServerProtocolAsync(port, isHttps);\r\n        this.trace.info(`port ${port} protocol updated to ${isHttps ? 'https' : 'http'}.`);\r\n        return this;\r\n    }\r\n    async updateForwardedPortPrivacyCore(server, port, privacy) {\r\n        if (server.privacy === privacy) {\r\n            this.trace.info(`port ${port} privacy is already ${privacy}.`);\r\n            return this;\r\n        }\r\n        await this.serverSharingService.updateSharedServerPrivacyAsync(port, privacy);\r\n        this.trace.info(`port ${port} privacy updated to ${privacy}.`);\r\n        return this;\r\n    }\r\n    /*\r\n     * Stop forwarding vscode server port.\r\n     */\r\n    dispose(reason) {\r\n        if (this.remotePortReference == null) {\r\n            return super.dispose(reason);\r\n        }\r\n        this.trace.info(`stopping remote port \"${this.remotePortReference}\"`);\r\n        this.stopForwardingPort(this.remotePortReference).catch((e) => {\r\n            this.trace.warning('failed to stop forwarding vscode server port');\r\n        });\r\n        return super.dispose(reason);\r\n    }\r\n}\r\n/**\r\n * VS Code always requests 2 channels when connecting. The channels will be pre-allocated\r\n * so that those connections can be setup faster.\r\n */\r\nVSCodeConnection.channelForecast = 2;\r\n__decorate([\r\n    vscs_utils_2.withHelperDecorator(vscs_utils_1.withMutexByArguments, {\r\n        serializeArguments: (servers, port, host = exports.DEFAULT_FORWARDING_HOST) => {\r\n            return `${port}_${host}`;\r\n        },\r\n    }),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", [Array, Number, String]),\r\n    __metadata(\"design:returntype\", Promise)\r\n], VSCodeConnection.prototype, \"startForwardingPortCore\", null);\r\nexports.VSCodeConnection = VSCodeConnection;\r\n//# sourceMappingURL=VSCodeConnection.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscs_utils_1 = require(\"@vs/vscs-utils\");\r\nconst Connection_1 = require(\"./Connection\");\r\n/**\r\n * Class to connect establish a VSCode connection through a main thread or service worker.\r\n * Currently the fastest to connect wins, but in the future, we can add different criteria on\r\n * what connection should be used - for instance connection with better throughput or latency\r\n * characteristics can win instead, and the connections might be upgraded/downgraded dynamically.\r\n */\r\nclass VSCodeJointConnection extends Connection_1.Connection {\r\n    constructor(trace, performance, options, connectionHubs) {\r\n        super(trace.createChild('vscode-joint'), performance);\r\n        this.performance = performance;\r\n        this.options = options;\r\n        this.connectionHubs = connectionHubs;\r\n        this.connectionReference = null;\r\n    }\r\n    getSharedServers() {\r\n        throw new vscs_utils_1.NotImplementedError('Method not implemented.');\r\n    }\r\n    get vscodeServerHostClient() {\r\n        vscs_utils_1.assertDefined(this.connectionReference, 'No connection found.');\r\n        return this.connectionReference.vscodeServerHostClient;\r\n    }\r\n    get serverSharingService() {\r\n        vscs_utils_1.assertDefined(this.connectionReference, 'No connection found.');\r\n        return this.connectionReference.serverSharingService;\r\n    }\r\n    getRpcService(rpcServiceContract) {\r\n        throw new Error('Method not implemented.');\r\n    }\r\n    get connection() {\r\n        vscs_utils_1.assertDefined(this.connectionReference, 'No connection found.');\r\n        return this.connectionReference;\r\n    }\r\n    get workspaceClient() {\r\n        vscs_utils_1.assertDefined(this.connectionReference, 'No connection found.');\r\n        const { liveshareConnection } = this.connectionReference;\r\n        vscs_utils_1.assertDefined(liveshareConnection, 'No LiveShare connection found.');\r\n        return liveshareConnection.workspaceClient;\r\n    }\r\n    get liveshareConnection() {\r\n        var _a, _b;\r\n        vscs_utils_1.assertDefined((_a = this.connectionReference) === null || _a === void 0 ? void 0 : _a.liveshareConnection, 'No LiveShare conneciton found.');\r\n        return (_b = this.connectionReference) === null || _b === void 0 ? void 0 : _b.liveshareConnection;\r\n    }\r\n    get sharedServer() {\r\n        return this.connection.sharedServer;\r\n    }\r\n    async openChannel(performance) {\r\n        var _a;\r\n        const result = await ((_a = this.connectionReference) === null || _a === void 0 ? void 0 : _a.openChannel(performance));\r\n        return result !== null && result !== void 0 ? result : null;\r\n    }\r\n    get onVSCodeServerStarted() {\r\n        return this.connection.onVSCodeServerStarted;\r\n    }\r\n    get remotePort() {\r\n        vscs_utils_1.assertDefined(this.connectionReference, 'No connection found.');\r\n        return this.connectionReference.remotePort;\r\n    }\r\n    async startForwardingPort(port) {\r\n        return await this.connection.startForwardingPort(port);\r\n    }\r\n    async startForwardingPortWithVisibility(port, isPublic) {\r\n        return await this.connection.startForwardingPortWithVisibility(port, isPublic);\r\n    }\r\n    async updateForwardedPortVisibility(port, isPublic) {\r\n        await this.connection.updateForwardedPortVisibility(port, isPublic);\r\n        return this;\r\n    }\r\n    async updateForwardedPortProtocol(port, isHttps) {\r\n        await this.connection.updateForwardedPortProtocol(port, isHttps);\r\n        return this;\r\n    }\r\n    async updateForwardedPortPrivacy(port, privacy) {\r\n        await this.connection.updateForwardedPortPrivacy(port, privacy);\r\n        return this;\r\n    }\r\n    async stopForwardingPort(port) {\r\n        var _a;\r\n        await ((_a = this.connection) === null || _a === void 0 ? void 0 : _a.stopForwardingPort(port));\r\n        return this;\r\n    }\r\n    async sendHandshakeRequest(requestStr) {\r\n        return await this.connection.sendHandshakeRequest(requestStr);\r\n    }\r\n    /******************************************************\r\n     * Implementation details.\r\n     ******************************************************/\r\n    async createConnectionMock() {\r\n        try {\r\n            this.trace.info('creating connection');\r\n            this.connectionSignal = new vscs_utils_1.Signal();\r\n            this.addToDisposables(this.connectionSignal);\r\n            const [connectionHub, remoteConnectionHub] = this.connectionHubs;\r\n            vscs_utils_1.assertDefined(connectionHub, 'No VSCode ConnectionHub found.');\r\n            vscs_utils_1.assertDefined(remoteConnectionHub, 'No Remote VSCode ConnectionHub found.');\r\n            this.onConnectionChangedHandler('connecting');\r\n            const connection = await vscs_utils_1.raceAsync([\r\n                connectionHub.connectOnce(this.options, {\r\n                    performance: this.performance.createGroup('main-thread'),\r\n                }),\r\n                remoteConnectionHub.connectOnce(this.options, {\r\n                    performance: this.performance.createGroup('service-worker'),\r\n                }),\r\n            ]);\r\n            vscs_utils_1.assertDefined(this.connectionSignal, 'No connection signal found.');\r\n            vscs_utils_1.assertDefined(connection.liveshareConnection, 'Connected but no LiveShare connection found.');\r\n            this.connectionReference = connection;\r\n            this.addToDisposables(connection);\r\n            this.addToDisposables(connection.onConnectionChanged(this.onConnectionChangedEventEmitter.fire.bind(connection)));\r\n            this.connectionSignal.resolve(this);\r\n            // fire the event after the connection completed\r\n            vscs_utils_1.defer(() => {\r\n                this.onConnectionChangedHandler('connected');\r\n            });\r\n            return this;\r\n        }\r\n        catch (e) {\r\n            this.handleConnectionError(e);\r\n            throw e;\r\n        }\r\n    }\r\n}\r\nexports.VSCodeJointConnection = VSCodeJointConnection;\r\n//# sourceMappingURL=VSCodeJointConnection.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscs_utils_1 = require(\"@vs/vscs-utils\");\r\nconst vscode_jsonrpc_1 = require(\"vscode-jsonrpc\");\r\nconst constants_1 = require(\"./constants\");\r\nconst ConnectionTimeoutError_1 = require(\"../errors/ConnectionTimeoutError\");\r\nconst ConnectionHubRecord_1 = require(\"./ConnectionHubRecord\");\r\nconst errorToConnectionError_1 = require(\"../utils/errorToConnectionError\");\r\nconst optionsWithDefaults = (connectionOptions) => {\r\n    return Object.assign(Object.assign({}, constants_1.HUB_CONNECTION_DEFAULT_OPTIONS), connectionOptions);\r\n};\r\n/**\r\n * Orchestrator class for a `Connection`s. Gives back a LiveShare or\r\n * VSCode connection, either exisiting or create a new one for you.\r\n */\r\nclass ConnectionHub extends vscs_utils_1.DisposableClass {\r\n    constructor(trace, performance, connectionClass, childConnectionHubs = []) {\r\n        super(trace);\r\n        this.performance = performance;\r\n        this.connectionClass = connectionClass;\r\n        this.childConnectionHubs = childConnectionHubs;\r\n        /**\r\n         * The `onConnection` callback when a connection is created.\r\n         */\r\n        this.onConnectionEmitter = new vscode_jsonrpc_1.Emitter();\r\n        this.onConnection = this.onConnectionEmitter.event;\r\n        /**\r\n         * Get connection `id` by `connectionOptions`. Each connection\r\n         * type must provide the `getId` method that identifies\r\n         * the connection by the `connectionOptions`. Same connection\r\n         * type with the same options must have the same resulting `id`.\r\n         */\r\n        this.getConnectionId = (connectionOptions) => {\r\n            const connection = new this.connectionClass(this.trace, this.performance, connectionOptions);\r\n            return connection.getId(connectionOptions);\r\n        };\r\n        /**\r\n         * Connect without retries.\r\n         */\r\n        this.connectOnce = async (connectionOptions, hubConnectionOptions = {}) => {\r\n            const { trace = this.trace } = hubConnectionOptions;\r\n            trace.info('requested to connect once', connectionOptions, hubConnectionOptions);\r\n            return await this.connect(connectionOptions, Object.assign(Object.assign({}, constants_1.HUB_NO_RETRY_OPTIONS), hubConnectionOptions));\r\n        };\r\n        this.connections = {};\r\n        this.retrySignals = {};\r\n        /**\r\n         * If connection is not complete after specified timeout, throw the ConnectionError.\r\n         */\r\n        this.createConnectionWithTimeout = async (connectionOptions, hubConnectionOptions) => {\r\n            const { timeout } = hubConnectionOptions;\r\n            if (!isFinite(timeout)) {\r\n                this.trace.verbose(`creating connection without a timeout`);\r\n                return await this.createConnection(connectionOptions, hubConnectionOptions);\r\n            }\r\n            this.trace.verbose(`creating connection with timeout of ${timeout}ms`);\r\n            const result = await vscs_utils_1.timeoutPromise(this.createConnection(connectionOptions, hubConnectionOptions), timeout, new ConnectionTimeoutError_1.ConnectionTimeoutError(`Could not establish connection in ${timeout}ms.`));\r\n            return result;\r\n        };\r\n        this.createConnection = async (connectionOptions, hubConnectionOptions) => {\r\n            const { retries, retryDelay, performance = this.performance, trace = this.trace, } = hubConnectionOptions;\r\n            const options = connectionOptions;\r\n            const id = this.getConnectionId(options);\r\n            try {\r\n                this.trace.info('creating connection', hubConnectionOptions);\r\n                // create new connection\r\n                const connection = new this.connectionClass(trace.createChild(`connection:${id}`), performance.createGroup(`${trace.name}:${vscs_utils_1.hashString(id)}`), options, this.childConnectionHubs);\r\n                const record = new ConnectionHubRecord_1.ConnectionHubRecord(this.trace.createChild('connection-record'), connection, connectionOptions, hubConnectionOptions, connection.onConnectionChanged(this.onConnectionChanged.bind(this, id)));\r\n                this.connections[id] = record;\r\n                const connectionResult = await connection.connect();\r\n                this.addToDisposables(record);\r\n                // fire the event after the connection is complete\r\n                vscs_utils_1.defer(() => {\r\n                    this.onConnectionEmitter.fire(connectionResult);\r\n                }, 0);\r\n                return connectionResult;\r\n            }\r\n            catch (e) {\r\n                this.trace.warning(`disposing connection \"${id}\" due to an error`, e);\r\n                this.disposeConnection(id);\r\n                /**\r\n                 * If no retries left, re-throw the error.\r\n                 */\r\n                if (retries < 1) {\r\n                    throw e;\r\n                }\r\n                this.trace.info(`connection failed, retrying ${retries}`);\r\n                /**\r\n                 * If a `disconnect` is requested when we wait on `retryDelay`,\r\n                 * we must not create a new connection after the `retryDelay` is\r\n                 * finished but rather bail out immediately.\r\n                 */\r\n                const signal = new vscs_utils_1.Signal();\r\n                this.retrySignals[id] = signal;\r\n                await Promise.race([signal.promise, vscs_utils_1.wait(retryDelay)]);\r\n                return await this.createConnection(connectionOptions, Object.assign(Object.assign({}, hubConnectionOptions), { retries: retries - 1 }));\r\n            }\r\n        };\r\n    }\r\n    get childHubs() {\r\n        return [...this.childConnectionHubs];\r\n    }\r\n    /**\r\n     * Return a possible existing connection based on the connection options.\r\n     * The returned connection if exists would have\r\n     */\r\n    getConnection(connectionOptions) {\r\n        const id = this.getConnectionId(connectionOptions);\r\n        const connectionRecord = this.connections[id];\r\n        if (connectionRecord) {\r\n            const { connection } = connectionRecord;\r\n            return connection;\r\n        }\r\n    }\r\n    /**\r\n     * Will give you a LiveShare\r\n     * connection back, either exisiting or will create a new one for you.\r\n     */\r\n    async connect(connectionOptions, hubConnectionOptions = {}) {\r\n        const { trace = this.trace } = hubConnectionOptions;\r\n        trace.info('requested to connect', connectionOptions, hubConnectionOptions);\r\n        try {\r\n            const id = this.getConnectionId(connectionOptions);\r\n            const connectionRecord = this.connections[id];\r\n            const connectionTrace = trace.createChild(`${id}`);\r\n            connectionTrace.info(`connection record: ${!!connectionRecord}`);\r\n            if (!connectionRecord) {\r\n                connectionTrace.info('creating new connection');\r\n                return await this.createConnectionWithTimeout(connectionOptions, optionsWithDefaults(hubConnectionOptions));\r\n            }\r\n            const { connection } = connectionRecord;\r\n            if (!connection) {\r\n                connectionTrace.info('no connection on connection record, creating');\r\n                return await this.createConnectionWithTimeout(connectionOptions, optionsWithDefaults(hubConnectionOptions));\r\n            }\r\n            if (connection.status === 'disconnected') {\r\n                connectionTrace.info('disposed, creating');\r\n                this.disposeConnection(id);\r\n                return await this.createConnectionWithTimeout(connectionOptions, optionsWithDefaults(hubConnectionOptions));\r\n            }\r\n            if (connection.status === 'connected') {\r\n                connectionTrace.info('return connected');\r\n                return connection;\r\n            }\r\n            const { timeout = Infinity } = hubConnectionOptions;\r\n            connectionTrace.info(`connecting with timeout - ${timeout} ms`);\r\n            const result = await connection.connectWithTimeout(timeout);\r\n            return result;\r\n        }\r\n        catch (err) {\r\n            trace.warning('error during connection', err);\r\n            throw errorToConnectionError_1.errorToConnectionError(err);\r\n        }\r\n    }\r\n    /**\r\n     * Disconnect a connection.\r\n     */\r\n    async disconnect(connectionOptions, reason) {\r\n        this.trace.info('requested disconnect', connectionOptions);\r\n        const id = this.getConnectionId(connectionOptions);\r\n        const retryAwaitSignal = this.retrySignals[id];\r\n        if (retryAwaitSignal) {\r\n            retryAwaitSignal.cancel();\r\n            this.retrySignals[id] = undefined;\r\n        }\r\n        const connectionRecord = this.connections[id];\r\n        if (!connectionRecord) {\r\n            return false;\r\n        }\r\n        await connectionRecord.disconnect(reason);\r\n        this.connections[id] = undefined;\r\n        return true;\r\n    }\r\n    /******************************************************\r\n     * Implementation details.\r\n     ******************************************************/\r\n    /**\r\n     * Individual connection state changed.\r\n     */\r\n    async onConnectionChanged(id, connectionChange) {\r\n        const trace = this.trace.createChild(`onConnectionChanged:${id}`);\r\n        const { status, previousStatus } = connectionChange;\r\n        trace.info(`${previousStatus} -> ${status}`);\r\n        if (status !== 'disconnected') {\r\n            return;\r\n        }\r\n        // if disconnected, dispose the current connection\r\n        const connectionRecord = this.connections[id];\r\n        if (!connectionRecord) {\r\n            trace.info('no connection record found');\r\n            return;\r\n        }\r\n        trace.info('disposing the connection');\r\n        this.disposeConnection(id);\r\n        this.connections[id] = undefined;\r\n        if (previousStatus !== 'connected') {\r\n            return;\r\n        }\r\n        // if prev status was \"connected\" and we should also reconnect\r\n        const { hubConnectionOptions, connectionOptions, connection } = connectionRecord;\r\n        if (hubConnectionOptions.shouldReconnect && !connection.isDisposing) {\r\n            trace.info('reconnecting..');\r\n            return await this.connect(connectionOptions, hubConnectionOptions);\r\n        }\r\n        trace.info('not reconnecting');\r\n    }\r\n    disposeConnection(id) {\r\n        try {\r\n            this.trace.info(`disposing ${id} connection`);\r\n            const connectionRecord = this.connections[id];\r\n            if (!connectionRecord) {\r\n                return;\r\n            }\r\n            connectionRecord.dispose('connection record disposed by ConnectionHub');\r\n            this.connections[id] = undefined;\r\n        }\r\n        catch (err) {\r\n            this.trace.warning(`error while disposing ${id} connection`, err);\r\n        }\r\n    }\r\n}\r\nexports.ConnectionHub = ConnectionHub;\r\n//# sourceMappingURL=ConnectionHub.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscs_utils_1 = require(\"@vs/vscs-utils\");\r\n/**\r\n * Record of a connection inside a ConnectionHub.\r\n */\r\nclass ConnectionHubRecord extends vscs_utils_1.DisposableClass {\r\n    constructor(trace, connectionArg, connectionOptionsArg, hubConnectionOptionsArg, eventHandlerArg) {\r\n        super(trace);\r\n        this.connectionArg = connectionArg;\r\n        this.connectionOptionsArg = connectionOptionsArg;\r\n        this.hubConnectionOptionsArg = hubConnectionOptionsArg;\r\n        this.eventHandlerArg = eventHandlerArg;\r\n        this.addToDisposables(eventHandlerArg, connectionArg);\r\n    }\r\n    get connection() {\r\n        return this.connectionArg;\r\n    }\r\n    get connectionOptions() {\r\n        return this.connectionOptionsArg;\r\n    }\r\n    get hubConnectionOptions() {\r\n        return this.hubConnectionOptionsArg;\r\n    }\r\n    get eventHandler() {\r\n        return this.eventHandlerArg;\r\n    }\r\n    async disconnect(reason) {\r\n        await this.connection.disconnect(reason);\r\n        return super.dispose(reason);\r\n    }\r\n}\r\nexports.ConnectionHubRecord = ConnectionHubRecord;\r\n//# sourceMappingURL=ConnectionHubRecord.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.HUB_CONNECTION_DEFAULT_OPTIONS = {\r\n    retries: 3,\r\n    retryDelay: 0,\r\n    timeout: Infinity,\r\n    shouldReconnect: true,\r\n};\r\nexports.HUB_NO_RETRY_OPTIONS = Object.assign(Object.assign({}, exports.HUB_CONNECTION_DEFAULT_OPTIONS), { retries: 0, shouldReconnect: false });\r\n//# sourceMappingURL=constants.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.VSCODE_SERVER_PORT_NAME = 'VSCodeServerInternal';\r\n//# sourceMappingURL=constants.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst ConnectionError_1 = require(\"./ConnectionError\");\r\nclass ConnectionCancellationError extends ConnectionError_1.ConnectionError {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.errorType = 'ConnectionCancellationError';\r\n    }\r\n}\r\nexports.ConnectionCancellationError = ConnectionCancellationError;\r\n//# sourceMappingURL=ConnectionCancellationError.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscs_utils_1 = require(\"@vs/vscs-utils\");\r\n/**\r\n * The main error type for the connection hub package. All errors\r\n * thrown by this package or any of libraries used by the package\r\n * should derrive from this class.\r\n */\r\nclass ConnectionError extends vscs_utils_1.BaseError {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.errorType = 'ConnectionError';\r\n    }\r\n}\r\nexports.ConnectionError = ConnectionError;\r\n//# sourceMappingURL=ConnectionError.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst ConnectionError_1 = require(\"./ConnectionError\");\r\nclass ConnectionStateError extends ConnectionError_1.ConnectionError {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.errorType = 'ConnectionStateError';\r\n    }\r\n}\r\nexports.ConnectionStateError = ConnectionStateError;\r\n//# sourceMappingURL=ConnectionStateError.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst ConnectionError_1 = require(\"./ConnectionError\");\r\nclass ConnectionTimeoutError extends ConnectionError_1.ConnectionError {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.errorType = 'ConnectionTimeoutError';\r\n    }\r\n}\r\nexports.ConnectionTimeoutError = ConnectionTimeoutError;\r\n//# sourceMappingURL=ConnectionTimeoutError.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * The main error type for the connection hub package. All errors\r\n * thrown by this package or any of libraries used by the package\r\n * should derrive from this class.\r\n */\r\nvar ConnectionError_1 = require(\"./ConnectionError\");\r\nexports.ConnectionError = ConnectionError_1.ConnectionError;\r\n/**\r\n * `ConnectionTimeoutError` expected to be throw when a connection\r\n * attempt timeouts.\r\n */\r\nvar ConnectionTimeoutError_1 = require(\"./ConnectionTimeoutError\");\r\nexports.ConnectionTimeoutError = ConnectionTimeoutError_1.ConnectionTimeoutError;\r\n/**\r\n * `ConnectionStateError` when connection encounters unexpected state,\r\n * commonly from the public method call, for instance, if you try to\r\n * add a `onConnectionChange` event listener to a disposed connection.\r\n */\r\nvar ConnectionStateError_1 = require(\"./ConnectionStateError\");\r\nexports.ConnectionStateError = ConnectionStateError_1.ConnectionStateError;\r\n/**\r\n * `ConnectionCancellationError` when the connection is cancelled or disposed\r\n * during on going connection (connection has the `connecting` status).\r\n */\r\nvar ConnectionCancellationError_1 = require(\"./ConnectionCancellationError\");\r\nexports.ConnectionCancellationError = ConnectionCancellationError_1.ConnectionCancellationError;\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// Connections\r\nvar Connection_1 = require(\"./connection/Connection\");\r\nexports.Connection = Connection_1.Connection;\r\nvar LiveShareConnection_1 = require(\"./connection/LiveShareConnection\");\r\nexports.LiveShareConnection = LiveShareConnection_1.LiveShareConnection;\r\nvar VSCodeConnection_1 = require(\"./connection/VSCodeConnection\");\r\nexports.VSCodeConnection = VSCodeConnection_1.VSCodeConnection;\r\nvar CodespaceConnection_1 = require(\"./connection/CodespaceConnection\");\r\nexports.CodespaceConnection = CodespaceConnection_1.CodespaceConnection;\r\n// - joint\r\nvar LiveShareJointConnection_1 = require(\"./connection/LiveShareJointConnection\");\r\nexports.LiveShareJointConnection = LiveShareJointConnection_1.LiveShareJointConnection;\r\nvar VSCodeJointConnection_1 = require(\"./connection/VSCodeJointConnection\");\r\nexports.VSCodeJointConnection = VSCodeJointConnection_1.VSCodeJointConnection;\r\n// ConnectionHub\r\nvar ConnectionHub_1 = require(\"./connectionHub/ConnectionHub\");\r\nexports.ConnectionHub = ConnectionHub_1.ConnectionHub;\r\n// utils\r\nvar errorToConnectionError_1 = require(\"./utils/errorToConnectionError\");\r\nexports.errorToConnectionError = errorToConnectionError_1.errorToConnectionError;\r\nvar getVSCodeServerSessionName_1 = require(\"./utils/getVSCodeServerSessionName\");\r\nexports.getVSCodeServerSessionName = getVSCodeServerSessionName_1.getVSCodeServerSessionName;\r\nvar isVSCodeServerSession_1 = require(\"./utils/isVSCodeServerSession\");\r\nexports.isVSCodeServerSession = isVSCodeServerSession_1.isVSCodeServerSession;\r\n// interfaces & contracts\r\nvar VSCodeServerHostRPCService_1 = require(\"./interfaces/VSCodeServerHostRPCService\");\r\nexports.vscodeServerHostRPCService = VSCodeServerHostRPCService_1.vscodeServerHostRPCService;\r\nvar TConnectionTypes_1 = require(\"./interfaces/TConnectionTypes\");\r\nexports.TConnectionTypes = TConnectionTypes_1.TConnectionTypes;\r\n// Errors\r\n__export(require(\"./errors\"));\r\n// mocks\r\nconst mocks = __importStar(require(\"./mocks\"));\r\nexports.mocks = mocks;\r\n// performance\r\nvar PerformanceEventIds_1 = require(\"./performance/PerformanceEventIds\");\r\nexports.PerformanceEventIds = PerformanceEventIds_1.PerformanceEventIds;\r\nvar PerformanceGroupIds_1 = require(\"./performance/PerformanceGroupIds\");\r\nexports.PerformanceGroupIds = PerformanceGroupIds_1.PerformanceGroupIds;\r\n// constants\r\nvar constants_1 = require(\"./constants\");\r\nexports.VSCODE_SERVER_PORT_NAME = constants_1.VSCODE_SERVER_PORT_NAME;\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar TConnectionTypes;\r\n(function (TConnectionTypes) {\r\n    TConnectionTypes[\"MainThread\"] = \"MainThread\";\r\n    TConnectionTypes[\"ServiceWorker\"] = \"ServiceWorker\";\r\n    TConnectionTypes[\"WorkspaceHub\"] = \"WorkspaceHub\";\r\n})(TConnectionTypes = exports.TConnectionTypes || (exports.TConnectionTypes = {}));\r\n//# sourceMappingURL=TConnectionTypes.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.vscodeServerHostRPCService = {\r\n    name: 'IVSCodeServerHostService',\r\n    methods: [\r\n        'startRemoteServer',\r\n        'exportLogs',\r\n        'shutDownRemoteServer',\r\n        'getVMTerminalFilePath',\r\n        'getContainerTerminalFilePath',\r\n        'getStateFolderPath',\r\n        'getSharedFolderPath',\r\n        'getCodespaceStateFilePath',\r\n        'getDevcontainerStateFilePath',\r\n        'getSharedFile',\r\n        'getContainerPersistedFolderPath',\r\n        'isRecoveryContainer',\r\n        'terminateOryxTask',\r\n        'downloadVsCodeServerByCommitId',\r\n        'getPerformanceData',\r\n        'getCreationLogStatus',\r\n    ],\r\n    events: [\r\n        'configurationFinished',\r\n        'devContainerConfigChanged',\r\n        'codespaceStopping',\r\n        'codespaceAvailable',\r\n        'creationLogUpdated',\r\n    ],\r\n};\r\n//# sourceMappingURL=VSCodeServerHostRPCService.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscs_utils_1 = require(\"@vs/vscs-utils\");\r\nconst vscs_utils_2 = require(\"@vs/vscs-utils\");\r\nconst Connection_1 = require(\"../../connection/Connection\");\r\nconst ConnectionError_1 = require(\"../../errors/ConnectionError\");\r\n// import { IConnectionMockOptions } from '../interfaces/IConnectionMockOptions';\r\n/**\r\n * `ConnectionMock` is a `Connection` class for the tests.\r\n * Exposes some `protected` properties and adds few mock methods.\r\n */\r\nclass ConnectionMock extends Connection_1.Connection {\r\n    constructor() {\r\n        super(...arguments);\r\n        /**\r\n         * Expose `onConnectionChangedEventEmitter` for tests.\r\n         */\r\n        this.onConnectionChangedEventEmitterMock = this.onConnectionChangedEventEmitter;\r\n    }\r\n    /**\r\n     * Get connection `id` from the connection `options`.\r\n     */\r\n    getId(options) {\r\n        const { id, someProp, numericProp } = options;\r\n        return `${id}_${someProp}_${numericProp}`;\r\n    }\r\n    /**\r\n     * Expose `onConnectionChangedHandler` for tests.\r\n     */\r\n    onConnectionChangedHandlerMock(connectionStatus, error) {\r\n        return this.onConnectionChangedHandler(connectionStatus, error);\r\n    }\r\n    /**\r\n     * Expose `connectionSignal` for tests.\r\n     */\r\n    get connectionSignalMock() {\r\n        return this.connectionSignal;\r\n    }\r\n    /**\r\n     * Finish the connection, error presence defines the connection result.\r\n     */\r\n    finish(error) {\r\n        vscs_utils_1.assertDefined(this.connectionSignal, 'No `Connection Signal` found.');\r\n        if (error) {\r\n            this.connectionSignal.reject(error);\r\n            return this;\r\n        }\r\n        this.connectionSignal.resolve(this);\r\n        return this;\r\n    }\r\n    /**\r\n     * Finish the connection with optional `delay`. Error presence defines\r\n     * the connection result. If `delay` is not set, the connection is\r\n     * finished immediatelly.\r\n     */\r\n    finishWithDelay(error, delay = 0) {\r\n        if (!delay) {\r\n            return this.finish(error);\r\n        }\r\n        vscs_utils_2.defer(() => {\r\n            this.finish(error);\r\n        }, delay);\r\n        return this;\r\n    }\r\n    /**\r\n     * Mock implementation of the `Connection` waits on the connection\r\n     * signal and sets the `status` to connected, if no error thrown.\r\n     */\r\n    async createConnection() {\r\n        this.initializeConnection();\r\n        vscs_utils_1.assertDefined(this.connectionSignal, new ConnectionError_1.ConnectionError('No `connectionSignal` found.'));\r\n        await this.connectionSignal.promise;\r\n        this.onConnectionChangedHandler('connected');\r\n        return this;\r\n    }\r\n    /**\r\n     * Expose the `initializeConnection` for tests.\r\n     */\r\n    initializeConnectionMock() {\r\n        return this.initializeConnection();\r\n    }\r\n    /**\r\n     * Expose the `performance` for tests.\r\n     */\r\n    get performanceMock() {\r\n        return this.performance;\r\n    }\r\n}\r\nexports.ConnectionMock = ConnectionMock;\r\n//# sourceMappingURL=ConnectionMock.js.map","\"use strict\";\r\n// import { Performance } from '@vs/vscs-performance';\r\n// import { Signal } from '@vs/vscs-utils';\r\n// import { Emitter } from 'vscode-jsonrpc';\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode_jsonrpc_1 = require(\"vscode-jsonrpc\");\r\nconst ConnectionMock_1 = require(\"./ConnectionMock\");\r\n// interface IVSCodeConnectionMock extends TType {}\r\nclass VSCodeConnectionMock extends ConnectionMock_1.ConnectionMock {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.onVSCodeServerStarted = new vscode_jsonrpc_1.Emitter().event;\r\n    }\r\n    startForwardingPortWithVisibility(port, isPublic) {\r\n        return Promise.resolve({});\r\n    }\r\n    get workspaceClient() {\r\n        return {};\r\n    }\r\n    get liveshareConnection() {\r\n        return {};\r\n    }\r\n    get vscodeServerHostClient() {\r\n        return {};\r\n    }\r\n    sendHandshakeRequest(requestStr) {\r\n        return {};\r\n    }\r\n    openChannel(performance) {\r\n        return Promise.resolve(null);\r\n    }\r\n    startForwardingPort(port) {\r\n        return Promise.resolve({});\r\n    }\r\n    stopForwardingPort(port) {\r\n        return Promise.resolve(this);\r\n    }\r\n    updateForwardedPortVisibility(port, isPublic) {\r\n        return Promise.resolve(this);\r\n    }\r\n    updateForwardedPortProtocol(port, isHttps) {\r\n        return Promise.resolve(this);\r\n    }\r\n    updateForwardedPortPrivacy(port, privacy) {\r\n        return Promise.resolve(this);\r\n    }\r\n    get serverSharingService() {\r\n        return {};\r\n    }\r\n    get sharedServer() {\r\n        return {};\r\n    }\r\n    get remotePort() {\r\n        return 0;\r\n    }\r\n    getSharedServers() {\r\n        throw new Error('Method not implemented.');\r\n    }\r\n    getRpcService(rpcServiceContract) {\r\n        throw new Error('Method not implemented.');\r\n    }\r\n}\r\nexports.VSCodeConnectionMock = VSCodeConnectionMock;\r\n//# sourceMappingURL=VSCodeConnectionMock.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscs_utils_1 = require(\"@vs/vscs-utils\");\r\nconst ConnectionHub_1 = require(\"../../connectionHub/ConnectionHub\");\r\nclass ConnectionHubMock extends ConnectionHub_1.ConnectionHub {\r\n    constructor() {\r\n        super(...arguments);\r\n        /**\r\n         * Mock the failure for the `this.createConnection` method.\r\n         */\r\n        this.mockCreateConnectionFail = (error, delay = 1) => {\r\n            this.createConnection = async () => {\r\n                await vscs_utils_1.wait(delay);\r\n                throw error;\r\n            };\r\n        };\r\n    }\r\n    /**\r\n     * Expose the method to calculate the connection id.\r\n     */\r\n    getConnectionIdMock(options) {\r\n        return this.getConnectionId(options);\r\n    }\r\n    /**\r\n     * Get `ConnectionMock` instantse by `ConnectionMockOptions`.\r\n     */\r\n    getConnectionMock(options) {\r\n        const id = this.getConnectionId(options);\r\n        const record = this.connections[id];\r\n        return record ? record.connection : undefined;\r\n    }\r\n    /**\r\n     * Get `ConnectionMock` record instantse by `ConnectionMockOptions`.\r\n     */\r\n    getConnectionRecordMock(options) {\r\n        const id = this.getConnectionId(options);\r\n        const record = this.connections[id];\r\n        return record;\r\n    }\r\n}\r\nexports.ConnectionHubMock = ConnectionHubMock;\r\n//# sourceMappingURL=ConnectionHubMock.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscs_performance_1 = require(\"@vs/vscs-performance\");\r\nconst vso_logging_1 = require(\"@vs/vso-logging\");\r\nconst ConnectionMock_1 = require(\"../connection/ConnectionMock\");\r\n// import { IConnectionMock } from '../connectionHub/IConnectionMock';\r\n// import { IConnectionMockOptions } from '../interfaces/IConnectionMockOptions';\r\nexports.testTrace = new vso_logging_1.TraceSource('test-trace');\r\nexports.performance = vscs_performance_1.initializePerformanceInstance('test:start');\r\n/**\r\n * Mock helper to generate default `ConnectionHubMock` options.\r\n * Pass real trace if you want to see logs in the console.\r\n */\r\nexports.getConnectionHubMockOptions = (options = {}) => {\r\n    const { trace = exports.testTrace, childHubs } = options;\r\n    return [\r\n        trace,\r\n        exports.performance,\r\n        ConnectionMock_1.ConnectionMock,\r\n        childHubs,\r\n    ];\r\n};\r\n//# sourceMappingURL=getConnectionHubMockOptions.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscs_performance_1 = require(\"@vs/vscs-performance\");\r\nconst vscs_utils_1 = require(\"@vs/vscs-utils\");\r\nconst vso_logging_1 = require(\"@vs/vso-logging\");\r\n// import { mocks } from '../../../src';\r\nexports.PerformanceMock = vscs_performance_1.mocks.PerformanceMock;\r\n/**\r\n * Mock helper to a random `IConnectionMockOptions`.\r\n */\r\nexports.getRandomConnectionMockOptions = () => {\r\n    return {\r\n        id: vscs_utils_1.randomString(),\r\n        someProp: vscs_utils_1.randomString(),\r\n        numericProp: vscs_utils_1.randomInt(100),\r\n    };\r\n};\r\nexports.testTrace = new vso_logging_1.TraceSource('test-trace');\r\nconst performance = new exports.PerformanceMock('test-performance', 'test-start');\r\n/**\r\n * Mock helper to generate default `ConnectionMock` options.\r\n * Pass real trace if you want to see logs in the console.\r\n */\r\nexports.getConnectionMockOptions = (options = {}) => {\r\n    const { trace = exports.testTrace } = options;\r\n    return [\r\n        trace,\r\n        performance,\r\n        Object.assign({}, exports.getRandomConnectionMockOptions()),\r\n    ];\r\n};\r\n//# sourceMappingURL=getConnectionMockOptions.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vso_logging_1 = require(\"@vs/vso-logging\");\r\nconst vscs_utils_1 = require(\"@vs/vscs-utils\");\r\nconst getConnectionMockOptions_1 = require(\"./getConnectionMockOptions\");\r\nexports.testTrace = new vso_logging_1.TraceSource(vscs_utils_1.randomString());\r\nexports.getRandomLiveShareMockOptions = () => {\r\n    const connectionInfo = {\r\n        id: 'mock-connection-id',\r\n        relayLink: 'sb://test-namespace.servicebus.windows.net/anyEndpointId',\r\n        relaySas: 'mock-relay',\r\n        hostPublicKeys: ['mock-host-public-key'],\r\n        sessionToken: 'mock-session-token',\r\n    };\r\n    return {\r\n        liveShareEndpoint: 'mock-liveshare-endpoint',\r\n        workspaceId: 'mock-id',\r\n        connectionInfo,\r\n        token: 'mock-token',\r\n        id: 'mock-id',\r\n        someProp: 'mock-prop',\r\n        numericProp: 12345,\r\n    };\r\n};\r\n/**\r\n * Mock helper to generate default `LiveShareConnectionMock` options.\r\n * Pass real trace if you want to see logs in the console.\r\n */\r\nexports.getLiveShareConnectionMockOptions = (options = {}) => {\r\n    const { trace = exports.testTrace } = options;\r\n    const performance = new getConnectionMockOptions_1.PerformanceMock('test-performance', 'test-start', 'test-path-string');\r\n    return [trace, performance, Object.assign({}, exports.getRandomLiveShareMockOptions())];\r\n};\r\n//# sourceMappingURL=getLiveShareConnectionMockOptionsTestHelper.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar getConnectionHubMockOptions_1 = require(\"./getConnectionHubMockOptions\");\r\nexports.getConnectionHubMockOptions = getConnectionHubMockOptions_1.getConnectionHubMockOptions;\r\nvar getConnectionMockOptions_1 = require(\"./getConnectionMockOptions\");\r\nexports.getConnectionMockOptions = getConnectionMockOptions_1.getConnectionMockOptions;\r\nvar getLiveShareConnectionMockOptionsTestHelper_1 = require(\"./getLiveShareConnectionMockOptionsTestHelper\");\r\nexports.getLiveShareConnectionMockOptions = getLiveShareConnectionMockOptionsTestHelper_1.getLiveShareConnectionMockOptions;\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// class mocks\r\nvar VSCodeConnectionMock_1 = require(\"./connection/VSCodeConnectionMock\");\r\nexports.VSCodeConnectionMock = VSCodeConnectionMock_1.VSCodeConnectionMock;\r\nvar ConnectionHubMock_1 = require(\"./connectionHub/ConnectionHubMock\");\r\nexports.ConnectionHubMock = ConnectionHubMock_1.ConnectionHubMock;\r\nvar ConnectionMock_1 = require(\"./connection/ConnectionMock\");\r\nexports.ConnectionMock = ConnectionMock_1.ConnectionMock;\r\n// helpers\r\n__export(require(\"./helpers\"));\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar PerformanceEventIds;\r\n(function (PerformanceEventIds) {\r\n    /**\r\n     * Join a liveshare workspace\r\n     */\r\n    PerformanceEventIds[\"LiveshareJoinWorkspace\"] = \"LiveshareJoinWorkspace\";\r\n    /**\r\n     * Start vscode server inside the codespace.\r\n     */\r\n    PerformanceEventIds[\"VSCodeServerStartupServerStart\"] = \"VSCodeServerStartupServerStart\";\r\n    /**\r\n     * Forward vscode server TCP port inside the codespace.\r\n     */\r\n    PerformanceEventIds[\"VSCodeServerStartupServerTcpPortForwarding\"] = \"VSCodeServerStartupServerTCPPortForwarding\";\r\n})(PerformanceEventIds = exports.PerformanceEventIds || (exports.PerformanceEventIds = {}));\r\n//# sourceMappingURL=PerformanceEventIds.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar PerformanceGroupIds;\r\n(function (PerformanceGroupIds) {\r\n    /**\r\n     * The time to start vscode server on the remote side:\r\n     *\r\n     *  - including the RPC message travel time\r\n     *  - including downloading vscode server, if needed\r\n     *  - including installing extensions, if needed\r\n     *  - including sharing vscode server port\r\n     */\r\n    PerformanceGroupIds[\"VSCodeServerStartup\"] = \"VSCodeServerStartup\";\r\n})(PerformanceGroupIds = exports.PerformanceGroupIds || (exports.PerformanceGroupIds = {}));\r\n//# sourceMappingURL=PerformanceGroupIds.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscs_utils_1 = require(\"@vs/vscs-utils\");\r\nconst ConnectionCancellationError_1 = require(\"../errors/ConnectionCancellationError\");\r\nconst ConnectionError_1 = require(\"../errors/ConnectionError\");\r\n/**\r\n * Map an error to `ConnectionError` instance, all errors thrown by this\r\n * library or any of the child libraries should extend the `ConnectionError`.\r\n */\r\nexports.errorToConnectionError = (e) => {\r\n    /**\r\n     * `ConnectionError` is not wrapped.\r\n     */\r\n    if (e instanceof ConnectionError_1.ConnectionError) {\r\n        return e;\r\n    }\r\n    /**\r\n     * `CancellationError` is wrapped with `ConnectionCancellationError`.\r\n     */\r\n    if (e instanceof vscs_utils_1.CancellationError) {\r\n        return new ConnectionCancellationError_1.ConnectionCancellationError(e);\r\n    }\r\n    /**\r\n     * `generic error` is wrapped with `ConnectionError` base class.\r\n     */\r\n    return new ConnectionError_1.ConnectionError(e);\r\n};\r\n//# sourceMappingURL=errorToConnectionError.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Function to find a specific source port in shared servers list.\r\n */\r\n// TODO legomushroom - test this\r\nexports.findSourcePort = (servers, port, targetSessionName) => {\r\n    return servers.find((server) => {\r\n        const { sourcePort, sessionName } = server;\r\n        const isPortMatch = sourcePort === port;\r\n        if (!targetSessionName) {\r\n            return isPortMatch;\r\n        }\r\n        return isPortMatch && sessionName === targetSessionName;\r\n    });\r\n};\r\n//# sourceMappingURL=findSourcePort.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst constants_1 = require(\"../constants\");\r\n/**\r\n * Function to construct vscode server session name.\r\n */\r\nexports.getVSCodeServerSessionName = (clientId) => {\r\n    if (!clientId) {\r\n        return constants_1.VSCODE_SERVER_PORT_NAME;\r\n    }\r\n    return `${constants_1.VSCODE_SERVER_PORT_NAME}_${clientId}`;\r\n};\r\n//# sourceMappingURL=getVSCodeServerSessionName.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst constants_1 = require(\"../constants\");\r\n/**\r\n * Function to check of forwarded port session belongs to vscode server.\r\n */\r\nexports.isVSCodeServerSession = (sessionName) => {\r\n    return sessionName.startsWith(constants_1.VSCODE_SERVER_PORT_NAME);\r\n};\r\n//# sourceMappingURL=isVSCodeServerSession.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ConnectedState;\r\n(function (ConnectedState) {\r\n    ConnectedState[ConnectedState[\"Reconnecting\"] = 1] = \"Reconnecting\";\r\n    ConnectedState[ConnectedState[\"Reconnected\"] = 2] = \"Reconnected\";\r\n    ConnectedState[ConnectedState[\"Closed\"] = 3] = \"Closed\";\r\n})(ConnectedState = exports.ConnectedState || (exports.ConnectedState = {}));\r\n//# sourceMappingURL=ConnectedState.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Error when a workspace has no host connected, hence no join could happen.\r\n */\r\nclass NoHostConnectedError extends Error {\r\n    constructor(workspaceId) {\r\n        super(`Host not connected to workspace:${workspaceId}`);\r\n        this.workspaceId = workspaceId;\r\n    }\r\n}\r\nexports.NoHostConnectedError = NoHostConnectedError;\r\n/**\r\n * Type of relay connection error types.\r\n */\r\nvar RelayErrorType;\r\n(function (RelayErrorType) {\r\n    RelayErrorType[RelayErrorType[\"ConnectionError\"] = 1] = \"ConnectionError\";\r\n    RelayErrorType[RelayErrorType[\"SasInvalid\"] = 2] = \"SasInvalid\";\r\n    RelayErrorType[RelayErrorType[\"EndpointNotFound\"] = 3] = \"EndpointNotFound\";\r\n    RelayErrorType[RelayErrorType[\"ListenerOffline\"] = 4] = \"ListenerOffline\";\r\n    RelayErrorType[RelayErrorType[\"ServerError\"] = 5] = \"ServerError\";\r\n})(RelayErrorType = exports.RelayErrorType || (exports.RelayErrorType = {}));\r\n/**\r\n * Error used when a connection to an Azure relay failed.\r\n */\r\nclass RelayConnectionError extends Error {\r\n    constructor(message, errorContext) {\r\n        super(message);\r\n        this.errorContext = errorContext;\r\n    }\r\n}\r\nexports.RelayConnectionError = RelayConnectionError;\r\n//# sourceMappingURL=Errors.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass LatencyMetrics {\r\n    constructor(latencyCurrent, latencyAvg, latencyMin, latencyMax) {\r\n        this.current = latencyCurrent;\r\n        this.average = latencyAvg;\r\n        this.min = latencyMin;\r\n        this.max = latencyMax;\r\n    }\r\n}\r\nexports.LatencyMetrics = LatencyMetrics;\r\n//# sourceMappingURL=IWorkspaceConnection.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Workspace connection mode. Must match vsls.ConnectionMode\r\n */\r\nvar ConnectionMode;\r\n(function (ConnectionMode) {\r\n    ConnectionMode[\"Auto\"] = \"auto\";\r\n    ConnectionMode[\"Direct\"] = \"direct\";\r\n    ConnectionMode[\"Relay\"] = \"relay\";\r\n    ConnectionMode[\"Local\"] = \"local\";\r\n    ConnectionMode[\"SignalR\"] = \"signalR\";\r\n})(ConnectionMode = exports.ConnectionMode || (exports.ConnectionMode = {}));\r\n//# sourceMappingURL=IWorkspaceSessionInfo.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RPC_ERR_NO_HOST_NOT_CONNECTED = 270;\r\nexports.RPC_ERR_RELAY_CONNECTIONY_SSH = 271;\r\n//# sourceMappingURL=RpcErrorCodes.js.map","\"use strict\";\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vso_logging_1 = require(\"@vs/vso-logging\");\r\nconst vso_http_client_1 = require(\"@vs/vso-http-client\");\r\nconst vscs_utils_1 = require(\"@vs/vscs-utils\");\r\nconst ssh = __importStar(require(\"@vs/vs-ssh\"));\r\nconst vsls_contracts_1 = require(\"@vs/vsls-contracts\");\r\nclass WorkspaceApi {\r\n    constructor(serviceUri, tokenProvider, logger) {\r\n        this.serviceUri = serviceUri;\r\n        this.tokenProvider = tokenProvider;\r\n        this.logger = logger;\r\n        this.getRequestHeaders = () => {\r\n            return {\r\n                Authorization: `Bearer ${this.tokenProvider()}`,\r\n                'Cache-Control': 'no-cache',\r\n                'Content-Type': 'application/json',\r\n            };\r\n        };\r\n        vscs_utils_1.assertDefined(serviceUri, 'service uri needs to be defined');\r\n        let baseUri = serviceUri;\r\n        if (!baseUri.endsWith('/')) {\r\n            baseUri = baseUri + '/';\r\n        }\r\n        if (!baseUri.includes('api/v1.2')) {\r\n            baseUri = baseUri + 'api/v1.2';\r\n        }\r\n        // We need to remove the trailing slash in the case it was directly\r\n        // taken from an environment record\r\n        this.baseUri = this.removeTrailingSlash(baseUri);\r\n        this.httpClient = new vso_http_client_1.HttpClient(logger);\r\n    }\r\n    static async getWorkspaceSessionInfo(workspaceId, options, logger) {\r\n        logger.info(`getWorkspaceSessionInfo -> workspaceId:${workspaceId}`);\r\n        const workspaceApi = new WorkspaceApi(options.liveShareEndpoint, () => options.token, logger);\r\n        const [workspaceAccess, workspaceInfo] = await Promise.all([\r\n            workspaceApi.getWorkspaceAccess(workspaceId),\r\n            workspaceApi.getWorkspaceInfo(workspaceId),\r\n        ]);\r\n        const workspaceSessionInfo = Object.assign(Object.assign({}, workspaceAccess), workspaceInfo);\r\n        vscs_utils_1.assertDefined(workspaceInfo, 'Cannot get LiveShare workspace info.');\r\n        vscs_utils_1.assertDefined(workspaceAccess, 'Cannot get LiveShare workspace access.');\r\n        vscs_utils_1.assertDefined(workspaceInfo.relaySas, 'No RelaySas token found.');\r\n        return workspaceSessionInfo;\r\n    }\r\n    async deleteWorkspace(workspaceId) {\r\n        vscs_utils_1.assertDefined(workspaceId, 'Cannot get Live Share workspaceId');\r\n        workspaceId = workspaceId.toUpperCase();\r\n        const url = `${this.baseUri}/workspace/${workspaceId}`;\r\n        this.logger.log(vso_logging_1.LogLevel.Debug, `delete workspace -> ${url}`);\r\n        await this.httpClient.delete(url, {\r\n            headers: this.getRequestHeaders(),\r\n        });\r\n    }\r\n    async getWorkspaceInfo(workspaceId) {\r\n        vscs_utils_1.assertDefined(workspaceId, 'Cannot get Live Share workspaceId');\r\n        workspaceId = workspaceId.toUpperCase();\r\n        const url = `${this.baseUri}/workspace/${workspaceId}`;\r\n        this.logger.log(vso_logging_1.LogLevel.Debug, `get workspace info -> ${url}`);\r\n        return await this.httpClient\r\n            .get(url, {\r\n            headers: this.getRequestHeaders(),\r\n        })\r\n            .value();\r\n    }\r\n    async getWorkspaceAccess(workspaceId) {\r\n        vscs_utils_1.assertDefined(workspaceId, 'Cannot get Live Share workspaceId');\r\n        workspaceId = workspaceId.toUpperCase();\r\n        const url = `${this.baseUri}/workspace/${workspaceId}/user`;\r\n        this.logger.log(vso_logging_1.LogLevel.Debug, `get workspace access -> ${url}`);\r\n        return await this.httpClient\r\n            .put(url, {\r\n            headers: this.getRequestHeaders(),\r\n        })\r\n            .value();\r\n    }\r\n    async postWorkspaceInfo(workspaceInfo) {\r\n        const url = `${this.baseUri}/workspace`;\r\n        this.logger.log(vso_logging_1.LogLevel.Debug, `post workspace info -> ${url}`);\r\n        return await this.httpClient\r\n            .post(url, {\r\n            headers: this.getRequestHeaders(),\r\n            body: JSON.stringify(workspaceInfo),\r\n        })\r\n            .value();\r\n    }\r\n    async createInvitationLink(invitationLinkInfo) {\r\n        const url = `${this.baseUri}/workspace/${invitationLinkInfo.workspaceId}/link`;\r\n        const response = await this.httpClient\r\n            .put(url, {\r\n            headers: this.getRequestHeaders(),\r\n            body: JSON.stringify(invitationLinkInfo),\r\n        })\r\n            .value();\r\n        return response;\r\n    }\r\n    async getWorkspaceUserProfile(workspaceId, userToken) {\r\n        var _a;\r\n        vscs_utils_1.assertDefined(workspaceId, 'Cannot get Live Share workspaceId');\r\n        workspaceId = workspaceId.toUpperCase();\r\n        const url = `${this.baseUri}/workspace/${workspaceId}/user`;\r\n        this.logger.log(vso_logging_1.LogLevel.Debug, `get workspace user profile -> ${url}`);\r\n        const workspaceUserProfile = await this.httpClient\r\n            .get(url, {\r\n            headers: Object.assign(Object.assign({}, this.getRequestHeaders()), { 'User-Session-Token': userToken }),\r\n        })\r\n            .value();\r\n        // The collaboration service's WorkspaceGetProfileResponse returns 'username'\r\n        // vsls.WorkspaceUserProfile property has a different casing 'userName'\r\n        if ((_a = workspaceUserProfile) === null || _a === void 0 ? void 0 : _a.username) {\r\n            workspaceUserProfile.userName = workspaceUserProfile.username;\r\n        }\r\n        return workspaceUserProfile;\r\n    }\r\n    static async createSshKeys() {\r\n        const rsa = ssh.SshAlgorithms.publicKey.rsaWithSha512;\r\n        const hostPrivateKey = await rsa.generateKeyPair();\r\n        const hostPublicKey = (await hostPrivateKey.getPublicKeyBytes(hostPrivateKey.keyAlgorithmName)).toString('base64');\r\n        return [hostPrivateKey, hostPublicKey];\r\n    }\r\n    async createSharedWorkspace(workspaceShareInfo) {\r\n        const sshKeys = await WorkspaceApi.createSshKeys();\r\n        const workspacePayload = {\r\n            name: workspaceShareInfo.name,\r\n            connectionMode: vsls_contracts_1.vsls.ConnectionMode.Relay,\r\n            areAnonymousGuestsAllowed: workspaceShareInfo.areAnonymousGuestsAllowed,\r\n            hostPublicKeys: [sshKeys[1]],\r\n        };\r\n        const workspaceInfo = await this.postWorkspaceInfo(workspacePayload);\r\n        return {\r\n            workspaceInfo,\r\n            hostPrivateKeys: [sshKeys[0]],\r\n            getWorkspaceUserProfile: (userToken) => this.getWorkspaceUserProfile(workspaceInfo.id, userToken),\r\n        };\r\n    }\r\n    removeTrailingSlash(baseUri) {\r\n        return baseUri.endsWith('/') ? baseUri.substr(0, baseUri.length - 1) : baseUri;\r\n    }\r\n}\r\nexports.WorkspaceApi = WorkspaceApi;\r\n//# sourceMappingURL=WorkspaceApi.js.map","\"use strict\";\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst rpc = __importStar(require(\"vscode-jsonrpc\"));\r\nconst vscs_utils_1 = require(\"@vs/vscs-utils\");\r\nconst checkWorkspaceClient_1 = require(\"./checkWorkspaceClient\");\r\nconst vso_rpc_1 = require(\"@vs/vso-rpc\");\r\n/**\r\n * A base class to implement the IWorkspaceClient interface contract.\r\n */\r\nclass WorkspaceClientBase extends vscs_utils_1.DisposableClass {\r\n    constructor(rcpClientInstance, logger) {\r\n        super(logger);\r\n        this.rcpClientInstance = rcpClientInstance;\r\n        this.onHostConnectionChangedEmitter = new rpc.Emitter();\r\n        this.onHostConnectionChanged = this.onHostConnectionChangedEmitter.event;\r\n        this.onWorkspaceMetricsUpdatedEmitter = new rpc.Emitter();\r\n        this.onWorkspaceMetricsUpdated = this.onWorkspaceMetricsUpdatedEmitter.event;\r\n        this.rpcProxyCache = new vso_rpc_1.RpcProxyCache(this.rcpClientInstance, logger);\r\n        this.addToDisposables(vscs_utils_1.createDisposable(() => {\r\n            this.stopCheckConnection('disposed');\r\n        }));\r\n    }\r\n    get rpcClient() {\r\n        return this.rcpClientInstance;\r\n    }\r\n    getServiceProxy(serviceInfo, traceName) {\r\n        return this.rpcProxyCache.getOrCreate(serviceInfo, traceName);\r\n    }\r\n    setCheckConnectionOptions(options) {\r\n        if (options.enabled && this.checkConnectionDisposable === undefined && !this.isDisposed) {\r\n            this.ensureIsJoined();\r\n            this.checkConnectionDisposable = checkWorkspaceClient_1.checkWorkspaceClient(this, this.trace, options.metricsTimeout, options.checkConnectionTimeout, () => this.canCheckConnection());\r\n        }\r\n        else if (!options.enabled) {\r\n            this.stopCheckConnection('connection options');\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n    ensureIsJoined() { }\r\n    canCheckConnection() {\r\n        return true;\r\n    }\r\n    stopCheckConnection(reason) {\r\n        this.trace.info(`stopCheckConnection reason:'${reason}'`);\r\n        if (this.checkConnectionDisposable !== undefined) {\r\n            this.checkConnectionDisposable.dispose();\r\n            this.checkConnectionDisposable = undefined;\r\n        }\r\n    }\r\n}\r\nexports.WorkspaceClientBase = WorkspaceClientBase;\r\n//# sourceMappingURL=WorkspaceClientBase.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.workspaceServiceClient = {\r\n    name: 'workspaceServiceClient',\r\n    methods: [\r\n        'getSessionInfo',\r\n        'join',\r\n        'disconnect',\r\n        'openStreamingChannel',\r\n        'keepAlive',\r\n        'checkConnection',\r\n        'setCheckConnectionOptions',\r\n    ],\r\n    events: ['hostConnectionChanged', 'workspaceMetricsUpdated'],\r\n};\r\n//# sourceMappingURL=WorkspaceServiceClient.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscs_utils_1 = require(\"@vs/vscs-utils\");\r\n// timeout to wait to check to check the health of a connection\r\nconst defaultCheckConnectionTimeout = 10 * vscs_utils_1.TIME_SECOND_MS;\r\n// message to log and throw if timeout is reached\r\nexports.failedtoCheckConnectionMessage = 'failed to check connection';\r\nconst checkConnectionWithTimeoutMessage = 'checkConnectionWithTimeout';\r\n/**\r\n * Check a workspace client by invoking the checkConnection method with a timeout\r\n * @returns false if the connection check failed or timeout.\r\n */\r\nexports.checkConnectionWithTimeout = async (workspaceClient, logger, checkConnectionTimeout, cancellationTokenSource) => {\r\n    const start = Date.now();\r\n    const totalTime = () => {\r\n        return (Date.now() - start).toFixed(1);\r\n    };\r\n    try {\r\n        logger === null || logger === void 0 ? void 0 : logger.verbose(`${checkConnectionWithTimeoutMessage} -> 'started'`);\r\n        await vscs_utils_1.timeoutPromise(workspaceClient.checkConnection(), checkConnectionTimeout !== null && checkConnectionTimeout !== void 0 ? checkConnectionTimeout : defaultCheckConnectionTimeout, undefined, cancellationTokenSource);\r\n        logger === null || logger === void 0 ? void 0 : logger.verbose(`${checkConnectionWithTimeoutMessage} -> 'succeeded' t:${totalTime()}`);\r\n        return true;\r\n    }\r\n    catch (err) {\r\n        if (err instanceof vscs_utils_1.CancellationError) {\r\n            logger === null || logger === void 0 ? void 0 : logger.verbose(`${checkConnectionWithTimeoutMessage} -> 'cancelled' t:${totalTime()}`);\r\n            return true;\r\n        }\r\n        logger === null || logger === void 0 ? void 0 : logger.error(`${checkConnectionWithTimeoutMessage} -> 'failed' t:${totalTime()}`, err);\r\n        return false;\r\n    }\r\n};\r\n//# sourceMappingURL=checkConnectionWithTimeout.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscs_utils_1 = require(\"@vs/vscs-utils\");\r\nconst checkConnectionWithTimeout_1 = require(\"./checkConnectionWithTimeout\");\r\nconst vscode_jsonrpc_1 = require(\"vscode-jsonrpc\");\r\n// timeout to wait on workspace metrics\r\nconst defaultTimeout = 5 * vscs_utils_1.TIME_SECOND_MS;\r\nlet session = 0;\r\n/**\r\n * Check if a liveshare connection is healthy by checking the connection when\r\n * the metrics event is not received in a period of time.\r\n * @returns A disposable instance if we want to stop the health check.\r\n */\r\nfunction checkWorkspaceClient(workspaceClient, logger, metricsTimeout, checkConnectionTimeout, isCheckConnectionEnabled) {\r\n    metricsTimeout = metricsTimeout !== null && metricsTimeout !== void 0 ? metricsTimeout : defaultTimeout;\r\n    logger = logger.createChild(`${++session}`);\r\n    logger.info(`Start checking connection timeout:${metricsTimeout}`);\r\n    let timeoutReference;\r\n    const setTimeoutMetrics = () => {\r\n        timeoutReference = setTimeout(onWorkspaceMetricsTimeout, metricsTimeout);\r\n    };\r\n    const clearTimeoutMetrics = () => {\r\n        clearTimeout(timeoutReference);\r\n    };\r\n    let isChecking = false;\r\n    const cts = new vscode_jsonrpc_1.CancellationTokenSource();\r\n    const isDisposed = () => {\r\n        return cts.token.isCancellationRequested;\r\n    };\r\n    const onWorkspaceMetricsTimeout = async () => {\r\n        if (isDisposed()) {\r\n            return;\r\n        }\r\n        isChecking = true;\r\n        if ((!isCheckConnectionEnabled || isCheckConnectionEnabled()) &&\r\n            !(await checkConnectionWithTimeout_1.checkConnectionWithTimeout(workspaceClient, logger, checkConnectionTimeout, cts))) {\r\n            logger.info(`Failed check -> isDisposed:${isDisposed()}`);\r\n            onMetricsDisposable === null || onMetricsDisposable === void 0 ? void 0 : onMetricsDisposable.dispose();\r\n            if (!isDisposed()) {\r\n                workspaceClient.dispose(checkConnectionWithTimeout_1.failedtoCheckConnectionMessage);\r\n            }\r\n        }\r\n        else {\r\n            setTimeoutMetrics();\r\n        }\r\n        isChecking = false;\r\n    };\r\n    workspaceClient.rpcClient.onDispose(() => {\r\n        clearTimeoutMetrics();\r\n    });\r\n    const onMetricsDisposable = workspaceClient.onWorkspaceMetricsUpdated((e) => {\r\n        clearTimeoutMetrics();\r\n        if (!isChecking) {\r\n            setTimeoutMetrics();\r\n        }\r\n    });\r\n    // kick first metrics timeout\r\n    setTimeoutMetrics();\r\n    return {\r\n        dispose: () => {\r\n            logger.info(`Stop checking connection`);\r\n            cts.cancel();\r\n            onMetricsDisposable === null || onMetricsDisposable === void 0 ? void 0 : onMetricsDisposable.dispose();\r\n        },\r\n    };\r\n}\r\nexports.checkWorkspaceClient = checkWorkspaceClient;\r\n//# sourceMappingURL=checkWorkspaceClient.js.map","\"use strict\";\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ConnectedState_1 = require(\"./ConnectedState\");\r\nexports.ConnectedState = ConnectedState_1.ConnectedState;\r\n__export(require(\"./IWorkspaceSessionInfo\"));\r\n__export(require(\"./IWorkspaceConnection\"));\r\nvar WorkspaceApi_1 = require(\"./WorkspaceApi\");\r\nexports.WorkspaceApi = WorkspaceApi_1.WorkspaceApi;\r\n__export(require(\"./WorkspaceServiceClient\"));\r\n__export(require(\"./Errors\"));\r\n__export(require(\"./RpcErrorCodes\"));\r\n__export(require(\"./telemetryStrings\"));\r\n__export(require(\"./checkConnectionWithTimeout\"));\r\n__export(require(\"./checkWorkspaceClient\"));\r\nvar WorkspaceClientBase_1 = require(\"./WorkspaceClientBase\");\r\nexports.WorkspaceClientBase = WorkspaceClientBase_1.WorkspaceClientBase;\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass TelemetryEventNames {\r\n}\r\nexports.TelemetryEventNames = TelemetryEventNames;\r\nTelemetryEventNames.WORKSPACE_RECONNECT = 'workspace-reconnect';\r\nclass TelemetryPropertyNames {\r\n}\r\nexports.TelemetryPropertyNames = TelemetryPropertyNames;\r\nTelemetryPropertyNames.RECONNECT_SUCCEEDED = 'reconnect-succeeded';\r\nTelemetryPropertyNames.RECONNECT_ELAPSED = 'reconnect-elapsed';\r\nTelemetryPropertyNames.RECONNECT_RETRY_COUNT = 'reconnect-retry-count';\r\nTelemetryPropertyNames.RECONNECT_ERROR_MESSAGE = 'reconnect-error-message';\r\nTelemetryPropertyNames.RECONNECT_ERROR_REASON = 'reconnect-error-reason';\r\n//# sourceMappingURL=telemetryStrings.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vso_logging_1 = require(\"@vs/vso-logging\");\r\nconst vso_telemetry_1 = require(\"@vs/vso-telemetry\");\r\nconst vso_node_telemetry_reporter_1 = require(\"@vs/vso-node-telemetry-reporter\");\r\nconst vso_node_server_1 = require(\"@vs/vso-node-server\");\r\nconst vscs_utils_1 = require(\"@vs/vscs-utils\");\r\nconst logUtils_1 = require(\"./logUtils\");\r\nfunction getServerArgOptions() {\r\n    return logUtils_1.getLoggingArgOptions()\r\n        .option('telemetryOptions', {\r\n        description: 'telemetry options',\r\n        type: 'string',\r\n    })\r\n        .option('port', {\r\n        description: 'port number',\r\n        type: 'number',\r\n    })\r\n        .option('pipe', {\r\n        description: 'pipe name',\r\n        type: 'string',\r\n    })\r\n        .option('autoExit', {\r\n        description: 'If auto exit is enabled',\r\n        type: 'boolean',\r\n    })\r\n        .option('disableObfuscation', {\r\n        description: 'If disable obfuscation is enabled',\r\n        type: 'boolean',\r\n    })\r\n        .option('keepAliveTime', {\r\n        description: 'keep alive timeout',\r\n        type: 'number',\r\n    })\r\n        .option('noVerbose', {\r\n        description: 'If verbose is disabled',\r\n        type: 'boolean',\r\n    })\r\n        .option('noLogConsole', {\r\n        description: 'If log file is disabled',\r\n        type: 'boolean',\r\n    })\r\n        .option('noLogFile', {\r\n        description: 'If log file is disabled',\r\n        type: 'boolean',\r\n    })\r\n        .option('logFile', {\r\n        description: 'the log file name',\r\n        type: 'string',\r\n    })\r\n        .option('maxRetries', {\r\n        description: 'number of attempt on listening to a port',\r\n        type: 'number',\r\n    })\r\n        .option('maxLogSize', {\r\n        description: 'max number of logs to keep in memory',\r\n        type: 'number',\r\n    })\r\n        .option('isRawPipe', {\r\n        description: 'If the pipe name should be processed',\r\n        type: 'boolean',\r\n    })\r\n        .help()\r\n        .alias('help', 'h');\r\n}\r\nexports.getServerArgOptions = getServerArgOptions;\r\nasync function startServer(options, socketServerFactory) {\r\n    const keepAliveTime = options.keepAliveTime || 10000;\r\n    if (!(options.port || options.pipe)) {\r\n        console.log('You need to specify a port or a pipe name');\r\n        process.exit(1);\r\n    }\r\n    const listeners = [];\r\n    const traceSource = await logUtils_1.initLogging(options, listeners);\r\n    // init telemetry\r\n    let telemetryOptions;\r\n    if (typeof options.telemetryOptions === 'string' || options.telemetryOptions instanceof String) {\r\n        telemetryOptions = JSON.parse(Buffer.from(String(options.telemetryOptions), 'base64').toString('utf-8'));\r\n    }\r\n    else if (options.telemetryOptions) {\r\n        telemetryOptions = options.telemetryOptions;\r\n    }\r\n    if (telemetryOptions) {\r\n        traceSource.info(`initialize telemetry with options: ${JSON.stringify(telemetryOptions)}`);\r\n        vso_telemetry_1.Telemetry.init(new vso_node_telemetry_reporter_1.TelemetryReporter(telemetryOptions.key, telemetryOptions.reporterConfiguration, undefined, traceSource.withName('telemetryReporter')), telemetryOptions.featureName, telemetryOptions.canSendSensistiveInformation);\r\n    }\r\n    else {\r\n        vso_telemetry_1.Telemetry.init({\r\n            sendTelemetryEvent: (eventName, properties, measurements) => void {},\r\n            sendTelemetryErrorEvent: (eventName, properties, measurements, errorProps) => void {},\r\n            dispose: () => {\r\n                return Promise.resolve();\r\n            },\r\n        }, `${options.name}.`);\r\n    }\r\n    const serverStopped = (reason) => process.exit((reason === null || reason === void 0 ? void 0 : reason.code) === 'EADDRINUSE' ? 10 :\r\n        typeof reason === 'number' ? reason :\r\n            0);\r\n    const serverHost = {\r\n        keepAliveTriggered: () => traceSource.info(`keep alive triggered...`),\r\n        serverStopped,\r\n    };\r\n    const memoryTraceListener = listeners.find(l => l instanceof vso_logging_1.MemoryTraceListener);\r\n    const getLogs = (logLevel) => memoryTraceListener.getLogs(logLevel);\r\n    var server;\r\n    try {\r\n        server = await vso_node_server_1.startSocketServer(Object.assign(Object.assign({}, options), { traceSource,\r\n            keepAliveTime,\r\n            getLogs,\r\n            socketServerFactory,\r\n            serverHost }));\r\n    }\r\n    catch (e) {\r\n        traceSource.writeLine(`Exception err:${e} stack:${e === null || e === void 0 ? void 0 : e.stack}`);\r\n        serverStopped(e);\r\n    }\r\n    traceSource.info(`starting server -> platform:${process.platform} exe:${process.execPath} version:${process.version} pid:${process.pid} auto exit:${options.autoExit ? 1 : 0} keepAliveTime:${keepAliveTime}`);\r\n    process.on('exit', (code) => {\r\n        traceSource.writeLine(`Server process exit event with code: ${code}`);\r\n    });\r\n    // warning message from node engine\r\n    process.on('warning', (warning) => {\r\n        traceSource.writeLine(`Node warning:${warning}`);\r\n    });\r\n    // catch undhandled rejections. \r\n    process.on('unhandledRejection', (reason, promise) => {\r\n        traceSource.writeLine(`Unhandled Rejection reason -> ${vscs_utils_1.propertiesToString(reason)}`);\r\n    });\r\n    // catch undhandled exceptions. \r\n    process.on('uncaughtException', function (err) {\r\n        traceSource.writeLine(`Uncaught exception err:${err} stack:${err === null || err === void 0 ? void 0 : err.stack}`);\r\n        server.stop(99);\r\n    });\r\n    // catch NodeJS.Signals events and exit normally\r\n    const signalCodes = {\r\n        'SIGINT': 100,\r\n        'SIGUSR1': 101,\r\n        'SIGUSR2': 102,\r\n        'SIGTERM': 103,\r\n    };\r\n    Object.keys(signalCodes).forEach((eventType) => {\r\n        process.on(eventType, function () {\r\n            traceSource.writeLine(`Signal received eventType:${eventType}`);\r\n            server.stop(signalCodes[eventType]);\r\n        });\r\n    });\r\n    return traceSource;\r\n}\r\nexports.startServer = startServer;\r\n//# sourceMappingURL=hubUtils.js.map","\"use strict\";\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__export(require(\"./hubUtils\"));\r\n__export(require(\"./logUtils\"));\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst os = __importStar(require(\"os\"));\r\nconst fs = __importStar(require(\"fs\"));\r\nconst path = __importStar(require(\"path\"));\r\nconst util = __importStar(require(\"util\"));\r\nconst yargs = __importStar(require(\"yargs\"));\r\nconst vso_logging_1 = require(\"@vs/vso-logging\");\r\nconst vso_logging_node_1 = require(\"@vs/vso-logging-node\");\r\nconst openAsync = util.promisify(fs.open);\r\nfunction getLoggingArgOptions() {\r\n    return yargs\r\n        .option('disableObfuscation', {\r\n        description: 'If disable obfuscation is enabled',\r\n        type: 'boolean',\r\n    })\r\n        .option('noVerbose', {\r\n        description: 'If verbose is disabled',\r\n        type: 'boolean',\r\n    })\r\n        .option('noLogConsole', {\r\n        description: 'If log file is disabled',\r\n        type: 'boolean',\r\n    })\r\n        .option('noLogFile', {\r\n        description: 'If log file is disabled',\r\n        type: 'boolean',\r\n    })\r\n        .option('logFile', {\r\n        description: 'the log file name',\r\n        type: 'string',\r\n    })\r\n        .option('maxLogSize', {\r\n        description: 'max number of logs to keep in memory',\r\n        type: 'number',\r\n    });\r\n}\r\nexports.getLoggingArgOptions = getLoggingArgOptions;\r\nasync function initLogging(options, listeners) {\r\n    if (options.disableObfuscation) {\r\n        vso_logging_1.LoggerSettings.disableObfuscation = true;\r\n    }\r\n    const noVerboseTarceFilter = {\r\n        shouldTrace: (source, logLevel, id) => {\r\n            return logLevel >= vso_logging_1.LogLevel.Info;\r\n        }\r\n    };\r\n    // init logging\r\n    const traceSource = new vso_logging_1.TraceSource(options.name);\r\n    const addTraceListener = (listener) => {\r\n        if (options.noVerbose) {\r\n            listener.filter = noVerboseTarceFilter;\r\n        }\r\n        traceSource.addTraceListener(listener);\r\n        listeners === null || listeners === void 0 ? void 0 : listeners.push(listener);\r\n    };\r\n    // memory trace listener\r\n    const maxLogSize = options.maxLogSize || 512;\r\n    const memoryTraceListener = new vso_logging_1.MemoryTraceListener(maxLogSize);\r\n    addTraceListener(memoryTraceListener);\r\n    if (!options.noLogConsole) {\r\n        addTraceListener(new vso_logging_1.ConsoleTraceListener());\r\n    }\r\n    if (!options.noLogFile) {\r\n        const logDirectory = path.join(os.tmpdir(), options.logTmpDirectory);\r\n        const fd = options.logFile ? await openAsync(options.logFile, 'a') : undefined;\r\n        const logFileTraceListener = new vso_logging_node_1.LogFileTraceListener(options.processName, logDirectory, fd);\r\n        if (fd) {\r\n            traceSource.info('Trace log: ' + options.logFile);\r\n            addTraceListener(logFileTraceListener);\r\n        }\r\n        else {\r\n            const loggingFilePath = await logFileTraceListener.openAsync();\r\n            if (loggingFilePath) {\r\n                traceSource.info('Trace log: ' + logFileTraceListener.logFileName);\r\n                addTraceListener(logFileTraceListener);\r\n            }\r\n        }\r\n    }\r\n    return traceSource;\r\n}\r\nexports.initLogging = initLogging;\r\n//# sourceMappingURL=logUtils.js.map","\"use strict\";\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst net = __importStar(require(\"net\"));\r\nconst getPort = __importStar(require(\"get-port\"));\r\nconst vso_workspace_core_1 = require(\"@vs/vso-workspace-core\");\r\nconst vscs_utils_1 = require(\"@vs/vscs-utils\");\r\nconst MessageWorkspaceClientClosed = 'Workspace client was closed.';\r\nconst DEFAULT_SERVER_ADDRESS = '127.0.0.1';\r\nvar ErrorCodes;\r\n(function (ErrorCodes) {\r\n    ErrorCodes[\"AlreadyInUse\"] = \"EADDRINUSE\";\r\n    ErrorCodes[\"NoAccess\"] = \"EACCES\";\r\n})(ErrorCodes || (ErrorCodes = {}));\r\n;\r\n/**\r\n * Accepts incoming TCP connections on a local port and forwards them to a\r\n * shared server on the remote host.\r\n */\r\nclass LocalPortForwarder extends vscs_utils_1.DisposableClass {\r\n    constructor(trace, sharedServer, workspaceConnection, streamManagerClient, localPortRef, rebindToRandomPortOnErrors = [\r\n        ErrorCodes.AlreadyInUse,\r\n        ErrorCodes.NoAccess,\r\n    ]) {\r\n        super(trace.createChild(`local-port-forwarder[${sharedServer.sourcePort}]`));\r\n        this.sharedServer = sharedServer;\r\n        this.workspaceConnection = workspaceConnection;\r\n        this.streamManagerClient = streamManagerClient;\r\n        this.localPortRef = localPortRef;\r\n        this.rebindToRandomPortOnErrors = rebindToRandomPortOnErrors;\r\n        this.connections = [];\r\n        this.channels = [];\r\n        this.forecastChannels = [];\r\n        this.stoppingSignal = new vscs_utils_1.Signal();\r\n        this.isClosed = false;\r\n        this.trace.info('rebindToRandomPortOnErrors: ', JSON.stringify(rebindToRandomPortOnErrors));\r\n        this.server = new net.Server(this.onConnection.bind(this));\r\n        this.addToDisposables(workspaceConnection.onHostConnectionChanged(e => {\r\n            if (e.state === vso_workspace_core_1.ConnectedState.Closed) {\r\n                this.trace.info(MessageWorkspaceClientClosed);\r\n                this.isClosed = true;\r\n                this.dispose('workspace connection closed');\r\n            }\r\n        }), this.onDispose(() => {\r\n            this.stop()\r\n                .catch((err) => {\r\n                this.trace.error('Failed to stop local server.', err);\r\n            });\r\n        }));\r\n    }\r\n    get localPort() {\r\n        return this.localPortRef;\r\n    }\r\n    /**\r\n     * Start listening for incoming connections.\r\n     */\r\n    async start(channelForecast = 0) {\r\n        try {\r\n            this.trace.info(`start with \"${channelForecast}\" channels`);\r\n            this.trace.info(`start: sourcePort=${this.sharedServer.sourcePort} localPort=${this.localPortRef} host=${this.sharedServer.sessionName}`);\r\n            await this.listen();\r\n            this.trace.info('server started');\r\n        }\r\n        catch (error) {\r\n            this.trace.info('error while starting: ', JSON.stringify(vscs_utils_1.errorToObject(error)));\r\n            /**\r\n             * If error code is not on the list - rethrow the error,\r\n             * if error code is in the list, bind to a random port.\r\n             */\r\n            vscs_utils_1.assert(this.rebindToRandomPortOnErrors.includes(error.code), error);\r\n            this.trace.info('rebinding to a random port');\r\n            // Try again, this time with a RANDOM port number.\r\n            this.localPortRef = await getPort.default();\r\n            await this.listen();\r\n            this.trace.info(`start (failed): sourcePort=${this.sharedServer.sourcePort} localPort=${this.localPortRef} host=${this.sharedServer.sessionName}`);\r\n        }\r\n        // Start opening the forecasted number of channels, so they will\r\n        // will be available more quickly when requested.\r\n        for (let i = 0; i < channelForecast; i++) {\r\n            this.forecastChannels.push(this.openChannel());\r\n        }\r\n    }\r\n    stop() {\r\n        var _a;\r\n        this.trace.info('stopping');\r\n        if (!this.server.listening) {\r\n            return Promise.resolve();\r\n        }\r\n        for (const channel of this.channels) {\r\n            (_a = channel.close()) === null || _a === void 0 ? void 0 : _a.catch((err) => this.trace.error(`failed to close channel`, err));\r\n        }\r\n        this.trace.verbose(`stop: stopping local server port=${this.localPortRef} connections=${this.connections.length}`);\r\n        this.server.close((err) => {\r\n            if (err) {\r\n                this.trace.error(`stop: failed to stop local server port=${this.localPortRef}`, err);\r\n                this.stoppingSignal.reject(err);\r\n                return;\r\n            }\r\n            this.trace.verbose(`stop: stopped local server port=${this.localPortRef}`, err);\r\n            this.stoppingSignal.resolve();\r\n        });\r\n        for (const conn of this.connections) {\r\n            conn.destroy();\r\n        }\r\n        return this.stoppingSignal.promise;\r\n    }\r\n    async listen() {\r\n        return await new Promise((resolve, reject) => {\r\n            // Listen on the IPv4 loopback interface, because connections are only expected\r\n            // from local clients.\r\n            this.server.once('listening', () => {\r\n                this.trace.info(`listening on local port=${this.localPortRef}`);\r\n                resolve();\r\n            });\r\n            this.server.once('error', (e) => {\r\n                this.trace.error(`failed to listen on local port=${this.localPortRef}`, e);\r\n                reject(e);\r\n            });\r\n            this.trace.info(`start listen to port: \"${DEFAULT_SERVER_ADDRESS}:${this.localPortRef}\"`);\r\n            this.server.listen(this.localPortRef, DEFAULT_SERVER_ADDRESS);\r\n        });\r\n    }\r\n    /**\r\n     * Accept incoming connections from VS Code and forward them to the shared server.\r\n     */\r\n    async onConnection(socket) {\r\n        var _a, _b;\r\n        this.connections.push(socket);\r\n        try {\r\n            // Wait for a forecasted channel if available, otherwise wait for a new channel.\r\n            const channel = await ((_a = this.forecastChannels.shift()) !== null && _a !== void 0 ? _a : this.openChannel());\r\n            this.addToDisposables(vscs_utils_1.createDisposable(() => {\r\n                channel.close();\r\n                socket.end();\r\n            }), channel);\r\n            this.channels.push(channel);\r\n            // Normally these are SSH channels, which have a `channelId` property, but it's not required.\r\n            const channelId = (_b = channel.channelId) !== null && _b !== void 0 ? _b : '?';\r\n            this.trace.info(`Forwarding connection on channel #${channelId}.`);\r\n            // Forward data between the socket and the SSH channel.\r\n            socket.on('data', (data) => {\r\n                // console.log(ssh.formatBuffer(data, ` sending`));\r\n                // Block further data events while sending.\r\n                socket.pause();\r\n                channel.send(data).then(() => {\r\n                    socket.resume();\r\n                }, (e) => {\r\n                    this.trace.error('Error sending channel data: ' + e.message, e);\r\n                });\r\n            });\r\n            channel.onDataReceived((data) => {\r\n                // Make a copy of the data before passing it to the async socket.write()\r\n                // because the current buffer may get re-used after this callback returns.\r\n                data = Buffer.from(data);\r\n                // console.log(ssh.formatBuffer(data, ` receiving`));\r\n                socket.write(data, () => {\r\n                    // Notify the channel that the data has been consumed and more data may be sent.\r\n                    channel.adjustWindow(data.length);\r\n                });\r\n            });\r\n            // Propagate close events both directions.\r\n            socket.on('close', () => {\r\n                var _a;\r\n                const i = this.connections.indexOf(socket);\r\n                if (i >= 0) {\r\n                    this.connections.splice(i, 1);\r\n                }\r\n                (_a = channel\r\n                    .close()) === null || _a === void 0 ? void 0 : _a.catch((e) => this.trace.error('Channel close failed with error', e));\r\n            });\r\n            socket.on('error', (e) => {\r\n                var _a;\r\n                const i = this.connections.indexOf(socket);\r\n                if (i >= 0) {\r\n                    this.connections.splice(i, 1);\r\n                }\r\n                (_a = channel\r\n                    .close(e)) === null || _a === void 0 ? void 0 : _a.catch((err) => this.trace.error('Channel close failed with error', err));\r\n            });\r\n            channel.onClosed((e) => {\r\n                if (e.error || e.errorMessage) {\r\n                    const errorMsg = `Port-forward channel #${channelId} closed with error: ${e.error && e.error.message ? e.error.message : e.errorMessage}`;\r\n                    this.trace.error(errorMsg);\r\n                }\r\n                else {\r\n                    this.trace.info(`Port-forward channel #${channelId} closed.`);\r\n                }\r\n                socket.end();\r\n            });\r\n        }\r\n        catch (e) {\r\n            this.trace.error('Failed to forward incoming connection to remote server: ' + e.message, e);\r\n            socket.end();\r\n        }\r\n    }\r\n    /**\r\n     * Open a new SSH channel that is remotely connected to the shared server.\r\n     */\r\n    async openChannel() {\r\n        vscs_utils_1.assert(!this.isClosed, MessageWorkspaceClientClosed);\r\n        const streamId = await this.streamManagerClient.getStreamAsync(this.sharedServer.streamName, this.sharedServer.streamCondition);\r\n        return await this.workspaceConnection.openStreamingChannel(streamId);\r\n    }\r\n}\r\nexports.LocalPortForwarder = LocalPortForwarder;\r\n//# sourceMappingURL=LocalPortForwarder.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vso_rpc_1 = require(\"@vs/vso-rpc\");\r\nconst SudoPortForwarderServiceClient_1 = require(\"./SudoPortForwarderServiceClient\");\r\nconst vscs_utils_1 = require(\"@vs/vscs-utils\");\r\nclass SudoPortforwarderClient extends vscs_utils_1.DisposableClass {\r\n    constructor(trace, rpcClient) {\r\n        super(trace.createChild('sudo-pf-client'));\r\n        this.rpcClient = rpcClient;\r\n        this.codespacePortForwarderServiceClient = vso_rpc_1.RpcProxy.create(SudoPortForwarderServiceClient_1.SudoPortForwarderServiceClient, rpcClient, this.trace);\r\n    }\r\n    async connect(hubPipeName) {\r\n        const start = Date.now();\r\n        const workspaceSessionInfo = await this.codespacePortForwarderServiceClient.connectAsync(hubPipeName);\r\n        const time = Math.round(Date.now() - start);\r\n        this.trace.verbose(`connect codespacePortForwarderService completed -> time:${time}`);\r\n        return workspaceSessionInfo;\r\n    }\r\n    async startPortForwarding(sharedServer) {\r\n        const start = Date.now();\r\n        const localPort = await this.codespacePortForwarderServiceClient.startPortForwardingAsync(sharedServer);\r\n        const time = Math.round(Date.now() - start);\r\n        this.trace.verbose(`start portforwarding using codespacePortForwarderService completed -> time:${time}`);\r\n        return localPort;\r\n    }\r\n    async stopPortForwarding(sharedServer) {\r\n        const start = Date.now();\r\n        const workspaceSessionInfo = await this.codespacePortForwarderServiceClient.stopPortForwardingAsync(sharedServer);\r\n        const time = Math.round(Date.now() - start);\r\n        this.trace.verbose(`stop portforwarding using codespacePortForwarderService completed -> time:${time}`);\r\n        return workspaceSessionInfo;\r\n    }\r\n    async disconnect() {\r\n        const start = Date.now();\r\n        const workspaceSessionInfo = await this.codespacePortForwarderServiceClient.disconnectAsync();\r\n        const time = Math.round(Date.now() - start);\r\n        this.trace.verbose(`disconnect codespacePortForwarderService completed -> time:${time}`);\r\n        return workspaceSessionInfo;\r\n    }\r\n}\r\nexports.SudoPortforwarderClient = SudoPortforwarderClient;\r\n//# sourceMappingURL=SudoPortForwarderClient.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vso_rpc_1 = require(\"@vs/vso-rpc\");\r\nconst vsls_contracts_1 = require(\"@vs/vsls-contracts\");\r\nconst LocalPortForwarder_1 = require(\"./LocalPortForwarder\");\r\nconst SudoPortForwarderServiceClient_1 = require(\"./SudoPortForwarderServiceClient\");\r\nconst vscs_utils_1 = require(\"@vs/vscs-utils\");\r\nclass SudoPortForwarderService extends vscs_utils_1.DisposableClass {\r\n    constructor(trace, workspaceId, connectionHub) {\r\n        super(trace.createChild('sudo-pf-service'));\r\n        this.workspaceId = workspaceId;\r\n        this.connectionHub = connectionHub;\r\n        this.sudoLocalPortForwarders = new Map();\r\n        this.hubPipeName = null;\r\n        this.rpcServer = new vso_rpc_1.RpcServer(trace.createChild('RpcServer'));\r\n        this.rpcServer.registerRpcService(this, SudoPortForwarderServiceClient_1.SudoPortForwarderServiceClient);\r\n        this.addToDisposables(this.rpcServer);\r\n        this.rpcServer.addToDisposables(this);\r\n    }\r\n    acceptStream(rpcMessageStream) {\r\n        const rpcConnection = this.rpcServer.acceptRpcMessageStream(rpcMessageStream)[0];\r\n        rpcConnection.onClose(() => {\r\n            this.disconnectAsync();\r\n        });\r\n        return rpcConnection;\r\n    }\r\n    async connectAsync(hubPipeName) {\r\n        try {\r\n            this.hubPipeName = hubPipeName;\r\n            const start = Date.now();\r\n            this.trace.info(`connectAsync: Connecting now.. pipename ${hubPipeName}`);\r\n            const connection = await this.connectionHub.connect({\r\n                hubPipeName,\r\n                workspaceId: this.workspaceId,\r\n                liveShareEndpoint: '',\r\n                token: '',\r\n            });\r\n            connection.workspaceClient.rpcClient.onClose(() => {\r\n                this.sudoLocalPortForwarders.forEach(async (portForwarder) => {\r\n                    await portForwarder.stop();\r\n                });\r\n                this.sudoLocalPortForwarders = new Map();\r\n            });\r\n            const time = (Date.now() - start).toFixed(1);\r\n            this.trace.verbose(`connectAsync: connected -> total time:${time}`);\r\n        }\r\n        catch (err) {\r\n            this.trace.error('connectAsync: Error connecting', err);\r\n            throw err;\r\n        }\r\n    }\r\n    async startPortForwardingAsync(sharedServer) {\r\n        try {\r\n            this.trace.verbose(`startPortForwardingAsync`);\r\n            const start = Date.now();\r\n            vscs_utils_1.assertDefined(this.hubPipeName, 'No hub pipe name set, please call `connectAsync` first.');\r\n            const connection = await this.connectionHub.connect({\r\n                hubPipeName: this.hubPipeName,\r\n                workspaceId: this.workspaceId,\r\n                liveShareEndpoint: '',\r\n                token: '',\r\n            });\r\n            const streamManagerClient = connection.workspaceClient.getServiceProxy(vsls_contracts_1.vsls.StreamManagerService);\r\n            const portForwarder = new LocalPortForwarder_1.LocalPortForwarder(this.trace, sharedServer, connection.workspaceClient, streamManagerClient, sharedServer.sourcePort, []);\r\n            this.sudoLocalPortForwarders.set(sharedServer.sourcePort, portForwarder);\r\n            await portForwarder.start();\r\n            const time = (Date.now() - start).toFixed(1);\r\n            this.trace.verbose(`startPortForwardingAsync: forwarded port -> total time:${time}`);\r\n            return portForwarder.localPort;\r\n        }\r\n        catch (err) {\r\n            this.trace.error('startPortForwardingAsync: Error forwarding port', err);\r\n            throw err;\r\n        }\r\n    }\r\n    async stopPortForwardingAsync(sharedServer) {\r\n        try {\r\n            const portForwarder = this.sudoLocalPortForwarders.get(sharedServer.sourcePort);\r\n            if (!portForwarder) {\r\n                this.trace.error(`stopPortForwardingAsync: Trying to stop port forwarder (for port ${sharedServer.sourcePort}) which is not already forwarded`);\r\n                return;\r\n            }\r\n            await portForwarder.stop();\r\n            this.sudoLocalPortForwarders.delete(sharedServer.sourcePort);\r\n            this.trace.verbose('stopPortForwardingAsync: stopped forwarded port');\r\n        }\r\n        catch (err) {\r\n            this.trace.error('stopPortForwardingAsync: Error stopping forwarded port', err);\r\n            throw err;\r\n        }\r\n    }\r\n    async disconnectAsync() {\r\n        var _a;\r\n        if (!this.hubPipeName) {\r\n            this.trace.info('not connected');\r\n            return;\r\n        }\r\n        const connection = await this.connectionHub.getConnection({\r\n            hubPipeName: this.hubPipeName,\r\n            workspaceId: this.workspaceId,\r\n            liveShareEndpoint: '',\r\n            token: '',\r\n        });\r\n        await ((_a = connection === null || connection === void 0 ? void 0 : connection.workspaceClient) === null || _a === void 0 ? void 0 : _a.disconnect());\r\n    }\r\n}\r\nexports.SudoPortForwarderService = SudoPortForwarderService;\r\n//# sourceMappingURL=SudoPortForwarderService.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SudoPortForwarderServiceClient = {\r\n    name: 'csSudoPortForwarderServiceClient',\r\n    methods: ['connect', 'startPortForwarding', 'stopPortForwarding', 'disconnect'],\r\n    events: [],\r\n};\r\n//# sourceMappingURL=SudoPortForwarderServiceClient.js.map","\"use strict\";\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscs_utils_1 = require(\"@vs/vscs-utils\");\r\nconst vscs_connection_hub_1 = require(\"@vs/vscs-connection-hub\");\r\nconst vso_workspace_client_hub_1 = require(\"@vs/vso-workspace-client-hub\");\r\nconst vso_node_utils_1 = require(\"@vs/vso-node-utils\");\r\nconst vs_ssh_1 = require(\"@vs/vs-ssh\");\r\nlet hubClientSession = 0;\r\nconst MAX_RETRIES = 20;\r\nconst WAIT_TIME_MS = 1000;\r\n;\r\n/**\r\n * A hub client connection to use the hub-agent to create\r\n * liveshare connections thru the separate process.\r\n */\r\nclass HubClientConnection extends vscs_connection_hub_1.LiveShareConnection {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.socket = null;\r\n    }\r\n    get type() {\r\n        return vscs_connection_hub_1.TConnectionTypes.WorkspaceHub;\r\n    }\r\n    /**\r\n     * Create the WorkspaceClient that is capable of connecting thru the \"remote\" WorkspaceHub.\r\n     */\r\n    async createWorkspaceClient() {\r\n        const { hubPipeName } = this.options;\r\n        const socket = await this.startSocketSessionForHubWorkspace(hubPipeName);\r\n        return await vso_workspace_client_hub_1.WorkspaceHubClient.create(new vs_ssh_1.NodeStream(socket), this.trace.createChild(`workspace-hub-client:${++hubClientSession}`));\r\n    }\r\n    /**\r\n     * Connect to the WorkspaceHub socket.\r\n     */\r\n    async startSocketSessionForHubWorkspace(hubPipeName) {\r\n        return await vscs_utils_1.withRetries(async (retriesLeft) => {\r\n            const retry = MAX_RETRIES - retriesLeft;\r\n            this.trace\r\n                .verbose(`trying to connect to the TCP socket, retries left: \"${retriesLeft}\" (retry: \"${retry}\")`);\r\n            const pipeName = retry === 0 ? hubPipeName : `${hubPipeName}-${retry}`;\r\n            this.socket = await vso_node_utils_1.startSocketSessionOnPipe(pipeName);\r\n            this.socket.on('close', this.dispose.bind(this, 'TCP socket closed.'));\r\n            this.socket.on('end', this.dispose.bind(this, 'TCP socket ended'));\r\n            return this.socket;\r\n        }, {\r\n            retries: MAX_RETRIES,\r\n            retryDelay: WAIT_TIME_MS,\r\n        });\r\n    }\r\n    /**\r\n     * Make sure we disconnect from the WorkspaceHub and close\r\n     * the socket on dispose.\r\n     */\r\n    dispose(reason) {\r\n        var _a, _b;\r\n        if (this.isDisposed) {\r\n            return this;\r\n        }\r\n        // disconnect WorkspaceClient\r\n        (_a = this.workspaceClientReference) === null || _a === void 0 ? void 0 : _a.disconnect().catch((error) => {\r\n            this.trace.verbose('error while disconnecting workspace client: ', vscs_utils_1.errorToObject(error));\r\n        }).finally(() => {\r\n            var _a;\r\n            (_a = this.workspaceClientReference) === null || _a === void 0 ? void 0 : _a.dispose(reason);\r\n            this.workspaceClientReference = undefined;\r\n            this.workspaceSessionInfoReference = undefined;\r\n        });\r\n        // close the socket\r\n        (_b = this.socket) === null || _b === void 0 ? void 0 : _b.destroy();\r\n        return this;\r\n    }\r\n}\r\n__decorate([\r\n    vscs_utils_1.withHelperDecorator(vscs_utils_1.once),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", [String]),\r\n    __metadata(\"design:returntype\", Promise)\r\n], HubClientConnection.prototype, \"startSocketSessionForHubWorkspace\", null);\r\nexports.HubClientConnection = HubClientConnection;\r\n;\r\n//# sourceMappingURL=HubClientConnection.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscs_connection_hub_1 = require(\"@vs/vscs-connection-hub\");\r\nconst vscs_utils_1 = require(\"@vs/vscs-utils\");\r\nconst HubClientConnection_1 = require(\"./HubClientConnection\");\r\nconst performance_1 = require(\"../performance/performance\");\r\n/**\r\n * \"Persistent\" conenction hub that maintains\r\n * conenction in a separate process.\r\n */\r\nexports.initWorkspaceHubConnectionHub = vscs_utils_1.once((trace) => {\r\n    // connection in separate process\r\n    const remoteConnectionHub = new vscs_connection_hub_1.ConnectionHub(trace.createChild('sudo-pf-remote'), performance_1.performance, HubClientConnection_1.HubClientConnection);\r\n    return remoteConnectionHub;\r\n});\r\n//# sourceMappingURL=connection-hub.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar SudoPortForwarderServiceClient_1 = require(\"./SudoPortForwarderServiceClient\");\r\nexports.SudoPortForwarderServiceClient = SudoPortForwarderServiceClient_1.SudoPortForwarderServiceClient;\r\nvar connection_hub_1 = require(\"./connection/connection-hub\");\r\nexports.initWorkspaceHubConnectionHub = connection_hub_1.initWorkspaceHubConnectionHub;\r\nvar SudoPortForwarderService_1 = require(\"./SudoPortForwarderService\");\r\nexports.SudoPortForwarderService = SudoPortForwarderService_1.SudoPortForwarderService;\r\nvar SudoPortForwarderClient_1 = require(\"./SudoPortForwarderClient\");\r\nexports.SudoPortforwarderClient = SudoPortForwarderClient_1.SudoPortforwarderClient;\r\nvar LocalPortForwarder_1 = require(\"./LocalPortForwarder\");\r\nexports.LocalPortForwarder = LocalPortForwarder_1.LocalPortForwarder;\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscs_performance_1 = require(\"@vs/vscs-performance\");\r\nexports.performance = vscs_performance_1.initializePerformanceInstance('start');\r\n//# sourceMappingURL=performance.js.map","import * as rpc from \"vscode-jsonrpc\";\r\nimport * as net from 'net';\r\n\r\nimport { TraceSource } from '@vs/vso-logging';\r\n\r\nimport { SudoPortForwarderService, initWorkspaceHubConnectionHub } from '@vs/port-forwarder';\r\nimport { SocketServer } from '@vs/vso-node-server';\r\nimport { getServerArgOptions, startServer, ServerOptions } from '@vs/vso-workspace-hub-util';\r\n\r\nconst argv = \r\n    getServerArgOptions()\r\n    .option('workspaceId', {\r\n        description: 'Workspace Id',\r\n        alias: 'w',\r\n        type: 'string'\r\n    })\r\n    .argv;\r\n\r\nclass PortAgentServer implements SocketServer {\r\n    private sudoPortForwarderService: SudoPortForwarderService;\r\n\r\n    constructor(traceSource: TraceSource) {\r\n        if (!argv.workspaceId) {\r\n            traceSource.error(`workspace id needs to be defined`);\r\n            process.exit(2);\r\n        }\r\n\r\n        const connectionHub = initWorkspaceHubConnectionHub(traceSource);\r\n        this.sudoPortForwarderService = new SudoPortForwarderService(\r\n            traceSource,\r\n            argv.workspaceId,\r\n            connectionHub,\r\n        );\r\n    }\r\n\r\n    public accept(socket: net.Socket): Promise<rpc.MessageConnection> {\r\n        const messageReader = new rpc.StreamMessageReader(socket);\r\n        const messageWriter = new rpc.StreamMessageWriter(socket);\r\n        const rpcConnection =  this.sudoPortForwarderService.acceptStream({\r\n            reader: messageReader,\r\n            writer: messageWriter\r\n        });\r\n\r\n        return  Promise.resolve(rpcConnection);\r\n    }\r\n\r\n    public dispose(): Promise<void> {\r\n        return this.sudoPortForwarderService.disconnectAsync();\r\n    }\r\n}\r\n\r\nconst options: ServerOptions = Object.assign({\r\n    name: 'port-forwarder',\r\n    processName: 'CodespacePortForwarder',\r\n    logTmpDirectory: 'CodespacePortForwarder_logs',\r\n    isAdmin: true,\r\n}, getServerArgOptions().argv);\r\n\r\nstartServer(options, (keepAliveCallback, traceSource) => new PortAgentServer(traceSource))\r\n    .then((traceSource) => {\r\n        traceSource.info('succeeded..');\r\n    })\r\n    .catch(err => {\r\n        // Deal with the fact the chain failed\r\n        console.error(`failed err:${err}`);\r\n    });","module.exports = require(\"assert\");","module.exports = require(\"async_hooks\");","module.exports = require(\"buffer\");","module.exports = require(\"child_process\");","module.exports = require(\"console\");","module.exports = require(\"constants\");","module.exports = require(\"crypto\");","module.exports = require(\"dns\");","module.exports = require(\"events\");","module.exports = require(\"fs\");","module.exports = require(\"http\");","module.exports = require(\"https\");","module.exports = require(\"module\");","module.exports = require(\"net\");","module.exports = require(\"os\");","module.exports = require(\"path\");","module.exports = require(\"perf_hooks\");","module.exports = require(\"stream\");","module.exports = require(\"timers\");","module.exports = require(\"tty\");","module.exports = require(\"url\");","module.exports = require(\"util\");","module.exports = require(\"vscode\");","module.exports = require(\"zlib\");"],"sourceRoot":""}